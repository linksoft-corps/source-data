// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: data.proto

#include "data.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace data {
PROTOBUF_CONSTEXPR AdjustedClosingPrice::AdjustedClosingPrice(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.issuesymbol_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.adjustedclosingprice_)*/0
  , /*decltype(_impl_.securityclass_)*/0} {}
struct AdjustedClosingPriceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AdjustedClosingPriceDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~AdjustedClosingPriceDefaultTypeInternal() {}
  union {
    AdjustedClosingPrice _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AdjustedClosingPriceDefaultTypeInternal _AdjustedClosingPrice_default_instance_;
PROTOBUF_CONSTEXPR DayTradeSummary::DayTradeSummary(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.issuesymbol_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.nasdaqhighprice_)*/0
  , /*decltype(_impl_.nasdaqlowprice_)*/0
  , /*decltype(_impl_.nasdaqclosingprice_)*/0
  , /*decltype(_impl_.consolidatedvolume_)*/int64_t{0}
  , /*decltype(_impl_.marketcategory_)*/0} {}
struct DayTradeSummaryDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DayTradeSummaryDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DayTradeSummaryDefaultTypeInternal() {}
  union {
    DayTradeSummary _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DayTradeSummaryDefaultTypeInternal _DayTradeSummary_default_instance_;
PROTOBUF_CONSTEXPR DayTradeSummaryNextShares::DayTradeSummaryNextShares(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.issuesymbol_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.nasdaqhighprice_)*/0
  , /*decltype(_impl_.navoffsetamounthigh_)*/0
  , /*decltype(_impl_.nasdaqlowprice_)*/0
  , /*decltype(_impl_.navoffsetamountlow_)*/0
  , /*decltype(_impl_.nasdaqclosingprice_)*/0
  , /*decltype(_impl_.navoffsetamountclose_)*/0
  , /*decltype(_impl_.consolidatedvolume_)*/int64_t{0}
  , /*decltype(_impl_.marketcategory_)*/0} {}
struct DayTradeSummaryNextSharesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DayTradeSummaryNextSharesDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DayTradeSummaryNextSharesDefaultTypeInternal() {}
  union {
    DayTradeSummaryNextShares _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DayTradeSummaryNextSharesDefaultTypeInternal _DayTradeSummaryNextShares_default_instance_;
PROTOBUF_CONSTEXPR IPOInformation::IPOInformation(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.issuesymbol_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.securityclass_)*/0
  , /*decltype(_impl_.referencefornetchange_)*/0
  , /*decltype(_impl_.referenceprice_)*/0} {}
struct IPOInformationDefaultTypeInternal {
  PROTOBUF_CONSTEXPR IPOInformationDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~IPOInformationDefaultTypeInternal() {}
  union {
    IPOInformation _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 IPOInformationDefaultTypeInternal _IPOInformation_default_instance_;
PROTOBUF_CONSTEXPR IPOQuotingPeriodUpdate::IPOQuotingPeriodUpdate(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.stock_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.ipoquotationreleasetime_)*/int64_t{0}
  , /*decltype(_impl_.ipoprice_)*/0
  , /*decltype(_impl_.quotationreleasequalifier_)*/0} {}
struct IPOQuotingPeriodUpdateDefaultTypeInternal {
  PROTOBUF_CONSTEXPR IPOQuotingPeriodUpdateDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~IPOQuotingPeriodUpdateDefaultTypeInternal() {}
  union {
    IPOQuotingPeriodUpdate _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 IPOQuotingPeriodUpdateDefaultTypeInternal _IPOQuotingPeriodUpdate_default_instance_;
PROTOBUF_CONSTEXPR MWCBStatusMessage::MWCBStatusMessage(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.breachedlevel_)*/0} {}
struct MWCBStatusMessageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MWCBStatusMessageDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MWCBStatusMessageDefaultTypeInternal() {}
  union {
    MWCBStatusMessage _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MWCBStatusMessageDefaultTypeInternal _MWCBStatusMessage_default_instance_;
PROTOBUF_CONSTEXPR MarketWideCircuitBreaker::MarketWideCircuitBreaker(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.level1_)*/0
  , /*decltype(_impl_.level2_)*/0
  , /*decltype(_impl_.level3_)*/0} {}
struct MarketWideCircuitBreakerDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MarketWideCircuitBreakerDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MarketWideCircuitBreakerDefaultTypeInternal() {}
  union {
    MarketWideCircuitBreaker _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MarketWideCircuitBreakerDefaultTypeInternal _MarketWideCircuitBreaker_default_instance_;
PROTOBUF_CONSTEXPR MessageHeader::MessageHeader(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.timestamp_)*/int64_t{0}
  , /*decltype(_impl_.trackingnumber_)*/0
  , /*decltype(_impl_.messagetype_)*/0} {}
struct MessageHeaderDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MessageHeaderDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MessageHeaderDefaultTypeInternal() {}
  union {
    MessageHeader _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MessageHeaderDefaultTypeInternal _MessageHeader_default_instance_;
PROTOBUF_CONSTEXPR OperationalHalt::OperationalHalt(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.stock_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.marketcode_)*/0
  , /*decltype(_impl_.operationalhaltaction_)*/0} {}
struct OperationalHaltDefaultTypeInternal {
  PROTOBUF_CONSTEXPR OperationalHaltDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~OperationalHaltDefaultTypeInternal() {}
  union {
    OperationalHalt _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 OperationalHaltDefaultTypeInternal _OperationalHalt_default_instance_;
PROTOBUF_CONSTEXPR SaleConditionModifier::SaleConditionModifier(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.level1_)*/0
  , /*decltype(_impl_.level2_)*/0
  , /*decltype(_impl_.level3_)*/0
  , /*decltype(_impl_.level4_)*/0} {}
struct SaleConditionModifierDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SaleConditionModifierDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SaleConditionModifierDefaultTypeInternal() {}
  union {
    SaleConditionModifier _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SaleConditionModifierDefaultTypeInternal _SaleConditionModifier_default_instance_;
PROTOBUF_CONSTEXPR ShortSaleRestrictionIndicatorMessage::ShortSaleRestrictionIndicatorMessage(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.issuesymbol_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.regshoaction_)*/0} {}
struct ShortSaleRestrictionIndicatorMessageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ShortSaleRestrictionIndicatorMessageDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ShortSaleRestrictionIndicatorMessageDefaultTypeInternal() {}
  union {
    ShortSaleRestrictionIndicatorMessage _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ShortSaleRestrictionIndicatorMessageDefaultTypeInternal _ShortSaleRestrictionIndicatorMessage_default_instance_;
PROTOBUF_CONSTEXPR StockDirectory::StockDirectory(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.stock_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.issueclassification_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.issuesubtype_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.bloombergid_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.marketcategory_)*/0
  , /*decltype(_impl_.financialstatusindicator_)*/0
  , /*decltype(_impl_.roundlotsize_)*/int64_t{0}
  , /*decltype(_impl_.roundlotonly_)*/0
  , /*decltype(_impl_.authenticity_)*/0
  , /*decltype(_impl_.shortsalethresholdindicator_)*/0
  , /*decltype(_impl_.ipoflag_)*/0
  , /*decltype(_impl_.luldreferencepricetier_)*/0
  , /*decltype(_impl_.etplag_)*/0
  , /*decltype(_impl_.etpleveragefactor_)*/int64_t{0}
  , /*decltype(_impl_.inverseindicator_)*/0} {}
struct StockDirectoryDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StockDirectoryDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~StockDirectoryDefaultTypeInternal() {}
  union {
    StockDirectory _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StockDirectoryDefaultTypeInternal _StockDirectory_default_instance_;
PROTOBUF_CONSTEXPR StockTradingAction::StockTradingAction(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.reserved_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.issuesymbol_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.reason_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.securityclass_)*/0
  , /*decltype(_impl_.currenttradingstate_)*/0} {}
struct StockTradingActionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StockTradingActionDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~StockTradingActionDefaultTypeInternal() {}
  union {
    StockTradingAction _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StockTradingActionDefaultTypeInternal _StockTradingAction_default_instance_;
PROTOBUF_CONSTEXPR SystemEventMessage::SystemEventMessage(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.eventcode_)*/0} {}
struct SystemEventMessageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SystemEventMessageDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SystemEventMessageDefaultTypeInternal() {}
  union {
    SystemEventMessage _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SystemEventMessageDefaultTypeInternal _SystemEventMessage_default_instance_;
PROTOBUF_CONSTEXPR TradeCancelForNextsharesTrades::TradeCancelForNextsharesTrades(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.issuesymbol_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.originaltradecontrolnumber_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.originalsaleconditionmodifier_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.marketcenteridentifier_)*/0
  , /*decltype(_impl_.securityclass_)*/0
  , /*decltype(_impl_.originalproxyprice_)*/0
  , /*decltype(_impl_.originalnavoffsetamount_)*/0
  , /*decltype(_impl_.originaltradesize_)*/int64_t{0}
  , /*decltype(_impl_.consolidatedvolume_)*/int64_t{0}} {}
struct TradeCancelForNextsharesTradesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TradeCancelForNextsharesTradesDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TradeCancelForNextsharesTradesDefaultTypeInternal() {}
  union {
    TradeCancelForNextsharesTrades _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TradeCancelForNextsharesTradesDefaultTypeInternal _TradeCancelForNextsharesTrades_default_instance_;
PROTOBUF_CONSTEXPR TradeCancelForNonNextSharesTrades::TradeCancelForNonNextSharesTrades(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.issuesymbol_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.originalcontrolnumber_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.originalsaleconditionmodifier_)*/nullptr
  , /*decltype(_impl_.marketcenteridentifier_)*/0
  , /*decltype(_impl_.securityclass_)*/0
  , /*decltype(_impl_.originaltradeprice_)*/0
  , /*decltype(_impl_.originaltradesize_)*/int64_t{0}
  , /*decltype(_impl_.consolidatedvolume_)*/int64_t{0}} {}
struct TradeCancelForNonNextSharesTradesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TradeCancelForNonNextSharesTradesDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TradeCancelForNonNextSharesTradesDefaultTypeInternal() {}
  union {
    TradeCancelForNonNextSharesTrades _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TradeCancelForNonNextSharesTradesDefaultTypeInternal _TradeCancelForNonNextSharesTrades_default_instance_;
PROTOBUF_CONSTEXPR TradeCorrectionForNextsharesTrades::TradeCorrectionForNextsharesTrades(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.issuesymbol_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.originalcontrolnumber_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.originalconditionmodifier_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.correctedtradecontrolnumber_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.correctedsaleconditionmodifier_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.marketcenteridentifier_)*/0
  , /*decltype(_impl_.securityclass_)*/0
  , /*decltype(_impl_.originalproxyprice_)*/0
  , /*decltype(_impl_.originalnavoffsetamount_)*/0
  , /*decltype(_impl_.originaltradesize_)*/int64_t{0}
  , /*decltype(_impl_.correctedtradeprice_)*/0
  , /*decltype(_impl_.correctednavoffsetamount_)*/0
  , /*decltype(_impl_.correctedtradesize_)*/int64_t{0}
  , /*decltype(_impl_.consolidatedvolume_)*/int64_t{0}} {}
struct TradeCorrectionForNextsharesTradesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TradeCorrectionForNextsharesTradesDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TradeCorrectionForNextsharesTradesDefaultTypeInternal() {}
  union {
    TradeCorrectionForNextsharesTrades _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TradeCorrectionForNextsharesTradesDefaultTypeInternal _TradeCorrectionForNextsharesTrades_default_instance_;
PROTOBUF_CONSTEXPR TradeCorrectionForNonNextsharesTrades::TradeCorrectionForNonNextsharesTrades(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.issuesymbol_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.originalcontrolnumber_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.originalconditionmodifier_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.correctedtradecontrolnumber_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.correctedsaleconditionmodifier_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.marketcenteridentifier_)*/0
  , /*decltype(_impl_.securityclass_)*/0
  , /*decltype(_impl_.originaltradeprice_)*/0
  , /*decltype(_impl_.originaltradesize_)*/int64_t{0}
  , /*decltype(_impl_.correctedtradeprice_)*/0
  , /*decltype(_impl_.correctedtradesize_)*/int64_t{0}
  , /*decltype(_impl_.consolidatedvolume_)*/int64_t{0}} {}
struct TradeCorrectionForNonNextsharesTradesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TradeCorrectionForNonNextsharesTradesDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TradeCorrectionForNonNextsharesTradesDefaultTypeInternal() {}
  union {
    TradeCorrectionForNonNextsharesTrades _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TradeCorrectionForNonNextsharesTradesDefaultTypeInternal _TradeCorrectionForNonNextsharesTrades_default_instance_;
PROTOBUF_CONSTEXPR TradeReportForNextshares::TradeReportForNextshares(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.nextsharessymbol_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.tradecontrolnumber_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.saleconditionmodifier_)*/nullptr
  , /*decltype(_impl_.originatingmarketcenteridentifier_)*/0
  , /*decltype(_impl_.securityclass_)*/0
  , /*decltype(_impl_.proxyprice_)*/0
  , /*decltype(_impl_.tradesize_)*/int64_t{0}
  , /*decltype(_impl_.navoffsetamount_)*/0
  , /*decltype(_impl_.consolidatedvolume_)*/0} {}
struct TradeReportForNextsharesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TradeReportForNextsharesDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TradeReportForNextsharesDefaultTypeInternal() {}
  union {
    TradeReportForNextshares _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TradeReportForNextsharesDefaultTypeInternal _TradeReportForNextshares_default_instance_;
PROTOBUF_CONSTEXPR TradeReportForNonNextshares::TradeReportForNonNextshares(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.issuesymbol_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.tradecontrolnumber_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.saleconditionmodifier_)*/nullptr
  , /*decltype(_impl_.originatingmarketcenteridentifier_)*/0
  , /*decltype(_impl_.securityclass_)*/0
  , /*decltype(_impl_.tradeprice_)*/0
  , /*decltype(_impl_.tradesize_)*/int64_t{0}
  , /*decltype(_impl_.consolidatedvolume_)*/int64_t{0}} {}
struct TradeReportForNonNextsharesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TradeReportForNonNextsharesDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TradeReportForNonNextsharesDefaultTypeInternal() {}
  union {
    TradeReportForNonNextshares _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TradeReportForNonNextsharesDefaultTypeInternal _TradeReportForNonNextshares_default_instance_;
PROTOBUF_CONSTEXPR QBBOMWCBBreachMessage::QBBOMWCBBreachMessage(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.breachedlevel_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct QBBOMWCBBreachMessageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR QBBOMWCBBreachMessageDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~QBBOMWCBBreachMessageDefaultTypeInternal() {}
  union {
    QBBOMWCBBreachMessage _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 QBBOMWCBBreachMessageDefaultTypeInternal _QBBOMWCBBreachMessage_default_instance_;
PROTOBUF_CONSTEXPR QBBOMWCBDeclineLevelMessage::QBBOMWCBDeclineLevelMessage(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.level1_)*/0
  , /*decltype(_impl_.level2_)*/0
  , /*decltype(_impl_.level3_)*/0} {}
struct QBBOMWCBDeclineLevelMessageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR QBBOMWCBDeclineLevelMessageDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~QBBOMWCBDeclineLevelMessageDefaultTypeInternal() {}
  union {
    QBBOMWCBDeclineLevelMessage _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 QBBOMWCBDeclineLevelMessageDefaultTypeInternal _QBBOMWCBDeclineLevelMessage_default_instance_;
PROTOBUF_CONSTEXPR QBBOMessageHeader::QBBOMessageHeader(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.messagetype_)*/0
  , /*decltype(_impl_.trackingnumber_)*/0
  , /*decltype(_impl_.timestamp_)*/int64_t{0}} {}
struct QBBOMessageHeaderDefaultTypeInternal {
  PROTOBUF_CONSTEXPR QBBOMessageHeaderDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~QBBOMessageHeaderDefaultTypeInternal() {}
  union {
    QBBOMessageHeader _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 QBBOMessageHeaderDefaultTypeInternal _QBBOMessageHeader_default_instance_;
PROTOBUF_CONSTEXPR QBBONextSharesQuotationMessage::QBBONextSharesQuotationMessage(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.nextsharessymbol_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.nasdaqbestbid_)*/0
  , /*decltype(_impl_.nasdaqbestbidsize_)*/int64_t{0}
  , /*decltype(_impl_.nasdaqbestbiddiscountamount_)*/0
  , /*decltype(_impl_.nasdaqbestofferproxyprice_)*/0
  , /*decltype(_impl_.nasdaqbestoffersize_)*/int64_t{0}
  , /*decltype(_impl_.nasdaqbestofferdiscountamount_)*/0
  , /*decltype(_impl_.securityclass_)*/0} {}
struct QBBONextSharesQuotationMessageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR QBBONextSharesQuotationMessageDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~QBBONextSharesQuotationMessageDefaultTypeInternal() {}
  union {
    QBBONextSharesQuotationMessage _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 QBBONextSharesQuotationMessageDefaultTypeInternal _QBBONextSharesQuotationMessage_default_instance_;
PROTOBUF_CONSTEXPR QBBOOperationalHalt::QBBOOperationalHalt(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.stock_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.marketcode_)*/0
  , /*decltype(_impl_.operationalhaltaction_)*/0} {}
struct QBBOOperationalHaltDefaultTypeInternal {
  PROTOBUF_CONSTEXPR QBBOOperationalHaltDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~QBBOOperationalHaltDefaultTypeInternal() {}
  union {
    QBBOOperationalHalt _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 QBBOOperationalHaltDefaultTypeInternal _QBBOOperationalHalt_default_instance_;
PROTOBUF_CONSTEXPR QBBOQuotationMessage::QBBOQuotationMessage(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.stock_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.nasdaqbestbidprice_)*/0
  , /*decltype(_impl_.nasdaqbestbidsize_)*/int64_t{0}
  , /*decltype(_impl_.nasdaqbestofferprice_)*/0
  , /*decltype(_impl_.nasdaqbestoffersize_)*/int64_t{0}
  , /*decltype(_impl_.securityclass_)*/0} {}
struct QBBOQuotationMessageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR QBBOQuotationMessageDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~QBBOQuotationMessageDefaultTypeInternal() {}
  union {
    QBBOQuotationMessage _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 QBBOQuotationMessageDefaultTypeInternal _QBBOQuotationMessage_default_instance_;
PROTOBUF_CONSTEXPR QBBORegShoRestriction::QBBORegShoRestriction(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.stock_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.regshoaction_)*/0} {}
struct QBBORegShoRestrictionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR QBBORegShoRestrictionDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~QBBORegShoRestrictionDefaultTypeInternal() {}
  union {
    QBBORegShoRestriction _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 QBBORegShoRestrictionDefaultTypeInternal _QBBORegShoRestriction_default_instance_;
PROTOBUF_CONSTEXPR QBBOStockDirectory::QBBOStockDirectory(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.stock_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.issueclassification_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.issuesubtype_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.marketcategory_)*/0
  , /*decltype(_impl_.financialstatusindicator_)*/0
  , /*decltype(_impl_.roundlotsize_)*/int64_t{0}
  , /*decltype(_impl_.roundlotonly_)*/0
  , /*decltype(_impl_.authenticity_)*/0
  , /*decltype(_impl_.shortsalethresholdindicator_)*/0
  , /*decltype(_impl_.ipoflag_)*/0
  , /*decltype(_impl_.luldreferencepricetier_)*/0
  , /*decltype(_impl_.etplag_)*/0
  , /*decltype(_impl_.etpleveragefactor_)*/int64_t{0}
  , /*decltype(_impl_.inverseindicator_)*/0} {}
struct QBBOStockDirectoryDefaultTypeInternal {
  PROTOBUF_CONSTEXPR QBBOStockDirectoryDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~QBBOStockDirectoryDefaultTypeInternal() {}
  union {
    QBBOStockDirectory _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 QBBOStockDirectoryDefaultTypeInternal _QBBOStockDirectory_default_instance_;
PROTOBUF_CONSTEXPR QBBOStockTradingAction::QBBOStockTradingAction(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.stock_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.reason_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.securityclass_)*/0
  , /*decltype(_impl_.currenttradingstate_)*/0} {}
struct QBBOStockTradingActionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR QBBOStockTradingActionDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~QBBOStockTradingActionDefaultTypeInternal() {}
  union {
    QBBOStockTradingAction _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 QBBOStockTradingActionDefaultTypeInternal _QBBOStockTradingAction_default_instance_;
PROTOBUF_CONSTEXPR QBBOSystemEventMessage::QBBOSystemEventMessage(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.eventcode_)*/0} {}
struct QBBOSystemEventMessageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR QBBOSystemEventMessageDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~QBBOSystemEventMessageDefaultTypeInternal() {}
  union {
    QBBOSystemEventMessage _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 QBBOSystemEventMessageDefaultTypeInternal _QBBOSystemEventMessage_default_instance_;
PROTOBUF_CONSTEXPR AddOddLotOrder::AddOddLotOrder(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.securitycode_)*/int64_t{0}
  , /*decltype(_impl_.orderid_)*/int64_t{0}
  , /*decltype(_impl_.price_)*/0
  , /*decltype(_impl_.quantity_)*/int64_t{0}
  , /*decltype(_impl_.brokerid_)*/0
  , /*decltype(_impl_.side_)*/0} {}
struct AddOddLotOrderDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AddOddLotOrderDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~AddOddLotOrderDefaultTypeInternal() {}
  union {
    AddOddLotOrder _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AddOddLotOrderDefaultTypeInternal _AddOddLotOrder_default_instance_;
PROTOBUF_CONSTEXPR AggregateOrderBookUpdate::AggregateOrderBookUpdate(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.noentries_)*/{}
  , /*decltype(_impl_.securitycode_)*/int64_t{0}} {}
struct AggregateOrderBookUpdateDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AggregateOrderBookUpdateDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~AggregateOrderBookUpdateDefaultTypeInternal() {}
  union {
    AggregateOrderBookUpdate _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AggregateOrderBookUpdateDefaultTypeInternal _AggregateOrderBookUpdate_default_instance_;
PROTOBUF_CONSTEXPR BQMoreItem::BQMoreItem(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.item_)*/0
  , /*decltype(_impl_.type_)*/0} {}
struct BQMoreItemDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BQMoreItemDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~BQMoreItemDefaultTypeInternal() {}
  union {
    BQMoreItem _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BQMoreItemDefaultTypeInternal _BQMoreItem_default_instance_;
PROTOBUF_CONSTEXPR BrokerQueue::BrokerQueue(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.items_)*/{}
  , /*decltype(_impl_.securitycode_)*/int64_t{0}
  , /*decltype(_impl_.itemcount_)*/0
  , /*decltype(_impl_.side_)*/0
  , /*decltype(_impl_.bqmoreflag_)*/0} {}
struct BrokerQueueDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BrokerQueueDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~BrokerQueueDefaultTypeInternal() {}
  union {
    BrokerQueue _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BrokerQueueDefaultTypeInternal _BrokerQueue_default_instance_;
PROTOBUF_CONSTEXPR ClosingPrice::ClosingPrice(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.securitycode_)*/int64_t{0}
  , /*decltype(_impl_.closingprice_)*/0
  , /*decltype(_impl_.numberoftrades_)*/int64_t{0}} {}
struct ClosingPriceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ClosingPriceDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ClosingPriceDefaultTypeInternal() {}
  union {
    ClosingPrice _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClosingPriceDefaultTypeInternal _ClosingPrice_default_instance_;
PROTOBUF_CONSTEXPR CurrencyRate::CurrencyRate(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.currencycode_)*/0
  , /*decltype(_impl_.currencyfactor_)*/0
  , /*decltype(_impl_.currencyrate_)*/0} {}
struct CurrencyRateDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CurrencyRateDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CurrencyRateDefaultTypeInternal() {}
  union {
    CurrencyRate _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CurrencyRateDefaultTypeInternal _CurrencyRate_default_instance_;
PROTOBUF_CONSTEXPR DeleteOddLotOrder::DeleteOddLotOrder(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.securitycode_)*/int64_t{0}
  , /*decltype(_impl_.orderid_)*/int64_t{0}
  , /*decltype(_impl_.brokerid_)*/0
  , /*decltype(_impl_.side_)*/0} {}
struct DeleteOddLotOrderDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DeleteOddLotOrderDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DeleteOddLotOrderDefaultTypeInternal() {}
  union {
    DeleteOddLotOrder _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DeleteOddLotOrderDefaultTypeInternal _DeleteOddLotOrder_default_instance_;
PROTOBUF_CONSTEXPR IndexData::IndexData(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.indexcode_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.exception_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.indextime_)*/int64_t{0}
  , /*decltype(_impl_.indexvalue_)*/0
  , /*decltype(_impl_.netchgprevday_)*/0
  , /*decltype(_impl_.highvalue_)*/0
  , /*decltype(_impl_.lowvalue_)*/0
  , /*decltype(_impl_.easvalue_)*/0
  , /*decltype(_impl_.indexturnover_)*/0
  , /*decltype(_impl_.openingvalue_)*/0
  , /*decltype(_impl_.closingvalue_)*/0
  , /*decltype(_impl_.previoussesclose_)*/0
  , /*decltype(_impl_.indexvolume_)*/int64_t{0}
  , /*decltype(_impl_.netchgprevdaypct_)*/0
  , /*decltype(_impl_.indexstatus_)*/0} {}
struct IndexDataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR IndexDataDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~IndexDataDefaultTypeInternal() {}
  union {
    IndexData _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 IndexDataDefaultTypeInternal _IndexData_default_instance_;
PROTOBUF_CONSTEXPR IndexDefinition::IndexDefinition(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.indexcode_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.indexsource_)*/0
  , /*decltype(_impl_.currencycode_)*/0} {}
struct IndexDefinitionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR IndexDefinitionDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~IndexDefinitionDefaultTypeInternal() {}
  union {
    IndexDefinition _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 IndexDefinitionDefaultTypeInternal _IndexDefinition_default_instance_;
PROTOBUF_CONSTEXPR IndicativeEquilibriumPrice::IndicativeEquilibriumPrice(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.securitycode_)*/int64_t{0}
  , /*decltype(_impl_.price_)*/0
  , /*decltype(_impl_.aggregatequantity_)*/int64_t{0}} {}
struct IndicativeEquilibriumPriceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR IndicativeEquilibriumPriceDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~IndicativeEquilibriumPriceDefaultTypeInternal() {}
  union {
    IndicativeEquilibriumPrice _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 IndicativeEquilibriumPriceDefaultTypeInternal _IndicativeEquilibriumPrice_default_instance_;
PROTOBUF_CONSTEXPR LiquidityProvider::LiquidityProvider(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.noliquidityproviders_)*/{}
  , /*decltype(_impl_.securitycode_)*/int64_t{0}} {}
struct LiquidityProviderDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LiquidityProviderDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LiquidityProviderDefaultTypeInternal() {}
  union {
    LiquidityProvider _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LiquidityProviderDefaultTypeInternal _LiquidityProvider_default_instance_;
PROTOBUF_CONSTEXPR MarketDefinition::MarketDefinition(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.marketname_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.marketcode_)*/0
  , /*decltype(_impl_.currencycode_)*/0
  , /*decltype(_impl_.numberofsecurities_)*/int64_t{0}} {}
struct MarketDefinitionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MarketDefinitionDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MarketDefinitionDefaultTypeInternal() {}
  union {
    MarketDefinition _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MarketDefinitionDefaultTypeInternal _MarketDefinition_default_instance_;
PROTOBUF_CONSTEXPR MarketTurnover::MarketTurnover(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.marketcode_)*/0
  , /*decltype(_impl_.currencycode_)*/0
  , /*decltype(_impl_.turnover_)*/0} {}
struct MarketTurnoverDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MarketTurnoverDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MarketTurnoverDefaultTypeInternal() {}
  union {
    MarketTurnover _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MarketTurnoverDefaultTypeInternal _MarketTurnover_default_instance_;
PROTOBUF_CONSTEXPR News::News(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.nomarketcodes_)*/{}
  , /*decltype(_impl_.nosecuritycodes_)*/{}
  , /*decltype(_impl_.nonewslines_)*/{}
  , /*decltype(_impl_.newsid_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.headline_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.newstype_)*/0
  , /*decltype(_impl_.cancelflag_)*/0
  , /*decltype(_impl_.releasetime_)*/int64_t{0}
  , /*decltype(_impl_.lastfragment_)*/0} {}
struct NewsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NewsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~NewsDefaultTypeInternal() {}
  union {
    News _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NewsDefaultTypeInternal _News_default_instance_;
PROTOBUF_CONSTEXPR NoEntry::NoEntry(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.aggregatequantity_)*/int64_t{0}
  , /*decltype(_impl_.price_)*/0
  , /*decltype(_impl_.numberoforders_)*/int64_t{0}
  , /*decltype(_impl_.side_)*/0
  , /*decltype(_impl_.pricelevel_)*/0
  , /*decltype(_impl_.updateaction_)*/0} {}
struct NoEntryDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NoEntryDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~NoEntryDefaultTypeInternal() {}
  union {
    NoEntry _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NoEntryDefaultTypeInternal _NoEntry_default_instance_;
PROTOBUF_CONSTEXPR NoLiquidityProvider::NoLiquidityProvider(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.lpbrokernumber_)*/0} {}
struct NoLiquidityProviderDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NoLiquidityProviderDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~NoLiquidityProviderDefaultTypeInternal() {}
  union {
    NoLiquidityProvider _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NoLiquidityProviderDefaultTypeInternal _NoLiquidityProvider_default_instance_;
PROTOBUF_CONSTEXPR NoMarketCode::NoMarketCode(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.marketcode_)*/0} {}
struct NoMarketCodeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NoMarketCodeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~NoMarketCodeDefaultTypeInternal() {}
  union {
    NoMarketCode _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NoMarketCodeDefaultTypeInternal _NoMarketCode_default_instance_;
PROTOBUF_CONSTEXPR NoNewsLine::NoNewsLine(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.newsline_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct NoNewsLineDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NoNewsLineDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~NoNewsLineDefaultTypeInternal() {}
  union {
    NoNewsLine _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NoNewsLineDefaultTypeInternal _NoNewsLine_default_instance_;
PROTOBUF_CONSTEXPR NoSecurityCode::NoSecurityCode(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.securitycode_)*/int64_t{0}} {}
struct NoSecurityCodeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NoSecurityCodeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~NoSecurityCodeDefaultTypeInternal() {}
  union {
    NoSecurityCode _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NoSecurityCodeDefaultTypeInternal _NoSecurityCode_default_instance_;
PROTOBUF_CONSTEXPR NoUnderlyingSecurity::NoUnderlyingSecurity(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.underlyingsecuritycode_)*/int64_t{0}} {}
struct NoUnderlyingSecurityDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NoUnderlyingSecurityDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~NoUnderlyingSecurityDefaultTypeInternal() {}
  union {
    NoUnderlyingSecurity _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NoUnderlyingSecurityDefaultTypeInternal _NoUnderlyingSecurity_default_instance_;
PROTOBUF_CONSTEXPR NominalPrice::NominalPrice(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.securitycode_)*/int64_t{0}
  , /*decltype(_impl_.nominalprice_)*/0} {}
struct NominalPriceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NominalPriceDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~NominalPriceDefaultTypeInternal() {}
  union {
    NominalPrice _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NominalPriceDefaultTypeInternal _NominalPrice_default_instance_;
PROTOBUF_CONSTEXPR OrderImbalance::OrderImbalance(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.securitycode_)*/int64_t{0}
  , /*decltype(_impl_.orderimbalancequantity_)*/int64_t{0}
  , /*decltype(_impl_.orderimbalancedirection_)*/0} {}
struct OrderImbalanceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR OrderImbalanceDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~OrderImbalanceDefaultTypeInternal() {}
  union {
    OrderImbalance _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 OrderImbalanceDefaultTypeInternal _OrderImbalance_default_instance_;
PROTOBUF_CONSTEXPR PacketHeader::PacketHeader(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.filler_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.pktsize_)*/0
  , /*decltype(_impl_.msgcount_)*/0
  , /*decltype(_impl_.seqnum_)*/int64_t{0}
  , /*decltype(_impl_.sendtime_)*/int64_t{0}} {}
struct PacketHeaderDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PacketHeaderDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PacketHeaderDefaultTypeInternal() {}
  union {
    PacketHeader _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PacketHeaderDefaultTypeInternal _PacketHeader_default_instance_;
PROTOBUF_CONSTEXPR LongAdjustedClosingPrice::LongAdjustedClosingPrice(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.issuesymbol_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.adjustedclosingprice_)*/0
  , /*decltype(_impl_.securityclass_)*/0} {}
struct LongAdjustedClosingPriceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LongAdjustedClosingPriceDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LongAdjustedClosingPriceDefaultTypeInternal() {}
  union {
    LongAdjustedClosingPrice _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LongAdjustedClosingPriceDefaultTypeInternal _LongAdjustedClosingPrice_default_instance_;
PROTOBUF_CONSTEXPR LongDayTradeSummary::LongDayTradeSummary(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.issuesymbol_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.nasdaqhighprice_)*/0
  , /*decltype(_impl_.nasdaqlowprice_)*/0
  , /*decltype(_impl_.nasdaqclosingprice_)*/0
  , /*decltype(_impl_.consolidatedvolume_)*/int64_t{0}
  , /*decltype(_impl_.consolidatedopenprice_)*/0
  , /*decltype(_impl_.marketcategory_)*/0} {}
struct LongDayTradeSummaryDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LongDayTradeSummaryDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LongDayTradeSummaryDefaultTypeInternal() {}
  union {
    LongDayTradeSummary _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LongDayTradeSummaryDefaultTypeInternal _LongDayTradeSummary_default_instance_;
PROTOBUF_CONSTEXPR LongTradeCancelForNonNextSharesTrades::LongTradeCancelForNonNextSharesTrades(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.issuesymbol_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.originalcontrolnumber_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.originalsaleconditionmodifier_)*/nullptr
  , /*decltype(_impl_.marketcenteridentifier_)*/0
  , /*decltype(_impl_.securityclass_)*/0
  , /*decltype(_impl_.originaltradeprice_)*/0
  , /*decltype(_impl_.originaltradesize_)*/int64_t{0}
  , /*decltype(_impl_.consolidatedvolume_)*/int64_t{0}} {}
struct LongTradeCancelForNonNextSharesTradesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LongTradeCancelForNonNextSharesTradesDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LongTradeCancelForNonNextSharesTradesDefaultTypeInternal() {}
  union {
    LongTradeCancelForNonNextSharesTrades _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LongTradeCancelForNonNextSharesTradesDefaultTypeInternal _LongTradeCancelForNonNextSharesTrades_default_instance_;
PROTOBUF_CONSTEXPR LongTradeCorrectionForNonNextsharesTrades::LongTradeCorrectionForNonNextsharesTrades(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.issuesymbol_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.originalcontrolnumber_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.originalconditionmodifier_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.correctedtradecontrolnumber_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.correctedsaleconditionmodifier_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.marketcenteridentifier_)*/0
  , /*decltype(_impl_.securityclass_)*/0
  , /*decltype(_impl_.originaltradeprice_)*/0
  , /*decltype(_impl_.originaltradesize_)*/int64_t{0}
  , /*decltype(_impl_.correctedtradeprice_)*/0
  , /*decltype(_impl_.correctedtradesize_)*/int64_t{0}
  , /*decltype(_impl_.consolidatedvolume_)*/int64_t{0}} {}
struct LongTradeCorrectionForNonNextsharesTradesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LongTradeCorrectionForNonNextsharesTradesDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LongTradeCorrectionForNonNextsharesTradesDefaultTypeInternal() {}
  union {
    LongTradeCorrectionForNonNextsharesTrades _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LongTradeCorrectionForNonNextsharesTradesDefaultTypeInternal _LongTradeCorrectionForNonNextsharesTrades_default_instance_;
PROTOBUF_CONSTEXPR LongTradeReportForNonNextshares::LongTradeReportForNonNextshares(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.consolidatedvolume_)*/int64_t{0}} {}
struct LongTradeReportForNonNextsharesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LongTradeReportForNonNextsharesDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LongTradeReportForNonNextsharesDefaultTypeInternal() {}
  union {
    LongTradeReportForNonNextshares _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LongTradeReportForNonNextsharesDefaultTypeInternal _LongTradeReportForNonNextshares_default_instance_;
PROTOBUF_CONSTEXPR ReferencePrice::ReferencePrice(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.securitycode_)*/int64_t{0}
  , /*decltype(_impl_.referenceprice_)*/0
  , /*decltype(_impl_.lowerprice_)*/0
  , /*decltype(_impl_.upperprice_)*/0} {}
struct ReferencePriceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ReferencePriceDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ReferencePriceDefaultTypeInternal() {}
  union {
    ReferencePrice _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ReferencePriceDefaultTypeInternal _ReferencePrice_default_instance_;
PROTOBUF_CONSTEXPR QBBOIPOQuotingPeriodUpdate::QBBOIPOQuotingPeriodUpdate(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.stock_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.ipoquotationreleasetime_)*/int64_t{0}
  , /*decltype(_impl_.ipoprice_)*/0
  , /*decltype(_impl_.quotationreleasequalifier_)*/0} {}
struct QBBOIPOQuotingPeriodUpdateDefaultTypeInternal {
  PROTOBUF_CONSTEXPR QBBOIPOQuotingPeriodUpdateDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~QBBOIPOQuotingPeriodUpdateDefaultTypeInternal() {}
  union {
    QBBOIPOQuotingPeriodUpdate _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 QBBOIPOQuotingPeriodUpdateDefaultTypeInternal _QBBOIPOQuotingPeriodUpdate_default_instance_;
PROTOBUF_CONSTEXPR SecurityDefinition::SecurityDefinition(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.nounderlyingsecurities_)*/{}
  , /*decltype(_impl_.isincode_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.securityshortname_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.securitynamegccs_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.securitynamegb_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.vcmflag_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.freetext_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.facevaluecurrency_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.warranttype_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.securitycode_)*/int64_t{0}
  , /*decltype(_impl_.marketcode_)*/0
  , /*decltype(_impl_.instrumenttype_)*/0
  , /*decltype(_impl_.producttype_)*/0
  , /*decltype(_impl_.spreadtablecode_)*/0
  , /*decltype(_impl_.lotsize_)*/int64_t{0}
  , /*decltype(_impl_.currencycode_)*/0
  , /*decltype(_impl_.shortsellflag_)*/0
  , /*decltype(_impl_.previousclosingprice_)*/0
  , /*decltype(_impl_.casflag_)*/0
  , /*decltype(_impl_.ccassflag_)*/0
  , /*decltype(_impl_.dummysecurityflag_)*/0
  , /*decltype(_impl_.stampdutyflag_)*/0
  , /*decltype(_impl_.listingdate_)*/int64_t{0}
  , /*decltype(_impl_.delistingdate_)*/int64_t{0}
  , /*decltype(_impl_.posflag_)*/0
  , /*decltype(_impl_.posupperlimit_)*/0
  , /*decltype(_impl_.poslowerlimit_)*/0
  , /*decltype(_impl_.efnflag_)*/0
  , /*decltype(_impl_.accruedinterest_)*/0
  , /*decltype(_impl_.couponrate_)*/0
  , /*decltype(_impl_.facevalue_)*/int64_t{0}
  , /*decltype(_impl_.decimalsinfacevalue_)*/0
  , /*decltype(_impl_.investortype_)*/0
  , /*decltype(_impl_.bondmaturitydate_)*/int64_t{0}
  , /*decltype(_impl_.conversionratio_)*/0
  , /*decltype(_impl_.strikeprice1_)*/0
  , /*decltype(_impl_.strikeprice2_)*/0
  , /*decltype(_impl_.warrantmaturitydate_)*/int64_t{0}
  , /*decltype(_impl_.callputflag_)*/0
  , /*decltype(_impl_.style_)*/0
  , /*decltype(_impl_.callprice_)*/0
  , /*decltype(_impl_.decimalsincallprice_)*/0
  , /*decltype(_impl_.entitlement_)*/0
  , /*decltype(_impl_.decimalsinentitlement_)*/0
  , /*decltype(_impl_.nowarrantsperentitlement_)*/int64_t{0}} {}
struct SecurityDefinitionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SecurityDefinitionDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SecurityDefinitionDefaultTypeInternal() {}
  union {
    SecurityDefinition _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SecurityDefinitionDefaultTypeInternal _SecurityDefinition_default_instance_;
PROTOBUF_CONSTEXPR SecurityStatus::SecurityStatus(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.securitycode_)*/int64_t{0}
  , /*decltype(_impl_.suspensionindicator_)*/0} {}
struct SecurityStatusDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SecurityStatusDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SecurityStatusDefaultTypeInternal() {}
  union {
    SecurityStatus _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SecurityStatusDefaultTypeInternal _SecurityStatus_default_instance_;
PROTOBUF_CONSTEXPR Statistics::Statistics(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.securitycode_)*/int64_t{0}
  , /*decltype(_impl_.sharestraded_)*/int64_t{0}
  , /*decltype(_impl_.vcmreferenceprice_)*/0
  , /*decltype(_impl_.highprice_)*/0
  , /*decltype(_impl_.lowprice_)*/0
  , /*decltype(_impl_.lastprice_)*/0
  , /*decltype(_impl_.vwap_)*/0
  , /*decltype(_impl_.shortsellsharestraded_)*/int64_t{0}
  , /*decltype(_impl_.shortsellturnover_)*/0} {}
struct StatisticsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StatisticsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~StatisticsDefaultTypeInternal() {}
  union {
    Statistics _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StatisticsDefaultTypeInternal _Statistics_default_instance_;
PROTOBUF_CONSTEXPR StockConnectDailyQuotaBalance::StockConnectDailyQuotaBalance(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.stockconnectmarket_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.tradingdirection_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.dailyquotabalance_)*/int64_t{0}
  , /*decltype(_impl_.dailyquotabalancetime_)*/int64_t{0}} {}
struct StockConnectDailyQuotaBalanceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StockConnectDailyQuotaBalanceDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~StockConnectDailyQuotaBalanceDefaultTypeInternal() {}
  union {
    StockConnectDailyQuotaBalance _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StockConnectDailyQuotaBalanceDefaultTypeInternal _StockConnectDailyQuotaBalance_default_instance_;
PROTOBUF_CONSTEXPR StockConnectMarketTurnover::StockConnectMarketTurnover(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.stockconnectmarket_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.tradingdirection_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.buyturnover_)*/int64_t{0}
  , /*decltype(_impl_.sellturnover_)*/int64_t{0}
  , /*decltype(_impl_.buysellturnover_)*/int64_t{0}} {}
struct StockConnectMarketTurnoverDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StockConnectMarketTurnoverDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~StockConnectMarketTurnoverDefaultTypeInternal() {}
  union {
    StockConnectMarketTurnover _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StockConnectMarketTurnoverDefaultTypeInternal _StockConnectMarketTurnover_default_instance_;
PROTOBUF_CONSTEXPR Trade::Trade(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.securitycode_)*/int64_t{0}
  , /*decltype(_impl_.tradeid_)*/int64_t{0}
  , /*decltype(_impl_.price_)*/0
  , /*decltype(_impl_.quantity_)*/int64_t{0}
  , /*decltype(_impl_.tradetime_)*/int64_t{0}
  , /*decltype(_impl_.trdtype_)*/0} {}
struct TradeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TradeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TradeDefaultTypeInternal() {}
  union {
    Trade _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TradeDefaultTypeInternal _Trade_default_instance_;
PROTOBUF_CONSTEXPR TradeCancel::TradeCancel(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.securitycode_)*/int64_t{0}
  , /*decltype(_impl_.tradeid_)*/int64_t{0}} {}
struct TradeCancelDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TradeCancelDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TradeCancelDefaultTypeInternal() {}
  union {
    TradeCancel _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TradeCancelDefaultTypeInternal _TradeCancel_default_instance_;
PROTOBUF_CONSTEXPR TradingSessionStatus::TradingSessionStatus(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.marketcode_)*/0
  , /*decltype(_impl_.tradingsessionsubid_)*/0
  , /*decltype(_impl_.tradingsesstatus_)*/0
  , /*decltype(_impl_.tradingsescontrolflag_)*/0
  , /*decltype(_impl_.startdatetime_)*/int64_t{0}
  , /*decltype(_impl_.enddatetime_)*/int64_t{0}} {}
struct TradingSessionStatusDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TradingSessionStatusDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TradingSessionStatusDefaultTypeInternal() {}
  union {
    TradingSessionStatus _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TradingSessionStatusDefaultTypeInternal _TradingSessionStatus_default_instance_;
PROTOBUF_CONSTEXPR VCMTrigger::VCMTrigger(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.securitycode_)*/int64_t{0}
  , /*decltype(_impl_.coolingoffstarttime_)*/int64_t{0}
  , /*decltype(_impl_.coolingoffendtime_)*/int64_t{0}
  , /*decltype(_impl_.vcmreferenceprice_)*/0
  , /*decltype(_impl_.vcmlowerprice_)*/0
  , /*decltype(_impl_.vcmupperprice_)*/0} {}
struct VCMTriggerDefaultTypeInternal {
  PROTOBUF_CONSTEXPR VCMTriggerDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~VCMTriggerDefaultTypeInternal() {}
  union {
    VCMTrigger _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 VCMTriggerDefaultTypeInternal _VCMTrigger_default_instance_;
PROTOBUF_CONSTEXPR Yield::Yield(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.securitycode_)*/int64_t{0}
  , /*decltype(_impl_.yield_)*/0} {}
struct YieldDefaultTypeInternal {
  PROTOBUF_CONSTEXPR YieldDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~YieldDefaultTypeInternal() {}
  union {
    Yield _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 YieldDefaultTypeInternal _Yield_default_instance_;
PROTOBUF_CONSTEXPR CNMarketDefinition::CNMarketDefinition(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.marketname_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.marketcode_)*/0
  , /*decltype(_impl_.currencycode_)*/0
  , /*decltype(_impl_.numberofsecurities_)*/int64_t{0}} {}
struct CNMarketDefinitionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CNMarketDefinitionDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CNMarketDefinitionDefaultTypeInternal() {}
  union {
    CNMarketDefinition _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CNMarketDefinitionDefaultTypeInternal _CNMarketDefinition_default_instance_;
PROTOBUF_CONSTEXPR CNSecurityDefinition::CNSecurityDefinition(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.isincode_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.securityshortname_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.securitynamegb_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.securitycode_)*/int64_t{0}
  , /*decltype(_impl_.marketcode_)*/0
  , /*decltype(_impl_.instrumenttype_)*/0
  , /*decltype(_impl_.lotsize_)*/int64_t{0}
  , /*decltype(_impl_.currencycode_)*/0
  , /*decltype(_impl_.shortsellflag_)*/0
  , /*decltype(_impl_.previousclosingprice_)*/0
  , /*decltype(_impl_.listingdate_)*/int64_t{0}} {}
struct CNSecurityDefinitionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CNSecurityDefinitionDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CNSecurityDefinitionDefaultTypeInternal() {}
  union {
    CNSecurityDefinition _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CNSecurityDefinitionDefaultTypeInternal _CNSecurityDefinition_default_instance_;
PROTOBUF_CONSTEXPR CNSecurityStatus::CNSecurityStatus(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.tradingphasecode_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.securitycode_)*/int64_t{0}
  , /*decltype(_impl_.securitytradingstatus_)*/0} {}
struct CNSecurityStatusDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CNSecurityStatusDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CNSecurityStatusDefaultTypeInternal() {}
  union {
    CNSecurityStatus _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CNSecurityStatusDefaultTypeInternal _CNSecurityStatus_default_instance_;
PROTOBUF_CONSTEXPR CNStatistics::CNStatistics(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.securitycode_)*/int64_t{0}
  , /*decltype(_impl_.sharestraded_)*/int64_t{0}
  , /*decltype(_impl_.turnover_)*/0
  , /*decltype(_impl_.highprice_)*/0
  , /*decltype(_impl_.lowprice_)*/0
  , /*decltype(_impl_.lastprice_)*/0
  , /*decltype(_impl_.openingprice_)*/0} {}
struct CNStatisticsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CNStatisticsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CNStatisticsDefaultTypeInternal() {}
  union {
    CNStatistics _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CNStatisticsDefaultTypeInternal _CNStatistics_default_instance_;
PROTOBUF_CONSTEXPR CNTopBook::CNTopBook(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.securitycode_)*/int64_t{0}
  , /*decltype(_impl_.aggregatebidquantity_)*/int64_t{0}
  , /*decltype(_impl_.aggregateaskquantity_)*/int64_t{0}
  , /*decltype(_impl_.bidprice_)*/0
  , /*decltype(_impl_.askprice_)*/0} {}
struct CNTopBookDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CNTopBookDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CNTopBookDefaultTypeInternal() {}
  union {
    CNTopBook _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CNTopBookDefaultTypeInternal _CNTopBook_default_instance_;
PROTOBUF_CONSTEXPR CertificationMsg::CertificationMsg(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.auth_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.response_)*/nullptr
  , /*decltype(_impl_.actiontype_)*/0} {}
struct CertificationMsgDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CertificationMsgDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CertificationMsgDefaultTypeInternal() {}
  union {
    CertificationMsg _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CertificationMsgDefaultTypeInternal _CertificationMsg_default_instance_;
PROTOBUF_CONSTEXPR Resp::Resp(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.errormsg_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.type_)*/0} {}
struct RespDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RespDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RespDefaultTypeInternal() {}
  union {
    Resp _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RespDefaultTypeInternal _Resp_default_instance_;
PROTOBUF_CONSTEXPR Message::Message(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.timestamp_)*/int64_t{0}
  , /*decltype(_impl_.data_type_)*/0
  , /*decltype(_impl_.dataBody_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct MessageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MessageDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MessageDefaultTypeInternal() {}
  union {
    Message _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MessageDefaultTypeInternal _Message_default_instance_;
}  // namespace data
static ::_pb::Metadata file_level_metadata_data_2eproto[78];
static const ::_pb::EnumDescriptor* file_level_enum_descriptors_data_2eproto[54];
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_data_2eproto = nullptr;

const uint32_t TableStruct_data_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  PROTOBUF_FIELD_OFFSET(::data::AdjustedClosingPrice, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::data::AdjustedClosingPrice, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::data::AdjustedClosingPrice, _impl_.issuesymbol_),
  PROTOBUF_FIELD_OFFSET(::data::AdjustedClosingPrice, _impl_.securityclass_),
  PROTOBUF_FIELD_OFFSET(::data::AdjustedClosingPrice, _impl_.adjustedclosingprice_),
  0,
  2,
  1,
  PROTOBUF_FIELD_OFFSET(::data::DayTradeSummary, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::data::DayTradeSummary, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::data::DayTradeSummary, _impl_.issuesymbol_),
  PROTOBUF_FIELD_OFFSET(::data::DayTradeSummary, _impl_.marketcategory_),
  PROTOBUF_FIELD_OFFSET(::data::DayTradeSummary, _impl_.nasdaqhighprice_),
  PROTOBUF_FIELD_OFFSET(::data::DayTradeSummary, _impl_.nasdaqlowprice_),
  PROTOBUF_FIELD_OFFSET(::data::DayTradeSummary, _impl_.nasdaqclosingprice_),
  PROTOBUF_FIELD_OFFSET(::data::DayTradeSummary, _impl_.consolidatedvolume_),
  0,
  5,
  1,
  2,
  3,
  4,
  PROTOBUF_FIELD_OFFSET(::data::DayTradeSummaryNextShares, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::data::DayTradeSummaryNextShares, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::data::DayTradeSummaryNextShares, _impl_.issuesymbol_),
  PROTOBUF_FIELD_OFFSET(::data::DayTradeSummaryNextShares, _impl_.marketcategory_),
  PROTOBUF_FIELD_OFFSET(::data::DayTradeSummaryNextShares, _impl_.nasdaqhighprice_),
  PROTOBUF_FIELD_OFFSET(::data::DayTradeSummaryNextShares, _impl_.navoffsetamounthigh_),
  PROTOBUF_FIELD_OFFSET(::data::DayTradeSummaryNextShares, _impl_.nasdaqlowprice_),
  PROTOBUF_FIELD_OFFSET(::data::DayTradeSummaryNextShares, _impl_.navoffsetamountlow_),
  PROTOBUF_FIELD_OFFSET(::data::DayTradeSummaryNextShares, _impl_.nasdaqclosingprice_),
  PROTOBUF_FIELD_OFFSET(::data::DayTradeSummaryNextShares, _impl_.navoffsetamountclose_),
  PROTOBUF_FIELD_OFFSET(::data::DayTradeSummaryNextShares, _impl_.consolidatedvolume_),
  0,
  8,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  PROTOBUF_FIELD_OFFSET(::data::IPOInformation, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::data::IPOInformation, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::data::IPOInformation, _impl_.issuesymbol_),
  PROTOBUF_FIELD_OFFSET(::data::IPOInformation, _impl_.securityclass_),
  PROTOBUF_FIELD_OFFSET(::data::IPOInformation, _impl_.referencefornetchange_),
  PROTOBUF_FIELD_OFFSET(::data::IPOInformation, _impl_.referenceprice_),
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::data::IPOQuotingPeriodUpdate, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::data::IPOQuotingPeriodUpdate, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::data::IPOQuotingPeriodUpdate, _impl_.stock_),
  PROTOBUF_FIELD_OFFSET(::data::IPOQuotingPeriodUpdate, _impl_.ipoquotationreleasetime_),
  PROTOBUF_FIELD_OFFSET(::data::IPOQuotingPeriodUpdate, _impl_.quotationreleasequalifier_),
  PROTOBUF_FIELD_OFFSET(::data::IPOQuotingPeriodUpdate, _impl_.ipoprice_),
  0,
  1,
  3,
  2,
  PROTOBUF_FIELD_OFFSET(::data::MWCBStatusMessage, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::data::MWCBStatusMessage, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::data::MWCBStatusMessage, _impl_.breachedlevel_),
  0,
  PROTOBUF_FIELD_OFFSET(::data::MarketWideCircuitBreaker, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::data::MarketWideCircuitBreaker, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::data::MarketWideCircuitBreaker, _impl_.level1_),
  PROTOBUF_FIELD_OFFSET(::data::MarketWideCircuitBreaker, _impl_.level2_),
  PROTOBUF_FIELD_OFFSET(::data::MarketWideCircuitBreaker, _impl_.level3_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::data::MessageHeader, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::data::MessageHeader, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::data::MessageHeader, _impl_.trackingnumber_),
  PROTOBUF_FIELD_OFFSET(::data::MessageHeader, _impl_.timestamp_),
  PROTOBUF_FIELD_OFFSET(::data::MessageHeader, _impl_.messagetype_),
  1,
  0,
  2,
  PROTOBUF_FIELD_OFFSET(::data::OperationalHalt, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::data::OperationalHalt, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::data::OperationalHalt, _impl_.stock_),
  PROTOBUF_FIELD_OFFSET(::data::OperationalHalt, _impl_.marketcode_),
  PROTOBUF_FIELD_OFFSET(::data::OperationalHalt, _impl_.operationalhaltaction_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::data::SaleConditionModifier, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::data::SaleConditionModifier, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::data::SaleConditionModifier, _impl_.level1_),
  PROTOBUF_FIELD_OFFSET(::data::SaleConditionModifier, _impl_.level2_),
  PROTOBUF_FIELD_OFFSET(::data::SaleConditionModifier, _impl_.level3_),
  PROTOBUF_FIELD_OFFSET(::data::SaleConditionModifier, _impl_.level4_),
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::data::ShortSaleRestrictionIndicatorMessage, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::data::ShortSaleRestrictionIndicatorMessage, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::data::ShortSaleRestrictionIndicatorMessage, _impl_.issuesymbol_),
  PROTOBUF_FIELD_OFFSET(::data::ShortSaleRestrictionIndicatorMessage, _impl_.regshoaction_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::data::StockDirectory, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::data::StockDirectory, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::data::StockDirectory, _impl_.stock_),
  PROTOBUF_FIELD_OFFSET(::data::StockDirectory, _impl_.marketcategory_),
  PROTOBUF_FIELD_OFFSET(::data::StockDirectory, _impl_.financialstatusindicator_),
  PROTOBUF_FIELD_OFFSET(::data::StockDirectory, _impl_.roundlotsize_),
  PROTOBUF_FIELD_OFFSET(::data::StockDirectory, _impl_.roundlotonly_),
  PROTOBUF_FIELD_OFFSET(::data::StockDirectory, _impl_.issueclassification_),
  PROTOBUF_FIELD_OFFSET(::data::StockDirectory, _impl_.issuesubtype_),
  PROTOBUF_FIELD_OFFSET(::data::StockDirectory, _impl_.authenticity_),
  PROTOBUF_FIELD_OFFSET(::data::StockDirectory, _impl_.shortsalethresholdindicator_),
  PROTOBUF_FIELD_OFFSET(::data::StockDirectory, _impl_.ipoflag_),
  PROTOBUF_FIELD_OFFSET(::data::StockDirectory, _impl_.luldreferencepricetier_),
  PROTOBUF_FIELD_OFFSET(::data::StockDirectory, _impl_.etplag_),
  PROTOBUF_FIELD_OFFSET(::data::StockDirectory, _impl_.etpleveragefactor_),
  PROTOBUF_FIELD_OFFSET(::data::StockDirectory, _impl_.inverseindicator_),
  PROTOBUF_FIELD_OFFSET(::data::StockDirectory, _impl_.bloombergid_),
  0,
  4,
  5,
  6,
  7,
  1,
  2,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  3,
  PROTOBUF_FIELD_OFFSET(::data::StockTradingAction, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::data::StockTradingAction, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::data::StockTradingAction, _impl_.reserved_),
  PROTOBUF_FIELD_OFFSET(::data::StockTradingAction, _impl_.issuesymbol_),
  PROTOBUF_FIELD_OFFSET(::data::StockTradingAction, _impl_.securityclass_),
  PROTOBUF_FIELD_OFFSET(::data::StockTradingAction, _impl_.currenttradingstate_),
  PROTOBUF_FIELD_OFFSET(::data::StockTradingAction, _impl_.reason_),
  0,
  1,
  3,
  4,
  2,
  PROTOBUF_FIELD_OFFSET(::data::SystemEventMessage, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::data::SystemEventMessage, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::data::SystemEventMessage, _impl_.eventcode_),
  0,
  PROTOBUF_FIELD_OFFSET(::data::TradeCancelForNextsharesTrades, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::data::TradeCancelForNextsharesTrades, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::data::TradeCancelForNextsharesTrades, _impl_.marketcenteridentifier_),
  PROTOBUF_FIELD_OFFSET(::data::TradeCancelForNextsharesTrades, _impl_.issuesymbol_),
  PROTOBUF_FIELD_OFFSET(::data::TradeCancelForNextsharesTrades, _impl_.securityclass_),
  PROTOBUF_FIELD_OFFSET(::data::TradeCancelForNextsharesTrades, _impl_.originaltradecontrolnumber_),
  PROTOBUF_FIELD_OFFSET(::data::TradeCancelForNextsharesTrades, _impl_.originalproxyprice_),
  PROTOBUF_FIELD_OFFSET(::data::TradeCancelForNextsharesTrades, _impl_.originalnavoffsetamount_),
  PROTOBUF_FIELD_OFFSET(::data::TradeCancelForNextsharesTrades, _impl_.originaltradesize_),
  PROTOBUF_FIELD_OFFSET(::data::TradeCancelForNextsharesTrades, _impl_.originalsaleconditionmodifier_),
  PROTOBUF_FIELD_OFFSET(::data::TradeCancelForNextsharesTrades, _impl_.consolidatedvolume_),
  3,
  0,
  4,
  1,
  5,
  6,
  7,
  2,
  8,
  PROTOBUF_FIELD_OFFSET(::data::TradeCancelForNonNextSharesTrades, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::data::TradeCancelForNonNextSharesTrades, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::data::TradeCancelForNonNextSharesTrades, _impl_.marketcenteridentifier_),
  PROTOBUF_FIELD_OFFSET(::data::TradeCancelForNonNextSharesTrades, _impl_.issuesymbol_),
  PROTOBUF_FIELD_OFFSET(::data::TradeCancelForNonNextSharesTrades, _impl_.securityclass_),
  PROTOBUF_FIELD_OFFSET(::data::TradeCancelForNonNextSharesTrades, _impl_.originalcontrolnumber_),
  PROTOBUF_FIELD_OFFSET(::data::TradeCancelForNonNextSharesTrades, _impl_.originaltradeprice_),
  PROTOBUF_FIELD_OFFSET(::data::TradeCancelForNonNextSharesTrades, _impl_.originaltradesize_),
  PROTOBUF_FIELD_OFFSET(::data::TradeCancelForNonNextSharesTrades, _impl_.originalsaleconditionmodifier_),
  PROTOBUF_FIELD_OFFSET(::data::TradeCancelForNonNextSharesTrades, _impl_.consolidatedvolume_),
  3,
  0,
  4,
  1,
  5,
  6,
  2,
  7,
  PROTOBUF_FIELD_OFFSET(::data::TradeCorrectionForNextsharesTrades, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::data::TradeCorrectionForNextsharesTrades, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::data::TradeCorrectionForNextsharesTrades, _impl_.marketcenteridentifier_),
  PROTOBUF_FIELD_OFFSET(::data::TradeCorrectionForNextsharesTrades, _impl_.issuesymbol_),
  PROTOBUF_FIELD_OFFSET(::data::TradeCorrectionForNextsharesTrades, _impl_.securityclass_),
  PROTOBUF_FIELD_OFFSET(::data::TradeCorrectionForNextsharesTrades, _impl_.originalcontrolnumber_),
  PROTOBUF_FIELD_OFFSET(::data::TradeCorrectionForNextsharesTrades, _impl_.originalproxyprice_),
  PROTOBUF_FIELD_OFFSET(::data::TradeCorrectionForNextsharesTrades, _impl_.originalnavoffsetamount_),
  PROTOBUF_FIELD_OFFSET(::data::TradeCorrectionForNextsharesTrades, _impl_.originaltradesize_),
  PROTOBUF_FIELD_OFFSET(::data::TradeCorrectionForNextsharesTrades, _impl_.originalconditionmodifier_),
  PROTOBUF_FIELD_OFFSET(::data::TradeCorrectionForNextsharesTrades, _impl_.correctedtradecontrolnumber_),
  PROTOBUF_FIELD_OFFSET(::data::TradeCorrectionForNextsharesTrades, _impl_.correctedtradeprice_),
  PROTOBUF_FIELD_OFFSET(::data::TradeCorrectionForNextsharesTrades, _impl_.correctednavoffsetamount_),
  PROTOBUF_FIELD_OFFSET(::data::TradeCorrectionForNextsharesTrades, _impl_.correctedtradesize_),
  PROTOBUF_FIELD_OFFSET(::data::TradeCorrectionForNextsharesTrades, _impl_.correctedsaleconditionmodifier_),
  PROTOBUF_FIELD_OFFSET(::data::TradeCorrectionForNextsharesTrades, _impl_.consolidatedvolume_),
  5,
  0,
  6,
  1,
  7,
  8,
  9,
  2,
  3,
  10,
  11,
  12,
  4,
  13,
  PROTOBUF_FIELD_OFFSET(::data::TradeCorrectionForNonNextsharesTrades, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::data::TradeCorrectionForNonNextsharesTrades, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::data::TradeCorrectionForNonNextsharesTrades, _impl_.marketcenteridentifier_),
  PROTOBUF_FIELD_OFFSET(::data::TradeCorrectionForNonNextsharesTrades, _impl_.issuesymbol_),
  PROTOBUF_FIELD_OFFSET(::data::TradeCorrectionForNonNextsharesTrades, _impl_.securityclass_),
  PROTOBUF_FIELD_OFFSET(::data::TradeCorrectionForNonNextsharesTrades, _impl_.originalcontrolnumber_),
  PROTOBUF_FIELD_OFFSET(::data::TradeCorrectionForNonNextsharesTrades, _impl_.originaltradeprice_),
  PROTOBUF_FIELD_OFFSET(::data::TradeCorrectionForNonNextsharesTrades, _impl_.originaltradesize_),
  PROTOBUF_FIELD_OFFSET(::data::TradeCorrectionForNonNextsharesTrades, _impl_.originalconditionmodifier_),
  PROTOBUF_FIELD_OFFSET(::data::TradeCorrectionForNonNextsharesTrades, _impl_.correctedtradecontrolnumber_),
  PROTOBUF_FIELD_OFFSET(::data::TradeCorrectionForNonNextsharesTrades, _impl_.correctedtradeprice_),
  PROTOBUF_FIELD_OFFSET(::data::TradeCorrectionForNonNextsharesTrades, _impl_.correctedtradesize_),
  PROTOBUF_FIELD_OFFSET(::data::TradeCorrectionForNonNextsharesTrades, _impl_.correctedsaleconditionmodifier_),
  PROTOBUF_FIELD_OFFSET(::data::TradeCorrectionForNonNextsharesTrades, _impl_.consolidatedvolume_),
  5,
  0,
  6,
  1,
  7,
  8,
  2,
  3,
  9,
  10,
  4,
  11,
  PROTOBUF_FIELD_OFFSET(::data::TradeReportForNextshares, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::data::TradeReportForNextshares, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::data::TradeReportForNextshares, _impl_.originatingmarketcenteridentifier_),
  PROTOBUF_FIELD_OFFSET(::data::TradeReportForNextshares, _impl_.nextsharessymbol_),
  PROTOBUF_FIELD_OFFSET(::data::TradeReportForNextshares, _impl_.securityclass_),
  PROTOBUF_FIELD_OFFSET(::data::TradeReportForNextshares, _impl_.tradecontrolnumber_),
  PROTOBUF_FIELD_OFFSET(::data::TradeReportForNextshares, _impl_.proxyprice_),
  PROTOBUF_FIELD_OFFSET(::data::TradeReportForNextshares, _impl_.tradesize_),
  PROTOBUF_FIELD_OFFSET(::data::TradeReportForNextshares, _impl_.navoffsetamount_),
  PROTOBUF_FIELD_OFFSET(::data::TradeReportForNextshares, _impl_.saleconditionmodifier_),
  PROTOBUF_FIELD_OFFSET(::data::TradeReportForNextshares, _impl_.consolidatedvolume_),
  3,
  0,
  4,
  1,
  5,
  6,
  7,
  2,
  8,
  PROTOBUF_FIELD_OFFSET(::data::TradeReportForNonNextshares, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::data::TradeReportForNonNextshares, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::data::TradeReportForNonNextshares, _impl_.originatingmarketcenteridentifier_),
  PROTOBUF_FIELD_OFFSET(::data::TradeReportForNonNextshares, _impl_.issuesymbol_),
  PROTOBUF_FIELD_OFFSET(::data::TradeReportForNonNextshares, _impl_.securityclass_),
  PROTOBUF_FIELD_OFFSET(::data::TradeReportForNonNextshares, _impl_.tradecontrolnumber_),
  PROTOBUF_FIELD_OFFSET(::data::TradeReportForNonNextshares, _impl_.tradeprice_),
  PROTOBUF_FIELD_OFFSET(::data::TradeReportForNonNextshares, _impl_.tradesize_),
  PROTOBUF_FIELD_OFFSET(::data::TradeReportForNonNextshares, _impl_.saleconditionmodifier_),
  PROTOBUF_FIELD_OFFSET(::data::TradeReportForNonNextshares, _impl_.consolidatedvolume_),
  3,
  0,
  4,
  1,
  5,
  6,
  2,
  7,
  PROTOBUF_FIELD_OFFSET(::data::QBBOMWCBBreachMessage, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::data::QBBOMWCBBreachMessage, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::data::QBBOMWCBBreachMessage, _impl_.breachedlevel_),
  0,
  PROTOBUF_FIELD_OFFSET(::data::QBBOMWCBDeclineLevelMessage, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::data::QBBOMWCBDeclineLevelMessage, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::data::QBBOMWCBDeclineLevelMessage, _impl_.level1_),
  PROTOBUF_FIELD_OFFSET(::data::QBBOMWCBDeclineLevelMessage, _impl_.level2_),
  PROTOBUF_FIELD_OFFSET(::data::QBBOMWCBDeclineLevelMessage, _impl_.level3_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::data::QBBOMessageHeader, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::data::QBBOMessageHeader, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::data::QBBOMessageHeader, _impl_.messagetype_),
  PROTOBUF_FIELD_OFFSET(::data::QBBOMessageHeader, _impl_.trackingnumber_),
  PROTOBUF_FIELD_OFFSET(::data::QBBOMessageHeader, _impl_.timestamp_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::data::QBBONextSharesQuotationMessage, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::data::QBBONextSharesQuotationMessage, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::data::QBBONextSharesQuotationMessage, _impl_.nextsharessymbol_),
  PROTOBUF_FIELD_OFFSET(::data::QBBONextSharesQuotationMessage, _impl_.securityclass_),
  PROTOBUF_FIELD_OFFSET(::data::QBBONextSharesQuotationMessage, _impl_.nasdaqbestbid_),
  PROTOBUF_FIELD_OFFSET(::data::QBBONextSharesQuotationMessage, _impl_.nasdaqbestbidsize_),
  PROTOBUF_FIELD_OFFSET(::data::QBBONextSharesQuotationMessage, _impl_.nasdaqbestbiddiscountamount_),
  PROTOBUF_FIELD_OFFSET(::data::QBBONextSharesQuotationMessage, _impl_.nasdaqbestofferproxyprice_),
  PROTOBUF_FIELD_OFFSET(::data::QBBONextSharesQuotationMessage, _impl_.nasdaqbestoffersize_),
  PROTOBUF_FIELD_OFFSET(::data::QBBONextSharesQuotationMessage, _impl_.nasdaqbestofferdiscountamount_),
  0,
  7,
  1,
  2,
  3,
  4,
  5,
  6,
  PROTOBUF_FIELD_OFFSET(::data::QBBOOperationalHalt, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::data::QBBOOperationalHalt, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::data::QBBOOperationalHalt, _impl_.stock_),
  PROTOBUF_FIELD_OFFSET(::data::QBBOOperationalHalt, _impl_.marketcode_),
  PROTOBUF_FIELD_OFFSET(::data::QBBOOperationalHalt, _impl_.operationalhaltaction_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::data::QBBOQuotationMessage, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::data::QBBOQuotationMessage, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::data::QBBOQuotationMessage, _impl_.stock_),
  PROTOBUF_FIELD_OFFSET(::data::QBBOQuotationMessage, _impl_.securityclass_),
  PROTOBUF_FIELD_OFFSET(::data::QBBOQuotationMessage, _impl_.nasdaqbestbidprice_),
  PROTOBUF_FIELD_OFFSET(::data::QBBOQuotationMessage, _impl_.nasdaqbestbidsize_),
  PROTOBUF_FIELD_OFFSET(::data::QBBOQuotationMessage, _impl_.nasdaqbestofferprice_),
  PROTOBUF_FIELD_OFFSET(::data::QBBOQuotationMessage, _impl_.nasdaqbestoffersize_),
  0,
  5,
  1,
  2,
  3,
  4,
  PROTOBUF_FIELD_OFFSET(::data::QBBORegShoRestriction, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::data::QBBORegShoRestriction, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::data::QBBORegShoRestriction, _impl_.stock_),
  PROTOBUF_FIELD_OFFSET(::data::QBBORegShoRestriction, _impl_.regshoaction_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::data::QBBOStockDirectory, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::data::QBBOStockDirectory, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::data::QBBOStockDirectory, _impl_.stock_),
  PROTOBUF_FIELD_OFFSET(::data::QBBOStockDirectory, _impl_.marketcategory_),
  PROTOBUF_FIELD_OFFSET(::data::QBBOStockDirectory, _impl_.financialstatusindicator_),
  PROTOBUF_FIELD_OFFSET(::data::QBBOStockDirectory, _impl_.roundlotsize_),
  PROTOBUF_FIELD_OFFSET(::data::QBBOStockDirectory, _impl_.roundlotonly_),
  PROTOBUF_FIELD_OFFSET(::data::QBBOStockDirectory, _impl_.issueclassification_),
  PROTOBUF_FIELD_OFFSET(::data::QBBOStockDirectory, _impl_.issuesubtype_),
  PROTOBUF_FIELD_OFFSET(::data::QBBOStockDirectory, _impl_.authenticity_),
  PROTOBUF_FIELD_OFFSET(::data::QBBOStockDirectory, _impl_.shortsalethresholdindicator_),
  PROTOBUF_FIELD_OFFSET(::data::QBBOStockDirectory, _impl_.ipoflag_),
  PROTOBUF_FIELD_OFFSET(::data::QBBOStockDirectory, _impl_.luldreferencepricetier_),
  PROTOBUF_FIELD_OFFSET(::data::QBBOStockDirectory, _impl_.etplag_),
  PROTOBUF_FIELD_OFFSET(::data::QBBOStockDirectory, _impl_.etpleveragefactor_),
  PROTOBUF_FIELD_OFFSET(::data::QBBOStockDirectory, _impl_.inverseindicator_),
  0,
  3,
  4,
  5,
  6,
  1,
  2,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  PROTOBUF_FIELD_OFFSET(::data::QBBOStockTradingAction, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::data::QBBOStockTradingAction, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::data::QBBOStockTradingAction, _impl_.stock_),
  PROTOBUF_FIELD_OFFSET(::data::QBBOStockTradingAction, _impl_.securityclass_),
  PROTOBUF_FIELD_OFFSET(::data::QBBOStockTradingAction, _impl_.currenttradingstate_),
  PROTOBUF_FIELD_OFFSET(::data::QBBOStockTradingAction, _impl_.reason_),
  0,
  2,
  3,
  1,
  PROTOBUF_FIELD_OFFSET(::data::QBBOSystemEventMessage, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::data::QBBOSystemEventMessage, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::data::QBBOSystemEventMessage, _impl_.eventcode_),
  0,
  PROTOBUF_FIELD_OFFSET(::data::AddOddLotOrder, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::data::AddOddLotOrder, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::data::AddOddLotOrder, _impl_.securitycode_),
  PROTOBUF_FIELD_OFFSET(::data::AddOddLotOrder, _impl_.orderid_),
  PROTOBUF_FIELD_OFFSET(::data::AddOddLotOrder, _impl_.price_),
  PROTOBUF_FIELD_OFFSET(::data::AddOddLotOrder, _impl_.quantity_),
  PROTOBUF_FIELD_OFFSET(::data::AddOddLotOrder, _impl_.brokerid_),
  PROTOBUF_FIELD_OFFSET(::data::AddOddLotOrder, _impl_.side_),
  0,
  1,
  2,
  3,
  4,
  5,
  PROTOBUF_FIELD_OFFSET(::data::AggregateOrderBookUpdate, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::data::AggregateOrderBookUpdate, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::data::AggregateOrderBookUpdate, _impl_.securitycode_),
  PROTOBUF_FIELD_OFFSET(::data::AggregateOrderBookUpdate, _impl_.noentries_),
  0,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::data::BQMoreItem, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::data::BQMoreItem, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::data::BQMoreItem, _impl_.item_),
  PROTOBUF_FIELD_OFFSET(::data::BQMoreItem, _impl_.type_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::data::BrokerQueue, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::data::BrokerQueue, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::data::BrokerQueue, _impl_.securitycode_),
  PROTOBUF_FIELD_OFFSET(::data::BrokerQueue, _impl_.itemcount_),
  PROTOBUF_FIELD_OFFSET(::data::BrokerQueue, _impl_.side_),
  PROTOBUF_FIELD_OFFSET(::data::BrokerQueue, _impl_.bqmoreflag_),
  PROTOBUF_FIELD_OFFSET(::data::BrokerQueue, _impl_.items_),
  0,
  1,
  2,
  3,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::data::ClosingPrice, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::data::ClosingPrice, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::data::ClosingPrice, _impl_.securitycode_),
  PROTOBUF_FIELD_OFFSET(::data::ClosingPrice, _impl_.closingprice_),
  PROTOBUF_FIELD_OFFSET(::data::ClosingPrice, _impl_.numberoftrades_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::data::CurrencyRate, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::data::CurrencyRate, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::data::CurrencyRate, _impl_.currencycode_),
  PROTOBUF_FIELD_OFFSET(::data::CurrencyRate, _impl_.currencyfactor_),
  PROTOBUF_FIELD_OFFSET(::data::CurrencyRate, _impl_.currencyrate_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::data::DeleteOddLotOrder, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::data::DeleteOddLotOrder, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::data::DeleteOddLotOrder, _impl_.securitycode_),
  PROTOBUF_FIELD_OFFSET(::data::DeleteOddLotOrder, _impl_.orderid_),
  PROTOBUF_FIELD_OFFSET(::data::DeleteOddLotOrder, _impl_.brokerid_),
  PROTOBUF_FIELD_OFFSET(::data::DeleteOddLotOrder, _impl_.side_),
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::data::IndexData, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::data::IndexData, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::data::IndexData, _impl_.indexcode_),
  PROTOBUF_FIELD_OFFSET(::data::IndexData, _impl_.indexstatus_),
  PROTOBUF_FIELD_OFFSET(::data::IndexData, _impl_.indextime_),
  PROTOBUF_FIELD_OFFSET(::data::IndexData, _impl_.indexvalue_),
  PROTOBUF_FIELD_OFFSET(::data::IndexData, _impl_.netchgprevday_),
  PROTOBUF_FIELD_OFFSET(::data::IndexData, _impl_.highvalue_),
  PROTOBUF_FIELD_OFFSET(::data::IndexData, _impl_.lowvalue_),
  PROTOBUF_FIELD_OFFSET(::data::IndexData, _impl_.easvalue_),
  PROTOBUF_FIELD_OFFSET(::data::IndexData, _impl_.indexturnover_),
  PROTOBUF_FIELD_OFFSET(::data::IndexData, _impl_.openingvalue_),
  PROTOBUF_FIELD_OFFSET(::data::IndexData, _impl_.closingvalue_),
  PROTOBUF_FIELD_OFFSET(::data::IndexData, _impl_.previoussesclose_),
  PROTOBUF_FIELD_OFFSET(::data::IndexData, _impl_.indexvolume_),
  PROTOBUF_FIELD_OFFSET(::data::IndexData, _impl_.netchgprevdaypct_),
  PROTOBUF_FIELD_OFFSET(::data::IndexData, _impl_.exception_),
  0,
  14,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  1,
  PROTOBUF_FIELD_OFFSET(::data::IndexDefinition, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::data::IndexDefinition, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::data::IndexDefinition, _impl_.indexcode_),
  PROTOBUF_FIELD_OFFSET(::data::IndexDefinition, _impl_.indexsource_),
  PROTOBUF_FIELD_OFFSET(::data::IndexDefinition, _impl_.currencycode_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::data::IndicativeEquilibriumPrice, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::data::IndicativeEquilibriumPrice, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::data::IndicativeEquilibriumPrice, _impl_.securitycode_),
  PROTOBUF_FIELD_OFFSET(::data::IndicativeEquilibriumPrice, _impl_.price_),
  PROTOBUF_FIELD_OFFSET(::data::IndicativeEquilibriumPrice, _impl_.aggregatequantity_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::data::LiquidityProvider, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::data::LiquidityProvider, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::data::LiquidityProvider, _impl_.securitycode_),
  PROTOBUF_FIELD_OFFSET(::data::LiquidityProvider, _impl_.noliquidityproviders_),
  0,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::data::MarketDefinition, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::data::MarketDefinition, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::data::MarketDefinition, _impl_.marketcode_),
  PROTOBUF_FIELD_OFFSET(::data::MarketDefinition, _impl_.marketname_),
  PROTOBUF_FIELD_OFFSET(::data::MarketDefinition, _impl_.currencycode_),
  PROTOBUF_FIELD_OFFSET(::data::MarketDefinition, _impl_.numberofsecurities_),
  1,
  0,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::data::MarketTurnover, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::data::MarketTurnover, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::data::MarketTurnover, _impl_.marketcode_),
  PROTOBUF_FIELD_OFFSET(::data::MarketTurnover, _impl_.currencycode_),
  PROTOBUF_FIELD_OFFSET(::data::MarketTurnover, _impl_.turnover_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::data::News, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::data::News, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::data::News, _impl_.newstype_),
  PROTOBUF_FIELD_OFFSET(::data::News, _impl_.newsid_),
  PROTOBUF_FIELD_OFFSET(::data::News, _impl_.headline_),
  PROTOBUF_FIELD_OFFSET(::data::News, _impl_.cancelflag_),
  PROTOBUF_FIELD_OFFSET(::data::News, _impl_.lastfragment_),
  PROTOBUF_FIELD_OFFSET(::data::News, _impl_.releasetime_),
  PROTOBUF_FIELD_OFFSET(::data::News, _impl_.nomarketcodes_),
  PROTOBUF_FIELD_OFFSET(::data::News, _impl_.nosecuritycodes_),
  PROTOBUF_FIELD_OFFSET(::data::News, _impl_.nonewslines_),
  2,
  0,
  1,
  3,
  5,
  4,
  ~0u,
  ~0u,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::data::NoEntry, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::data::NoEntry, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::data::NoEntry, _impl_.aggregatequantity_),
  PROTOBUF_FIELD_OFFSET(::data::NoEntry, _impl_.price_),
  PROTOBUF_FIELD_OFFSET(::data::NoEntry, _impl_.numberoforders_),
  PROTOBUF_FIELD_OFFSET(::data::NoEntry, _impl_.side_),
  PROTOBUF_FIELD_OFFSET(::data::NoEntry, _impl_.pricelevel_),
  PROTOBUF_FIELD_OFFSET(::data::NoEntry, _impl_.updateaction_),
  0,
  1,
  2,
  3,
  4,
  5,
  PROTOBUF_FIELD_OFFSET(::data::NoLiquidityProvider, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::data::NoLiquidityProvider, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::data::NoLiquidityProvider, _impl_.lpbrokernumber_),
  0,
  PROTOBUF_FIELD_OFFSET(::data::NoMarketCode, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::data::NoMarketCode, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::data::NoMarketCode, _impl_.marketcode_),
  0,
  PROTOBUF_FIELD_OFFSET(::data::NoNewsLine, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::data::NoNewsLine, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::data::NoNewsLine, _impl_.newsline_),
  0,
  PROTOBUF_FIELD_OFFSET(::data::NoSecurityCode, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::data::NoSecurityCode, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::data::NoSecurityCode, _impl_.securitycode_),
  0,
  PROTOBUF_FIELD_OFFSET(::data::NoUnderlyingSecurity, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::data::NoUnderlyingSecurity, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::data::NoUnderlyingSecurity, _impl_.underlyingsecuritycode_),
  0,
  PROTOBUF_FIELD_OFFSET(::data::NominalPrice, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::data::NominalPrice, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::data::NominalPrice, _impl_.securitycode_),
  PROTOBUF_FIELD_OFFSET(::data::NominalPrice, _impl_.nominalprice_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::data::OrderImbalance, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::data::OrderImbalance, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::data::OrderImbalance, _impl_.securitycode_),
  PROTOBUF_FIELD_OFFSET(::data::OrderImbalance, _impl_.orderimbalancedirection_),
  PROTOBUF_FIELD_OFFSET(::data::OrderImbalance, _impl_.orderimbalancequantity_),
  0,
  2,
  1,
  PROTOBUF_FIELD_OFFSET(::data::PacketHeader, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::data::PacketHeader, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::data::PacketHeader, _impl_.pktsize_),
  PROTOBUF_FIELD_OFFSET(::data::PacketHeader, _impl_.msgcount_),
  PROTOBUF_FIELD_OFFSET(::data::PacketHeader, _impl_.filler_),
  PROTOBUF_FIELD_OFFSET(::data::PacketHeader, _impl_.seqnum_),
  PROTOBUF_FIELD_OFFSET(::data::PacketHeader, _impl_.sendtime_),
  1,
  2,
  0,
  3,
  4,
  PROTOBUF_FIELD_OFFSET(::data::LongAdjustedClosingPrice, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::data::LongAdjustedClosingPrice, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::data::LongAdjustedClosingPrice, _impl_.issuesymbol_),
  PROTOBUF_FIELD_OFFSET(::data::LongAdjustedClosingPrice, _impl_.securityclass_),
  PROTOBUF_FIELD_OFFSET(::data::LongAdjustedClosingPrice, _impl_.adjustedclosingprice_),
  0,
  2,
  1,
  PROTOBUF_FIELD_OFFSET(::data::LongDayTradeSummary, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::data::LongDayTradeSummary, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::data::LongDayTradeSummary, _impl_.issuesymbol_),
  PROTOBUF_FIELD_OFFSET(::data::LongDayTradeSummary, _impl_.marketcategory_),
  PROTOBUF_FIELD_OFFSET(::data::LongDayTradeSummary, _impl_.nasdaqhighprice_),
  PROTOBUF_FIELD_OFFSET(::data::LongDayTradeSummary, _impl_.nasdaqlowprice_),
  PROTOBUF_FIELD_OFFSET(::data::LongDayTradeSummary, _impl_.nasdaqclosingprice_),
  PROTOBUF_FIELD_OFFSET(::data::LongDayTradeSummary, _impl_.consolidatedvolume_),
  PROTOBUF_FIELD_OFFSET(::data::LongDayTradeSummary, _impl_.consolidatedopenprice_),
  0,
  6,
  1,
  2,
  3,
  4,
  5,
  PROTOBUF_FIELD_OFFSET(::data::LongTradeCancelForNonNextSharesTrades, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::data::LongTradeCancelForNonNextSharesTrades, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::data::LongTradeCancelForNonNextSharesTrades, _impl_.marketcenteridentifier_),
  PROTOBUF_FIELD_OFFSET(::data::LongTradeCancelForNonNextSharesTrades, _impl_.issuesymbol_),
  PROTOBUF_FIELD_OFFSET(::data::LongTradeCancelForNonNextSharesTrades, _impl_.securityclass_),
  PROTOBUF_FIELD_OFFSET(::data::LongTradeCancelForNonNextSharesTrades, _impl_.originalcontrolnumber_),
  PROTOBUF_FIELD_OFFSET(::data::LongTradeCancelForNonNextSharesTrades, _impl_.originaltradeprice_),
  PROTOBUF_FIELD_OFFSET(::data::LongTradeCancelForNonNextSharesTrades, _impl_.originaltradesize_),
  PROTOBUF_FIELD_OFFSET(::data::LongTradeCancelForNonNextSharesTrades, _impl_.originalsaleconditionmodifier_),
  PROTOBUF_FIELD_OFFSET(::data::LongTradeCancelForNonNextSharesTrades, _impl_.consolidatedvolume_),
  3,
  0,
  4,
  1,
  5,
  6,
  2,
  7,
  PROTOBUF_FIELD_OFFSET(::data::LongTradeCorrectionForNonNextsharesTrades, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::data::LongTradeCorrectionForNonNextsharesTrades, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::data::LongTradeCorrectionForNonNextsharesTrades, _impl_.marketcenteridentifier_),
  PROTOBUF_FIELD_OFFSET(::data::LongTradeCorrectionForNonNextsharesTrades, _impl_.issuesymbol_),
  PROTOBUF_FIELD_OFFSET(::data::LongTradeCorrectionForNonNextsharesTrades, _impl_.securityclass_),
  PROTOBUF_FIELD_OFFSET(::data::LongTradeCorrectionForNonNextsharesTrades, _impl_.originalcontrolnumber_),
  PROTOBUF_FIELD_OFFSET(::data::LongTradeCorrectionForNonNextsharesTrades, _impl_.originaltradeprice_),
  PROTOBUF_FIELD_OFFSET(::data::LongTradeCorrectionForNonNextsharesTrades, _impl_.originaltradesize_),
  PROTOBUF_FIELD_OFFSET(::data::LongTradeCorrectionForNonNextsharesTrades, _impl_.originalconditionmodifier_),
  PROTOBUF_FIELD_OFFSET(::data::LongTradeCorrectionForNonNextsharesTrades, _impl_.correctedtradecontrolnumber_),
  PROTOBUF_FIELD_OFFSET(::data::LongTradeCorrectionForNonNextsharesTrades, _impl_.correctedtradeprice_),
  PROTOBUF_FIELD_OFFSET(::data::LongTradeCorrectionForNonNextsharesTrades, _impl_.correctedtradesize_),
  PROTOBUF_FIELD_OFFSET(::data::LongTradeCorrectionForNonNextsharesTrades, _impl_.correctedsaleconditionmodifier_),
  PROTOBUF_FIELD_OFFSET(::data::LongTradeCorrectionForNonNextsharesTrades, _impl_.consolidatedvolume_),
  5,
  0,
  6,
  1,
  7,
  8,
  2,
  3,
  9,
  10,
  4,
  11,
  PROTOBUF_FIELD_OFFSET(::data::LongTradeReportForNonNextshares, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::data::LongTradeReportForNonNextshares, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::data::LongTradeReportForNonNextshares, _impl_.consolidatedvolume_),
  0,
  PROTOBUF_FIELD_OFFSET(::data::ReferencePrice, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::data::ReferencePrice, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::data::ReferencePrice, _impl_.securitycode_),
  PROTOBUF_FIELD_OFFSET(::data::ReferencePrice, _impl_.referenceprice_),
  PROTOBUF_FIELD_OFFSET(::data::ReferencePrice, _impl_.lowerprice_),
  PROTOBUF_FIELD_OFFSET(::data::ReferencePrice, _impl_.upperprice_),
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::data::QBBOIPOQuotingPeriodUpdate, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::data::QBBOIPOQuotingPeriodUpdate, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::data::QBBOIPOQuotingPeriodUpdate, _impl_.stock_),
  PROTOBUF_FIELD_OFFSET(::data::QBBOIPOQuotingPeriodUpdate, _impl_.ipoquotationreleasetime_),
  PROTOBUF_FIELD_OFFSET(::data::QBBOIPOQuotingPeriodUpdate, _impl_.quotationreleasequalifier_),
  PROTOBUF_FIELD_OFFSET(::data::QBBOIPOQuotingPeriodUpdate, _impl_.ipoprice_),
  0,
  1,
  3,
  2,
  PROTOBUF_FIELD_OFFSET(::data::SecurityDefinition, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::data::SecurityDefinition, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::data::SecurityDefinition, _impl_.securitycode_),
  PROTOBUF_FIELD_OFFSET(::data::SecurityDefinition, _impl_.marketcode_),
  PROTOBUF_FIELD_OFFSET(::data::SecurityDefinition, _impl_.isincode_),
  PROTOBUF_FIELD_OFFSET(::data::SecurityDefinition, _impl_.instrumenttype_),
  PROTOBUF_FIELD_OFFSET(::data::SecurityDefinition, _impl_.producttype_),
  PROTOBUF_FIELD_OFFSET(::data::SecurityDefinition, _impl_.spreadtablecode_),
  PROTOBUF_FIELD_OFFSET(::data::SecurityDefinition, _impl_.securityshortname_),
  PROTOBUF_FIELD_OFFSET(::data::SecurityDefinition, _impl_.currencycode_),
  PROTOBUF_FIELD_OFFSET(::data::SecurityDefinition, _impl_.securitynamegccs_),
  PROTOBUF_FIELD_OFFSET(::data::SecurityDefinition, _impl_.securitynamegb_),
  PROTOBUF_FIELD_OFFSET(::data::SecurityDefinition, _impl_.lotsize_),
  PROTOBUF_FIELD_OFFSET(::data::SecurityDefinition, _impl_.previousclosingprice_),
  PROTOBUF_FIELD_OFFSET(::data::SecurityDefinition, _impl_.vcmflag_),
  PROTOBUF_FIELD_OFFSET(::data::SecurityDefinition, _impl_.shortsellflag_),
  PROTOBUF_FIELD_OFFSET(::data::SecurityDefinition, _impl_.casflag_),
  PROTOBUF_FIELD_OFFSET(::data::SecurityDefinition, _impl_.ccassflag_),
  PROTOBUF_FIELD_OFFSET(::data::SecurityDefinition, _impl_.dummysecurityflag_),
  PROTOBUF_FIELD_OFFSET(::data::SecurityDefinition, _impl_.stampdutyflag_),
  PROTOBUF_FIELD_OFFSET(::data::SecurityDefinition, _impl_.listingdate_),
  PROTOBUF_FIELD_OFFSET(::data::SecurityDefinition, _impl_.delistingdate_),
  PROTOBUF_FIELD_OFFSET(::data::SecurityDefinition, _impl_.freetext_),
  PROTOBUF_FIELD_OFFSET(::data::SecurityDefinition, _impl_.posflag_),
  PROTOBUF_FIELD_OFFSET(::data::SecurityDefinition, _impl_.posupperlimit_),
  PROTOBUF_FIELD_OFFSET(::data::SecurityDefinition, _impl_.poslowerlimit_),
  PROTOBUF_FIELD_OFFSET(::data::SecurityDefinition, _impl_.efnflag_),
  PROTOBUF_FIELD_OFFSET(::data::SecurityDefinition, _impl_.accruedinterest_),
  PROTOBUF_FIELD_OFFSET(::data::SecurityDefinition, _impl_.couponrate_),
  PROTOBUF_FIELD_OFFSET(::data::SecurityDefinition, _impl_.facevalue_),
  PROTOBUF_FIELD_OFFSET(::data::SecurityDefinition, _impl_.decimalsinfacevalue_),
  PROTOBUF_FIELD_OFFSET(::data::SecurityDefinition, _impl_.facevaluecurrency_),
  PROTOBUF_FIELD_OFFSET(::data::SecurityDefinition, _impl_.bondmaturitydate_),
  PROTOBUF_FIELD_OFFSET(::data::SecurityDefinition, _impl_.investortype_),
  PROTOBUF_FIELD_OFFSET(::data::SecurityDefinition, _impl_.conversionratio_),
  PROTOBUF_FIELD_OFFSET(::data::SecurityDefinition, _impl_.strikeprice1_),
  PROTOBUF_FIELD_OFFSET(::data::SecurityDefinition, _impl_.strikeprice2_),
  PROTOBUF_FIELD_OFFSET(::data::SecurityDefinition, _impl_.warrantmaturitydate_),
  PROTOBUF_FIELD_OFFSET(::data::SecurityDefinition, _impl_.callputflag_),
  PROTOBUF_FIELD_OFFSET(::data::SecurityDefinition, _impl_.style_),
  PROTOBUF_FIELD_OFFSET(::data::SecurityDefinition, _impl_.warranttype_),
  PROTOBUF_FIELD_OFFSET(::data::SecurityDefinition, _impl_.callprice_),
  PROTOBUF_FIELD_OFFSET(::data::SecurityDefinition, _impl_.decimalsincallprice_),
  PROTOBUF_FIELD_OFFSET(::data::SecurityDefinition, _impl_.entitlement_),
  PROTOBUF_FIELD_OFFSET(::data::SecurityDefinition, _impl_.decimalsinentitlement_),
  PROTOBUF_FIELD_OFFSET(::data::SecurityDefinition, _impl_.nowarrantsperentitlement_),
  PROTOBUF_FIELD_OFFSET(::data::SecurityDefinition, _impl_.nounderlyingsecurities_),
  8,
  9,
  0,
  10,
  11,
  12,
  1,
  14,
  2,
  3,
  13,
  16,
  4,
  15,
  17,
  18,
  19,
  20,
  21,
  22,
  5,
  23,
  24,
  25,
  26,
  27,
  28,
  29,
  30,
  6,
  32,
  31,
  33,
  34,
  35,
  36,
  37,
  38,
  7,
  39,
  40,
  41,
  42,
  43,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::data::SecurityStatus, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::data::SecurityStatus, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::data::SecurityStatus, _impl_.securitycode_),
  PROTOBUF_FIELD_OFFSET(::data::SecurityStatus, _impl_.suspensionindicator_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::data::Statistics, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::data::Statistics, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::data::Statistics, _impl_.securitycode_),
  PROTOBUF_FIELD_OFFSET(::data::Statistics, _impl_.sharestraded_),
  PROTOBUF_FIELD_OFFSET(::data::Statistics, _impl_.vcmreferenceprice_),
  PROTOBUF_FIELD_OFFSET(::data::Statistics, _impl_.highprice_),
  PROTOBUF_FIELD_OFFSET(::data::Statistics, _impl_.lowprice_),
  PROTOBUF_FIELD_OFFSET(::data::Statistics, _impl_.lastprice_),
  PROTOBUF_FIELD_OFFSET(::data::Statistics, _impl_.vwap_),
  PROTOBUF_FIELD_OFFSET(::data::Statistics, _impl_.shortsellsharestraded_),
  PROTOBUF_FIELD_OFFSET(::data::Statistics, _impl_.shortsellturnover_),
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  PROTOBUF_FIELD_OFFSET(::data::StockConnectDailyQuotaBalance, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::data::StockConnectDailyQuotaBalance, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::data::StockConnectDailyQuotaBalance, _impl_.stockconnectmarket_),
  PROTOBUF_FIELD_OFFSET(::data::StockConnectDailyQuotaBalance, _impl_.tradingdirection_),
  PROTOBUF_FIELD_OFFSET(::data::StockConnectDailyQuotaBalance, _impl_.dailyquotabalance_),
  PROTOBUF_FIELD_OFFSET(::data::StockConnectDailyQuotaBalance, _impl_.dailyquotabalancetime_),
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::data::StockConnectMarketTurnover, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::data::StockConnectMarketTurnover, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::data::StockConnectMarketTurnover, _impl_.stockconnectmarket_),
  PROTOBUF_FIELD_OFFSET(::data::StockConnectMarketTurnover, _impl_.tradingdirection_),
  PROTOBUF_FIELD_OFFSET(::data::StockConnectMarketTurnover, _impl_.buyturnover_),
  PROTOBUF_FIELD_OFFSET(::data::StockConnectMarketTurnover, _impl_.sellturnover_),
  PROTOBUF_FIELD_OFFSET(::data::StockConnectMarketTurnover, _impl_.buysellturnover_),
  0,
  1,
  2,
  3,
  4,
  PROTOBUF_FIELD_OFFSET(::data::Trade, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::data::Trade, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::data::Trade, _impl_.securitycode_),
  PROTOBUF_FIELD_OFFSET(::data::Trade, _impl_.tradeid_),
  PROTOBUF_FIELD_OFFSET(::data::Trade, _impl_.price_),
  PROTOBUF_FIELD_OFFSET(::data::Trade, _impl_.quantity_),
  PROTOBUF_FIELD_OFFSET(::data::Trade, _impl_.trdtype_),
  PROTOBUF_FIELD_OFFSET(::data::Trade, _impl_.tradetime_),
  0,
  1,
  2,
  3,
  5,
  4,
  PROTOBUF_FIELD_OFFSET(::data::TradeCancel, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::data::TradeCancel, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::data::TradeCancel, _impl_.securitycode_),
  PROTOBUF_FIELD_OFFSET(::data::TradeCancel, _impl_.tradeid_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::data::TradingSessionStatus, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::data::TradingSessionStatus, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::data::TradingSessionStatus, _impl_.marketcode_),
  PROTOBUF_FIELD_OFFSET(::data::TradingSessionStatus, _impl_.tradingsessionsubid_),
  PROTOBUF_FIELD_OFFSET(::data::TradingSessionStatus, _impl_.tradingsesstatus_),
  PROTOBUF_FIELD_OFFSET(::data::TradingSessionStatus, _impl_.tradingsescontrolflag_),
  PROTOBUF_FIELD_OFFSET(::data::TradingSessionStatus, _impl_.startdatetime_),
  PROTOBUF_FIELD_OFFSET(::data::TradingSessionStatus, _impl_.enddatetime_),
  0,
  1,
  2,
  3,
  4,
  5,
  PROTOBUF_FIELD_OFFSET(::data::VCMTrigger, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::data::VCMTrigger, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::data::VCMTrigger, _impl_.securitycode_),
  PROTOBUF_FIELD_OFFSET(::data::VCMTrigger, _impl_.coolingoffstarttime_),
  PROTOBUF_FIELD_OFFSET(::data::VCMTrigger, _impl_.coolingoffendtime_),
  PROTOBUF_FIELD_OFFSET(::data::VCMTrigger, _impl_.vcmreferenceprice_),
  PROTOBUF_FIELD_OFFSET(::data::VCMTrigger, _impl_.vcmlowerprice_),
  PROTOBUF_FIELD_OFFSET(::data::VCMTrigger, _impl_.vcmupperprice_),
  0,
  1,
  2,
  3,
  4,
  5,
  PROTOBUF_FIELD_OFFSET(::data::Yield, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::data::Yield, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::data::Yield, _impl_.securitycode_),
  PROTOBUF_FIELD_OFFSET(::data::Yield, _impl_.yield_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::data::CNMarketDefinition, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::data::CNMarketDefinition, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::data::CNMarketDefinition, _impl_.marketcode_),
  PROTOBUF_FIELD_OFFSET(::data::CNMarketDefinition, _impl_.marketname_),
  PROTOBUF_FIELD_OFFSET(::data::CNMarketDefinition, _impl_.currencycode_),
  PROTOBUF_FIELD_OFFSET(::data::CNMarketDefinition, _impl_.numberofsecurities_),
  1,
  0,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::data::CNSecurityDefinition, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::data::CNSecurityDefinition, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::data::CNSecurityDefinition, _impl_.securitycode_),
  PROTOBUF_FIELD_OFFSET(::data::CNSecurityDefinition, _impl_.marketcode_),
  PROTOBUF_FIELD_OFFSET(::data::CNSecurityDefinition, _impl_.isincode_),
  PROTOBUF_FIELD_OFFSET(::data::CNSecurityDefinition, _impl_.instrumenttype_),
  PROTOBUF_FIELD_OFFSET(::data::CNSecurityDefinition, _impl_.securityshortname_),
  PROTOBUF_FIELD_OFFSET(::data::CNSecurityDefinition, _impl_.currencycode_),
  PROTOBUF_FIELD_OFFSET(::data::CNSecurityDefinition, _impl_.securitynamegb_),
  PROTOBUF_FIELD_OFFSET(::data::CNSecurityDefinition, _impl_.lotsize_),
  PROTOBUF_FIELD_OFFSET(::data::CNSecurityDefinition, _impl_.previousclosingprice_),
  PROTOBUF_FIELD_OFFSET(::data::CNSecurityDefinition, _impl_.shortsellflag_),
  PROTOBUF_FIELD_OFFSET(::data::CNSecurityDefinition, _impl_.listingdate_),
  3,
  4,
  0,
  5,
  1,
  7,
  2,
  6,
  9,
  8,
  10,
  PROTOBUF_FIELD_OFFSET(::data::CNSecurityStatus, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::data::CNSecurityStatus, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::data::CNSecurityStatus, _impl_.securitycode_),
  PROTOBUF_FIELD_OFFSET(::data::CNSecurityStatus, _impl_.securitytradingstatus_),
  PROTOBUF_FIELD_OFFSET(::data::CNSecurityStatus, _impl_.tradingphasecode_),
  1,
  2,
  0,
  PROTOBUF_FIELD_OFFSET(::data::CNStatistics, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::data::CNStatistics, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::data::CNStatistics, _impl_.securitycode_),
  PROTOBUF_FIELD_OFFSET(::data::CNStatistics, _impl_.sharestraded_),
  PROTOBUF_FIELD_OFFSET(::data::CNStatistics, _impl_.turnover_),
  PROTOBUF_FIELD_OFFSET(::data::CNStatistics, _impl_.highprice_),
  PROTOBUF_FIELD_OFFSET(::data::CNStatistics, _impl_.lowprice_),
  PROTOBUF_FIELD_OFFSET(::data::CNStatistics, _impl_.lastprice_),
  PROTOBUF_FIELD_OFFSET(::data::CNStatistics, _impl_.openingprice_),
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  PROTOBUF_FIELD_OFFSET(::data::CNTopBook, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::data::CNTopBook, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::data::CNTopBook, _impl_.securitycode_),
  PROTOBUF_FIELD_OFFSET(::data::CNTopBook, _impl_.aggregatebidquantity_),
  PROTOBUF_FIELD_OFFSET(::data::CNTopBook, _impl_.aggregateaskquantity_),
  PROTOBUF_FIELD_OFFSET(::data::CNTopBook, _impl_.bidprice_),
  PROTOBUF_FIELD_OFFSET(::data::CNTopBook, _impl_.askprice_),
  0,
  1,
  2,
  3,
  4,
  PROTOBUF_FIELD_OFFSET(::data::CertificationMsg, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::data::CertificationMsg, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::data::CertificationMsg, _impl_.actiontype_),
  PROTOBUF_FIELD_OFFSET(::data::CertificationMsg, _impl_.auth_),
  PROTOBUF_FIELD_OFFSET(::data::CertificationMsg, _impl_.response_),
  2,
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::data::Resp, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::data::Resp, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::data::Resp, _impl_.type_),
  PROTOBUF_FIELD_OFFSET(::data::Resp, _impl_.errormsg_),
  1,
  0,
  PROTOBUF_FIELD_OFFSET(::data::Message, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::data::Message, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::data::Message, _impl_._oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::data::Message, _impl_.data_type_),
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::data::Message, _impl_.timestamp_),
  PROTOBUF_FIELD_OFFSET(::data::Message, _impl_.dataBody_),
  1,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  0,
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 9, -1, sizeof(::data::AdjustedClosingPrice)},
  { 12, 24, -1, sizeof(::data::DayTradeSummary)},
  { 30, 45, -1, sizeof(::data::DayTradeSummaryNextShares)},
  { 54, 64, -1, sizeof(::data::IPOInformation)},
  { 68, 78, -1, sizeof(::data::IPOQuotingPeriodUpdate)},
  { 82, 89, -1, sizeof(::data::MWCBStatusMessage)},
  { 90, 99, -1, sizeof(::data::MarketWideCircuitBreaker)},
  { 102, 111, -1, sizeof(::data::MessageHeader)},
  { 114, 123, -1, sizeof(::data::OperationalHalt)},
  { 126, 136, -1, sizeof(::data::SaleConditionModifier)},
  { 140, 148, -1, sizeof(::data::ShortSaleRestrictionIndicatorMessage)},
  { 150, 171, -1, sizeof(::data::StockDirectory)},
  { 186, 197, -1, sizeof(::data::StockTradingAction)},
  { 202, 209, -1, sizeof(::data::SystemEventMessage)},
  { 210, 225, -1, sizeof(::data::TradeCancelForNextsharesTrades)},
  { 234, 248, -1, sizeof(::data::TradeCancelForNonNextSharesTrades)},
  { 256, 276, -1, sizeof(::data::TradeCorrectionForNextsharesTrades)},
  { 290, 308, -1, sizeof(::data::TradeCorrectionForNonNextsharesTrades)},
  { 320, 335, -1, sizeof(::data::TradeReportForNextshares)},
  { 344, 358, -1, sizeof(::data::TradeReportForNonNextshares)},
  { 366, 373, -1, sizeof(::data::QBBOMWCBBreachMessage)},
  { 374, 383, -1, sizeof(::data::QBBOMWCBDeclineLevelMessage)},
  { 386, 395, -1, sizeof(::data::QBBOMessageHeader)},
  { 398, 412, -1, sizeof(::data::QBBONextSharesQuotationMessage)},
  { 420, 429, -1, sizeof(::data::QBBOOperationalHalt)},
  { 432, 444, -1, sizeof(::data::QBBOQuotationMessage)},
  { 450, 458, -1, sizeof(::data::QBBORegShoRestriction)},
  { 460, 480, -1, sizeof(::data::QBBOStockDirectory)},
  { 494, 504, -1, sizeof(::data::QBBOStockTradingAction)},
  { 508, 515, -1, sizeof(::data::QBBOSystemEventMessage)},
  { 516, 528, -1, sizeof(::data::AddOddLotOrder)},
  { 534, 542, -1, sizeof(::data::AggregateOrderBookUpdate)},
  { 544, 552, -1, sizeof(::data::BQMoreItem)},
  { 554, 565, -1, sizeof(::data::BrokerQueue)},
  { 570, 579, -1, sizeof(::data::ClosingPrice)},
  { 582, 591, -1, sizeof(::data::CurrencyRate)},
  { 594, 604, -1, sizeof(::data::DeleteOddLotOrder)},
  { 608, 629, -1, sizeof(::data::IndexData)},
  { 644, 653, -1, sizeof(::data::IndexDefinition)},
  { 656, 665, -1, sizeof(::data::IndicativeEquilibriumPrice)},
  { 668, 676, -1, sizeof(::data::LiquidityProvider)},
  { 678, 688, -1, sizeof(::data::MarketDefinition)},
  { 692, 701, -1, sizeof(::data::MarketTurnover)},
  { 704, 719, -1, sizeof(::data::News)},
  { 728, 740, -1, sizeof(::data::NoEntry)},
  { 746, 753, -1, sizeof(::data::NoLiquidityProvider)},
  { 754, 761, -1, sizeof(::data::NoMarketCode)},
  { 762, 769, -1, sizeof(::data::NoNewsLine)},
  { 770, 777, -1, sizeof(::data::NoSecurityCode)},
  { 778, 785, -1, sizeof(::data::NoUnderlyingSecurity)},
  { 786, 794, -1, sizeof(::data::NominalPrice)},
  { 796, 805, -1, sizeof(::data::OrderImbalance)},
  { 808, 819, -1, sizeof(::data::PacketHeader)},
  { 824, 833, -1, sizeof(::data::LongAdjustedClosingPrice)},
  { 836, 849, -1, sizeof(::data::LongDayTradeSummary)},
  { 856, 870, -1, sizeof(::data::LongTradeCancelForNonNextSharesTrades)},
  { 878, 896, -1, sizeof(::data::LongTradeCorrectionForNonNextsharesTrades)},
  { 908, 915, -1, sizeof(::data::LongTradeReportForNonNextshares)},
  { 916, 926, -1, sizeof(::data::ReferencePrice)},
  { 930, 940, -1, sizeof(::data::QBBOIPOQuotingPeriodUpdate)},
  { 944, 995, -1, sizeof(::data::SecurityDefinition)},
  { 1040, 1048, -1, sizeof(::data::SecurityStatus)},
  { 1050, 1065, -1, sizeof(::data::Statistics)},
  { 1074, 1084, -1, sizeof(::data::StockConnectDailyQuotaBalance)},
  { 1088, 1099, -1, sizeof(::data::StockConnectMarketTurnover)},
  { 1104, 1116, -1, sizeof(::data::Trade)},
  { 1122, 1130, -1, sizeof(::data::TradeCancel)},
  { 1132, 1144, -1, sizeof(::data::TradingSessionStatus)},
  { 1150, 1162, -1, sizeof(::data::VCMTrigger)},
  { 1168, 1176, -1, sizeof(::data::Yield)},
  { 1178, 1188, -1, sizeof(::data::CNMarketDefinition)},
  { 1192, 1209, -1, sizeof(::data::CNSecurityDefinition)},
  { 1220, 1229, -1, sizeof(::data::CNSecurityStatus)},
  { 1232, 1245, -1, sizeof(::data::CNStatistics)},
  { 1252, 1263, -1, sizeof(::data::CNTopBook)},
  { 1268, 1277, -1, sizeof(::data::CertificationMsg)},
  { 1280, 1288, -1, sizeof(::data::Resp)},
  { 1290, 1365, -1, sizeof(::data::Message)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::data::_AdjustedClosingPrice_default_instance_._instance,
  &::data::_DayTradeSummary_default_instance_._instance,
  &::data::_DayTradeSummaryNextShares_default_instance_._instance,
  &::data::_IPOInformation_default_instance_._instance,
  &::data::_IPOQuotingPeriodUpdate_default_instance_._instance,
  &::data::_MWCBStatusMessage_default_instance_._instance,
  &::data::_MarketWideCircuitBreaker_default_instance_._instance,
  &::data::_MessageHeader_default_instance_._instance,
  &::data::_OperationalHalt_default_instance_._instance,
  &::data::_SaleConditionModifier_default_instance_._instance,
  &::data::_ShortSaleRestrictionIndicatorMessage_default_instance_._instance,
  &::data::_StockDirectory_default_instance_._instance,
  &::data::_StockTradingAction_default_instance_._instance,
  &::data::_SystemEventMessage_default_instance_._instance,
  &::data::_TradeCancelForNextsharesTrades_default_instance_._instance,
  &::data::_TradeCancelForNonNextSharesTrades_default_instance_._instance,
  &::data::_TradeCorrectionForNextsharesTrades_default_instance_._instance,
  &::data::_TradeCorrectionForNonNextsharesTrades_default_instance_._instance,
  &::data::_TradeReportForNextshares_default_instance_._instance,
  &::data::_TradeReportForNonNextshares_default_instance_._instance,
  &::data::_QBBOMWCBBreachMessage_default_instance_._instance,
  &::data::_QBBOMWCBDeclineLevelMessage_default_instance_._instance,
  &::data::_QBBOMessageHeader_default_instance_._instance,
  &::data::_QBBONextSharesQuotationMessage_default_instance_._instance,
  &::data::_QBBOOperationalHalt_default_instance_._instance,
  &::data::_QBBOQuotationMessage_default_instance_._instance,
  &::data::_QBBORegShoRestriction_default_instance_._instance,
  &::data::_QBBOStockDirectory_default_instance_._instance,
  &::data::_QBBOStockTradingAction_default_instance_._instance,
  &::data::_QBBOSystemEventMessage_default_instance_._instance,
  &::data::_AddOddLotOrder_default_instance_._instance,
  &::data::_AggregateOrderBookUpdate_default_instance_._instance,
  &::data::_BQMoreItem_default_instance_._instance,
  &::data::_BrokerQueue_default_instance_._instance,
  &::data::_ClosingPrice_default_instance_._instance,
  &::data::_CurrencyRate_default_instance_._instance,
  &::data::_DeleteOddLotOrder_default_instance_._instance,
  &::data::_IndexData_default_instance_._instance,
  &::data::_IndexDefinition_default_instance_._instance,
  &::data::_IndicativeEquilibriumPrice_default_instance_._instance,
  &::data::_LiquidityProvider_default_instance_._instance,
  &::data::_MarketDefinition_default_instance_._instance,
  &::data::_MarketTurnover_default_instance_._instance,
  &::data::_News_default_instance_._instance,
  &::data::_NoEntry_default_instance_._instance,
  &::data::_NoLiquidityProvider_default_instance_._instance,
  &::data::_NoMarketCode_default_instance_._instance,
  &::data::_NoNewsLine_default_instance_._instance,
  &::data::_NoSecurityCode_default_instance_._instance,
  &::data::_NoUnderlyingSecurity_default_instance_._instance,
  &::data::_NominalPrice_default_instance_._instance,
  &::data::_OrderImbalance_default_instance_._instance,
  &::data::_PacketHeader_default_instance_._instance,
  &::data::_LongAdjustedClosingPrice_default_instance_._instance,
  &::data::_LongDayTradeSummary_default_instance_._instance,
  &::data::_LongTradeCancelForNonNextSharesTrades_default_instance_._instance,
  &::data::_LongTradeCorrectionForNonNextsharesTrades_default_instance_._instance,
  &::data::_LongTradeReportForNonNextshares_default_instance_._instance,
  &::data::_ReferencePrice_default_instance_._instance,
  &::data::_QBBOIPOQuotingPeriodUpdate_default_instance_._instance,
  &::data::_SecurityDefinition_default_instance_._instance,
  &::data::_SecurityStatus_default_instance_._instance,
  &::data::_Statistics_default_instance_._instance,
  &::data::_StockConnectDailyQuotaBalance_default_instance_._instance,
  &::data::_StockConnectMarketTurnover_default_instance_._instance,
  &::data::_Trade_default_instance_._instance,
  &::data::_TradeCancel_default_instance_._instance,
  &::data::_TradingSessionStatus_default_instance_._instance,
  &::data::_VCMTrigger_default_instance_._instance,
  &::data::_Yield_default_instance_._instance,
  &::data::_CNMarketDefinition_default_instance_._instance,
  &::data::_CNSecurityDefinition_default_instance_._instance,
  &::data::_CNSecurityStatus_default_instance_._instance,
  &::data::_CNStatistics_default_instance_._instance,
  &::data::_CNTopBook_default_instance_._instance,
  &::data::_CertificationMsg_default_instance_._instance,
  &::data::_Resp_default_instance_._instance,
  &::data::_Message_default_instance_._instance,
};

const char descriptor_table_protodef_data_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\ndata.proto\022\004data\"\277\001\n\024AdjustedClosingPr"
  "ice\022\030\n\013issueSymbol\030\001 \001(\tH\000\210\001\001\022/\n\rsecurit"
  "yClass\030\002 \001(\0162\023.data.SecurityClassH\001\210\001\001\022!"
  "\n\024adjustedClosingPrice\030\003 \001(\001H\002\210\001\001B\016\n\014_is"
  "sueSymbolB\020\n\016_securityClassB\027\n\025_adjusted"
  "ClosingPrice\"\323\002\n\017DayTradeSummary\022\030\n\013issu"
  "eSymbol\030\001 \001(\tH\000\210\001\001\0221\n\016marketCategory\030\002 \001"
  "(\0162\024.data.MarketCategoryH\001\210\001\001\022\034\n\017nasdaqH"
  "ighPrice\030\003 \001(\001H\002\210\001\001\022\033\n\016nasdaqLowPrice\030\004 "
  "\001(\001H\003\210\001\001\022\037\n\022nasdaqClosingPrice\030\005 \001(\001H\004\210\001"
  "\001\022\037\n\022consolidatedVolume\030\006 \001(\003H\005\210\001\001B\016\n\014_i"
  "ssueSymbolB\021\n\017_marketCategoryB\022\n\020_nasdaq"
  "HighPriceB\021\n\017_nasdaqLowPriceB\025\n\023_nasdaqC"
  "losingPriceB\025\n\023_consolidatedVolume\"\213\004\n\031D"
  "ayTradeSummaryNextShares\022\030\n\013issueSymbol\030"
  "\001 \001(\tH\000\210\001\001\0221\n\016marketCategory\030\002 \001(\0162\024.dat"
  "a.MarketCategoryH\001\210\001\001\022\034\n\017nasdaqHighPrice"
  "\030\003 \001(\001H\002\210\001\001\022 \n\023NAVOffsetAmountHigh\030\004 \001(\001"
  "H\003\210\001\001\022\033\n\016nasdaqLowPrice\030\005 \001(\001H\004\210\001\001\022\037\n\022NA"
  "VOffsetAmountLow\030\006 \001(\001H\005\210\001\001\022\037\n\022nasdaqClo"
  "singPrice\030\007 \001(\001H\006\210\001\001\022!\n\024NAVOffsetAmountC"
  "lose\030\010 \001(\001H\007\210\001\001\022\037\n\022consolidatedVolume\030\t "
  "\001(\003H\010\210\001\001B\016\n\014_issueSymbolB\021\n\017_marketCateg"
  "oryB\022\n\020_nasdaqHighPriceB\026\n\024_NAVOffsetAmo"
  "untHighB\021\n\017_nasdaqLowPriceB\025\n\023_NAVOffset"
  "AmountLowB\025\n\023_nasdaqClosingPriceB\027\n\025_NAV"
  "OffsetAmountCloseB\025\n\023_consolidatedVolume"
  "\"\374\001\n\016IPOInformation\022\030\n\013issueSymbol\030\001 \001(\t"
  "H\000\210\001\001\022/\n\rsecurityClass\030\002 \001(\0162\023.data.Secu"
  "rityClassH\001\210\001\001\0223\n\025referenceForNetChange\030"
  "\003 \001(\0162\017.data.NetChangeH\002\210\001\001\022\033\n\016reference"
  "Price\030\004 \001(\001H\003\210\001\001B\016\n\014_issueSymbolB\020\n\016_sec"
  "urityClassB\030\n\026_referenceForNetChangeB\021\n\017"
  "_referencePrice\"\206\002\n\026IPOQuotingPeriodUpda"
  "te\022\022\n\005stock\030\001 \001(\tH\000\210\001\001\022$\n\027iPOQuotationRe"
  "leaseTime\030\002 \001(\003H\001\210\001\001\022J\n\031quotationRelease"
  "Qualifier\030\003 \001(\0162\".data.IPOQuotationRelea"
  "seQualifierH\002\210\001\001\022\025\n\010iPOPrice\030\004 \001(\001H\003\210\001\001B"
  "\010\n\006_stockB\032\n\030_iPOQuotationReleaseTimeB\034\n"
  "\032_quotationReleaseQualifierB\013\n\t_iPOPrice"
  "\"V\n\021MWCBStatusMessage\022/\n\rbreachedLevel\030\001"
  " \001(\0162\023.data.BreachedLevelH\000\210\001\001B\020\n\016_breac"
  "hedLevel\"z\n\030MarketWideCircuitBreaker\022\023\n\006"
  "Level1\030\001 \001(\001H\000\210\001\001\022\023\n\006Level2\030\002 \001(\001H\001\210\001\001\022\023"
  "\n\006Level3\030\003 \001(\001H\002\210\001\001B\t\n\007_Level1B\t\n\007_Level"
  "2B\t\n\007_Level3\"\242\001\n\rMessageHeader\022\033\n\016tracki"
  "ngNumber\030\001 \001(\005H\000\210\001\001\022\026\n\ttimestamp\030\002 \001(\003H\001"
  "\210\001\001\022+\n\013messageType\030\003 \001(\0162\021.data.MessageT"
  "ypeH\002\210\001\001B\021\n\017_trackingNumberB\014\n\n_timestam"
  "pB\016\n\014_messageType\"\304\001\n\017OperationalHalt\022\022\n"
  "\005stock\030\001 \001(\tH\000\210\001\001\022)\n\nmarketCode\030\002 \001(\0162\020."
  "data.MarketCodeH\001\210\001\001\022\?\n\025operationalHaltA"
  "ction\030\003 \001(\0162\033.data.OperationalHaltAction"
  "H\002\210\001\001B\010\n\006_stockB\r\n\013_marketCodeB\030\n\026_opera"
  "tionalHaltAction\"\332\001\n\025SaleConditionModifi"
  "er\022#\n\006level1\030\001 \001(\0162\016.data.LevelOneH\000\210\001\001\022"
  "#\n\006level2\030\002 \001(\0162\016.data.LevelTwoH\001\210\001\001\022%\n\006"
  "level3\030\003 \001(\0162\020.data.LevelThreeH\002\210\001\001\022$\n\006l"
  "evel4\030\004 \001(\0162\017.data.LevelFourH\003\210\001\001B\t\n\007_le"
  "vel1B\t\n\007_level2B\t\n\007_level3B\t\n\007_level4\"\220\001"
  "\n$ShortSaleRestrictionIndicatorMessage\022\030"
  "\n\013issueSymbol\030\001 \001(\tH\000\210\001\001\022-\n\014regSHOAction"
  "\030\002 \001(\0162\022.data.RegSHOActionH\001\210\001\001B\016\n\014_issu"
  "eSymbolB\017\n\r_regSHOAction\"\245\007\n\016StockDirect"
  "ory\022\022\n\005stock\030\001 \001(\tH\000\210\001\001\0221\n\016marketCategor"
  "y\030\002 \001(\0162\024.data.MarketCategoryH\001\210\001\001\022E\n\030fi"
  "nancialStatusIndicator\030\003 \001(\0162\036.data.Fina"
  "ncialStatusIndicatorH\002\210\001\001\022\031\n\014roundLotsiz"
  "e\030\004 \001(\003H\003\210\001\001\022,\n\014roundLotOnly\030\005 \001(\0162\021.dat"
  "a.IndicatesIfH\004\210\001\001\022 \n\023issueClassificatio"
  "n\030\006 \001(\tH\005\210\001\001\022\031\n\014issueSubType\030\007 \001(\tH\006\210\001\001\022"
  "-\n\014authenticity\030\010 \001(\0162\022.data.Authenticit"
  "yH\007\210\001\001\022;\n\033shortSaleThresholdIndicator\030\t "
  "\001(\0162\021.data.IndicatesIfH\010\210\001\001\022\'\n\007IPOFlag\030\n"
  " \001(\0162\021.data.IndicatesIfH\t\210\001\001\0223\n\026lULDRefe"
  "rencePriceTier\030\013 \001(\0162\016.data.LULDRuleH\n\210\001"
  "\001\022&\n\006ETPlag\030\014 \001(\0162\021.data.IndicatesIfH\013\210\001"
  "\001\022\036\n\021ETPLeverageFactor\030\r \001(\003H\014\210\001\001\0220\n\020inv"
  "erseIndicator\030\016 \001(\0162\021.data.IndicatesIfH\r"
  "\210\001\001\022\030\n\013bloombergID\030\017 \001(\tH\016\210\001\001B\010\n\006_stockB"
  "\021\n\017_marketCategoryB\033\n\031_financialStatusIn"
  "dicatorB\017\n\r_roundLotsizeB\017\n\r_roundLotOnl"
  "yB\026\n\024_issueClassificationB\017\n\r_issueSubTy"
  "peB\017\n\r_authenticityB\036\n\034_shortSaleThresho"
  "ldIndicatorB\n\n\010_IPOFlagB\031\n\027_lULDReferenc"
  "ePriceTierB\t\n\007_ETPlagB\024\n\022_ETPLeverageFac"
  "torB\023\n\021_inverseIndicatorB\016\n\014_bloombergID"
  "\"\232\002\n\022StockTradingAction\022\025\n\010reserved\030\001 \001("
  "\tH\000\210\001\001\022\030\n\013issueSymbol\030\002 \001(\tH\001\210\001\001\022/\n\rsecu"
  "rityClass\030\003 \001(\0162\023.data.SecurityClassH\002\210\001"
  "\001\022;\n\023currentTradingState\030\004 \001(\0162\031.data.Cu"
  "rrentTradingStateH\003\210\001\001\022\023\n\006reason\030\005 \001(\tH\004"
  "\210\001\001B\013\n\t_reservedB\016\n\014_issueSymbolB\020\n\016_sec"
  "urityClassB\026\n\024_currentTradingStateB\t\n\007_r"
  "eason\"K\n\022SystemEventMessage\022\'\n\teventCode"
  "\030\001 \001(\0162\017.data.EventCodeH\000\210\001\001B\014\n\n_eventCo"
  "de\"\364\004\n\036TradeCancelForNextsharesTrades\022L\n"
  "\026marketCenterIdentifier\030\001 \001(\0162\'.data.Ori"
  "ginatingMarketCenterIdentifierH\000\210\001\001\022\030\n\013i"
  "ssueSymbol\030\002 \001(\tH\001\210\001\001\022/\n\rsecurityClass\030\003"
  " \001(\0162\023.data.SecurityClassH\002\210\001\001\022\'\n\032origin"
  "alTradeControlNumber\030\004 \001(\tH\003\210\001\001\022\037\n\022origi"
  "nalProxyPrice\030\005 \001(\001H\004\210\001\001\022$\n\027originalNAVO"
  "ffsetAmount\030\006 \001(\001H\005\210\001\001\022\036\n\021originalTradeS"
  "ize\030\007 \001(\003H\006\210\001\001\022*\n\035originalSaleConditionM"
  "odifier\030\010 \001(\tH\007\210\001\001\022\037\n\022consolidatedVolume"
  "\030\t \001(\003H\010\210\001\001B\031\n\027_marketCenterIdentifierB\016"
  "\n\014_issueSymbolB\020\n\016_securityClassB\035\n\033_ori"
  "ginalTradeControlNumberB\025\n\023_originalProx"
  "yPriceB\032\n\030_originalNAVOffsetAmountB\024\n\022_o"
  "riginalTradeSizeB \n\036_originalSaleConditi"
  "onModifierB\025\n\023_consolidatedVolume\"\310\004\n!Tr"
  "adeCancelForNonNextSharesTrades\022L\n\026marke"
  "tCenterIdentifier\030\001 \001(\0162\'.data.Originati"
  "ngMarketCenterIdentifierH\000\210\001\001\022\030\n\013issueSy"
  "mbol\030\002 \001(\tH\001\210\001\001\022/\n\rsecurityClass\030\003 \001(\0162\023"
  ".data.SecurityClassH\002\210\001\001\022\"\n\025originalCont"
  "rolNumber\030\004 \001(\tH\003\210\001\001\022\037\n\022originalTradePri"
  "ce\030\005 \001(\001H\004\210\001\001\022\036\n\021originalTradeSize\030\006 \001(\003"
  "H\005\210\001\001\022G\n\035originalSaleConditionModifier\030\007"
  " \001(\0132\033.data.SaleConditionModifierH\006\210\001\001\022\037"
  "\n\022consolidatedVolume\030\010 \001(\003H\007\210\001\001B\031\n\027_mark"
  "etCenterIdentifierB\016\n\014_issueSymbolB\020\n\016_s"
  "ecurityClassB\030\n\026_originalControlNumberB\025"
  "\n\023_originalTradePriceB\024\n\022_originalTradeS"
  "izeB \n\036_originalSaleConditionModifierB\025\n"
  "\023_consolidatedVolume\"\266\007\n\"TradeCorrection"
  "ForNextsharesTrades\022L\n\026marketCenterIdent"
  "ifier\030\001 \001(\0162\'.data.OriginatingMarketCent"
  "erIdentifierH\000\210\001\001\022\030\n\013issueSymbol\030\002 \001(\tH\001"
  "\210\001\001\022/\n\rsecurityClass\030\003 \001(\0162\023.data.Securi"
  "tyClassH\002\210\001\001\022\"\n\025originalControlNumber\030\004 "
  "\001(\tH\003\210\001\001\022\037\n\022originalProxyPrice\030\005 \001(\001H\004\210\001"
  "\001\022$\n\027originalNAVOffsetAmount\030\006 \001(\001H\005\210\001\001\022"
  "\036\n\021originalTradeSize\030\007 \001(\003H\006\210\001\001\022&\n\031origi"
  "nalConditionModifier\030\010 \001(\tH\007\210\001\001\022(\n\033corre"
  "ctedTradeControlNumber\030\t \001(\tH\010\210\001\001\022 \n\023cor"
  "rectedTradePrice\030\n \001(\001H\t\210\001\001\022%\n\030corrected"
  "NAVOffsetAmount\030\013 \001(\001H\n\210\001\001\022\037\n\022CorrectedT"
  "radeSize\030\014 \001(\003H\013\210\001\001\022+\n\036CorrectedSaleCond"
  "itionModifier\030\r \001(\tH\014\210\001\001\022\037\n\022consolidated"
  "Volume\030\016 \001(\003H\r\210\001\001B\031\n\027_marketCenterIdenti"
  "fierB\016\n\014_issueSymbolB\020\n\016_securityClassB\030"
  "\n\026_originalControlNumberB\025\n\023_originalPro"
  "xyPriceB\032\n\030_originalNAVOffsetAmountB\024\n\022_"
  "originalTradeSizeB\034\n\032_originalConditionM"
  "odifierB\036\n\034_correctedTradeControlNumberB"
  "\026\n\024_correctedTradePriceB\033\n\031_correctedNAV"
  "OffsetAmountB\025\n\023_CorrectedTradeSizeB!\n\037_"
  "CorrectedSaleConditionModifierB\025\n\023_conso"
  "lidatedVolume\"\263\006\n%TradeCorrectionForNonN"
  "extsharesTrades\022L\n\026marketCenterIdentifie"
  "r\030\001 \001(\0162\'.data.OriginatingMarketCenterId"
  "entifierH\000\210\001\001\022\030\n\013issueSymbol\030\002 \001(\tH\001\210\001\001\022"
  "/\n\rsecurityClass\030\003 \001(\0162\023.data.SecurityCl"
  "assH\002\210\001\001\022\"\n\025originalControlNumber\030\004 \001(\tH"
  "\003\210\001\001\022\037\n\022originalTradePrice\030\005 \001(\001H\004\210\001\001\022\036\n"
  "\021originalTradeSize\030\006 \001(\003H\005\210\001\001\022&\n\031origina"
  "lConditionModifier\030\007 \001(\tH\006\210\001\001\022(\n\033correct"
  "edTradeControlNumber\030\010 \001(\tH\007\210\001\001\022 \n\023corre"
  "ctedTradePrice\030\t \001(\001H\010\210\001\001\022\037\n\022CorrectedTr"
  "adeSize\030\n \001(\003H\t\210\001\001\022+\n\036CorrectedSaleCondi"
  "tionModifier\030\013 \001(\tH\n\210\001\001\022\037\n\022consolidatedV"
  "olume\030\014 \001(\003H\013\210\001\001B\031\n\027_marketCenterIdentif"
  "ierB\016\n\014_issueSymbolB\020\n\016_securityClassB\030\n"
  "\026_originalControlNumberB\025\n\023_originalTrad"
  "ePriceB\024\n\022_originalTradeSizeB\034\n\032_origina"
  "lConditionModifierB\036\n\034_correctedTradeCon"
  "trolNumberB\026\n\024_correctedTradePriceB\025\n\023_C"
  "orrectedTradeSizeB!\n\037_CorrectedSaleCondi"
  "tionModifierB\025\n\023_consolidatedVolume\"\333\004\n\030"
  "TradeReportForNextshares\022W\n!originatingM"
  "arketCenterIdentifier\030\001 \001(\0162\'.data.Origi"
  "natingMarketCenterIdentifierH\000\210\001\001\022\035\n\020nex"
  "tsharesSymbol\030\002 \001(\tH\001\210\001\001\022/\n\rsecurityClas"
  "s\030\003 \001(\0162\023.data.SecurityClassH\002\210\001\001\022\037\n\022tra"
  "deControlNumber\030\004 \001(\tH\003\210\001\001\022\027\n\nproxyPrice"
  "\030\005 \001(\001H\004\210\001\001\022\026\n\ttradeSize\030\006 \001(\003H\005\210\001\001\022\034\n\017N"
  "AVOffsetAmount\030\007 \001(\001H\006\210\001\001\022\?\n\025saleConditi"
  "onModifier\030\010 \001(\0132\033.data.SaleConditionMod"
  "ifierH\007\210\001\001\022\037\n\022consolidatedVolume\030\t \001(\005H\010"
  "\210\001\001B$\n\"_originatingMarketCenterIdentifie"
  "rB\023\n\021_nextsharesSymbolB\020\n\016_securityClass"
  "B\025\n\023_tradeControlNumberB\r\n\013_proxyPriceB\014"
  "\n\n_tradeSizeB\022\n\020_NAVOffsetAmountB\030\n\026_sal"
  "eConditionModifierB\025\n\023_consolidatedVolum"
  "e\"\242\004\n\033TradeReportForNonNextshares\022W\n!ori"
  "ginatingMarketCenterIdentifier\030\001 \001(\0162\'.d"
  "ata.OriginatingMarketCenterIdentifierH\000\210"
  "\001\001\022\030\n\013issueSymbol\030\002 \001(\tH\001\210\001\001\022/\n\rsecurity"
  "Class\030\003 \001(\0162\023.data.SecurityClassH\002\210\001\001\022\037\n"
  "\022tradeControlNumber\030\004 \001(\tH\003\210\001\001\022\027\n\ntradeP"
  "rice\030\005 \001(\001H\004\210\001\001\022\026\n\ttradeSize\030\006 \001(\003H\005\210\001\001\022"
  "\?\n\025saleConditionModifier\030\007 \001(\0132\033.data.Sa"
  "leConditionModifierH\006\210\001\001\022\037\n\022consolidated"
  "Volume\030\010 \001(\003H\007\210\001\001B$\n\"_originatingMarketC"
  "enterIdentifierB\016\n\014_issueSymbolB\020\n\016_secu"
  "rityClassB\025\n\023_tradeControlNumberB\r\n\013_tra"
  "dePriceB\014\n\n_tradeSizeB\030\n\026_saleConditionM"
  "odifierB\025\n\023_consolidatedVolume\"E\n\025QBBOMW"
  "CBBreachMessage\022\032\n\rbreachedLevel\030\001 \001(\tH\000"
  "\210\001\001B\020\n\016_breachedLevel\"}\n\033QBBOMWCBDecline"
  "LevelMessage\022\023\n\006Level1\030\001 \001(\001H\000\210\001\001\022\023\n\006Lev"
  "el2\030\002 \001(\001H\001\210\001\001\022\023\n\006Level3\030\003 \001(\001H\002\210\001\001B\t\n\007_"
  "Level1B\t\n\007_Level2B\t\n\007_Level3\"\252\001\n\021QBBOMes"
  "sageHeader\022/\n\013messageType\030\001 \001(\0162\025.data.Q"
  "BBOMessageTypeH\000\210\001\001\022\033\n\016trackingNumber\030\002 "
  "\001(\005H\001\210\001\001\022\026\n\ttimestamp\030\003 \001(\003H\002\210\001\001B\016\n\014_mes"
  "sageTypeB\021\n\017_trackingNumberB\014\n\n_timestam"
  "p\"\223\004\n\036QBBONextSharesQuotationMessage\022\035\n\020"
  "nextsharesSymbol\030\001 \001(\tH\000\210\001\001\022/\n\rsecurityC"
  "lass\030\002 \001(\0162\023.data.SecurityClassH\001\210\001\001\022\032\n\r"
  "nasdaqBestBid\030\003 \001(\001H\002\210\001\001\022\036\n\021nasdaqBestBi"
  "dSize\030\004 \001(\003H\003\210\001\001\022(\n\033nasdaqBestBidDiscoun"
  "tAmount\030\005 \001(\001H\004\210\001\001\022&\n\031nasdaqBestOfferPro"
  "xyPrice\030\006 \001(\001H\005\210\001\001\022 \n\023nasdaqBestOfferSiz"
  "e\030\007 \001(\003H\006\210\001\001\022*\n\035nasdaqBestOfferDiscountA"
  "mount\030\010 \001(\001H\007\210\001\001B\023\n\021_nextsharesSymbolB\020\n"
  "\016_securityClassB\020\n\016_nasdaqBestBidB\024\n\022_na"
  "sdaqBestBidSizeB\036\n\034_nasdaqBestBidDiscoun"
  "tAmountB\034\n\032_nasdaqBestOfferProxyPriceB\026\n"
  "\024_nasdaqBestOfferSizeB \n\036_nasdaqBestOffe"
  "rDiscountAmount\"\275\001\n\023QBBOOperationalHalt\022"
  "\022\n\005stock\030\001 \001(\tH\000\210\001\001\022)\n\nmarketCode\030\002 \001(\0162"
  "\020.data.MarketCodeH\001\210\001\001\0224\n\025operationalHal"
  "tAction\030\003 \001(\0162\020.data.HaltActionH\002\210\001\001B\010\n\006"
  "_stockB\r\n\013_marketCodeB\030\n\026_operationalHal"
  "tAction\"\333\002\n\024QBBOQuotationMessage\022\022\n\005stoc"
  "k\030\001 \001(\tH\000\210\001\001\022/\n\rsecurityClass\030\002 \001(\0162\023.da"
  "ta.SecurityClassH\001\210\001\001\022\037\n\022nasdaqBestBidPr"
  "ice\030\003 \001(\001H\002\210\001\001\022\036\n\021nasdaqBestBidSize\030\004 \001("
  "\003H\003\210\001\001\022!\n\024nasdaqBestOfferPrice\030\005 \001(\001H\004\210\001"
  "\001\022 \n\023nasdaqBestOfferSize\030\006 \001(\003H\005\210\001\001B\010\n\006_"
  "stockB\020\n\016_securityClassB\025\n\023_nasdaqBestBi"
  "dPriceB\024\n\022_nasdaqBestBidSizeB\027\n\025_nasdaqB"
  "estOfferPriceB\026\n\024_nasdaqBestOfferSize\"u\n"
  "\025QBBORegShoRestriction\022\022\n\005stock\030\001 \001(\tH\000\210"
  "\001\001\022-\n\014regSHOAction\030\002 \001(\0162\022.data.RegSHOAc"
  "tionH\001\210\001\001B\010\n\006_stockB\017\n\r_regSHOAction\"\377\006\n"
  "\022QBBOStockDirectory\022\022\n\005stock\030\001 \001(\tH\000\210\001\001\022"
  "1\n\016marketCategory\030\002 \001(\0162\024.data.MarketCat"
  "egoryH\001\210\001\001\022E\n\030financialStatusIndicator\030\003"
  " \001(\0162\036.data.FinancialStatusIndicatorH\002\210\001"
  "\001\022\031\n\014roundLotsize\030\004 \001(\003H\003\210\001\001\022,\n\014roundLot"
  "Only\030\005 \001(\0162\021.data.IndicatesIfH\004\210\001\001\022 \n\023is"
  "sueClassification\030\006 \001(\tH\005\210\001\001\022\031\n\014issueSub"
  "Type\030\007 \001(\tH\006\210\001\001\022-\n\014authenticity\030\010 \001(\0162\022."
  "data.AuthenticityH\007\210\001\001\022;\n\033shortSaleThres"
  "holdIndicator\030\t \001(\0162\021.data.IndicatesIfH\010"
  "\210\001\001\022\'\n\007IPOFlag\030\n \001(\0162\021.data.IndicatesIfH"
  "\t\210\001\001\0223\n\026lULDReferencePriceTier\030\013 \001(\0162\016.d"
  "ata.LULDRuleH\n\210\001\001\022&\n\006ETPlag\030\014 \001(\0162\021.data"
  ".IndicatesIfH\013\210\001\001\022\036\n\021ETPLeverageFactor\030\r"
  " \001(\003H\014\210\001\001\0220\n\020inverseIndicator\030\016 \001(\0162\021.da"
  "ta.IndicatesIfH\r\210\001\001B\010\n\006_stockB\021\n\017_market"
  "CategoryB\033\n\031_financialStatusIndicatorB\017\n"
  "\r_roundLotsizeB\017\n\r_roundLotOnlyB\026\n\024_issu"
  "eClassificationB\017\n\r_issueSubTypeB\017\n\r_aut"
  "henticityB\036\n\034_shortSaleThresholdIndicato"
  "rB\n\n\010_IPOFlagB\031\n\027_lULDReferencePriceTier"
  "B\t\n\007_ETPlagB\024\n\022_ETPLeverageFactorB\023\n\021_in"
  "verseIndicator\"\356\001\n\026QBBOStockTradingActio"
  "n\022\022\n\005stock\030\001 \001(\tH\000\210\001\001\022/\n\rsecurityClass\030\002"
  " \001(\0162\023.data.SecurityClassH\001\210\001\001\022;\n\023curren"
  "tTradingState\030\003 \001(\0162\031.data.CurrentTradin"
  "gStateH\002\210\001\001\022\023\n\006reason\030\004 \001(\tH\003\210\001\001B\010\n\006_sto"
  "ckB\020\n\016_securityClassB\026\n\024_currentTradingS"
  "tateB\t\n\007_reason\"O\n\026QBBOSystemEventMessag"
  "e\022\'\n\teventCode\030\001 \001(\0162\017.data.EventCodeH\000\210"
  "\001\001B\014\n\n_eventCode\"\354\001\n\016AddOddLotOrder\022\031\n\014s"
  "ecurityCode\030\001 \001(\003H\000\210\001\001\022\024\n\007orderId\030\002 \001(\003H"
  "\001\210\001\001\022\022\n\005price\030\003 \001(\001H\002\210\001\001\022\025\n\010quantity\030\004 \001"
  "(\003H\003\210\001\001\022\025\n\010brokerID\030\005 \001(\005H\004\210\001\001\022\035\n\004side\030\006"
  " \001(\0162\n.data.SideH\005\210\001\001B\017\n\r_securityCodeB\n"
  "\n\010_orderIdB\010\n\006_priceB\013\n\t_quantityB\013\n\t_br"
  "okerIDB\007\n\005_side\"h\n\030AggregateOrderBookUpd"
  "ate\022\031\n\014securityCode\030\001 \001(\003H\000\210\001\001\022 \n\tnoEntr"
  "ies\030\002 \003(\0132\r.data.NoEntryB\017\n\r_securityCod"
  "e\"Y\n\nBQMoreItem\022\021\n\004item\030\001 \001(\005H\000\210\001\001\022&\n\004ty"
  "pe\030\002 \001(\0162\023.data.IndicatesTypeH\001\210\001\001B\007\n\005_i"
  "temB\007\n\005_type\"\350\001\n\013BrokerQueue\022\031\n\014security"
  "Code\030\001 \001(\003H\000\210\001\001\022\026\n\titemCount\030\002 \001(\005H\001\210\001\001\022"
  "#\n\004side\030\003 \001(\0162\020.data.BrokerSideH\002\210\001\001\022)\n\n"
  "bQMoreFlag\030\004 \001(\0162\020.data.BQMoreFlagH\003\210\001\001\022"
  "\037\n\005items\030\005 \003(\0132\020.data.BQMoreItemB\017\n\r_sec"
  "urityCodeB\014\n\n_itemCountB\007\n\005_sideB\r\n\013_bQM"
  "oreFlag\"\226\001\n\014ClosingPrice\022\031\n\014securityCode"
  "\030\001 \001(\003H\000\210\001\001\022\031\n\014closingPrice\030\002 \001(\001H\001\210\001\001\022\033"
  "\n\016numberOfTrades\030\003 \001(\003H\002\210\001\001B\017\n\r_security"
  "CodeB\017\n\r_closingPriceB\021\n\017_numberOfTrades"
  "\"\252\001\n\014CurrencyRate\022-\n\014currencyCode\030\001 \001(\0162"
  "\022.data.CurrencyTypeH\000\210\001\001\022\033\n\016currencyFact"
  "or\030\002 \001(\005H\001\210\001\001\022\031\n\014currencyRate\030\003 \001(\001H\002\210\001\001"
  "B\017\n\r_currencyCodeB\021\n\017_currencyFactorB\017\n\r"
  "_currencyRate\"\255\001\n\021DeleteOddLotOrder\022\031\n\014s"
  "ecurityCode\030\001 \001(\003H\000\210\001\001\022\024\n\007orderId\030\002 \001(\003H"
  "\001\210\001\001\022\025\n\010brokerID\030\003 \001(\005H\002\210\001\001\022\035\n\004side\030\004 \001("
  "\0162\n.data.SideH\003\210\001\001B\017\n\r_securityCodeB\n\n\010_"
  "orderIdB\013\n\t_brokerIDB\007\n\005_side\"\226\005\n\tIndexD"
  "ata\022\026\n\tindexCode\030\001 \001(\tH\000\210\001\001\022+\n\013indexStat"
  "us\030\002 \001(\0162\021.data.IndexStatusH\001\210\001\001\022\026\n\tinde"
  "xTime\030\003 \001(\003H\002\210\001\001\022\027\n\nindexValue\030\004 \001(\001H\003\210\001"
  "\001\022\032\n\rnetChgPrevDay\030\005 \001(\001H\004\210\001\001\022\026\n\thighVal"
  "ue\030\006 \001(\001H\005\210\001\001\022\025\n\010lowValue\030\007 \001(\001H\006\210\001\001\022\025\n\010"
  "eASValue\030\010 \001(\001H\007\210\001\001\022\032\n\rindexTurnover\030\t \001"
  "(\001H\010\210\001\001\022\031\n\014openingValue\030\n \001(\001H\t\210\001\001\022\031\n\014cl"
  "osingValue\030\013 \001(\001H\n\210\001\001\022\035\n\020previousSesClos"
  "e\030\014 \001(\001H\013\210\001\001\022\030\n\013indexVolume\030\r \001(\003H\014\210\001\001\022\035"
  "\n\020netChgPrevDayPct\030\016 \001(\001H\r\210\001\001\022\026\n\texcepti"
  "on\030\017 \001(\tH\016\210\001\001B\014\n\n_indexCodeB\016\n\014_indexSta"
  "tusB\014\n\n_indexTimeB\r\n\013_indexValueB\020\n\016_net"
  "ChgPrevDayB\014\n\n_highValueB\013\n\t_lowValueB\013\n"
  "\t_eASValueB\020\n\016_indexTurnoverB\017\n\r_opening"
  "ValueB\017\n\r_closingValueB\023\n\021_previousSesCl"
  "oseB\016\n\014_indexVolumeB\023\n\021_netChgPrevDayPct"
  "B\014\n\n_exception\"\264\001\n\017IndexDefinition\022\026\n\tin"
  "dexCode\030\001 \001(\tH\000\210\001\001\022+\n\013indexSource\030\002 \001(\0162"
  "\021.data.IndexSourceH\001\210\001\001\022-\n\014currencyCode\030"
  "\003 \001(\0162\022.data.CurrencyTypeH\002\210\001\001B\014\n\n_index"
  "CodeB\016\n\014_indexSourceB\017\n\r_currencyCode\"\234\001"
  "\n\032IndicativeEquilibriumPrice\022\031\n\014security"
  "Code\030\001 \001(\003H\000\210\001\001\022\022\n\005price\030\002 \001(\001H\001\210\001\001\022\036\n\021a"
  "ggregateQuantity\030\003 \001(\003H\002\210\001\001B\017\n\r_security"
  "CodeB\010\n\006_priceB\024\n\022_aggregateQuantity\"x\n\021"
  "LiquidityProvider\022\031\n\014securityCode\030\001 \001(\003H"
  "\000\210\001\001\0227\n\024noLiquidityProviders\030\002 \003(\0132\031.dat"
  "a.NoLiquidityProviderB\017\n\r_securityCode\"\354"
  "\001\n\020MarketDefinition\022)\n\nmarketCode\030\001 \001(\0162"
  "\020.data.MarketCodeH\000\210\001\001\022\027\n\nmarketName\030\002 \001"
  "(\tH\001\210\001\001\022-\n\014currencyCode\030\003 \001(\0162\022.data.Cur"
  "rencyTypeH\002\210\001\001\022\037\n\022numberOfSecurities\030\004 \001"
  "(\003H\003\210\001\001B\r\n\013_marketCodeB\r\n\013_marketNameB\017\n"
  "\r_currencyCodeB\025\n\023_numberOfSecurities\"\256\001"
  "\n\016MarketTurnover\022)\n\nmarketCode\030\001 \001(\0162\020.d"
  "ata.MarketCodeH\000\210\001\001\022-\n\014currencyCode\030\002 \001("
  "\0162\022.data.CurrencyTypeH\001\210\001\001\022\025\n\010turnover\030\003"
  " \001(\001H\002\210\001\001B\r\n\013_marketCodeB\017\n\r_currencyCod"
  "eB\013\n\t_turnover\"\243\003\n\004News\022%\n\010newsType\030\001 \001("
  "\0162\016.data.NewsTypeH\000\210\001\001\022\023\n\006newsID\030\002 \001(\tH\001"
  "\210\001\001\022\025\n\010headline\030\003 \001(\tH\002\210\001\001\022)\n\ncancelFlag"
  "\030\004 \001(\0162\020.data.CancelFlagH\003\210\001\001\022-\n\014lastFra"
  "gment\030\005 \001(\0162\022.data.LastFragmentH\004\210\001\001\022\030\n\013"
  "releaseTime\030\006 \001(\003H\005\210\001\001\022)\n\rnoMarketCodes\030"
  "\007 \003(\0132\022.data.NoMarketCode\022-\n\017noSecurityC"
  "odes\030\010 \003(\0132\024.data.NoSecurityCode\022%\n\013noNe"
  "wsLines\030\t \003(\0132\020.data.NoNewsLineB\013\n\t_news"
  "TypeB\t\n\007_newsIDB\013\n\t_headlineB\r\n\013_cancelF"
  "lagB\017\n\r_lastFragmentB\016\n\014_releaseTime\"\235\002\n"
  "\007NoEntry\022\036\n\021aggregateQuantity\030\001 \001(\003H\000\210\001\001"
  "\022\022\n\005price\030\002 \001(\001H\001\210\001\001\022\033\n\016numberOfOrders\030\003"
  " \001(\003H\002\210\001\001\022\035\n\004side\030\004 \001(\0162\n.data.SideH\003\210\001\001"
  "\022\027\n\npriceLevel\030\005 \001(\005H\004\210\001\001\022-\n\014updateActio"
  "n\030\006 \001(\0162\022.data.UpdateActionH\005\210\001\001B\024\n\022_agg"
  "regateQuantityB\010\n\006_priceB\021\n\017_numberOfOrd"
  "ersB\007\n\005_sideB\r\n\013_priceLevelB\017\n\r_updateAc"
  "tion\"E\n\023NoLiquidityProvider\022\033\n\016lPBrokerN"
  "umber\030\001 \001(\005H\000\210\001\001B\021\n\017_lPBrokerNumber\"H\n\014N"
  "oMarketCode\022)\n\nmarketCode\030\001 \001(\0162\020.data.M"
  "arketCodeH\000\210\001\001B\r\n\013_marketCode\"0\n\nNoNewsL"
  "ine\022\025\n\010newsLine\030\001 \001(\tH\000\210\001\001B\013\n\t_newsLine\""
  "<\n\016NoSecurityCode\022\031\n\014securityCode\030\001 \001(\003H"
  "\000\210\001\001B\017\n\r_securityCode\"V\n\024NoUnderlyingSec"
  "urity\022#\n\026underlyingSecurityCode\030\001 \001(\003H\000\210"
  "\001\001B\031\n\027_underlyingSecurityCode\"f\n\014Nominal"
  "Price\022\031\n\014securityCode\030\001 \001(\003H\000\210\001\001\022\031\n\014nomi"
  "nalPrice\030\002 \001(\001H\001\210\001\001B\017\n\r_securityCodeB\017\n\r"
  "_nominalPrice\"\335\001\n\016OrderImbalance\022\031\n\014secu"
  "rityCode\030\001 \001(\003H\000\210\001\001\022C\n\027orderImbalanceDir"
  "ection\030\002 \001(\0162\035.data.OrderImbalanceDirect"
  "ionH\001\210\001\001\022#\n\026orderImbalanceQuantity\030\003 \001(\003"
  "H\002\210\001\001B\017\n\r_securityCodeB\032\n\030_orderImbalanc"
  "eDirectionB\031\n\027_orderImbalanceQuantity\"\270\001"
  "\n\014PacketHeader\022\024\n\007pktSize\030\001 \001(\005H\000\210\001\001\022\025\n\010"
  "msgCount\030\002 \001(\005H\001\210\001\001\022\023\n\006filler\030\003 \001(\tH\002\210\001\001"
  "\022\023\n\006seqNum\030\004 \001(\003H\003\210\001\001\022\025\n\010sendTime\030\005 \001(\003H"
  "\004\210\001\001B\n\n\010_pktSizeB\013\n\t_msgCountB\t\n\007_filler"
  "B\t\n\007_seqNumB\013\n\t_sendTime\"\303\001\n\030LongAdjuste"
  "dClosingPrice\022\030\n\013issueSymbol\030\001 \001(\tH\000\210\001\001\022"
  "/\n\rsecurityClass\030\002 \001(\0162\023.data.SecurityCl"
  "assH\001\210\001\001\022!\n\024adjustedClosingPrice\030\003 \001(\001H\002"
  "\210\001\001B\016\n\014_issueSymbolB\020\n\016_securityClassB\027\n"
  "\025_adjustedClosingPrice\"\225\003\n\023LongDayTradeS"
  "ummary\022\030\n\013issueSymbol\030\001 \001(\tH\000\210\001\001\0221\n\016mark"
  "etCategory\030\002 \001(\0162\024.data.MarketCategoryH\001"
  "\210\001\001\022\034\n\017nasdaqHighPrice\030\003 \001(\001H\002\210\001\001\022\033\n\016nas"
  "daqLowPrice\030\004 \001(\001H\003\210\001\001\022\037\n\022nasdaqClosingP"
  "rice\030\005 \001(\001H\004\210\001\001\022\037\n\022consolidatedVolume\030\006 "
  "\001(\003H\005\210\001\001\022\"\n\025consolidatedOpenPrice\030\007 \001(\001H"
  "\006\210\001\001B\016\n\014_issueSymbolB\021\n\017_marketCategoryB"
  "\022\n\020_nasdaqHighPriceB\021\n\017_nasdaqLowPriceB\025"
  "\n\023_nasdaqClosingPriceB\025\n\023_consolidatedVo"
  "lumeB\030\n\026_consolidatedOpenPrice\"\314\004\n%LongT"
  "radeCancelForNonNextSharesTrades\022L\n\026mark"
  "etCenterIdentifier\030\001 \001(\0162\'.data.Originat"
  "ingMarketCenterIdentifierH\000\210\001\001\022\030\n\013issueS"
  "ymbol\030\002 \001(\tH\001\210\001\001\022/\n\rsecurityClass\030\003 \001(\0162"
  "\023.data.SecurityClassH\002\210\001\001\022\"\n\025originalCon"
  "trolNumber\030\004 \001(\tH\003\210\001\001\022\037\n\022originalTradePr"
  "ice\030\005 \001(\001H\004\210\001\001\022\036\n\021originalTradeSize\030\006 \001("
  "\003H\005\210\001\001\022G\n\035originalSaleConditionModifier\030"
  "\007 \001(\0132\033.data.SaleConditionModifierH\006\210\001\001\022"
  "\037\n\022consolidatedVolume\030\010 \001(\003H\007\210\001\001B\031\n\027_mar"
  "ketCenterIdentifierB\016\n\014_issueSymbolB\020\n\016_"
  "securityClassB\030\n\026_originalControlNumberB"
  "\025\n\023_originalTradePriceB\024\n\022_originalTrade"
  "SizeB \n\036_originalSaleConditionModifierB\025"
  "\n\023_consolidatedVolume\"\267\006\n)LongTradeCorre"
  "ctionForNonNextsharesTrades\022L\n\026marketCen"
  "terIdentifier\030\001 \001(\0162\'.data.OriginatingMa"
  "rketCenterIdentifierH\000\210\001\001\022\030\n\013issueSymbol"
  "\030\002 \001(\tH\001\210\001\001\022/\n\rsecurityClass\030\003 \001(\0162\023.dat"
  "a.SecurityClassH\002\210\001\001\022\"\n\025originalControlN"
  "umber\030\004 \001(\tH\003\210\001\001\022\037\n\022originalTradePrice\030\005"
  " \001(\001H\004\210\001\001\022\036\n\021originalTradeSize\030\006 \001(\003H\005\210\001"
  "\001\022&\n\031originalConditionModifier\030\007 \001(\tH\006\210\001"
  "\001\022(\n\033correctedTradeControlNumber\030\010 \001(\tH\007"
  "\210\001\001\022 \n\023correctedTradePrice\030\t \001(\001H\010\210\001\001\022\037\n"
  "\022CorrectedTradeSize\030\n \001(\003H\t\210\001\001\022+\n\036Correc"
  "tedSaleConditionModifier\030\013 \001(\tH\n\210\001\001\022\037\n\022c"
  "onsolidatedVolume\030\014 \001(\003H\013\210\001\001B\031\n\027_marketC"
  "enterIdentifierB\016\n\014_issueSymbolB\020\n\016_secu"
  "rityClassB\030\n\026_originalControlNumberB\025\n\023_"
  "originalTradePriceB\024\n\022_originalTradeSize"
  "B\034\n\032_originalConditionModifierB\036\n\034_corre"
  "ctedTradeControlNumberB\026\n\024_correctedTrad"
  "ePriceB\025\n\023_CorrectedTradeSizeB!\n\037_Correc"
  "tedSaleConditionModifierB\025\n\023_consolidate"
  "dVolume\"Y\n\037LongTradeReportForNonNextshar"
  "es\022\037\n\022consolidatedVolume\030\001 \001(\003H\000\210\001\001B\025\n\023_"
  "consolidatedVolume\"\274\001\n\016ReferencePrice\022\031\n"
  "\014securityCode\030\001 \001(\003H\000\210\001\001\022\033\n\016referencePri"
  "ce\030\002 \001(\001H\001\210\001\001\022\027\n\nlowerPrice\030\003 \001(\001H\002\210\001\001\022\027"
  "\n\nupperPrice\030\004 \001(\001H\003\210\001\001B\017\n\r_securityCode"
  "B\021\n\017_referencePriceB\r\n\013_lowerPriceB\r\n\013_u"
  "pperPrice\"\212\002\n\032QBBOIPOQuotingPeriodUpdate"
  "\022\022\n\005stock\030\001 \001(\tH\000\210\001\001\022$\n\027iPOQuotationRele"
  "aseTime\030\002 \001(\003H\001\210\001\001\022J\n\031quotationReleaseQu"
  "alifier\030\003 \001(\0162\".data.IPOQuotationRelease"
  "QualifierH\002\210\001\001\022\025\n\010iPOPrice\030\004 \001(\001H\003\210\001\001B\010\n"
  "\006_stockB\032\n\030_iPOQuotationReleaseTimeB\034\n\032_"
  "quotationReleaseQualifierB\013\n\t_iPOPrice\"\344"
  "\022\n\022SecurityDefinition\022\031\n\014securityCode\030\001 "
  "\001(\003H\000\210\001\001\022)\n\nmarketCode\030\002 \001(\0162\020.data.Mark"
  "etCodeH\001\210\001\001\022\025\n\010isinCode\030\003 \001(\tH\002\210\001\001\0221\n\016in"
  "strumentType\030\004 \001(\0162\024.data.InstrumentType"
  "H\003\210\001\001\022+\n\013productType\030\005 \001(\0162\021.data.Produc"
  "tTypeH\004\210\001\001\0223\n\017spreadTableCode\030\006 \001(\0162\025.da"
  "ta.SpreadTableCodeH\005\210\001\001\022\036\n\021securityShort"
  "Name\030\007 \001(\tH\006\210\001\001\022-\n\014currencyCode\030\010 \001(\0162\022."
  "data.CurrencyTypeH\007\210\001\001\022\035\n\020securityNameGC"
  "CS\030\t \001(\tH\010\210\001\001\022\033\n\016securityNameGB\030\n \001(\tH\t\210"
  "\001\001\022\024\n\007lotSize\030\013 \001(\003H\n\210\001\001\022!\n\024previousClos"
  "ingPrice\030\014 \001(\001H\013\210\001\001\022\024\n\007VCMFlag\030\r \001(\tH\014\210\001"
  "\001\0222\n\rshortSellFlag\030\016 \001(\0162\026.data.Indicate"
  "sWhetherH\r\210\001\001\022,\n\007casFlag\030\017 \001(\0162\026.data.In"
  "dicatesWhetherH\016\210\001\001\022.\n\tCCASSFlag\030\020 \001(\0162\026"
  ".data.IndicatesWhetherH\017\210\001\001\0226\n\021dummySecu"
  "rityFlag\030\021 \001(\0162\026.data.IndicatesWhetherH\020"
  "\210\001\001\0222\n\rstampDutyFlag\030\022 \001(\0162\026.data.Indica"
  "tesWhetherH\021\210\001\001\022\030\n\013listingDate\030\023 \001(\003H\022\210\001"
  "\001\022\032\n\rdelistingDate\030\024 \001(\003H\023\210\001\001\022\025\n\010freeTex"
  "t\030\025 \001(\tH\024\210\001\001\022,\n\007posFlag\030\026 \001(\0162\026.data.Ind"
  "icatesWhetherH\025\210\001\001\022\032\n\rposUpperLimit\030\027 \001("
  "\005H\026\210\001\001\022\032\n\rposLowerLimit\030\030 \001(\005H\027\210\001\001\022,\n\007EF"
  "NFlag\030\031 \001(\0162\026.data.IndicatesWhetherH\030\210\001\001"
  "\022\034\n\017accruedInterest\030\032 \001(\001H\031\210\001\001\022\027\n\ncoupon"
  "Rate\030\033 \001(\001H\032\210\001\001\022\026\n\tfaceValue\030\034 \001(\003H\033\210\001\001\022"
  " \n\023decimalsInFaceValue\030\035 \001(\005H\034\210\001\001\022\036\n\021fac"
  "eValueCurrency\030\036 \001(\tH\035\210\001\001\022\035\n\020bondMaturit"
  "yDate\030\037 \001(\003H\036\210\001\001\022-\n\014investorType\030  \001(\0162\022"
  ".data.InvestorTypeH\037\210\001\001\022\034\n\017conversionRat"
  "io\030! \001(\001H \210\001\001\022\031\n\014strikePrice1\030\" \001(\001H!\210\001\001"
  "\022\031\n\014strikePrice2\030# \001(\001H\"\210\001\001\022 \n\023warrantMa"
  "turityDate\030$ \001(\003H#\210\001\001\022+\n\013callPutFlag\030% \001"
  "(\0162\021.data.CallPutFlagH$\210\001\001\022\037\n\005style\030& \001("
  "\0162\013.data.StyleH%\210\001\001\022\030\n\013warrantType\030\' \001(\t"
  "H&\210\001\001\022\026\n\tcallPrice\030( \001(\005H\'\210\001\001\022 \n\023Decimal"
  "sInCallPrice\030) \001(\005H(\210\001\001\022\030\n\013entitlement\030*"
  " \001(\005H)\210\001\001\022\"\n\025decimalsInEntitlement\030+ \001(\005"
  "H*\210\001\001\022%\n\030noWarrantsPerEntitlement\030, \001(\003H"
  "+\210\001\001\022:\n\026noUnderlyingSecurities\030- \003(\0132\032.d"
  "ata.NoUnderlyingSecurityB\017\n\r_securityCod"
  "eB\r\n\013_marketCodeB\013\n\t_isinCodeB\021\n\017_instru"
  "mentTypeB\016\n\014_productTypeB\022\n\020_spreadTable"
  "CodeB\024\n\022_securityShortNameB\017\n\r_currencyC"
  "odeB\023\n\021_securityNameGCCSB\021\n\017_securityNam"
  "eGBB\n\n\010_lotSizeB\027\n\025_previousClosingPrice"
  "B\n\n\010_VCMFlagB\020\n\016_shortSellFlagB\n\n\010_casFl"
  "agB\014\n\n_CCASSFlagB\024\n\022_dummySecurityFlagB\020"
  "\n\016_stampDutyFlagB\016\n\014_listingDateB\020\n\016_del"
  "istingDateB\013\n\t_freeTextB\n\n\010_posFlagB\020\n\016_"
  "posUpperLimitB\020\n\016_posLowerLimitB\n\n\010_EFNF"
  "lagB\022\n\020_accruedInterestB\r\n\013_couponRateB\014"
  "\n\n_faceValueB\026\n\024_decimalsInFaceValueB\024\n\022"
  "_faceValueCurrencyB\023\n\021_bondMaturityDateB"
  "\017\n\r_investorTypeB\022\n\020_conversionRatioB\017\n\r"
  "_strikePrice1B\017\n\r_strikePrice2B\026\n\024_warra"
  "ntMaturityDateB\016\n\014_callPutFlagB\010\n\006_style"
  "B\016\n\014_warrantTypeB\014\n\n_callPriceB\026\n\024_Decim"
  "alsInCallPriceB\016\n\014_entitlementB\030\n\026_decim"
  "alsInEntitlementB\033\n\031_noWarrantsPerEntitl"
  "ement\"\221\001\n\016SecurityStatus\022\031\n\014securityCode"
  "\030\001 \001(\003H\000\210\001\001\022;\n\023suspensionIndicator\030\002 \001(\016"
  "2\031.data.SuspensionIndicatorH\001\210\001\001B\017\n\r_sec"
  "urityCodeB\026\n\024_suspensionIndicator\"\232\003\n\nSt"
  "atistics\022\031\n\014securityCode\030\001 \001(\003H\000\210\001\001\022\031\n\014s"
  "haresTraded\030\002 \001(\003H\001\210\001\001\022\036\n\021vCMReferencePr"
  "ice\030\003 \001(\001H\002\210\001\001\022\026\n\thighPrice\030\004 \001(\001H\003\210\001\001\022\025"
  "\n\010lowPrice\030\005 \001(\001H\004\210\001\001\022\026\n\tlastPrice\030\006 \001(\001"
  "H\005\210\001\001\022\021\n\004vwap\030\007 \001(\001H\006\210\001\001\022\"\n\025shortSellSha"
  "resTraded\030\010 \001(\003H\007\210\001\001\022\036\n\021shortSellTurnove"
  "r\030\t \001(\001H\010\210\001\001B\017\n\r_securityCodeB\017\n\r_shares"
  "TradedB\024\n\022_vCMReferencePriceB\014\n\n_highPri"
  "ceB\013\n\t_lowPriceB\014\n\n_lastPriceB\007\n\005_vwapB\030"
  "\n\026_shortSellSharesTradedB\024\n\022_shortSellTu"
  "rnover\"\377\001\n\035StockConnectDailyQuotaBalance"
  "\022\037\n\022stockConnectMarket\030\001 \001(\tH\000\210\001\001\022\035\n\020tra"
  "dingDirection\030\002 \001(\tH\001\210\001\001\022\036\n\021dailyQuotaBa"
  "lance\030\003 \001(\003H\002\210\001\001\022\"\n\025dailyQuotaBalanceTim"
  "e\030\004 \001(\003H\003\210\001\001B\025\n\023_stockConnectMarketB\023\n\021_"
  "tradingDirectionB\024\n\022_dailyQuotaBalanceB\030"
  "\n\026_dailyQuotaBalanceTime\"\220\002\n\032StockConnec"
  "tMarketTurnover\022\037\n\022stockConnectMarket\030\001 "
  "\001(\tH\000\210\001\001\022\035\n\020tradingDirection\030\002 \001(\tH\001\210\001\001\022"
  "\030\n\013buyTurnover\030\003 \001(\003H\002\210\001\001\022\031\n\014sellTurnove"
  "r\030\004 \001(\003H\003\210\001\001\022\034\n\017buySellTurnover\030\005 \001(\003H\004\210"
  "\001\001B\025\n\023_stockConnectMarketB\023\n\021_tradingDir"
  "ectionB\016\n\014_buyTurnoverB\017\n\r_sellTurnoverB"
  "\022\n\020_buySellTurnover\"\356\001\n\005Trade\022\031\n\014securit"
  "yCode\030\001 \001(\003H\000\210\001\001\022\024\n\007tradeId\030\002 \001(\003H\001\210\001\001\022\022"
  "\n\005price\030\003 \001(\001H\002\210\001\001\022\025\n\010quantity\030\004 \001(\003H\003\210\001"
  "\001\022#\n\007trdType\030\005 \001(\0162\r.data.TrdTypeH\004\210\001\001\022\026"
  "\n\tTradeTime\030\006 \001(\003H\005\210\001\001B\017\n\r_securityCodeB"
  "\n\n\010_tradeIdB\010\n\006_priceB\013\n\t_quantityB\n\n\010_t"
  "rdTypeB\014\n\n_TradeTime\"[\n\013TradeCancel\022\031\n\014s"
  "ecurityCode\030\001 \001(\003H\000\210\001\001\022\024\n\007tradeId\030\002 \001(\003H"
  "\001\210\001\001B\017\n\r_securityCodeB\n\n\010_tradeId\"\244\003\n\024Tr"
  "adingSessionStatus\022)\n\nmarketCode\030\001 \001(\0162\020"
  ".data.MarketCodeH\000\210\001\001\022;\n\023tradingSessionS"
  "ubID\030\002 \001(\0162\031.data.TradingSessionSubIDH\001\210"
  "\001\001\0225\n\020tradingSesStatus\030\003 \001(\0162\026.data.Trad"
  "ingSesStatusH\002\210\001\001\022\?\n\025TradingSesControlFl"
  "ag\030\004 \001(\0162\033.data.TradingSesControlTypeH\003\210"
  "\001\001\022\032\n\rstartDateTime\030\005 \001(\003H\004\210\001\001\022\030\n\013endDat"
  "eTime\030\006 \001(\003H\005\210\001\001B\r\n\013_marketCodeB\026\n\024_trad"
  "ingSessionSubIDB\023\n\021_tradingSesStatusB\030\n\026"
  "_TradingSesControlFlagB\020\n\016_startDateTime"
  "B\016\n\014_endDateTime\"\272\002\n\nVCMTrigger\022\031\n\014secur"
  "ityCode\030\001 \001(\003H\000\210\001\001\022 \n\023coolingOffStartTim"
  "e\030\002 \001(\003H\001\210\001\001\022\036\n\021coolingOffEndTime\030\003 \001(\003H"
  "\002\210\001\001\022\036\n\021vCMReferencePrice\030\004 \001(\001H\003\210\001\001\022\032\n\r"
  "vCMLowerPrice\030\005 \001(\001H\004\210\001\001\022\032\n\rvCMUpperPric"
  "e\030\006 \001(\001H\005\210\001\001B\017\n\r_securityCodeB\026\n\024_coolin"
  "gOffStartTimeB\024\n\022_coolingOffEndTimeB\024\n\022_"
  "vCMReferencePriceB\020\n\016_vCMLowerPriceB\020\n\016_"
  "vCMUpperPrice\"Q\n\005Yield\022\031\n\014securityCode\030\001"
  " \001(\003H\000\210\001\001\022\022\n\005yield\030\002 \001(\005H\001\210\001\001B\017\n\r_securi"
  "tyCodeB\010\n\006_yield\"\360\001\n\022CNMarketDefinition\022"
  "+\n\nmarketCode\030\001 \001(\0162\022.data.CnMarketCodeH"
  "\000\210\001\001\022\027\n\nmarketName\030\002 \001(\tH\001\210\001\001\022-\n\014currenc"
  "yCode\030\003 \001(\0162\022.data.CurrencyTypeH\002\210\001\001\022\037\n\022"
  "numberOfSecurities\030\004 \001(\003H\003\210\001\001B\r\n\013_market"
  "CodeB\r\n\013_marketNameB\017\n\r_currencyCodeB\025\n\023"
  "_numberOfSecurities\"\334\004\n\024CNSecurityDefini"
  "tion\022\031\n\014securityCode\030\001 \001(\003H\000\210\001\001\022+\n\nmarke"
  "tCode\030\002 \001(\0162\022.data.CnMarketCodeH\001\210\001\001\022\025\n\010"
  "isinCode\030\003 \001(\tH\002\210\001\001\0221\n\016instrumentType\030\004 "
  "\001(\0162\024.data.InstrumentTypeH\003\210\001\001\022\036\n\021securi"
  "tyShortName\030\005 \001(\tH\004\210\001\001\022-\n\014currencyCode\030\006"
  " \001(\0162\022.data.CurrencyTypeH\005\210\001\001\022\033\n\016securit"
  "yNameGB\030\007 \001(\tH\006\210\001\001\022\024\n\007lotSize\030\010 \001(\003H\007\210\001\001"
  "\022!\n\024previousClosingPrice\030\t \001(\001H\010\210\001\001\0222\n\rs"
  "hortSellFlag\030\n \001(\0162\026.data.IndicatesWheth"
  "erH\t\210\001\001\022\030\n\013listingDate\030\013 \001(\003H\n\210\001\001B\017\n\r_se"
  "curityCodeB\r\n\013_marketCodeB\013\n\t_isinCodeB\021"
  "\n\017_instrumentTypeB\024\n\022_securityShortNameB"
  "\017\n\r_currencyCodeB\021\n\017_securityNameGBB\n\n\010_"
  "lotSizeB\027\n\025_previousClosingPriceB\020\n\016_sho"
  "rtSellFlagB\016\n\014_listingDate\"\315\001\n\020CNSecurit"
  "yStatus\022\031\n\014securityCode\030\001 \001(\003H\000\210\001\001\022\?\n\025se"
  "curityTradingStatus\030\002 \001(\0162\033.data.Securit"
  "yTradingStatusH\001\210\001\001\022\035\n\020tradingPhaseCode\030"
  "\003 \001(\tH\002\210\001\001B\017\n\r_securityCodeB\030\n\026_security"
  "TradingStatusB\023\n\021_tradingPhaseCode\"\246\002\n\014C"
  "NStatistics\022\031\n\014securityCode\030\001 \001(\003H\000\210\001\001\022\031"
  "\n\014sharesTraded\030\002 \001(\003H\001\210\001\001\022\025\n\010turnover\030\003 "
  "\001(\001H\002\210\001\001\022\026\n\thighPrice\030\004 \001(\001H\003\210\001\001\022\025\n\010lowP"
  "rice\030\005 \001(\001H\004\210\001\001\022\026\n\tlastPrice\030\006 \001(\001H\005\210\001\001\022"
  "\031\n\014openingPrice\030\007 \001(\001H\006\210\001\001B\017\n\r_securityC"
  "odeB\017\n\r_sharesTradedB\013\n\t_turnoverB\014\n\n_hi"
  "ghPriceB\013\n\t_lowPriceB\014\n\n_lastPriceB\017\n\r_o"
  "peningPrice\"\367\001\n\tCNTopBook\022\031\n\014securityCod"
  "e\030\001 \001(\003H\000\210\001\001\022!\n\024aggregateBidQuantity\030\002 \001"
  "(\003H\001\210\001\001\022!\n\024aggregateAskQuantity\030\003 \001(\003H\002\210"
  "\001\001\022\025\n\010bidPrice\030\004 \001(\001H\003\210\001\001\022\025\n\010askPrice\030\005 "
  "\001(\001H\004\210\001\001B\017\n\r_securityCodeB\027\n\025_aggregateB"
  "idQuantityB\027\n\025_aggregateAskQuantityB\013\n\t_"
  "bidPriceB\013\n\t_askPrice\"\230\001\n\020CertificationM"
  "sg\022)\n\nactionType\030\001 \001(\0162\020.data.ActionType"
  "H\000\210\001\001\022\021\n\004auth\030\002 \001(\tH\001\210\001\001\022!\n\010response\030\003 \001"
  "(\0132\n.data.RespH\002\210\001\001B\r\n\013_actionTypeB\007\n\005_a"
  "uthB\013\n\t_response\"Z\n\004Resp\022%\n\004type\030\001 \001(\0162\022"
  ".data.ResponseTypeH\000\210\001\001\022\025\n\010errorMsg\030\002 \001("
  "\tH\001\210\001\001B\007\n\005_typeB\013\n\t_errorMsg\"\346.\n\007Message"
  "\022.\n\tdata_type\030\001 \001(\0162\026.data.Message.DataT"
  "ypeH\001\210\001\001\022.\n\016addOddLotOrder\030\002 \001(\0132\024.data."
  "AddOddLotOrderH\000\022B\n\030aggregateOrderBookUp"
  "date\030\003 \001(\0132\036.data.AggregateOrderBookUpda"
  "teH\000\022(\n\013brokerQueue\030\004 \001(\0132\021.data.BrokerQ"
  "ueueH\000\022*\n\014closingPrice\030\005 \001(\0132\022.data.Clos"
  "ingPriceH\000\022*\n\014currencyRate\030\006 \001(\0132\022.data."
  "CurrencyRateH\000\0224\n\021deleteOddLotOrder\030\007 \001("
  "\0132\027.data.DeleteOddLotOrderH\000\022$\n\tindexDat"
  "a\030\010 \001(\0132\017.data.IndexDataH\000\0220\n\017indexDefin"
  "ition\030\t \001(\0132\025.data.IndexDefinitionH\000\022F\n\032"
  "indicativeEquilibriumPrice\030\n \001(\0132 .data."
  "IndicativeEquilibriumPriceH\000\0224\n\021liquidit"
  "yProvider\030\013 \001(\0132\027.data.LiquidityProvider"
  "H\000\0222\n\020marketDefinition\030\014 \001(\0132\026.data.Mark"
  "etDefinitionH\000\022.\n\016marketTurnover\030\r \001(\0132\024"
  ".data.MarketTurnoverH\000\022\032\n\004news\030\016 \001(\0132\n.d"
  "ata.NewsH\000\022*\n\014nominalPrice\030\017 \001(\0132\022.data."
  "NominalPriceH\000\022.\n\016orderImbalance\030\020 \001(\0132\024"
  ".data.OrderImbalanceH\000\022.\n\016referencePrice"
  "\030\021 \001(\0132\024.data.ReferencePriceH\000\0226\n\022securi"
  "tyDefinition\030\022 \001(\0132\030.data.SecurityDefini"
  "tionH\000\022.\n\016securityStatus\030\023 \001(\0132\024.data.Se"
  "curityStatusH\000\022&\n\nstatistics\030\024 \001(\0132\020.dat"
  "a.StatisticsH\000\022L\n\035stockConnectDailyQuota"
  "Balance\030\025 \001(\0132#.data.StockConnectDailyQu"
  "otaBalanceH\000\022F\n\032stockConnectMarketTurnov"
  "er\030\026 \001(\0132 .data.StockConnectMarketTurnov"
  "erH\000\022\034\n\005trade\030\027 \001(\0132\013.data.TradeH\000\022(\n\013tr"
  "adeCancel\030\030 \001(\0132\021.data.TradeCancelH\000\022:\n\024"
  "tradingSessionStatus\030\031 \001(\0132\032.data.Tradin"
  "gSessionStatusH\000\022&\n\nvCMTrigger\030\032 \001(\0132\020.d"
  "ata.VCMTriggerH\000\022\034\n\005yield\030\033 \001(\0132\013.data.Y"
  "ieldH\000\022:\n\024adjustedClosingPrice\030\034 \001(\0132\032.d"
  "ata.AdjustedClosingPriceH\000\0220\n\017dayTradeSu"
  "mmary\030\035 \001(\0132\025.data.DayTradeSummaryH\000\022D\n\031"
  "dayTradeSummaryNextShares\030\036 \001(\0132\037.data.D"
  "ayTradeSummaryNextSharesH\000\022.\n\016iPOInforma"
  "tion\030\037 \001(\0132\024.data.IPOInformationH\000\022>\n\026iP"
  "OQuotingPeriodUpdate\030  \001(\0132\034.data.IPOQuo"
  "tingPeriodUpdateH\000\022B\n\030longAdjustedClosin"
  "gPrice\030! \001(\0132\036.data.LongAdjustedClosingP"
  "riceH\000\0228\n\023longDayTradeSummary\030\" \001(\0132\031.da"
  "ta.LongDayTradeSummaryH\000\022\\\n%longTradeCan"
  "celForNonNextSharesTrades\030# \001(\0132+.data.L"
  "ongTradeCancelForNonNextSharesTradesH\000\022d"
  "\n)longTradeCorrectionForNonNextsharesTra"
  "des\030$ \001(\0132/.data.LongTradeCorrectionForN"
  "onNextsharesTradesH\000\022P\n\037longTradeReportF"
  "orNonNextshares\030% \001(\0132%.data.LongTradeRe"
  "portForNonNextsharesH\000\0224\n\021mWCBStatusMess"
  "age\030& \001(\0132\027.data.MWCBStatusMessageH\000\022B\n\030"
  "marketWideCircuitBreaker\030\' \001(\0132\036.data.Ma"
  "rketWideCircuitBreakerH\000\0220\n\017operationalH"
  "alt\030( \001(\0132\025.data.OperationalHaltH\000\022<\n\025sa"
  "leConditionModifier\030) \001(\0132\033.data.SaleCon"
  "ditionModifierH\000\022Z\n$shortSaleRestriction"
  "IndicatorMessage\030* \001(\0132*.data.ShortSaleR"
  "estrictionIndicatorMessageH\000\022.\n\016stockDir"
  "ectory\030+ \001(\0132\024.data.StockDirectoryH\000\0226\n\022"
  "stockTradingAction\030, \001(\0132\030.data.StockTra"
  "dingActionH\000\0226\n\022systemEventMessage\030- \001(\013"
  "2\030.data.SystemEventMessageH\000\022N\n\036tradeCan"
  "celForNextsharesTrades\030. \001(\0132$.data.Trad"
  "eCancelForNextsharesTradesH\000\022T\n!tradeCan"
  "celForNonNextSharesTrades\030/ \001(\0132\'.data.T"
  "radeCancelForNonNextSharesTradesH\000\022V\n\"tr"
  "adeCorrectionForNextsharesTrades\0300 \001(\0132("
  ".data.TradeCorrectionForNextsharesTrades"
  "H\000\022\\\n%tradeCorrectionForNonNextsharesTra"
  "des\0301 \001(\0132+.data.TradeCorrectionForNonNe"
  "xtsharesTradesH\000\022B\n\030tradeReportForNextsh"
  "ares\0302 \001(\0132\036.data.TradeReportForNextshar"
  "esH\000\022H\n\033tradeReportForNonNextshares\0303 \001("
  "\0132!.data.TradeReportForNonNextsharesH\000\022<"
  "\n\025qBBOMWCBBreachMessage\0304 \001(\0132\033.data.QBB"
  "OMWCBBreachMessageH\000\022H\n\033qBBOMWCBDeclineL"
  "evelMessage\0305 \001(\0132!.data.QBBOMWCBDecline"
  "LevelMessageH\000\022N\n\036qBBONextSharesQuotatio"
  "nMessage\0306 \001(\0132$.data.QBBONextSharesQuot"
  "ationMessageH\000\0228\n\023qBBOOperationalHalt\0307 "
  "\001(\0132\031.data.QBBOOperationalHaltH\000\022:\n\024qBBO"
  "QuotationMessage\0308 \001(\0132\032.data.QBBOQuotat"
  "ionMessageH\000\022<\n\025qBBORegShoRestriction\0309 "
  "\001(\0132\033.data.QBBORegShoRestrictionH\000\0226\n\022qB"
  "BOStockDirectory\030: \001(\0132\030.data.QBBOStockD"
  "irectoryH\000\022>\n\026qBBOStockTradingAction\030; \001"
  "(\0132\034.data.QBBOStockTradingActionH\000\022>\n\026qB"
  "BOSystemEventMessage\030< \001(\0132\034.data.QBBOSy"
  "stemEventMessageH\000\022F\n\032qBBOIPOQuotingPeri"
  "odUpdate\030= \001(\0132 .data.QBBOIPOQuotingPeri"
  "odUpdateH\000\0222\n\020certificationMsg\030> \001(\0132\026.d"
  "ata.CertificationMsgH\000\0226\n\022cNMarketDefini"
  "tion\030\? \001(\0132\030.data.CNMarketDefinitionH\000\022:"
  "\n\024cNSecurityDefinition\030@ \001(\0132\032.data.CNSe"
  "curityDefinitionH\000\0222\n\020cNSecurityStatus\030A"
  " \001(\0132\026.data.CNSecurityStatusH\000\022*\n\014cNStat"
  "istics\030B \001(\0132\022.data.CNStatisticsH\000\022$\n\tcN"
  "TopBook\030C \001(\0132\017.data.CNTopBookH\000\022\026\n\ttime"
  "stamp\030D \001(\003H\002\210\001\001\"\252\017\n\010DataType\022\026\n\022AddOddL"
  "otOrderType\020\000\022 \n\034AggregateOrderBookUpdat"
  "eType\020\001\022\023\n\017BrokerQueueType\020\002\022\024\n\020ClosingP"
  "riceType\020\003\022\024\n\020CurrencyRateType\020\004\022\031\n\025Dele"
  "teOddLotOrderType\020\005\022\021\n\rIndexDataType\020\006\022\027"
  "\n\023IndexDefinitionType\020\007\022\"\n\036IndicativeEqu"
  "ilibriumPriceType\020\010\022\031\n\025LiquidityProvider"
  "Type\020\t\022\030\n\024MarketDefinitionType\020\n\022\026\n\022Mark"
  "etTurnoverType\020\013\022\014\n\010NewsType\020\014\022\024\n\020Nomina"
  "lPriceType\020\r\022\026\n\022OrderImbalanceType\020\016\022\026\n\022"
  "ReferencePriceType\020\017\022\032\n\026SecurityDefiniti"
  "onType\020\020\022\026\n\022SecurityStatusType\020\021\022\022\n\016Stat"
  "isticsType\020\022\022%\n!StockConnectDailyQuotaBa"
  "lanceType\020\023\022\"\n\036StockConnectMarketTurnove"
  "rType\020\024\022\r\n\tTradeType\020\025\022\023\n\017TradeCancelTyp"
  "e\020\026\022\034\n\030TradingSessionStatusType\020\027\022\022\n\016VCM"
  "TriggerType\020\030\022\r\n\tYieldType\020\031\022\034\n\030Adjusted"
  "ClosingPriceType\020\032\022\027\n\023DayTradeSummaryTyp"
  "e\020\033\022!\n\035DayTradeSummaryNextSharesType\020\034\022\026"
  "\n\022IPOInformationType\020\035\022\036\n\032IPOQuotingPeri"
  "odUpdateType\020\036\022 \n\034LongAdjustedClosingPri"
  "ceType\020\037\022\033\n\027LongDayTradeSummaryType\020 \022-\n"
  ")LongTradeCancelForNonNextSharesTradesTy"
  "pe\020!\0221\n-LongTradeCorrectionForNonNextsha"
  "resTradesType\020\"\022\'\n#LongTradeReportForNon"
  "NextsharesType\020#\022\031\n\025MWCBStatusMessageTyp"
  "e\020$\022 \n\034MarketWideCircuitBreakerType\020%\022\027\n"
  "\023OperationalHaltType\020&\022\035\n\031SaleConditionM"
  "odifierType\020\'\022,\n(ShortSaleRestrictionInd"
  "icatorMessageType\020(\022\026\n\022StockDirectoryTyp"
  "e\020)\022\032\n\026StockTradingActionType\020*\022\032\n\026Syste"
  "mEventMessageType\020+\022&\n\"TradeCancelForNex"
  "tsharesTradesType\020,\022)\n%TradeCancelForNon"
  "NextSharesTradesType\020-\022*\n&TradeCorrectio"
  "nForNextsharesTradesType\020.\022-\n)TradeCorre"
  "ctionForNonNextsharesTradesType\020/\022 \n\034Tra"
  "deReportForNextsharesType\0200\022#\n\037TradeRepo"
  "rtForNonNextsharesType\0201\022\035\n\031QBBOMWCBBrea"
  "chMessageType\0202\022#\n\037QBBOMWCBDeclineLevelM"
  "essageType\0203\022&\n\"QBBONextSharesQuotationM"
  "essageType\0204\022\033\n\027QBBOOperationalHaltType\020"
  "5\022\034\n\030QBBOQuotationMessageType\0206\022\035\n\031QBBOR"
  "egShoRestrictionType\0207\022\032\n\026QBBOStockDirec"
  "toryType\0208\022\036\n\032QBBOStockTradingActionType"
  "\0209\022\036\n\032QBBOSystemEventMessageType\020:\022\"\n\036QB"
  "BOIPOQuotingPeriodUpdateType\020;\022\030\n\024Certif"
  "icationMsgType\020<\022\032\n\026CNMarketDefinitionTy"
  "pe\020=\022\034\n\030CNSecurityDefinitionType\020>\022\030\n\024CN"
  "SecurityStatusType\020\?\022\024\n\020CNStatisticsType"
  "\020@\022\021\n\rCNTopBookType\020AB\n\n\010dataBodyB\014\n\n_da"
  "ta_typeB\014\n\n_timestamp*2\n\nActionType\022\t\n\005L"
  "ogin\020\000\022\n\n\006Logout\020\001\022\r\n\tHeartbeat\020\002*(\n\014Res"
  "ponseType\022\013\n\007Success\020\000\022\013\n\007Failure\020\001*a\n\025S"
  "ecurityTradingStatus\022&\n\"SecurityTradingS"
  "tatus_Trading_Halt\020\000\022 \n\034SecurityTradingS"
  "tatus_Resume\020\001*f\n\023SuspensionIndicator\022/\n"
  "+SuspensionIndicator_Trading_Halt_OF_Sus"
  "pend\020\000\022\036\n\032SuspensionIndicator_Resume\020\001*G"
  "\n\014Authenticity\022 \n\034Authenticity_LIVE_PROD"
  "UCTION\020\000\022\025\n\021Authenticity_TEST\020\001*]\n\rBreac"
  "hedLevel\022\030\n\024BreachedLevel_LEVEL1\020\000\022\030\n\024Br"
  "eachedLevel_LEVEL2\020\001\022\030\n\024BreachedLevel_LE"
  "VEL3\020\002*\317\001\n\023CurrentTradingState\022&\n\"Curren"
  "tTradingState_HALT_IN_EFFECT\020\000\022)\n%Curren"
  "tTradingState_PAUSED_ACROSS_ALL\020\001\0223\n/Cur"
  "rentTradingState_QUOTE_ONLY_PERIOD_IN_EF"
  "FECT\020\002\0220\n,CurrentTradingState_TRADING_ON"
  "_NASDAQ_MARKET\020\003*\357\001\n\tEventCode\022$\n EventC"
  "ode_START_OF_TRANSMISSIONS\020\000\022#\n\037EventCod"
  "e_START_OF_SYSTEM_HOURS\020\001\022#\n\037EventCode_S"
  "TART_OF_MARKET_HOURS\020\002\022+\n\'EventCode_END_"
  "OF_THE_REGULAR_US_SESSION\020\003\022!\n\035EventCode"
  "_END_OF_SYSTEM_HOURS\020\004\022\"\n\036EventCode_END_"
  "OF_TRANSMISSIONS\020\005*\242\004\n\030FinancialStatusIn"
  "dicator\022&\n\"FinancialStatusIndicator_DEFI"
  "CIENT\020\000\022\'\n#FinancialStatusIndicator_DELI"
  "NQUENT\020\001\022%\n!FinancialStatusIndicator_BAN"
  "KRUPT\020\002\022&\n\"FinancialStatusIndicator_SUSP"
  "ENDED\020\003\0223\n/FinancialStatusIndicator_DEFI"
  "CIENT_AND_BANKRUPT\020\004\0225\n1FinancialStatusI"
  "ndicator_DEFICIENT_AND_DELINQUENT\020\005\0224\n0F"
  "inancialStatusIndicator_DELINQUENT_AND_B"
  "ANKRUPT\020\006\022>\n:FinancialStatusIndicator_DE"
  "FICIENT_DELINQUENT_AND_BANKRUPT\020\007\022N\nJFin"
  "ancialStatusIndicator_REDEMPTIONS_SUSPEN"
  "DED_FOR_EXCHANGE_TRADED_PRODUCT\020\010\0224\n0Fin"
  "ancialStatusIndicator_ISSUER_IS_NOT_DEFI"
  "CIENT\020\t*\217\001\n\nHaltAction\022<\n8HaltAction_OPE"
  "RATIONALLY_HALTED_ON_THE_IDENTIFIED_MARK"
  "ET\020\000\022C\n\?HaltAction_OPERATIONAL_HALT_HAS_"
  "BEEN_LIFTED_AND_TRADING_RESUMED\020\001*\244\001\n\034IP"
  "OQuotationReleaseQualifier\022C\n\?IPOQuotati"
  "onReleaseQualifier_ANTICIPATED_QUOTATION"
  "_RELEASE_TIME\020\000\022\?\n;IPOQuotationReleaseQu"
  "alifier_IPO_RELEASE_CANCELED_POSTPONED\020\001"
  "*3\n\013IndicatesIf\022\021\n\rIndicatesIf_Y\020\000\022\021\n\rIn"
  "dicatesIf_N\020\001*L\n\010LULDRule\022\'\n#LULDRule_NM"
  "S_STOCKS_AND_SELECT_ETPS\020\000\022\027\n\023LULDRule_N"
  "MS_STOCKS\020\001*\303\003\n\tLevelFour\022\031\n\025LevelFour_A"
  "CQUISITION\020\000\022\025\n\021LevelFour_BUNCHED\020\001\022\032\n\026L"
  "evelFour_DISTRIBUTION\020\002\022)\n%LevelFour_PRI"
  "CE_VARIATION_TRANSACTION\020\003\022)\n%LevelFour_"
  "NASDAQ_OFFICIAL_CLOSE_PRICE\020\004\022#\n\037LevelFo"
  "ur_PRIOR_REFERENCE_PRICE\020\005\022+\n\'LevelFour_"
  "NASDAQ_OFFICIAL_OPENING_PRICE\020\006\022\031\n\025Level"
  "Four_SPLIT_TRADE\020\007\022\036\n\032LevelFour_CONTINGE"
  "NT_TRADE\020\010\022\"\n\036LevelFour_AVERAGE_PRICE_TR"
  "ADE1\020\t\022\031\n\025LevelFour_CROSS_TRADE\020\n\022\037\n\033Lev"
  "elFour_ODD_LOT_EXECUTION\020\013\022%\n!LevelFour_"
  "ODD_LOT_CROSS_EXECUTION\020\014*\200\001\n\010LevelOne\022\024"
  "\n\020LevelOne_REGULAR\020\000\022\034\n\030LevelOne_CASH_SE"
  "TTLEMENT\020\001\022 \n\034LevelOne_NEXT_DAY_SETTLEME"
  "NT\020\002\022\036\n\032LevelOne_SELLER_SETTLEMENT\020\003*\324\001\n"
  "\nLevelThree\022#\n\037LevelThree_EXTENDED_HOURS"
  "_TRADE\020\000\0226\n2LevelThree_SOLD_LAST_REPORTE"
  "D_LATE_BUT_IN_SEQUENCE\020\001\022#\n\037LevelThree_S"
  "OLD_OUT_OF_SEQUENCE\020\002\022D\n@LevelThree_EXTE"
  "NDED_HOURS_TRADE_REPORTED_LATE_OR_OUT_OF"
  "_SEQUENCE\020\003*\312\001\n\010LevelTwo\022\036\n\032LevelTwo_INT"
  "ERMARKET_SWEEP\020\000\022\032\n\026LevelTwo_OPENING_PRI"
  "NT\020\001\022\036\n\032LevelTwo_DERIVATIVE_PRICED\020\002\022\035\n\031"
  "LevelTwo_RE_OPENING_PRINT\020\003\022\032\n\026LevelTwo_"
  "CLOSING_PRINT\020\004\022\'\n#LevelTwo_QUALIFIED_CO"
  "NTINGENT_TRADE\020\005*\370\002\n\016MarketCategory\0220\n,M"
  "arketCategory_NASDAQ_GLOBAL_SELECT_MARKE"
  "TSM\020\000\022)\n%MarketCategory_NASDAQ_GLOBAL_MA"
  "RKETSM\020\001\022F\nBMarketCategory_NASDAQ_CAPITA"
  "L_MARKET_NON_NASDAQ_LISTED_INSTRUMENTS\020\002"
  "\0226\n2MarketCategory_NEW_YORK_STOCK__EXCHA"
  "NGE_A_NYSE_MKT\020\003\022\034\n\030MarketCategory_NYSE_"
  "AMEX\020\004\022\034\n\030MarketCategory_NYSE_ARCA\020\005\022\"\n\036"
  "MarketCategory_BATS_Z_EXCHANGE\020\006\022)\n%Mark"
  "etCategory_INVESTORS_EXCHANGE_LLC\020\007*\201\006\n\013"
  "MessageType\022$\n MessageType_SYSTEM_EVENT_"
  "MESSAGE\020\000\0220\n,MessageType_TRADE_REPORT_FO"
  "R_NON_NEXT_SHARES\020\001\022+\n\'MessageType_TRADE"
  "_REPORT_FOR_NEXTSHARES\020\002\022\"\n\036MessageType_"
  "TRADE_CANCEL_ERROR\020\003\022&\n\"MessageType_TRAD"
  "E_CANCEL_ERROR_NON\020\004\022\036\n\032MessageType_TRAD"
  "ING_ACTION\020\005\022\'\n#MessageType_STOCK_DIRECT"
  "ORY_MESSAGE\020\006\0220\n,MessageType_SHORT_SALE_"
  "RESTRICTION_INDICATOR\020\007\022&\n\"MessageType_A"
  "DJUSTED_CLOSING_PRICE\020\010\022(\n$MessageType_E"
  "ND_OF_DAY_TRADE_SUMMARY\020\t\0223\n/MessageType"
  "_END_OF_DAY_TRADE_SUMMARY_NEXTSHARES\020\n\022\033"
  "\n\027MessageType_IPO_MESSAGE\020\013\022)\n%MessageTy"
  "pe_IPO_QUOTING_PERIOD_UPDATE\020\014\0229\n5Messag"
  "eType_MARKET_WIDE_CIRCUIT_BREAKER_DECLIN"
  "E_LEVEL\020\r\0222\n.MessageType_MARKET_WIDE_CIR"
  "CUIT_BREAKER_STATUS\020\016\022 \n\034MessageType_OPE"
  "RATIONAL_HALT\020\017\022 \n\034MessageType_TRADE_COR"
  "RECTION\020\020\022$\n MessageType_TRADE_CORRECTIO"
  "N_NON\020\021*M\n\tNetChange\022\037\n\033NetChange_FIRST_"
  "TRADE_PRICE\020\000\022\037\n\033NetChange_UNDERWRITER_P"
  "RICE\020\001*\260\001\n\025OperationalHaltAction\022G\nCOper"
  "ationalHaltAction_OPERATIONALLY_HALTED_O"
  "N_THE_IDENTIFIED_MARKET\020\000\022N\nJOperational"
  "HaltAction_OPERATIONAL_HALT_HAS_BEEN_LIF"
  "TED_AND_TRADING_RESUMED\020\001*\352\002\n!Originatin"
  "gMarketCenterIdentifier\022=\n9OriginatingMa"
  "rketCenterIdentifier_THE_NASDAQ_STOCK_MA"
  "RKET\020\000\022Q\nMOriginatingMarketCenterIdentif"
  "ier_FINRA_TRADE_REPORTING_FACILITY_TRF_C"
  "ARTARET\020\001\022P\nLOriginatingMarketCenterIden"
  "tifier_FINRA_TRADE_REPORTING_FACILITY_TR"
  "F_CHICAGO\020\002\022/\n+OriginatingMarketCenterId"
  "entifier_NASDAQ_BX\020\003\0220\n,OriginatingMarke"
  "tCenterIdentifier_NASDAQ_PSX\020\004*\363\003\n\017QBBOM"
  "essageType\022+\n\'QBBOMessageType_STOCK_DIRE"
  "CTORY_MESSAGE\020\000\022\"\n\036QBBOMessageType_TRADI"
  "NG_ACTION\020\001\022F\nBQBBOMessageType_REG_SHO_S"
  "HORT_SALE_PRICE_TEST_RESTRICTED_INDICATO"
  "R\020\002\022=\n9QBBOMessageType_MARKET_WIDE_CIRCU"
  "IT_BREAKER_DECLINE_LEVEL\020\003\022>\n:QBBOMessag"
  "eType_MARKET_WIDE_CIRCUIT_BREAKER_STATUS"
  "_MESSAGE\020\004\022$\n QBBOMessageType_OPERATIONA"
  "L_HALT\020\005\022%\n!QBBOMessageType_QUOTATION_ME"
  "SSAGE\020\006\0220\n,QBBOMessageType_NEXTSHARES_QU"
  "OTATION_MESSAGE\020\007\022\'\n#QBBOMessageType_IPO"
  "_RELEASE_MESSAGE\020\010\022 \n\034QBBOMessageType_SY"
  "STEM_EVENT\020\t*\226\001\n\031QuotationReleaseQualifi"
  "er\022;\n7QuotationReleaseQualifier_ANTICIPA"
  "TED_QUOTATION_RELEASE\020\000\022<\n8QuotationRele"
  "aseQualifier_IPO_RELEASE_CANCELED_POSTPO"
  "NED\020\001*\211\001\n\014RegSHOAction\022\'\n#RegSHOAction_N"
  "O_PRICE_TEST_IN_PLACE\020\000\022 \n\034RegSHOAction_"
  "INTRA_DAY_PRICE\020\001\022.\n*RegSHOAction_RESTRI"
  "CTION_REMAINS_IN_EFFECT\020\002*\274\001\n\rSecurityCl"
  "ass\022\030\n\024SecurityClass_Nasdaq\020\000\022\026\n\022Securit"
  "yClass_NYSE\020\001\022\032\n\026SecurityClass_NYSE_MKT\020"
  "\002\022\033\n\027SecurityClass_NYSE_ARCA\020\003\022\026\n\022Securi"
  "tyClass_BATS\020\004\022(\n$SecurityClass_Investor"
  "s_Exchange_LLC\020\005*a\n\nBQMoreFlag\0225\n1BQMore"
  "Flag_MORE_BROKER_NUMBERS_EXIST_IN_THE_QU"
  "EUE\020\000\022\034\n\030BQMoreFlag_NO_MORE_EXIST\020\001*5\n\nB"
  "rokerSide\022\022\n\016BrokerSide_BUY\020\000\022\023\n\017BrokerS"
  "ide_SELL\020\001*F\n\013CallPutFlag\022\021\n\rCallPutFlag"
  "_C\020\000\022\021\n\rCallPutFlag_P\020\001\022\021\n\rCallPutFlag_O"
  "\020\002*C\n\nCancelFlag\022\030\n\024CancelFlag_Cancelled"
  "\020\000\022\033\n\027CancelFlag_NotCancelled\020\001*\214\n\n\014Curr"
  "encyType\022\026\n\022CurrencyType_BLANK\020\000\022\024\n\020Curr"
  "encyType_HKD\020\001\022\024\n\020CurrencyType_AUD\020\002\022\024\n\020"
  "CurrencyType_ATS\020\003\022\024\n\020CurrencyType_BDT\020\004"
  "\022\024\n\020CurrencyType_BHD\020\005\022\024\n\020CurrencyType_B"
  "EC\020\006\022\024\n\020CurrencyType_BEL\020\007\022\024\n\020CurrencyTy"
  "pe_BND\020\010\022\024\n\020CurrencyType_BUK\020\t\022\024\n\020Curren"
  "cyType_CAD\020\n\022\024\n\020CurrencyType_LKR\020\013\022\024\n\020Cu"
  "rrencyType_CNY\020\014\022\024\n\020CurrencyType_CYP\020\r\022\024"
  "\n\020CurrencyType_DKK\020\016\022\024\n\020CurrencyType_DEM"
  "\020\017\022\024\n\020CurrencyType_NLG\020\020\022\024\n\020CurrencyType"
  "_FJD\020\021\022\024\n\020CurrencyType_FIM\020\022\022\024\n\020Currency"
  "Type_FRF\020\023\022\024\n\020CurrencyType_INR\020\024\022\024\n\020Curr"
  "encyType_IDR\020\025\022\024\n\020CurrencyType_ITL\020\026\022\024\n\020"
  "CurrencyType_JPY\020\027\022\024\n\020CurrencyType_KWD\020\030"
  "\022\024\n\020CurrencyType_KES\020\031\022\024\n\020CurrencyType_L"
  "BP\020\032\022\024\n\020CurrencyType_MUR\020\033\022\024\n\020CurrencyTy"
  "pe_MYR\020\034\022\024\n\020CurrencyType_NZD\020\035\022\024\n\020Curren"
  "cyType_NGN\020\036\022\024\n\020CurrencyType_NOK\020\037\022\024\n\020Cu"
  "rrencyType_OMR\020 \022\024\n\020CurrencyType_PKR\020!\022\024"
  "\n\020CurrencyType_PHP\020\"\022\024\n\020CurrencyType_PTE"
  "\020#\022\024\n\020CurrencyType_QAR\020$\022\024\n\020CurrencyType"
  "_SAR\020%\022\024\n\020CurrencyType_SCR\020&\022\024\n\020Currency"
  "Type_SGD\020\'\022\024\n\020CurrencyType_SLL\020(\022\024\n\020Curr"
  "encyType_ZAR\020)\022\024\n\020CurrencyType_KRW\020*\022\024\n\020"
  "CurrencyType_ESP\020+\022\024\n\020CurrencyType_GBP\020,"
  "\022\024\n\020CurrencyType_SEK\020-\022\024\n\020CurrencyType_C"
  "HF\020.\022\024\n\020CurrencyType_THB\020/\022\024\n\020CurrencyTy"
  "pe_AED\0200\022\024\n\020CurrencyType_USD\0201\022\024\n\020Curren"
  "cyType_IEP\0202\022\024\n\020CurrencyType_SDR\0203\022\024\n\020Cu"
  "rrencyType_MOP\0204\022\024\n\020CurrencyType_BRC\0205\022\024"
  "\n\020CurrencyType_ECU\0206\022\024\n\020CurrencyType_EUR"
  "\0207\022\024\n\020CurrencyType_MXN\0208\022\024\n\020CurrencyType"
  "_CNH\0209*h\n\013IndexSource\022\033\n\027IndexSource_CSI"
  "_AND_CES\020\000\022\023\n\017IndexSource_HSI\020\001\022\023\n\017Index"
  "Source_S_P\020\002\022\022\n\016IndexSource_TR\020\003*\373\001\n\013Ind"
  "exStatus\022*\n&IndexStatus_CLOSING_VALUE_I_"
  "INDICATIVE\020\000\022\035\n\031IndexStatus_OPENING_INDE"
  "X\020\001\022 \n\034IndexStatus_LAST_CLOSE_VALUE\020\002\022!\n"
  "\035IndexStatus_PRELIMINARY_CLOSE\020\003\022\037\n\033Inde"
  "xStatus_STOP_LOSS_INDEX\020\004\022$\n IndexStatus"
  "_REALTIME_INDEX_VALUE\020\005\022\025\n\021IndexStatus_B"
  "LANK\020\006*S\n\rIndicatesType\022\036\n\032IndicatesType"
  "_BROKERNUMBER\020\000\022\"\n\036IndicatesType_NUMBER_"
  "OF_SPREAD\020\001*B\n\020IndicatesWhether\022\026\n\022Indic"
  "atesWhether_Y\020\000\022\026\n\022IndicatesWhether_N\020\001*"
  "t\n\016InstrumentType\022\027\n\023InstrumentType_BOND"
  "\020\000\022\027\n\023InstrumentType_EQTY\020\001\022\027\n\023Instrumen"
  "tType_TRST\020\002\022\027\n\023InstrumentType_WRNT\020\003*X\n"
  "\014InvestorType\022 \n\034InvestorType_Retail_Inv"
  "estor\020\000\022&\n\"InvestorType_Professional_Inv"
  "estor\020\001*G\n\014LastFragment\022\031\n\025LastFragment_"
  "Complete\020\000\022\034\n\030LastFragment_NotComplete\020\001"
  "*!\n\014CnMarketCode\022\007\n\003SSE\020\000\022\010\n\004SZSE\020\001*\234\001\n\n"
  "MarketCode\022\023\n\017MarketCode_MAIN\020\000\022\022\n\016Marke"
  "tCode_GEM\020\001\022\023\n\017MarketCode_NASD\020\002\022\022\n\016Mark"
  "etCode_ETS\020\003\022\025\n\021MarketCode_NASDAQ\020\004\022\021\n\rM"
  "arketCode_BX\020\005\022\022\n\016MarketCode_PSX\020\006*\264\010\n\007M"
  "sgType\022\021\n\rMsgType_Blank\020\000\022\031\n\025MsgType_Seq"
  "uenceReset\020\001\022\021\n\rMsgType_Logon\020\002\022\031\n\025MsgTy"
  "pe_LogonResponse\020\003\022\"\n\036MsgType_DisasterRe"
  "coverySignal\020\004\022!\n\035MsgType_Retransmission"
  "Request\020\005\022\"\n\036MsgType_RetransmissionRespo"
  "nse\020\006\022\033\n\027MsgType_RefreshComplete\020\007\022\034\n\030Ms"
  "gType_MarketDefinition\020\010\022\036\n\032MsgType_Secu"
  "rityDefinition\020\t\022\035\n\031MsgType_LiquidityPro"
  "vider\020\n\022\030\n\024MsgType_CurrencyRate\020\013\022 \n\034Msg"
  "Type_TradingSessionStatus\020\014\022\032\n\026MsgType_S"
  "ecurityStatus\020\r\022\024\n\020MsgType_AddOrder\020\016\022\027\n"
  "\023MsgType_ModifyOrder\020\017\022\027\n\023MsgType_Delete"
  "Order\020\020\022\031\n\025MsgType_AddOddLotOder\020\021\022\035\n\031Ms"
  "gType_DeleteOddLotOrder\020\022\022$\n MsgType_Agg"
  "regateOrderBookUpdate\020\023\022\027\n\023MsgType_Broke"
  "rQueue\020\024\022\032\n\026MsgType_OrderImbalance\020\025\022\021\n\r"
  "MsgType_Trade\020\026\022\027\n\023MsgType_TradeCancel\020\027"
  "\022\027\n\023MsgType_TradeTicker\020\030\022\030\n\024MsgType_Clo"
  "singPrice\020\031\022\030\n\024MsgType_NominalPrice\020\032\022&\n"
  "\"MsgType_IndicativeEquilibriumPrice\020\033\022\032\n"
  "\026MsgType_ReferencePrice\020\034\022\026\n\022MsgType_VCM"
  "Trigger\020\035\022\026\n\022MsgType_Statistics\020\036\022\032\n\026Msg"
  "Type_MarketTurnover\020\037\022\021\n\rMsgType_Yield\020 "
  "\022\020\n\014MsgType_News\020!\022\033\n\027MsgType_IndexDefin"
  "ition\020\"\022\025\n\021MsgType_IndexData\020#\022)\n%MsgTyp"
  "e_StockConnectDailyQuotaBalance\020$\022&\n\"Msg"
  "Type_StockConnectMarketTurnover\020%*J\n\010New"
  "sType\022\032\n\026NewsType_EXCHANGE_NEWS\020\000\022\"\n\036New"
  "sType_CHINESE_EXCHANGE_NEWS\020\001*\260\001\n\027OrderI"
  "mbalanceDirection\022\037\n\033OrderImbalanceDirec"
  "tion_Buy\020\000\022\'\n#OrderImbalanceDirection_BU"
  "Y_SURPLUS\020\001\022(\n$OrderImbalanceDirection_S"
  "ELL_SURPLUS\020\002\022!\n\035OrderImbalanceDirection"
  "_BLANK\020\003*\231\007\n\013ProductType\022&\n\"ProductType_"
  "EQUITY_ORDINARY_SHARES\020\000\022(\n$ProductType_"
  "EQUITY_PREFERENCE_SHARES\020\001\022\035\n\031ProductTyp"
  "e_EQUITY_RIGHTS\020\002\0229\n5ProductType_EQUITY_"
  "DEPOSITORY_RECEIPT_ORDINARY_SHARES\020\003\022;\n7"
  "ProductType_EQUITY_DEPOSITORY_RECEIPT_PR"
  "EFERENCE_SHARES\020\004\022*\n&ProductType_EQUITY_"
  "SPAC_SHARES_WARRANT\020\005\022*\n&ProductType_WAR"
  "RANT_DERIVATIVE_WARRANT\020\006\0223\n/ProductType"
  "_WARRANT_CALLABLE_BULL_BEAR_CONTRACT\020\007\022&"
  "\n\"ProductType_WARRANT_EQUITY_WARRANT\020\010\0220"
  "\n,ProductType_WARRANT_EQUITY_LINKED_INST"
  "RUMENT\020\t\022&\n\"ProductType_WARRANT_INLINE_W"
  "ARRANT\020\n\022*\n&ProductType_WARRANT_SPAC_WAR"
  "RANTS_BOND\020\013\022(\n$ProductType_BOND_DEBT_SE"
  "CURITY_TRUST\020\014\0222\n.ProductType_TRUST_REAL"
  "_ESTATE_INVESTMENT_TRUST\020\r\022\'\n#ProductTyp"
  "e_TRUST_OTHER_UNIT_TRUSTS\020\016\0223\n/ProductTy"
  "pe_TRUST_LEVERAGED_AND_INVERSE_PRODUCT\020\017"
  "\022 \n\034ProductType_TRUST_EQUITY_ETF\020\020\0227\n3Pr"
  "oductType_TRUST_FIXED_INCOME_AND_MONEY_M"
  "ARKET_ETF\020\021\022%\n!ProductType_TRUST_COMMODI"
  "TIES_ETF\020\022\022(\n$ProductType_OTHERS_NONE_OF"
  "_THE_ABOVE\020\023*$\n\004Side\022\014\n\010Side_BID\020\000\022\016\n\nSi"
  "de_OFFER\020\001*\215\001\n\017SpreadTableCode\022\032\n\026Spread"
  "TableCode_Part_A\020\000\022\032\n\026SpreadTableCode_Pa"
  "rt_B\020\001\022&\n\"SpreadTableCode_FOR_INLINE_WAR"
  "RANT\020\002\022\032\n\026SpreadTableCode_PART_D\020\003*;\n\005St"
  "yle\022\030\n\024Style_American_Style\020\000\022\030\n\024Style_E"
  "uropean_Style\020\001*^\n\025TradingSesControlType"
  "\022#\n\037TradingSesControlType_AUTOMATIC\020\000\022 \n"
  "\034TradingSesControlType_MANUAL\020\001*\345\001\n\020Trad"
  "ingSesStatus\022\034\n\030TradingSesStatus_UNKNOWN"
  "\020\000\022\033\n\027TradingSesStatus_HALTED\020\001\022\035\n\031Tradi"
  "ngSesStatus_PRE_OPEN\020\002\022\031\n\025TradingSesStat"
  "us_OPEN\020\003\022\036\n\032TradingSesStatus_PRE_CLOSE\020"
  "\004\022\033\n\027TradingSesStatus_CLOSED\020\005\022\037\n\033Tradin"
  "gSesStatus_DAY_CLOSED\020\006*\237\005\n\023TradingSessi"
  "onSubID\022$\n TradingSessionSubID_NOT_YET_O"
  "PEN\020\000\022#\n\037TradingSessionSubID_ORDER_INPUT"
  "\020\001\022\'\n#TradingSessionSubID_NO_CANCELLATIO"
  "N\020\002\022\'\n#TradingSessionSubID_RANDOM_MATCHI"
  "NG\020\003\022&\n\"TradingSessionSubID_ORDER_MATCHI"
  "NG\020\004\022 \n\034TradingSessionSubID_BLOCKING\020\005\022*"
  "\n&TradingSessionSubID_CONTINUOUS_TRADING"
  "\020\006\0222\n.TradingSessionSubID_CAS_REFERENCE_"
  "PRICE_FIXING\020\007\022\'\n#TradingSessionSubID_CA"
  "S_ORDER_INPUT\020\010\022+\n\'TradingSessionSubID_C"
  "AS_NO_CANCELLATION\020\t\022(\n$TradingSessionSu"
  "bID_CAS_RANDOM_CLOSE\020\n\022*\n&TradingSession"
  "SubID_CAS_ORDER_MATCHING\020\013\022-\n)TradingSes"
  "sionSubID_EXCHANGE_INTERVENTION\020\014\022\035\n\031Tra"
  "dingSessionSubID_CLOSE\020\r\022$\n TradingSessi"
  "onSubID_ORDER_CANCEL\020\016\022!\n\035TradingSession"
  "SubID_DAY_CLOSE\020\017*\210\002\n\007TrdType\022\034\n\030TrdType"
  "_AUTOMATCH_NORMAL\020\000\022\026\n\022TrdType_LATE_TRAD"
  "E\020\001\022*\n&TrdType_NON_DIRECT_OFF__EXCHANGE_"
  "TRADE\020\002\022\"\n\036TrdType_AUTOMATCH_INTERNALIZE"
  "D\020\003\022%\n!TrdType_DIRECT_OFF_EXCHANGE_TRADE"
  "\020\004\022\031\n\025TrdType_ODD_LOT_TRADE\020\005\022\031\n\025TrdType"
  "_AUCTION_TRADE\020\006\022\032\n\026TrdType_OVERSEAS_TRA"
  "DE\020\007*x\n\014UpdateAction\022\024\n\020UpdateAction_NEW"
  "\020\000\022\027\n\023UpdateAction_CHANGE\020\001\022\027\n\023UpdateAct"
  "ion_DELETE\020\002\022 \n\034UpdateAction_ORDERBOOK_C"
  "LEAR\020\003*F\n\013WarrantType\022\021\n\rWarrantType_N\020\000"
  "\022\021\n\rWarrantType_X\020\001\022\021\n\rWarrantType_O\020\002b\006"
  "proto3"
  ;
static ::_pbi::once_flag descriptor_table_data_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_data_2eproto = {
    false, false, 42366, descriptor_table_protodef_data_2eproto,
    "data.proto",
    &descriptor_table_data_2eproto_once, nullptr, 0, 78,
    schemas, file_default_instances, TableStruct_data_2eproto::offsets,
    file_level_metadata_data_2eproto, file_level_enum_descriptors_data_2eproto,
    file_level_service_descriptors_data_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_data_2eproto_getter() {
  return &descriptor_table_data_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_data_2eproto(&descriptor_table_data_2eproto);
namespace data {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Message_DataType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_data_2eproto);
  return file_level_enum_descriptors_data_2eproto[0];
}
bool Message_DataType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
    case 27:
    case 28:
    case 29:
    case 30:
    case 31:
    case 32:
    case 33:
    case 34:
    case 35:
    case 36:
    case 37:
    case 38:
    case 39:
    case 40:
    case 41:
    case 42:
    case 43:
    case 44:
    case 45:
    case 46:
    case 47:
    case 48:
    case 49:
    case 50:
    case 51:
    case 52:
    case 53:
    case 54:
    case 55:
    case 56:
    case 57:
    case 58:
    case 59:
    case 60:
    case 61:
    case 62:
    case 63:
    case 64:
    case 65:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr Message_DataType Message::AddOddLotOrderType;
constexpr Message_DataType Message::AggregateOrderBookUpdateType;
constexpr Message_DataType Message::BrokerQueueType;
constexpr Message_DataType Message::ClosingPriceType;
constexpr Message_DataType Message::CurrencyRateType;
constexpr Message_DataType Message::DeleteOddLotOrderType;
constexpr Message_DataType Message::IndexDataType;
constexpr Message_DataType Message::IndexDefinitionType;
constexpr Message_DataType Message::IndicativeEquilibriumPriceType;
constexpr Message_DataType Message::LiquidityProviderType;
constexpr Message_DataType Message::MarketDefinitionType;
constexpr Message_DataType Message::MarketTurnoverType;
constexpr Message_DataType Message::NewsType;
constexpr Message_DataType Message::NominalPriceType;
constexpr Message_DataType Message::OrderImbalanceType;
constexpr Message_DataType Message::ReferencePriceType;
constexpr Message_DataType Message::SecurityDefinitionType;
constexpr Message_DataType Message::SecurityStatusType;
constexpr Message_DataType Message::StatisticsType;
constexpr Message_DataType Message::StockConnectDailyQuotaBalanceType;
constexpr Message_DataType Message::StockConnectMarketTurnoverType;
constexpr Message_DataType Message::TradeType;
constexpr Message_DataType Message::TradeCancelType;
constexpr Message_DataType Message::TradingSessionStatusType;
constexpr Message_DataType Message::VCMTriggerType;
constexpr Message_DataType Message::YieldType;
constexpr Message_DataType Message::AdjustedClosingPriceType;
constexpr Message_DataType Message::DayTradeSummaryType;
constexpr Message_DataType Message::DayTradeSummaryNextSharesType;
constexpr Message_DataType Message::IPOInformationType;
constexpr Message_DataType Message::IPOQuotingPeriodUpdateType;
constexpr Message_DataType Message::LongAdjustedClosingPriceType;
constexpr Message_DataType Message::LongDayTradeSummaryType;
constexpr Message_DataType Message::LongTradeCancelForNonNextSharesTradesType;
constexpr Message_DataType Message::LongTradeCorrectionForNonNextsharesTradesType;
constexpr Message_DataType Message::LongTradeReportForNonNextsharesType;
constexpr Message_DataType Message::MWCBStatusMessageType;
constexpr Message_DataType Message::MarketWideCircuitBreakerType;
constexpr Message_DataType Message::OperationalHaltType;
constexpr Message_DataType Message::SaleConditionModifierType;
constexpr Message_DataType Message::ShortSaleRestrictionIndicatorMessageType;
constexpr Message_DataType Message::StockDirectoryType;
constexpr Message_DataType Message::StockTradingActionType;
constexpr Message_DataType Message::SystemEventMessageType;
constexpr Message_DataType Message::TradeCancelForNextsharesTradesType;
constexpr Message_DataType Message::TradeCancelForNonNextSharesTradesType;
constexpr Message_DataType Message::TradeCorrectionForNextsharesTradesType;
constexpr Message_DataType Message::TradeCorrectionForNonNextsharesTradesType;
constexpr Message_DataType Message::TradeReportForNextsharesType;
constexpr Message_DataType Message::TradeReportForNonNextsharesType;
constexpr Message_DataType Message::QBBOMWCBBreachMessageType;
constexpr Message_DataType Message::QBBOMWCBDeclineLevelMessageType;
constexpr Message_DataType Message::QBBONextSharesQuotationMessageType;
constexpr Message_DataType Message::QBBOOperationalHaltType;
constexpr Message_DataType Message::QBBOQuotationMessageType;
constexpr Message_DataType Message::QBBORegShoRestrictionType;
constexpr Message_DataType Message::QBBOStockDirectoryType;
constexpr Message_DataType Message::QBBOStockTradingActionType;
constexpr Message_DataType Message::QBBOSystemEventMessageType;
constexpr Message_DataType Message::QBBOIPOQuotingPeriodUpdateType;
constexpr Message_DataType Message::CertificationMsgType;
constexpr Message_DataType Message::CNMarketDefinitionType;
constexpr Message_DataType Message::CNSecurityDefinitionType;
constexpr Message_DataType Message::CNSecurityStatusType;
constexpr Message_DataType Message::CNStatisticsType;
constexpr Message_DataType Message::CNTopBookType;
constexpr Message_DataType Message::DataType_MIN;
constexpr Message_DataType Message::DataType_MAX;
constexpr int Message::DataType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ActionType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_data_2eproto);
  return file_level_enum_descriptors_data_2eproto[1];
}
bool ActionType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ResponseType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_data_2eproto);
  return file_level_enum_descriptors_data_2eproto[2];
}
bool ResponseType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SecurityTradingStatus_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_data_2eproto);
  return file_level_enum_descriptors_data_2eproto[3];
}
bool SecurityTradingStatus_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SuspensionIndicator_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_data_2eproto);
  return file_level_enum_descriptors_data_2eproto[4];
}
bool SuspensionIndicator_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Authenticity_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_data_2eproto);
  return file_level_enum_descriptors_data_2eproto[5];
}
bool Authenticity_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* BreachedLevel_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_data_2eproto);
  return file_level_enum_descriptors_data_2eproto[6];
}
bool BreachedLevel_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CurrentTradingState_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_data_2eproto);
  return file_level_enum_descriptors_data_2eproto[7];
}
bool CurrentTradingState_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EventCode_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_data_2eproto);
  return file_level_enum_descriptors_data_2eproto[8];
}
bool EventCode_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* FinancialStatusIndicator_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_data_2eproto);
  return file_level_enum_descriptors_data_2eproto[9];
}
bool FinancialStatusIndicator_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* HaltAction_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_data_2eproto);
  return file_level_enum_descriptors_data_2eproto[10];
}
bool HaltAction_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* IPOQuotationReleaseQualifier_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_data_2eproto);
  return file_level_enum_descriptors_data_2eproto[11];
}
bool IPOQuotationReleaseQualifier_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* IndicatesIf_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_data_2eproto);
  return file_level_enum_descriptors_data_2eproto[12];
}
bool IndicatesIf_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* LULDRule_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_data_2eproto);
  return file_level_enum_descriptors_data_2eproto[13];
}
bool LULDRule_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* LevelFour_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_data_2eproto);
  return file_level_enum_descriptors_data_2eproto[14];
}
bool LevelFour_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* LevelOne_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_data_2eproto);
  return file_level_enum_descriptors_data_2eproto[15];
}
bool LevelOne_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* LevelThree_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_data_2eproto);
  return file_level_enum_descriptors_data_2eproto[16];
}
bool LevelThree_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* LevelTwo_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_data_2eproto);
  return file_level_enum_descriptors_data_2eproto[17];
}
bool LevelTwo_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MarketCategory_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_data_2eproto);
  return file_level_enum_descriptors_data_2eproto[18];
}
bool MarketCategory_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MessageType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_data_2eproto);
  return file_level_enum_descriptors_data_2eproto[19];
}
bool MessageType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* NetChange_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_data_2eproto);
  return file_level_enum_descriptors_data_2eproto[20];
}
bool NetChange_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* OperationalHaltAction_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_data_2eproto);
  return file_level_enum_descriptors_data_2eproto[21];
}
bool OperationalHaltAction_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* OriginatingMarketCenterIdentifier_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_data_2eproto);
  return file_level_enum_descriptors_data_2eproto[22];
}
bool OriginatingMarketCenterIdentifier_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* QBBOMessageType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_data_2eproto);
  return file_level_enum_descriptors_data_2eproto[23];
}
bool QBBOMessageType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* QuotationReleaseQualifier_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_data_2eproto);
  return file_level_enum_descriptors_data_2eproto[24];
}
bool QuotationReleaseQualifier_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RegSHOAction_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_data_2eproto);
  return file_level_enum_descriptors_data_2eproto[25];
}
bool RegSHOAction_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SecurityClass_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_data_2eproto);
  return file_level_enum_descriptors_data_2eproto[26];
}
bool SecurityClass_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* BQMoreFlag_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_data_2eproto);
  return file_level_enum_descriptors_data_2eproto[27];
}
bool BQMoreFlag_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* BrokerSide_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_data_2eproto);
  return file_level_enum_descriptors_data_2eproto[28];
}
bool BrokerSide_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CallPutFlag_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_data_2eproto);
  return file_level_enum_descriptors_data_2eproto[29];
}
bool CallPutFlag_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CancelFlag_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_data_2eproto);
  return file_level_enum_descriptors_data_2eproto[30];
}
bool CancelFlag_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CurrencyType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_data_2eproto);
  return file_level_enum_descriptors_data_2eproto[31];
}
bool CurrencyType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
    case 27:
    case 28:
    case 29:
    case 30:
    case 31:
    case 32:
    case 33:
    case 34:
    case 35:
    case 36:
    case 37:
    case 38:
    case 39:
    case 40:
    case 41:
    case 42:
    case 43:
    case 44:
    case 45:
    case 46:
    case 47:
    case 48:
    case 49:
    case 50:
    case 51:
    case 52:
    case 53:
    case 54:
    case 55:
    case 56:
    case 57:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* IndexSource_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_data_2eproto);
  return file_level_enum_descriptors_data_2eproto[32];
}
bool IndexSource_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* IndexStatus_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_data_2eproto);
  return file_level_enum_descriptors_data_2eproto[33];
}
bool IndexStatus_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* IndicatesType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_data_2eproto);
  return file_level_enum_descriptors_data_2eproto[34];
}
bool IndicatesType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* IndicatesWhether_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_data_2eproto);
  return file_level_enum_descriptors_data_2eproto[35];
}
bool IndicatesWhether_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* InstrumentType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_data_2eproto);
  return file_level_enum_descriptors_data_2eproto[36];
}
bool InstrumentType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* InvestorType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_data_2eproto);
  return file_level_enum_descriptors_data_2eproto[37];
}
bool InvestorType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* LastFragment_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_data_2eproto);
  return file_level_enum_descriptors_data_2eproto[38];
}
bool LastFragment_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CnMarketCode_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_data_2eproto);
  return file_level_enum_descriptors_data_2eproto[39];
}
bool CnMarketCode_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MarketCode_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_data_2eproto);
  return file_level_enum_descriptors_data_2eproto[40];
}
bool MarketCode_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MsgType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_data_2eproto);
  return file_level_enum_descriptors_data_2eproto[41];
}
bool MsgType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
    case 27:
    case 28:
    case 29:
    case 30:
    case 31:
    case 32:
    case 33:
    case 34:
    case 35:
    case 36:
    case 37:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* NewsType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_data_2eproto);
  return file_level_enum_descriptors_data_2eproto[42];
}
bool NewsType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* OrderImbalanceDirection_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_data_2eproto);
  return file_level_enum_descriptors_data_2eproto[43];
}
bool OrderImbalanceDirection_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ProductType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_data_2eproto);
  return file_level_enum_descriptors_data_2eproto[44];
}
bool ProductType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Side_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_data_2eproto);
  return file_level_enum_descriptors_data_2eproto[45];
}
bool Side_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SpreadTableCode_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_data_2eproto);
  return file_level_enum_descriptors_data_2eproto[46];
}
bool SpreadTableCode_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Style_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_data_2eproto);
  return file_level_enum_descriptors_data_2eproto[47];
}
bool Style_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TradingSesControlType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_data_2eproto);
  return file_level_enum_descriptors_data_2eproto[48];
}
bool TradingSesControlType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TradingSesStatus_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_data_2eproto);
  return file_level_enum_descriptors_data_2eproto[49];
}
bool TradingSesStatus_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TradingSessionSubID_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_data_2eproto);
  return file_level_enum_descriptors_data_2eproto[50];
}
bool TradingSessionSubID_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TrdType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_data_2eproto);
  return file_level_enum_descriptors_data_2eproto[51];
}
bool TrdType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* UpdateAction_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_data_2eproto);
  return file_level_enum_descriptors_data_2eproto[52];
}
bool UpdateAction_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* WarrantType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_data_2eproto);
  return file_level_enum_descriptors_data_2eproto[53];
}
bool WarrantType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}


// ===================================================================

class AdjustedClosingPrice::_Internal {
 public:
  using HasBits = decltype(std::declval<AdjustedClosingPrice>()._impl_._has_bits_);
  static void set_has_issuesymbol(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_securityclass(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_adjustedclosingprice(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

AdjustedClosingPrice::AdjustedClosingPrice(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:data.AdjustedClosingPrice)
}
AdjustedClosingPrice::AdjustedClosingPrice(const AdjustedClosingPrice& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  AdjustedClosingPrice* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.issuesymbol_){}
    , decltype(_impl_.adjustedclosingprice_){}
    , decltype(_impl_.securityclass_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.issuesymbol_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.issuesymbol_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_issuesymbol()) {
    _this->_impl_.issuesymbol_.Set(from._internal_issuesymbol(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.adjustedclosingprice_, &from._impl_.adjustedclosingprice_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.securityclass_) -
    reinterpret_cast<char*>(&_impl_.adjustedclosingprice_)) + sizeof(_impl_.securityclass_));
  // @@protoc_insertion_point(copy_constructor:data.AdjustedClosingPrice)
}

inline void AdjustedClosingPrice::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.issuesymbol_){}
    , decltype(_impl_.adjustedclosingprice_){0}
    , decltype(_impl_.securityclass_){0}
  };
  _impl_.issuesymbol_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.issuesymbol_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

AdjustedClosingPrice::~AdjustedClosingPrice() {
  // @@protoc_insertion_point(destructor:data.AdjustedClosingPrice)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AdjustedClosingPrice::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.issuesymbol_.Destroy();
}

void AdjustedClosingPrice::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AdjustedClosingPrice::Clear() {
// @@protoc_insertion_point(message_clear_start:data.AdjustedClosingPrice)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.issuesymbol_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&_impl_.adjustedclosingprice_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.securityclass_) -
        reinterpret_cast<char*>(&_impl_.adjustedclosingprice_)) + sizeof(_impl_.securityclass_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AdjustedClosingPrice::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string issueSymbol = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_issuesymbol();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "data.AdjustedClosingPrice.issueSymbol"));
        } else
          goto handle_unusual;
        continue;
      // optional .data.SecurityClass securityClass = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_securityclass(static_cast<::data::SecurityClass>(val));
        } else
          goto handle_unusual;
        continue;
      // optional double adjustedClosingPrice = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          _Internal::set_has_adjustedclosingprice(&has_bits);
          _impl_.adjustedclosingprice_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AdjustedClosingPrice::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:data.AdjustedClosingPrice)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional string issueSymbol = 1;
  if (_internal_has_issuesymbol()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_issuesymbol().data(), static_cast<int>(this->_internal_issuesymbol().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "data.AdjustedClosingPrice.issueSymbol");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_issuesymbol(), target);
  }

  // optional .data.SecurityClass securityClass = 2;
  if (_internal_has_securityclass()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_securityclass(), target);
  }

  // optional double adjustedClosingPrice = 3;
  if (_internal_has_adjustedclosingprice()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(3, this->_internal_adjustedclosingprice(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:data.AdjustedClosingPrice)
  return target;
}

size_t AdjustedClosingPrice::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:data.AdjustedClosingPrice)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string issueSymbol = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_issuesymbol());
    }

    // optional double adjustedClosingPrice = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 8;
    }

    // optional .data.SecurityClass securityClass = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_securityclass());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AdjustedClosingPrice::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    AdjustedClosingPrice::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AdjustedClosingPrice::GetClassData() const { return &_class_data_; }


void AdjustedClosingPrice::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<AdjustedClosingPrice*>(&to_msg);
  auto& from = static_cast<const AdjustedClosingPrice&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:data.AdjustedClosingPrice)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_issuesymbol(from._internal_issuesymbol());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.adjustedclosingprice_ = from._impl_.adjustedclosingprice_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.securityclass_ = from._impl_.securityclass_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AdjustedClosingPrice::CopyFrom(const AdjustedClosingPrice& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:data.AdjustedClosingPrice)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AdjustedClosingPrice::IsInitialized() const {
  return true;
}

void AdjustedClosingPrice::InternalSwap(AdjustedClosingPrice* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.issuesymbol_, lhs_arena,
      &other->_impl_.issuesymbol_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AdjustedClosingPrice, _impl_.securityclass_)
      + sizeof(AdjustedClosingPrice::_impl_.securityclass_)
      - PROTOBUF_FIELD_OFFSET(AdjustedClosingPrice, _impl_.adjustedclosingprice_)>(
          reinterpret_cast<char*>(&_impl_.adjustedclosingprice_),
          reinterpret_cast<char*>(&other->_impl_.adjustedclosingprice_));
}

::PROTOBUF_NAMESPACE_ID::Metadata AdjustedClosingPrice::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_data_2eproto_getter, &descriptor_table_data_2eproto_once,
      file_level_metadata_data_2eproto[0]);
}

// ===================================================================

class DayTradeSummary::_Internal {
 public:
  using HasBits = decltype(std::declval<DayTradeSummary>()._impl_._has_bits_);
  static void set_has_issuesymbol(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_marketcategory(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_nasdaqhighprice(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_nasdaqlowprice(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_nasdaqclosingprice(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_consolidatedvolume(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

DayTradeSummary::DayTradeSummary(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:data.DayTradeSummary)
}
DayTradeSummary::DayTradeSummary(const DayTradeSummary& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  DayTradeSummary* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.issuesymbol_){}
    , decltype(_impl_.nasdaqhighprice_){}
    , decltype(_impl_.nasdaqlowprice_){}
    , decltype(_impl_.nasdaqclosingprice_){}
    , decltype(_impl_.consolidatedvolume_){}
    , decltype(_impl_.marketcategory_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.issuesymbol_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.issuesymbol_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_issuesymbol()) {
    _this->_impl_.issuesymbol_.Set(from._internal_issuesymbol(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.nasdaqhighprice_, &from._impl_.nasdaqhighprice_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.marketcategory_) -
    reinterpret_cast<char*>(&_impl_.nasdaqhighprice_)) + sizeof(_impl_.marketcategory_));
  // @@protoc_insertion_point(copy_constructor:data.DayTradeSummary)
}

inline void DayTradeSummary::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.issuesymbol_){}
    , decltype(_impl_.nasdaqhighprice_){0}
    , decltype(_impl_.nasdaqlowprice_){0}
    , decltype(_impl_.nasdaqclosingprice_){0}
    , decltype(_impl_.consolidatedvolume_){int64_t{0}}
    , decltype(_impl_.marketcategory_){0}
  };
  _impl_.issuesymbol_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.issuesymbol_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

DayTradeSummary::~DayTradeSummary() {
  // @@protoc_insertion_point(destructor:data.DayTradeSummary)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DayTradeSummary::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.issuesymbol_.Destroy();
}

void DayTradeSummary::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DayTradeSummary::Clear() {
// @@protoc_insertion_point(message_clear_start:data.DayTradeSummary)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.issuesymbol_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000003eu) {
    ::memset(&_impl_.nasdaqhighprice_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.marketcategory_) -
        reinterpret_cast<char*>(&_impl_.nasdaqhighprice_)) + sizeof(_impl_.marketcategory_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DayTradeSummary::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string issueSymbol = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_issuesymbol();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "data.DayTradeSummary.issueSymbol"));
        } else
          goto handle_unusual;
        continue;
      // optional .data.MarketCategory marketCategory = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_marketcategory(static_cast<::data::MarketCategory>(val));
        } else
          goto handle_unusual;
        continue;
      // optional double nasdaqHighPrice = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          _Internal::set_has_nasdaqhighprice(&has_bits);
          _impl_.nasdaqhighprice_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double nasdaqLowPrice = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 33)) {
          _Internal::set_has_nasdaqlowprice(&has_bits);
          _impl_.nasdaqlowprice_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double nasdaqClosingPrice = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 41)) {
          _Internal::set_has_nasdaqclosingprice(&has_bits);
          _impl_.nasdaqclosingprice_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional int64 consolidatedVolume = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_consolidatedvolume(&has_bits);
          _impl_.consolidatedvolume_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DayTradeSummary::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:data.DayTradeSummary)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional string issueSymbol = 1;
  if (_internal_has_issuesymbol()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_issuesymbol().data(), static_cast<int>(this->_internal_issuesymbol().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "data.DayTradeSummary.issueSymbol");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_issuesymbol(), target);
  }

  // optional .data.MarketCategory marketCategory = 2;
  if (_internal_has_marketcategory()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_marketcategory(), target);
  }

  // optional double nasdaqHighPrice = 3;
  if (_internal_has_nasdaqhighprice()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(3, this->_internal_nasdaqhighprice(), target);
  }

  // optional double nasdaqLowPrice = 4;
  if (_internal_has_nasdaqlowprice()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(4, this->_internal_nasdaqlowprice(), target);
  }

  // optional double nasdaqClosingPrice = 5;
  if (_internal_has_nasdaqclosingprice()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(5, this->_internal_nasdaqclosingprice(), target);
  }

  // optional int64 consolidatedVolume = 6;
  if (_internal_has_consolidatedvolume()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(6, this->_internal_consolidatedvolume(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:data.DayTradeSummary)
  return target;
}

size_t DayTradeSummary::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:data.DayTradeSummary)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional string issueSymbol = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_issuesymbol());
    }

    // optional double nasdaqHighPrice = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 8;
    }

    // optional double nasdaqLowPrice = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 8;
    }

    // optional double nasdaqClosingPrice = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 8;
    }

    // optional int64 consolidatedVolume = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_consolidatedvolume());
    }

    // optional .data.MarketCategory marketCategory = 2;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_marketcategory());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DayTradeSummary::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    DayTradeSummary::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DayTradeSummary::GetClassData() const { return &_class_data_; }


void DayTradeSummary::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<DayTradeSummary*>(&to_msg);
  auto& from = static_cast<const DayTradeSummary&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:data.DayTradeSummary)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_issuesymbol(from._internal_issuesymbol());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.nasdaqhighprice_ = from._impl_.nasdaqhighprice_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.nasdaqlowprice_ = from._impl_.nasdaqlowprice_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.nasdaqclosingprice_ = from._impl_.nasdaqclosingprice_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.consolidatedvolume_ = from._impl_.consolidatedvolume_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.marketcategory_ = from._impl_.marketcategory_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DayTradeSummary::CopyFrom(const DayTradeSummary& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:data.DayTradeSummary)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DayTradeSummary::IsInitialized() const {
  return true;
}

void DayTradeSummary::InternalSwap(DayTradeSummary* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.issuesymbol_, lhs_arena,
      &other->_impl_.issuesymbol_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(DayTradeSummary, _impl_.marketcategory_)
      + sizeof(DayTradeSummary::_impl_.marketcategory_)
      - PROTOBUF_FIELD_OFFSET(DayTradeSummary, _impl_.nasdaqhighprice_)>(
          reinterpret_cast<char*>(&_impl_.nasdaqhighprice_),
          reinterpret_cast<char*>(&other->_impl_.nasdaqhighprice_));
}

::PROTOBUF_NAMESPACE_ID::Metadata DayTradeSummary::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_data_2eproto_getter, &descriptor_table_data_2eproto_once,
      file_level_metadata_data_2eproto[1]);
}

// ===================================================================

class DayTradeSummaryNextShares::_Internal {
 public:
  using HasBits = decltype(std::declval<DayTradeSummaryNextShares>()._impl_._has_bits_);
  static void set_has_issuesymbol(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_marketcategory(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_nasdaqhighprice(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_navoffsetamounthigh(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_nasdaqlowprice(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_navoffsetamountlow(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_nasdaqclosingprice(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_navoffsetamountclose(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_consolidatedvolume(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
};

DayTradeSummaryNextShares::DayTradeSummaryNextShares(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:data.DayTradeSummaryNextShares)
}
DayTradeSummaryNextShares::DayTradeSummaryNextShares(const DayTradeSummaryNextShares& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  DayTradeSummaryNextShares* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.issuesymbol_){}
    , decltype(_impl_.nasdaqhighprice_){}
    , decltype(_impl_.navoffsetamounthigh_){}
    , decltype(_impl_.nasdaqlowprice_){}
    , decltype(_impl_.navoffsetamountlow_){}
    , decltype(_impl_.nasdaqclosingprice_){}
    , decltype(_impl_.navoffsetamountclose_){}
    , decltype(_impl_.consolidatedvolume_){}
    , decltype(_impl_.marketcategory_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.issuesymbol_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.issuesymbol_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_issuesymbol()) {
    _this->_impl_.issuesymbol_.Set(from._internal_issuesymbol(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.nasdaqhighprice_, &from._impl_.nasdaqhighprice_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.marketcategory_) -
    reinterpret_cast<char*>(&_impl_.nasdaqhighprice_)) + sizeof(_impl_.marketcategory_));
  // @@protoc_insertion_point(copy_constructor:data.DayTradeSummaryNextShares)
}

inline void DayTradeSummaryNextShares::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.issuesymbol_){}
    , decltype(_impl_.nasdaqhighprice_){0}
    , decltype(_impl_.navoffsetamounthigh_){0}
    , decltype(_impl_.nasdaqlowprice_){0}
    , decltype(_impl_.navoffsetamountlow_){0}
    , decltype(_impl_.nasdaqclosingprice_){0}
    , decltype(_impl_.navoffsetamountclose_){0}
    , decltype(_impl_.consolidatedvolume_){int64_t{0}}
    , decltype(_impl_.marketcategory_){0}
  };
  _impl_.issuesymbol_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.issuesymbol_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

DayTradeSummaryNextShares::~DayTradeSummaryNextShares() {
  // @@protoc_insertion_point(destructor:data.DayTradeSummaryNextShares)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DayTradeSummaryNextShares::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.issuesymbol_.Destroy();
}

void DayTradeSummaryNextShares::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DayTradeSummaryNextShares::Clear() {
// @@protoc_insertion_point(message_clear_start:data.DayTradeSummaryNextShares)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.issuesymbol_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x000000feu) {
    ::memset(&_impl_.nasdaqhighprice_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.consolidatedvolume_) -
        reinterpret_cast<char*>(&_impl_.nasdaqhighprice_)) + sizeof(_impl_.consolidatedvolume_));
  }
  _impl_.marketcategory_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DayTradeSummaryNextShares::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string issueSymbol = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_issuesymbol();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "data.DayTradeSummaryNextShares.issueSymbol"));
        } else
          goto handle_unusual;
        continue;
      // optional .data.MarketCategory marketCategory = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_marketcategory(static_cast<::data::MarketCategory>(val));
        } else
          goto handle_unusual;
        continue;
      // optional double nasdaqHighPrice = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          _Internal::set_has_nasdaqhighprice(&has_bits);
          _impl_.nasdaqhighprice_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double NAVOffsetAmountHigh = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 33)) {
          _Internal::set_has_navoffsetamounthigh(&has_bits);
          _impl_.navoffsetamounthigh_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double nasdaqLowPrice = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 41)) {
          _Internal::set_has_nasdaqlowprice(&has_bits);
          _impl_.nasdaqlowprice_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double NAVOffsetAmountLow = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 49)) {
          _Internal::set_has_navoffsetamountlow(&has_bits);
          _impl_.navoffsetamountlow_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double nasdaqClosingPrice = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 57)) {
          _Internal::set_has_nasdaqclosingprice(&has_bits);
          _impl_.nasdaqclosingprice_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double NAVOffsetAmountClose = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 65)) {
          _Internal::set_has_navoffsetamountclose(&has_bits);
          _impl_.navoffsetamountclose_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional int64 consolidatedVolume = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_consolidatedvolume(&has_bits);
          _impl_.consolidatedvolume_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DayTradeSummaryNextShares::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:data.DayTradeSummaryNextShares)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional string issueSymbol = 1;
  if (_internal_has_issuesymbol()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_issuesymbol().data(), static_cast<int>(this->_internal_issuesymbol().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "data.DayTradeSummaryNextShares.issueSymbol");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_issuesymbol(), target);
  }

  // optional .data.MarketCategory marketCategory = 2;
  if (_internal_has_marketcategory()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_marketcategory(), target);
  }

  // optional double nasdaqHighPrice = 3;
  if (_internal_has_nasdaqhighprice()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(3, this->_internal_nasdaqhighprice(), target);
  }

  // optional double NAVOffsetAmountHigh = 4;
  if (_internal_has_navoffsetamounthigh()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(4, this->_internal_navoffsetamounthigh(), target);
  }

  // optional double nasdaqLowPrice = 5;
  if (_internal_has_nasdaqlowprice()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(5, this->_internal_nasdaqlowprice(), target);
  }

  // optional double NAVOffsetAmountLow = 6;
  if (_internal_has_navoffsetamountlow()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(6, this->_internal_navoffsetamountlow(), target);
  }

  // optional double nasdaqClosingPrice = 7;
  if (_internal_has_nasdaqclosingprice()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(7, this->_internal_nasdaqclosingprice(), target);
  }

  // optional double NAVOffsetAmountClose = 8;
  if (_internal_has_navoffsetamountclose()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(8, this->_internal_navoffsetamountclose(), target);
  }

  // optional int64 consolidatedVolume = 9;
  if (_internal_has_consolidatedvolume()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(9, this->_internal_consolidatedvolume(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:data.DayTradeSummaryNextShares)
  return target;
}

size_t DayTradeSummaryNextShares::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:data.DayTradeSummaryNextShares)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string issueSymbol = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_issuesymbol());
    }

    // optional double nasdaqHighPrice = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 8;
    }

    // optional double NAVOffsetAmountHigh = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 8;
    }

    // optional double nasdaqLowPrice = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 8;
    }

    // optional double NAVOffsetAmountLow = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 8;
    }

    // optional double nasdaqClosingPrice = 7;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 8;
    }

    // optional double NAVOffsetAmountClose = 8;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 8;
    }

    // optional int64 consolidatedVolume = 9;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_consolidatedvolume());
    }

  }
  // optional .data.MarketCategory marketCategory = 2;
  if (cached_has_bits & 0x00000100u) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_marketcategory());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DayTradeSummaryNextShares::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    DayTradeSummaryNextShares::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DayTradeSummaryNextShares::GetClassData() const { return &_class_data_; }


void DayTradeSummaryNextShares::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<DayTradeSummaryNextShares*>(&to_msg);
  auto& from = static_cast<const DayTradeSummaryNextShares&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:data.DayTradeSummaryNextShares)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_issuesymbol(from._internal_issuesymbol());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.nasdaqhighprice_ = from._impl_.nasdaqhighprice_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.navoffsetamounthigh_ = from._impl_.navoffsetamounthigh_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.nasdaqlowprice_ = from._impl_.nasdaqlowprice_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.navoffsetamountlow_ = from._impl_.navoffsetamountlow_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.nasdaqclosingprice_ = from._impl_.nasdaqclosingprice_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.navoffsetamountclose_ = from._impl_.navoffsetamountclose_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.consolidatedvolume_ = from._impl_.consolidatedvolume_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000100u) {
    _this->_internal_set_marketcategory(from._internal_marketcategory());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DayTradeSummaryNextShares::CopyFrom(const DayTradeSummaryNextShares& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:data.DayTradeSummaryNextShares)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DayTradeSummaryNextShares::IsInitialized() const {
  return true;
}

void DayTradeSummaryNextShares::InternalSwap(DayTradeSummaryNextShares* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.issuesymbol_, lhs_arena,
      &other->_impl_.issuesymbol_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(DayTradeSummaryNextShares, _impl_.marketcategory_)
      + sizeof(DayTradeSummaryNextShares::_impl_.marketcategory_)
      - PROTOBUF_FIELD_OFFSET(DayTradeSummaryNextShares, _impl_.nasdaqhighprice_)>(
          reinterpret_cast<char*>(&_impl_.nasdaqhighprice_),
          reinterpret_cast<char*>(&other->_impl_.nasdaqhighprice_));
}

::PROTOBUF_NAMESPACE_ID::Metadata DayTradeSummaryNextShares::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_data_2eproto_getter, &descriptor_table_data_2eproto_once,
      file_level_metadata_data_2eproto[2]);
}

// ===================================================================

class IPOInformation::_Internal {
 public:
  using HasBits = decltype(std::declval<IPOInformation>()._impl_._has_bits_);
  static void set_has_issuesymbol(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_securityclass(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_referencefornetchange(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_referenceprice(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

IPOInformation::IPOInformation(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:data.IPOInformation)
}
IPOInformation::IPOInformation(const IPOInformation& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  IPOInformation* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.issuesymbol_){}
    , decltype(_impl_.securityclass_){}
    , decltype(_impl_.referencefornetchange_){}
    , decltype(_impl_.referenceprice_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.issuesymbol_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.issuesymbol_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_issuesymbol()) {
    _this->_impl_.issuesymbol_.Set(from._internal_issuesymbol(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.securityclass_, &from._impl_.securityclass_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.referenceprice_) -
    reinterpret_cast<char*>(&_impl_.securityclass_)) + sizeof(_impl_.referenceprice_));
  // @@protoc_insertion_point(copy_constructor:data.IPOInformation)
}

inline void IPOInformation::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.issuesymbol_){}
    , decltype(_impl_.securityclass_){0}
    , decltype(_impl_.referencefornetchange_){0}
    , decltype(_impl_.referenceprice_){0}
  };
  _impl_.issuesymbol_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.issuesymbol_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

IPOInformation::~IPOInformation() {
  // @@protoc_insertion_point(destructor:data.IPOInformation)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void IPOInformation::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.issuesymbol_.Destroy();
}

void IPOInformation::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void IPOInformation::Clear() {
// @@protoc_insertion_point(message_clear_start:data.IPOInformation)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.issuesymbol_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(&_impl_.securityclass_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.referenceprice_) -
        reinterpret_cast<char*>(&_impl_.securityclass_)) + sizeof(_impl_.referenceprice_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* IPOInformation::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string issueSymbol = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_issuesymbol();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "data.IPOInformation.issueSymbol"));
        } else
          goto handle_unusual;
        continue;
      // optional .data.SecurityClass securityClass = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_securityclass(static_cast<::data::SecurityClass>(val));
        } else
          goto handle_unusual;
        continue;
      // optional .data.NetChange referenceForNetChange = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_referencefornetchange(static_cast<::data::NetChange>(val));
        } else
          goto handle_unusual;
        continue;
      // optional double referencePrice = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 33)) {
          _Internal::set_has_referenceprice(&has_bits);
          _impl_.referenceprice_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* IPOInformation::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:data.IPOInformation)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional string issueSymbol = 1;
  if (_internal_has_issuesymbol()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_issuesymbol().data(), static_cast<int>(this->_internal_issuesymbol().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "data.IPOInformation.issueSymbol");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_issuesymbol(), target);
  }

  // optional .data.SecurityClass securityClass = 2;
  if (_internal_has_securityclass()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_securityclass(), target);
  }

  // optional .data.NetChange referenceForNetChange = 3;
  if (_internal_has_referencefornetchange()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      3, this->_internal_referencefornetchange(), target);
  }

  // optional double referencePrice = 4;
  if (_internal_has_referenceprice()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(4, this->_internal_referenceprice(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:data.IPOInformation)
  return target;
}

size_t IPOInformation::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:data.IPOInformation)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string issueSymbol = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_issuesymbol());
    }

    // optional .data.SecurityClass securityClass = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_securityclass());
    }

    // optional .data.NetChange referenceForNetChange = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_referencefornetchange());
    }

    // optional double referencePrice = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 8;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData IPOInformation::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    IPOInformation::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*IPOInformation::GetClassData() const { return &_class_data_; }


void IPOInformation::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<IPOInformation*>(&to_msg);
  auto& from = static_cast<const IPOInformation&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:data.IPOInformation)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_issuesymbol(from._internal_issuesymbol());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.securityclass_ = from._impl_.securityclass_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.referencefornetchange_ = from._impl_.referencefornetchange_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.referenceprice_ = from._impl_.referenceprice_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void IPOInformation::CopyFrom(const IPOInformation& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:data.IPOInformation)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IPOInformation::IsInitialized() const {
  return true;
}

void IPOInformation::InternalSwap(IPOInformation* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.issuesymbol_, lhs_arena,
      &other->_impl_.issuesymbol_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(IPOInformation, _impl_.referenceprice_)
      + sizeof(IPOInformation::_impl_.referenceprice_)
      - PROTOBUF_FIELD_OFFSET(IPOInformation, _impl_.securityclass_)>(
          reinterpret_cast<char*>(&_impl_.securityclass_),
          reinterpret_cast<char*>(&other->_impl_.securityclass_));
}

::PROTOBUF_NAMESPACE_ID::Metadata IPOInformation::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_data_2eproto_getter, &descriptor_table_data_2eproto_once,
      file_level_metadata_data_2eproto[3]);
}

// ===================================================================

class IPOQuotingPeriodUpdate::_Internal {
 public:
  using HasBits = decltype(std::declval<IPOQuotingPeriodUpdate>()._impl_._has_bits_);
  static void set_has_stock(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ipoquotationreleasetime(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_quotationreleasequalifier(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_ipoprice(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

IPOQuotingPeriodUpdate::IPOQuotingPeriodUpdate(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:data.IPOQuotingPeriodUpdate)
}
IPOQuotingPeriodUpdate::IPOQuotingPeriodUpdate(const IPOQuotingPeriodUpdate& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  IPOQuotingPeriodUpdate* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.stock_){}
    , decltype(_impl_.ipoquotationreleasetime_){}
    , decltype(_impl_.ipoprice_){}
    , decltype(_impl_.quotationreleasequalifier_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.stock_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.stock_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_stock()) {
    _this->_impl_.stock_.Set(from._internal_stock(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.ipoquotationreleasetime_, &from._impl_.ipoquotationreleasetime_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.quotationreleasequalifier_) -
    reinterpret_cast<char*>(&_impl_.ipoquotationreleasetime_)) + sizeof(_impl_.quotationreleasequalifier_));
  // @@protoc_insertion_point(copy_constructor:data.IPOQuotingPeriodUpdate)
}

inline void IPOQuotingPeriodUpdate::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.stock_){}
    , decltype(_impl_.ipoquotationreleasetime_){int64_t{0}}
    , decltype(_impl_.ipoprice_){0}
    , decltype(_impl_.quotationreleasequalifier_){0}
  };
  _impl_.stock_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.stock_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

IPOQuotingPeriodUpdate::~IPOQuotingPeriodUpdate() {
  // @@protoc_insertion_point(destructor:data.IPOQuotingPeriodUpdate)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void IPOQuotingPeriodUpdate::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.stock_.Destroy();
}

void IPOQuotingPeriodUpdate::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void IPOQuotingPeriodUpdate::Clear() {
// @@protoc_insertion_point(message_clear_start:data.IPOQuotingPeriodUpdate)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.stock_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(&_impl_.ipoquotationreleasetime_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.quotationreleasequalifier_) -
        reinterpret_cast<char*>(&_impl_.ipoquotationreleasetime_)) + sizeof(_impl_.quotationreleasequalifier_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* IPOQuotingPeriodUpdate::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string stock = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_stock();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "data.IPOQuotingPeriodUpdate.stock"));
        } else
          goto handle_unusual;
        continue;
      // optional int64 iPOQuotationReleaseTime = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_ipoquotationreleasetime(&has_bits);
          _impl_.ipoquotationreleasetime_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .data.IPOQuotationReleaseQualifier quotationReleaseQualifier = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_quotationreleasequalifier(static_cast<::data::IPOQuotationReleaseQualifier>(val));
        } else
          goto handle_unusual;
        continue;
      // optional double iPOPrice = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 33)) {
          _Internal::set_has_ipoprice(&has_bits);
          _impl_.ipoprice_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* IPOQuotingPeriodUpdate::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:data.IPOQuotingPeriodUpdate)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional string stock = 1;
  if (_internal_has_stock()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_stock().data(), static_cast<int>(this->_internal_stock().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "data.IPOQuotingPeriodUpdate.stock");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_stock(), target);
  }

  // optional int64 iPOQuotationReleaseTime = 2;
  if (_internal_has_ipoquotationreleasetime()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(2, this->_internal_ipoquotationreleasetime(), target);
  }

  // optional .data.IPOQuotationReleaseQualifier quotationReleaseQualifier = 3;
  if (_internal_has_quotationreleasequalifier()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      3, this->_internal_quotationreleasequalifier(), target);
  }

  // optional double iPOPrice = 4;
  if (_internal_has_ipoprice()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(4, this->_internal_ipoprice(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:data.IPOQuotingPeriodUpdate)
  return target;
}

size_t IPOQuotingPeriodUpdate::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:data.IPOQuotingPeriodUpdate)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string stock = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_stock());
    }

    // optional int64 iPOQuotationReleaseTime = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_ipoquotationreleasetime());
    }

    // optional double iPOPrice = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 8;
    }

    // optional .data.IPOQuotationReleaseQualifier quotationReleaseQualifier = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_quotationreleasequalifier());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData IPOQuotingPeriodUpdate::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    IPOQuotingPeriodUpdate::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*IPOQuotingPeriodUpdate::GetClassData() const { return &_class_data_; }


void IPOQuotingPeriodUpdate::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<IPOQuotingPeriodUpdate*>(&to_msg);
  auto& from = static_cast<const IPOQuotingPeriodUpdate&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:data.IPOQuotingPeriodUpdate)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_stock(from._internal_stock());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.ipoquotationreleasetime_ = from._impl_.ipoquotationreleasetime_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.ipoprice_ = from._impl_.ipoprice_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.quotationreleasequalifier_ = from._impl_.quotationreleasequalifier_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void IPOQuotingPeriodUpdate::CopyFrom(const IPOQuotingPeriodUpdate& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:data.IPOQuotingPeriodUpdate)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IPOQuotingPeriodUpdate::IsInitialized() const {
  return true;
}

void IPOQuotingPeriodUpdate::InternalSwap(IPOQuotingPeriodUpdate* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.stock_, lhs_arena,
      &other->_impl_.stock_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(IPOQuotingPeriodUpdate, _impl_.quotationreleasequalifier_)
      + sizeof(IPOQuotingPeriodUpdate::_impl_.quotationreleasequalifier_)
      - PROTOBUF_FIELD_OFFSET(IPOQuotingPeriodUpdate, _impl_.ipoquotationreleasetime_)>(
          reinterpret_cast<char*>(&_impl_.ipoquotationreleasetime_),
          reinterpret_cast<char*>(&other->_impl_.ipoquotationreleasetime_));
}

::PROTOBUF_NAMESPACE_ID::Metadata IPOQuotingPeriodUpdate::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_data_2eproto_getter, &descriptor_table_data_2eproto_once,
      file_level_metadata_data_2eproto[4]);
}

// ===================================================================

class MWCBStatusMessage::_Internal {
 public:
  using HasBits = decltype(std::declval<MWCBStatusMessage>()._impl_._has_bits_);
  static void set_has_breachedlevel(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

MWCBStatusMessage::MWCBStatusMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:data.MWCBStatusMessage)
}
MWCBStatusMessage::MWCBStatusMessage(const MWCBStatusMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  MWCBStatusMessage* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.breachedlevel_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.breachedlevel_ = from._impl_.breachedlevel_;
  // @@protoc_insertion_point(copy_constructor:data.MWCBStatusMessage)
}

inline void MWCBStatusMessage::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.breachedlevel_){0}
  };
}

MWCBStatusMessage::~MWCBStatusMessage() {
  // @@protoc_insertion_point(destructor:data.MWCBStatusMessage)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MWCBStatusMessage::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void MWCBStatusMessage::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MWCBStatusMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:data.MWCBStatusMessage)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.breachedlevel_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MWCBStatusMessage::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .data.BreachedLevel breachedLevel = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_breachedlevel(static_cast<::data::BreachedLevel>(val));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MWCBStatusMessage::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:data.MWCBStatusMessage)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional .data.BreachedLevel breachedLevel = 1;
  if (_internal_has_breachedlevel()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_breachedlevel(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:data.MWCBStatusMessage)
  return target;
}

size_t MWCBStatusMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:data.MWCBStatusMessage)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .data.BreachedLevel breachedLevel = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_breachedlevel());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MWCBStatusMessage::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    MWCBStatusMessage::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MWCBStatusMessage::GetClassData() const { return &_class_data_; }


void MWCBStatusMessage::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<MWCBStatusMessage*>(&to_msg);
  auto& from = static_cast<const MWCBStatusMessage&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:data.MWCBStatusMessage)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_breachedlevel()) {
    _this->_internal_set_breachedlevel(from._internal_breachedlevel());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MWCBStatusMessage::CopyFrom(const MWCBStatusMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:data.MWCBStatusMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MWCBStatusMessage::IsInitialized() const {
  return true;
}

void MWCBStatusMessage::InternalSwap(MWCBStatusMessage* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.breachedlevel_, other->_impl_.breachedlevel_);
}

::PROTOBUF_NAMESPACE_ID::Metadata MWCBStatusMessage::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_data_2eproto_getter, &descriptor_table_data_2eproto_once,
      file_level_metadata_data_2eproto[5]);
}

// ===================================================================

class MarketWideCircuitBreaker::_Internal {
 public:
  using HasBits = decltype(std::declval<MarketWideCircuitBreaker>()._impl_._has_bits_);
  static void set_has_level1(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_level2(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_level3(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

MarketWideCircuitBreaker::MarketWideCircuitBreaker(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:data.MarketWideCircuitBreaker)
}
MarketWideCircuitBreaker::MarketWideCircuitBreaker(const MarketWideCircuitBreaker& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  MarketWideCircuitBreaker* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.level1_){}
    , decltype(_impl_.level2_){}
    , decltype(_impl_.level3_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.level1_, &from._impl_.level1_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.level3_) -
    reinterpret_cast<char*>(&_impl_.level1_)) + sizeof(_impl_.level3_));
  // @@protoc_insertion_point(copy_constructor:data.MarketWideCircuitBreaker)
}

inline void MarketWideCircuitBreaker::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.level1_){0}
    , decltype(_impl_.level2_){0}
    , decltype(_impl_.level3_){0}
  };
}

MarketWideCircuitBreaker::~MarketWideCircuitBreaker() {
  // @@protoc_insertion_point(destructor:data.MarketWideCircuitBreaker)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MarketWideCircuitBreaker::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void MarketWideCircuitBreaker::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MarketWideCircuitBreaker::Clear() {
// @@protoc_insertion_point(message_clear_start:data.MarketWideCircuitBreaker)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.level1_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.level3_) -
        reinterpret_cast<char*>(&_impl_.level1_)) + sizeof(_impl_.level3_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MarketWideCircuitBreaker::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional double Level1 = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _Internal::set_has_level1(&has_bits);
          _impl_.level1_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double Level2 = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _Internal::set_has_level2(&has_bits);
          _impl_.level2_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double Level3 = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          _Internal::set_has_level3(&has_bits);
          _impl_.level3_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MarketWideCircuitBreaker::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:data.MarketWideCircuitBreaker)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional double Level1 = 1;
  if (_internal_has_level1()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(1, this->_internal_level1(), target);
  }

  // optional double Level2 = 2;
  if (_internal_has_level2()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(2, this->_internal_level2(), target);
  }

  // optional double Level3 = 3;
  if (_internal_has_level3()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(3, this->_internal_level3(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:data.MarketWideCircuitBreaker)
  return target;
}

size_t MarketWideCircuitBreaker::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:data.MarketWideCircuitBreaker)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional double Level1 = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 8;
    }

    // optional double Level2 = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 8;
    }

    // optional double Level3 = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 8;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MarketWideCircuitBreaker::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    MarketWideCircuitBreaker::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MarketWideCircuitBreaker::GetClassData() const { return &_class_data_; }


void MarketWideCircuitBreaker::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<MarketWideCircuitBreaker*>(&to_msg);
  auto& from = static_cast<const MarketWideCircuitBreaker&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:data.MarketWideCircuitBreaker)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.level1_ = from._impl_.level1_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.level2_ = from._impl_.level2_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.level3_ = from._impl_.level3_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MarketWideCircuitBreaker::CopyFrom(const MarketWideCircuitBreaker& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:data.MarketWideCircuitBreaker)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MarketWideCircuitBreaker::IsInitialized() const {
  return true;
}

void MarketWideCircuitBreaker::InternalSwap(MarketWideCircuitBreaker* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MarketWideCircuitBreaker, _impl_.level3_)
      + sizeof(MarketWideCircuitBreaker::_impl_.level3_)
      - PROTOBUF_FIELD_OFFSET(MarketWideCircuitBreaker, _impl_.level1_)>(
          reinterpret_cast<char*>(&_impl_.level1_),
          reinterpret_cast<char*>(&other->_impl_.level1_));
}

::PROTOBUF_NAMESPACE_ID::Metadata MarketWideCircuitBreaker::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_data_2eproto_getter, &descriptor_table_data_2eproto_once,
      file_level_metadata_data_2eproto[6]);
}

// ===================================================================

class MessageHeader::_Internal {
 public:
  using HasBits = decltype(std::declval<MessageHeader>()._impl_._has_bits_);
  static void set_has_trackingnumber(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_timestamp(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_messagetype(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

MessageHeader::MessageHeader(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:data.MessageHeader)
}
MessageHeader::MessageHeader(const MessageHeader& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  MessageHeader* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.timestamp_){}
    , decltype(_impl_.trackingnumber_){}
    , decltype(_impl_.messagetype_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.timestamp_, &from._impl_.timestamp_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.messagetype_) -
    reinterpret_cast<char*>(&_impl_.timestamp_)) + sizeof(_impl_.messagetype_));
  // @@protoc_insertion_point(copy_constructor:data.MessageHeader)
}

inline void MessageHeader::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.timestamp_){int64_t{0}}
    , decltype(_impl_.trackingnumber_){0}
    , decltype(_impl_.messagetype_){0}
  };
}

MessageHeader::~MessageHeader() {
  // @@protoc_insertion_point(destructor:data.MessageHeader)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MessageHeader::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void MessageHeader::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MessageHeader::Clear() {
// @@protoc_insertion_point(message_clear_start:data.MessageHeader)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.timestamp_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.messagetype_) -
        reinterpret_cast<char*>(&_impl_.timestamp_)) + sizeof(_impl_.messagetype_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MessageHeader::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 trackingNumber = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_trackingnumber(&has_bits);
          _impl_.trackingnumber_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 timestamp = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_timestamp(&has_bits);
          _impl_.timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .data.MessageType messageType = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_messagetype(static_cast<::data::MessageType>(val));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MessageHeader::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:data.MessageHeader)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional int32 trackingNumber = 1;
  if (_internal_has_trackingnumber()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_trackingnumber(), target);
  }

  // optional int64 timestamp = 2;
  if (_internal_has_timestamp()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(2, this->_internal_timestamp(), target);
  }

  // optional .data.MessageType messageType = 3;
  if (_internal_has_messagetype()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      3, this->_internal_messagetype(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:data.MessageHeader)
  return target;
}

size_t MessageHeader::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:data.MessageHeader)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional int64 timestamp = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_timestamp());
    }

    // optional int32 trackingNumber = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_trackingnumber());
    }

    // optional .data.MessageType messageType = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_messagetype());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MessageHeader::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    MessageHeader::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MessageHeader::GetClassData() const { return &_class_data_; }


void MessageHeader::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<MessageHeader*>(&to_msg);
  auto& from = static_cast<const MessageHeader&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:data.MessageHeader)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.timestamp_ = from._impl_.timestamp_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.trackingnumber_ = from._impl_.trackingnumber_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.messagetype_ = from._impl_.messagetype_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MessageHeader::CopyFrom(const MessageHeader& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:data.MessageHeader)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MessageHeader::IsInitialized() const {
  return true;
}

void MessageHeader::InternalSwap(MessageHeader* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MessageHeader, _impl_.messagetype_)
      + sizeof(MessageHeader::_impl_.messagetype_)
      - PROTOBUF_FIELD_OFFSET(MessageHeader, _impl_.timestamp_)>(
          reinterpret_cast<char*>(&_impl_.timestamp_),
          reinterpret_cast<char*>(&other->_impl_.timestamp_));
}

::PROTOBUF_NAMESPACE_ID::Metadata MessageHeader::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_data_2eproto_getter, &descriptor_table_data_2eproto_once,
      file_level_metadata_data_2eproto[7]);
}

// ===================================================================

class OperationalHalt::_Internal {
 public:
  using HasBits = decltype(std::declval<OperationalHalt>()._impl_._has_bits_);
  static void set_has_stock(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_marketcode(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_operationalhaltaction(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

OperationalHalt::OperationalHalt(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:data.OperationalHalt)
}
OperationalHalt::OperationalHalt(const OperationalHalt& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  OperationalHalt* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.stock_){}
    , decltype(_impl_.marketcode_){}
    , decltype(_impl_.operationalhaltaction_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.stock_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.stock_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_stock()) {
    _this->_impl_.stock_.Set(from._internal_stock(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.marketcode_, &from._impl_.marketcode_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.operationalhaltaction_) -
    reinterpret_cast<char*>(&_impl_.marketcode_)) + sizeof(_impl_.operationalhaltaction_));
  // @@protoc_insertion_point(copy_constructor:data.OperationalHalt)
}

inline void OperationalHalt::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.stock_){}
    , decltype(_impl_.marketcode_){0}
    , decltype(_impl_.operationalhaltaction_){0}
  };
  _impl_.stock_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.stock_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

OperationalHalt::~OperationalHalt() {
  // @@protoc_insertion_point(destructor:data.OperationalHalt)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void OperationalHalt::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.stock_.Destroy();
}

void OperationalHalt::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void OperationalHalt::Clear() {
// @@protoc_insertion_point(message_clear_start:data.OperationalHalt)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.stock_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&_impl_.marketcode_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.operationalhaltaction_) -
        reinterpret_cast<char*>(&_impl_.marketcode_)) + sizeof(_impl_.operationalhaltaction_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* OperationalHalt::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string stock = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_stock();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "data.OperationalHalt.stock"));
        } else
          goto handle_unusual;
        continue;
      // optional .data.MarketCode marketCode = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_marketcode(static_cast<::data::MarketCode>(val));
        } else
          goto handle_unusual;
        continue;
      // optional .data.OperationalHaltAction operationalHaltAction = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_operationalhaltaction(static_cast<::data::OperationalHaltAction>(val));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* OperationalHalt::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:data.OperationalHalt)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional string stock = 1;
  if (_internal_has_stock()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_stock().data(), static_cast<int>(this->_internal_stock().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "data.OperationalHalt.stock");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_stock(), target);
  }

  // optional .data.MarketCode marketCode = 2;
  if (_internal_has_marketcode()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_marketcode(), target);
  }

  // optional .data.OperationalHaltAction operationalHaltAction = 3;
  if (_internal_has_operationalhaltaction()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      3, this->_internal_operationalhaltaction(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:data.OperationalHalt)
  return target;
}

size_t OperationalHalt::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:data.OperationalHalt)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string stock = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_stock());
    }

    // optional .data.MarketCode marketCode = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_marketcode());
    }

    // optional .data.OperationalHaltAction operationalHaltAction = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_operationalhaltaction());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData OperationalHalt::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    OperationalHalt::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*OperationalHalt::GetClassData() const { return &_class_data_; }


void OperationalHalt::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<OperationalHalt*>(&to_msg);
  auto& from = static_cast<const OperationalHalt&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:data.OperationalHalt)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_stock(from._internal_stock());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.marketcode_ = from._impl_.marketcode_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.operationalhaltaction_ = from._impl_.operationalhaltaction_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void OperationalHalt::CopyFrom(const OperationalHalt& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:data.OperationalHalt)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OperationalHalt::IsInitialized() const {
  return true;
}

void OperationalHalt::InternalSwap(OperationalHalt* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.stock_, lhs_arena,
      &other->_impl_.stock_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(OperationalHalt, _impl_.operationalhaltaction_)
      + sizeof(OperationalHalt::_impl_.operationalhaltaction_)
      - PROTOBUF_FIELD_OFFSET(OperationalHalt, _impl_.marketcode_)>(
          reinterpret_cast<char*>(&_impl_.marketcode_),
          reinterpret_cast<char*>(&other->_impl_.marketcode_));
}

::PROTOBUF_NAMESPACE_ID::Metadata OperationalHalt::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_data_2eproto_getter, &descriptor_table_data_2eproto_once,
      file_level_metadata_data_2eproto[8]);
}

// ===================================================================

class SaleConditionModifier::_Internal {
 public:
  using HasBits = decltype(std::declval<SaleConditionModifier>()._impl_._has_bits_);
  static void set_has_level1(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_level2(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_level3(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_level4(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

SaleConditionModifier::SaleConditionModifier(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:data.SaleConditionModifier)
}
SaleConditionModifier::SaleConditionModifier(const SaleConditionModifier& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SaleConditionModifier* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.level1_){}
    , decltype(_impl_.level2_){}
    , decltype(_impl_.level3_){}
    , decltype(_impl_.level4_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.level1_, &from._impl_.level1_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.level4_) -
    reinterpret_cast<char*>(&_impl_.level1_)) + sizeof(_impl_.level4_));
  // @@protoc_insertion_point(copy_constructor:data.SaleConditionModifier)
}

inline void SaleConditionModifier::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.level1_){0}
    , decltype(_impl_.level2_){0}
    , decltype(_impl_.level3_){0}
    , decltype(_impl_.level4_){0}
  };
}

SaleConditionModifier::~SaleConditionModifier() {
  // @@protoc_insertion_point(destructor:data.SaleConditionModifier)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SaleConditionModifier::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void SaleConditionModifier::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SaleConditionModifier::Clear() {
// @@protoc_insertion_point(message_clear_start:data.SaleConditionModifier)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&_impl_.level1_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.level4_) -
        reinterpret_cast<char*>(&_impl_.level1_)) + sizeof(_impl_.level4_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SaleConditionModifier::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .data.LevelOne level1 = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_level1(static_cast<::data::LevelOne>(val));
        } else
          goto handle_unusual;
        continue;
      // optional .data.LevelTwo level2 = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_level2(static_cast<::data::LevelTwo>(val));
        } else
          goto handle_unusual;
        continue;
      // optional .data.LevelThree level3 = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_level3(static_cast<::data::LevelThree>(val));
        } else
          goto handle_unusual;
        continue;
      // optional .data.LevelFour level4 = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_level4(static_cast<::data::LevelFour>(val));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SaleConditionModifier::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:data.SaleConditionModifier)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional .data.LevelOne level1 = 1;
  if (_internal_has_level1()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_level1(), target);
  }

  // optional .data.LevelTwo level2 = 2;
  if (_internal_has_level2()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_level2(), target);
  }

  // optional .data.LevelThree level3 = 3;
  if (_internal_has_level3()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      3, this->_internal_level3(), target);
  }

  // optional .data.LevelFour level4 = 4;
  if (_internal_has_level4()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      4, this->_internal_level4(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:data.SaleConditionModifier)
  return target;
}

size_t SaleConditionModifier::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:data.SaleConditionModifier)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional .data.LevelOne level1 = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_level1());
    }

    // optional .data.LevelTwo level2 = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_level2());
    }

    // optional .data.LevelThree level3 = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_level3());
    }

    // optional .data.LevelFour level4 = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_level4());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SaleConditionModifier::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SaleConditionModifier::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SaleConditionModifier::GetClassData() const { return &_class_data_; }


void SaleConditionModifier::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SaleConditionModifier*>(&to_msg);
  auto& from = static_cast<const SaleConditionModifier&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:data.SaleConditionModifier)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.level1_ = from._impl_.level1_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.level2_ = from._impl_.level2_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.level3_ = from._impl_.level3_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.level4_ = from._impl_.level4_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SaleConditionModifier::CopyFrom(const SaleConditionModifier& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:data.SaleConditionModifier)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SaleConditionModifier::IsInitialized() const {
  return true;
}

void SaleConditionModifier::InternalSwap(SaleConditionModifier* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SaleConditionModifier, _impl_.level4_)
      + sizeof(SaleConditionModifier::_impl_.level4_)
      - PROTOBUF_FIELD_OFFSET(SaleConditionModifier, _impl_.level1_)>(
          reinterpret_cast<char*>(&_impl_.level1_),
          reinterpret_cast<char*>(&other->_impl_.level1_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SaleConditionModifier::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_data_2eproto_getter, &descriptor_table_data_2eproto_once,
      file_level_metadata_data_2eproto[9]);
}

// ===================================================================

class ShortSaleRestrictionIndicatorMessage::_Internal {
 public:
  using HasBits = decltype(std::declval<ShortSaleRestrictionIndicatorMessage>()._impl_._has_bits_);
  static void set_has_issuesymbol(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_regshoaction(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

ShortSaleRestrictionIndicatorMessage::ShortSaleRestrictionIndicatorMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:data.ShortSaleRestrictionIndicatorMessage)
}
ShortSaleRestrictionIndicatorMessage::ShortSaleRestrictionIndicatorMessage(const ShortSaleRestrictionIndicatorMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ShortSaleRestrictionIndicatorMessage* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.issuesymbol_){}
    , decltype(_impl_.regshoaction_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.issuesymbol_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.issuesymbol_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_issuesymbol()) {
    _this->_impl_.issuesymbol_.Set(from._internal_issuesymbol(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.regshoaction_ = from._impl_.regshoaction_;
  // @@protoc_insertion_point(copy_constructor:data.ShortSaleRestrictionIndicatorMessage)
}

inline void ShortSaleRestrictionIndicatorMessage::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.issuesymbol_){}
    , decltype(_impl_.regshoaction_){0}
  };
  _impl_.issuesymbol_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.issuesymbol_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ShortSaleRestrictionIndicatorMessage::~ShortSaleRestrictionIndicatorMessage() {
  // @@protoc_insertion_point(destructor:data.ShortSaleRestrictionIndicatorMessage)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ShortSaleRestrictionIndicatorMessage::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.issuesymbol_.Destroy();
}

void ShortSaleRestrictionIndicatorMessage::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ShortSaleRestrictionIndicatorMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:data.ShortSaleRestrictionIndicatorMessage)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.issuesymbol_.ClearNonDefaultToEmpty();
  }
  _impl_.regshoaction_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ShortSaleRestrictionIndicatorMessage::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string issueSymbol = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_issuesymbol();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "data.ShortSaleRestrictionIndicatorMessage.issueSymbol"));
        } else
          goto handle_unusual;
        continue;
      // optional .data.RegSHOAction regSHOAction = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_regshoaction(static_cast<::data::RegSHOAction>(val));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ShortSaleRestrictionIndicatorMessage::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:data.ShortSaleRestrictionIndicatorMessage)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional string issueSymbol = 1;
  if (_internal_has_issuesymbol()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_issuesymbol().data(), static_cast<int>(this->_internal_issuesymbol().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "data.ShortSaleRestrictionIndicatorMessage.issueSymbol");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_issuesymbol(), target);
  }

  // optional .data.RegSHOAction regSHOAction = 2;
  if (_internal_has_regshoaction()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_regshoaction(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:data.ShortSaleRestrictionIndicatorMessage)
  return target;
}

size_t ShortSaleRestrictionIndicatorMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:data.ShortSaleRestrictionIndicatorMessage)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string issueSymbol = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_issuesymbol());
    }

    // optional .data.RegSHOAction regSHOAction = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_regshoaction());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ShortSaleRestrictionIndicatorMessage::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ShortSaleRestrictionIndicatorMessage::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ShortSaleRestrictionIndicatorMessage::GetClassData() const { return &_class_data_; }


void ShortSaleRestrictionIndicatorMessage::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ShortSaleRestrictionIndicatorMessage*>(&to_msg);
  auto& from = static_cast<const ShortSaleRestrictionIndicatorMessage&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:data.ShortSaleRestrictionIndicatorMessage)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_issuesymbol(from._internal_issuesymbol());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.regshoaction_ = from._impl_.regshoaction_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ShortSaleRestrictionIndicatorMessage::CopyFrom(const ShortSaleRestrictionIndicatorMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:data.ShortSaleRestrictionIndicatorMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ShortSaleRestrictionIndicatorMessage::IsInitialized() const {
  return true;
}

void ShortSaleRestrictionIndicatorMessage::InternalSwap(ShortSaleRestrictionIndicatorMessage* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.issuesymbol_, lhs_arena,
      &other->_impl_.issuesymbol_, rhs_arena
  );
  swap(_impl_.regshoaction_, other->_impl_.regshoaction_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ShortSaleRestrictionIndicatorMessage::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_data_2eproto_getter, &descriptor_table_data_2eproto_once,
      file_level_metadata_data_2eproto[10]);
}

// ===================================================================

class StockDirectory::_Internal {
 public:
  using HasBits = decltype(std::declval<StockDirectory>()._impl_._has_bits_);
  static void set_has_stock(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_marketcategory(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_financialstatusindicator(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_roundlotsize(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_roundlotonly(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_issueclassification(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_issuesubtype(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_authenticity(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_shortsalethresholdindicator(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_ipoflag(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_luldreferencepricetier(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_etplag(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_etpleveragefactor(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_inverseindicator(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static void set_has_bloombergid(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

StockDirectory::StockDirectory(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:data.StockDirectory)
}
StockDirectory::StockDirectory(const StockDirectory& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  StockDirectory* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.stock_){}
    , decltype(_impl_.issueclassification_){}
    , decltype(_impl_.issuesubtype_){}
    , decltype(_impl_.bloombergid_){}
    , decltype(_impl_.marketcategory_){}
    , decltype(_impl_.financialstatusindicator_){}
    , decltype(_impl_.roundlotsize_){}
    , decltype(_impl_.roundlotonly_){}
    , decltype(_impl_.authenticity_){}
    , decltype(_impl_.shortsalethresholdindicator_){}
    , decltype(_impl_.ipoflag_){}
    , decltype(_impl_.luldreferencepricetier_){}
    , decltype(_impl_.etplag_){}
    , decltype(_impl_.etpleveragefactor_){}
    , decltype(_impl_.inverseindicator_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.stock_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.stock_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_stock()) {
    _this->_impl_.stock_.Set(from._internal_stock(), 
      _this->GetArenaForAllocation());
  }
  _impl_.issueclassification_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.issueclassification_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_issueclassification()) {
    _this->_impl_.issueclassification_.Set(from._internal_issueclassification(), 
      _this->GetArenaForAllocation());
  }
  _impl_.issuesubtype_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.issuesubtype_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_issuesubtype()) {
    _this->_impl_.issuesubtype_.Set(from._internal_issuesubtype(), 
      _this->GetArenaForAllocation());
  }
  _impl_.bloombergid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.bloombergid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_bloombergid()) {
    _this->_impl_.bloombergid_.Set(from._internal_bloombergid(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.marketcategory_, &from._impl_.marketcategory_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.inverseindicator_) -
    reinterpret_cast<char*>(&_impl_.marketcategory_)) + sizeof(_impl_.inverseindicator_));
  // @@protoc_insertion_point(copy_constructor:data.StockDirectory)
}

inline void StockDirectory::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.stock_){}
    , decltype(_impl_.issueclassification_){}
    , decltype(_impl_.issuesubtype_){}
    , decltype(_impl_.bloombergid_){}
    , decltype(_impl_.marketcategory_){0}
    , decltype(_impl_.financialstatusindicator_){0}
    , decltype(_impl_.roundlotsize_){int64_t{0}}
    , decltype(_impl_.roundlotonly_){0}
    , decltype(_impl_.authenticity_){0}
    , decltype(_impl_.shortsalethresholdindicator_){0}
    , decltype(_impl_.ipoflag_){0}
    , decltype(_impl_.luldreferencepricetier_){0}
    , decltype(_impl_.etplag_){0}
    , decltype(_impl_.etpleveragefactor_){int64_t{0}}
    , decltype(_impl_.inverseindicator_){0}
  };
  _impl_.stock_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.stock_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.issueclassification_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.issueclassification_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.issuesubtype_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.issuesubtype_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.bloombergid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.bloombergid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

StockDirectory::~StockDirectory() {
  // @@protoc_insertion_point(destructor:data.StockDirectory)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void StockDirectory::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.stock_.Destroy();
  _impl_.issueclassification_.Destroy();
  _impl_.issuesubtype_.Destroy();
  _impl_.bloombergid_.Destroy();
}

void StockDirectory::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void StockDirectory::Clear() {
// @@protoc_insertion_point(message_clear_start:data.StockDirectory)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.stock_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.issueclassification_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.issuesubtype_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.bloombergid_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x000000f0u) {
    ::memset(&_impl_.marketcategory_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.roundlotonly_) -
        reinterpret_cast<char*>(&_impl_.marketcategory_)) + sizeof(_impl_.roundlotonly_));
  }
  if (cached_has_bits & 0x00007f00u) {
    ::memset(&_impl_.authenticity_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.inverseindicator_) -
        reinterpret_cast<char*>(&_impl_.authenticity_)) + sizeof(_impl_.inverseindicator_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StockDirectory::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string stock = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_stock();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "data.StockDirectory.stock"));
        } else
          goto handle_unusual;
        continue;
      // optional .data.MarketCategory marketCategory = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_marketcategory(static_cast<::data::MarketCategory>(val));
        } else
          goto handle_unusual;
        continue;
      // optional .data.FinancialStatusIndicator financialStatusIndicator = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_financialstatusindicator(static_cast<::data::FinancialStatusIndicator>(val));
        } else
          goto handle_unusual;
        continue;
      // optional int64 roundLotsize = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_roundlotsize(&has_bits);
          _impl_.roundlotsize_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .data.IndicatesIf roundLotOnly = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_roundlotonly(static_cast<::data::IndicatesIf>(val));
        } else
          goto handle_unusual;
        continue;
      // optional string issueClassification = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_issueclassification();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "data.StockDirectory.issueClassification"));
        } else
          goto handle_unusual;
        continue;
      // optional string issueSubType = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_issuesubtype();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "data.StockDirectory.issueSubType"));
        } else
          goto handle_unusual;
        continue;
      // optional .data.Authenticity authenticity = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_authenticity(static_cast<::data::Authenticity>(val));
        } else
          goto handle_unusual;
        continue;
      // optional .data.IndicatesIf shortSaleThresholdIndicator = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_shortsalethresholdindicator(static_cast<::data::IndicatesIf>(val));
        } else
          goto handle_unusual;
        continue;
      // optional .data.IndicatesIf IPOFlag = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_ipoflag(static_cast<::data::IndicatesIf>(val));
        } else
          goto handle_unusual;
        continue;
      // optional .data.LULDRule lULDReferencePriceTier = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_luldreferencepricetier(static_cast<::data::LULDRule>(val));
        } else
          goto handle_unusual;
        continue;
      // optional .data.IndicatesIf ETPlag = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_etplag(static_cast<::data::IndicatesIf>(val));
        } else
          goto handle_unusual;
        continue;
      // optional int64 ETPLeverageFactor = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          _Internal::set_has_etpleveragefactor(&has_bits);
          _impl_.etpleveragefactor_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .data.IndicatesIf inverseIndicator = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_inverseindicator(static_cast<::data::IndicatesIf>(val));
        } else
          goto handle_unusual;
        continue;
      // optional string bloombergID = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 122)) {
          auto str = _internal_mutable_bloombergid();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "data.StockDirectory.bloombergID"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* StockDirectory::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:data.StockDirectory)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional string stock = 1;
  if (_internal_has_stock()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_stock().data(), static_cast<int>(this->_internal_stock().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "data.StockDirectory.stock");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_stock(), target);
  }

  // optional .data.MarketCategory marketCategory = 2;
  if (_internal_has_marketcategory()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_marketcategory(), target);
  }

  // optional .data.FinancialStatusIndicator financialStatusIndicator = 3;
  if (_internal_has_financialstatusindicator()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      3, this->_internal_financialstatusindicator(), target);
  }

  // optional int64 roundLotsize = 4;
  if (_internal_has_roundlotsize()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(4, this->_internal_roundlotsize(), target);
  }

  // optional .data.IndicatesIf roundLotOnly = 5;
  if (_internal_has_roundlotonly()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      5, this->_internal_roundlotonly(), target);
  }

  // optional string issueClassification = 6;
  if (_internal_has_issueclassification()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_issueclassification().data(), static_cast<int>(this->_internal_issueclassification().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "data.StockDirectory.issueClassification");
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_issueclassification(), target);
  }

  // optional string issueSubType = 7;
  if (_internal_has_issuesubtype()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_issuesubtype().data(), static_cast<int>(this->_internal_issuesubtype().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "data.StockDirectory.issueSubType");
    target = stream->WriteStringMaybeAliased(
        7, this->_internal_issuesubtype(), target);
  }

  // optional .data.Authenticity authenticity = 8;
  if (_internal_has_authenticity()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      8, this->_internal_authenticity(), target);
  }

  // optional .data.IndicatesIf shortSaleThresholdIndicator = 9;
  if (_internal_has_shortsalethresholdindicator()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      9, this->_internal_shortsalethresholdindicator(), target);
  }

  // optional .data.IndicatesIf IPOFlag = 10;
  if (_internal_has_ipoflag()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      10, this->_internal_ipoflag(), target);
  }

  // optional .data.LULDRule lULDReferencePriceTier = 11;
  if (_internal_has_luldreferencepricetier()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      11, this->_internal_luldreferencepricetier(), target);
  }

  // optional .data.IndicatesIf ETPlag = 12;
  if (_internal_has_etplag()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      12, this->_internal_etplag(), target);
  }

  // optional int64 ETPLeverageFactor = 13;
  if (_internal_has_etpleveragefactor()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(13, this->_internal_etpleveragefactor(), target);
  }

  // optional .data.IndicatesIf inverseIndicator = 14;
  if (_internal_has_inverseindicator()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      14, this->_internal_inverseindicator(), target);
  }

  // optional string bloombergID = 15;
  if (_internal_has_bloombergid()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_bloombergid().data(), static_cast<int>(this->_internal_bloombergid().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "data.StockDirectory.bloombergID");
    target = stream->WriteStringMaybeAliased(
        15, this->_internal_bloombergid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:data.StockDirectory)
  return target;
}

size_t StockDirectory::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:data.StockDirectory)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string stock = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_stock());
    }

    // optional string issueClassification = 6;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_issueclassification());
    }

    // optional string issueSubType = 7;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_issuesubtype());
    }

    // optional string bloombergID = 15;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_bloombergid());
    }

    // optional .data.MarketCategory marketCategory = 2;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_marketcategory());
    }

    // optional .data.FinancialStatusIndicator financialStatusIndicator = 3;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_financialstatusindicator());
    }

    // optional int64 roundLotsize = 4;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_roundlotsize());
    }

    // optional .data.IndicatesIf roundLotOnly = 5;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_roundlotonly());
    }

  }
  if (cached_has_bits & 0x00007f00u) {
    // optional .data.Authenticity authenticity = 8;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_authenticity());
    }

    // optional .data.IndicatesIf shortSaleThresholdIndicator = 9;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_shortsalethresholdindicator());
    }

    // optional .data.IndicatesIf IPOFlag = 10;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_ipoflag());
    }

    // optional .data.LULDRule lULDReferencePriceTier = 11;
    if (cached_has_bits & 0x00000800u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_luldreferencepricetier());
    }

    // optional .data.IndicatesIf ETPlag = 12;
    if (cached_has_bits & 0x00001000u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_etplag());
    }

    // optional int64 ETPLeverageFactor = 13;
    if (cached_has_bits & 0x00002000u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_etpleveragefactor());
    }

    // optional .data.IndicatesIf inverseIndicator = 14;
    if (cached_has_bits & 0x00004000u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_inverseindicator());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StockDirectory::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    StockDirectory::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StockDirectory::GetClassData() const { return &_class_data_; }


void StockDirectory::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<StockDirectory*>(&to_msg);
  auto& from = static_cast<const StockDirectory&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:data.StockDirectory)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_stock(from._internal_stock());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_issueclassification(from._internal_issueclassification());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_issuesubtype(from._internal_issuesubtype());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_set_bloombergid(from._internal_bloombergid());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.marketcategory_ = from._impl_.marketcategory_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.financialstatusindicator_ = from._impl_.financialstatusindicator_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.roundlotsize_ = from._impl_.roundlotsize_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.roundlotonly_ = from._impl_.roundlotonly_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00007f00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.authenticity_ = from._impl_.authenticity_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.shortsalethresholdindicator_ = from._impl_.shortsalethresholdindicator_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.ipoflag_ = from._impl_.ipoflag_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.luldreferencepricetier_ = from._impl_.luldreferencepricetier_;
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_impl_.etplag_ = from._impl_.etplag_;
    }
    if (cached_has_bits & 0x00002000u) {
      _this->_impl_.etpleveragefactor_ = from._impl_.etpleveragefactor_;
    }
    if (cached_has_bits & 0x00004000u) {
      _this->_impl_.inverseindicator_ = from._impl_.inverseindicator_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StockDirectory::CopyFrom(const StockDirectory& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:data.StockDirectory)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StockDirectory::IsInitialized() const {
  return true;
}

void StockDirectory::InternalSwap(StockDirectory* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.stock_, lhs_arena,
      &other->_impl_.stock_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.issueclassification_, lhs_arena,
      &other->_impl_.issueclassification_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.issuesubtype_, lhs_arena,
      &other->_impl_.issuesubtype_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.bloombergid_, lhs_arena,
      &other->_impl_.bloombergid_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(StockDirectory, _impl_.inverseindicator_)
      + sizeof(StockDirectory::_impl_.inverseindicator_)
      - PROTOBUF_FIELD_OFFSET(StockDirectory, _impl_.marketcategory_)>(
          reinterpret_cast<char*>(&_impl_.marketcategory_),
          reinterpret_cast<char*>(&other->_impl_.marketcategory_));
}

::PROTOBUF_NAMESPACE_ID::Metadata StockDirectory::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_data_2eproto_getter, &descriptor_table_data_2eproto_once,
      file_level_metadata_data_2eproto[11]);
}

// ===================================================================

class StockTradingAction::_Internal {
 public:
  using HasBits = decltype(std::declval<StockTradingAction>()._impl_._has_bits_);
  static void set_has_reserved(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_issuesymbol(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_securityclass(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_currenttradingstate(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_reason(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

StockTradingAction::StockTradingAction(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:data.StockTradingAction)
}
StockTradingAction::StockTradingAction(const StockTradingAction& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  StockTradingAction* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.reserved_){}
    , decltype(_impl_.issuesymbol_){}
    , decltype(_impl_.reason_){}
    , decltype(_impl_.securityclass_){}
    , decltype(_impl_.currenttradingstate_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.reserved_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.reserved_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_reserved()) {
    _this->_impl_.reserved_.Set(from._internal_reserved(), 
      _this->GetArenaForAllocation());
  }
  _impl_.issuesymbol_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.issuesymbol_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_issuesymbol()) {
    _this->_impl_.issuesymbol_.Set(from._internal_issuesymbol(), 
      _this->GetArenaForAllocation());
  }
  _impl_.reason_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.reason_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_reason()) {
    _this->_impl_.reason_.Set(from._internal_reason(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.securityclass_, &from._impl_.securityclass_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.currenttradingstate_) -
    reinterpret_cast<char*>(&_impl_.securityclass_)) + sizeof(_impl_.currenttradingstate_));
  // @@protoc_insertion_point(copy_constructor:data.StockTradingAction)
}

inline void StockTradingAction::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.reserved_){}
    , decltype(_impl_.issuesymbol_){}
    , decltype(_impl_.reason_){}
    , decltype(_impl_.securityclass_){0}
    , decltype(_impl_.currenttradingstate_){0}
  };
  _impl_.reserved_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.reserved_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.issuesymbol_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.issuesymbol_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.reason_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.reason_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

StockTradingAction::~StockTradingAction() {
  // @@protoc_insertion_point(destructor:data.StockTradingAction)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void StockTradingAction::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.reserved_.Destroy();
  _impl_.issuesymbol_.Destroy();
  _impl_.reason_.Destroy();
}

void StockTradingAction::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void StockTradingAction::Clear() {
// @@protoc_insertion_point(message_clear_start:data.StockTradingAction)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.reserved_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.issuesymbol_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.reason_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x00000018u) {
    ::memset(&_impl_.securityclass_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.currenttradingstate_) -
        reinterpret_cast<char*>(&_impl_.securityclass_)) + sizeof(_impl_.currenttradingstate_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StockTradingAction::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string reserved = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_reserved();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "data.StockTradingAction.reserved"));
        } else
          goto handle_unusual;
        continue;
      // optional string issueSymbol = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_issuesymbol();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "data.StockTradingAction.issueSymbol"));
        } else
          goto handle_unusual;
        continue;
      // optional .data.SecurityClass securityClass = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_securityclass(static_cast<::data::SecurityClass>(val));
        } else
          goto handle_unusual;
        continue;
      // optional .data.CurrentTradingState currentTradingState = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_currenttradingstate(static_cast<::data::CurrentTradingState>(val));
        } else
          goto handle_unusual;
        continue;
      // optional string reason = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_reason();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "data.StockTradingAction.reason"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* StockTradingAction::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:data.StockTradingAction)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional string reserved = 1;
  if (_internal_has_reserved()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_reserved().data(), static_cast<int>(this->_internal_reserved().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "data.StockTradingAction.reserved");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_reserved(), target);
  }

  // optional string issueSymbol = 2;
  if (_internal_has_issuesymbol()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_issuesymbol().data(), static_cast<int>(this->_internal_issuesymbol().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "data.StockTradingAction.issueSymbol");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_issuesymbol(), target);
  }

  // optional .data.SecurityClass securityClass = 3;
  if (_internal_has_securityclass()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      3, this->_internal_securityclass(), target);
  }

  // optional .data.CurrentTradingState currentTradingState = 4;
  if (_internal_has_currenttradingstate()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      4, this->_internal_currenttradingstate(), target);
  }

  // optional string reason = 5;
  if (_internal_has_reason()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_reason().data(), static_cast<int>(this->_internal_reason().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "data.StockTradingAction.reason");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_reason(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:data.StockTradingAction)
  return target;
}

size_t StockTradingAction::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:data.StockTradingAction)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional string reserved = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_reserved());
    }

    // optional string issueSymbol = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_issuesymbol());
    }

    // optional string reason = 5;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_reason());
    }

    // optional .data.SecurityClass securityClass = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_securityclass());
    }

    // optional .data.CurrentTradingState currentTradingState = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_currenttradingstate());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StockTradingAction::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    StockTradingAction::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StockTradingAction::GetClassData() const { return &_class_data_; }


void StockTradingAction::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<StockTradingAction*>(&to_msg);
  auto& from = static_cast<const StockTradingAction&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:data.StockTradingAction)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_reserved(from._internal_reserved());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_issuesymbol(from._internal_issuesymbol());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_reason(from._internal_reason());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.securityclass_ = from._impl_.securityclass_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.currenttradingstate_ = from._impl_.currenttradingstate_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StockTradingAction::CopyFrom(const StockTradingAction& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:data.StockTradingAction)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StockTradingAction::IsInitialized() const {
  return true;
}

void StockTradingAction::InternalSwap(StockTradingAction* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.reserved_, lhs_arena,
      &other->_impl_.reserved_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.issuesymbol_, lhs_arena,
      &other->_impl_.issuesymbol_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.reason_, lhs_arena,
      &other->_impl_.reason_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(StockTradingAction, _impl_.currenttradingstate_)
      + sizeof(StockTradingAction::_impl_.currenttradingstate_)
      - PROTOBUF_FIELD_OFFSET(StockTradingAction, _impl_.securityclass_)>(
          reinterpret_cast<char*>(&_impl_.securityclass_),
          reinterpret_cast<char*>(&other->_impl_.securityclass_));
}

::PROTOBUF_NAMESPACE_ID::Metadata StockTradingAction::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_data_2eproto_getter, &descriptor_table_data_2eproto_once,
      file_level_metadata_data_2eproto[12]);
}

// ===================================================================

class SystemEventMessage::_Internal {
 public:
  using HasBits = decltype(std::declval<SystemEventMessage>()._impl_._has_bits_);
  static void set_has_eventcode(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

SystemEventMessage::SystemEventMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:data.SystemEventMessage)
}
SystemEventMessage::SystemEventMessage(const SystemEventMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SystemEventMessage* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.eventcode_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.eventcode_ = from._impl_.eventcode_;
  // @@protoc_insertion_point(copy_constructor:data.SystemEventMessage)
}

inline void SystemEventMessage::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.eventcode_){0}
  };
}

SystemEventMessage::~SystemEventMessage() {
  // @@protoc_insertion_point(destructor:data.SystemEventMessage)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SystemEventMessage::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void SystemEventMessage::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SystemEventMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:data.SystemEventMessage)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.eventcode_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SystemEventMessage::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .data.EventCode eventCode = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_eventcode(static_cast<::data::EventCode>(val));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SystemEventMessage::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:data.SystemEventMessage)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional .data.EventCode eventCode = 1;
  if (_internal_has_eventcode()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_eventcode(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:data.SystemEventMessage)
  return target;
}

size_t SystemEventMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:data.SystemEventMessage)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .data.EventCode eventCode = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_eventcode());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SystemEventMessage::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SystemEventMessage::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SystemEventMessage::GetClassData() const { return &_class_data_; }


void SystemEventMessage::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SystemEventMessage*>(&to_msg);
  auto& from = static_cast<const SystemEventMessage&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:data.SystemEventMessage)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_eventcode()) {
    _this->_internal_set_eventcode(from._internal_eventcode());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SystemEventMessage::CopyFrom(const SystemEventMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:data.SystemEventMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SystemEventMessage::IsInitialized() const {
  return true;
}

void SystemEventMessage::InternalSwap(SystemEventMessage* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.eventcode_, other->_impl_.eventcode_);
}

::PROTOBUF_NAMESPACE_ID::Metadata SystemEventMessage::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_data_2eproto_getter, &descriptor_table_data_2eproto_once,
      file_level_metadata_data_2eproto[13]);
}

// ===================================================================

class TradeCancelForNextsharesTrades::_Internal {
 public:
  using HasBits = decltype(std::declval<TradeCancelForNextsharesTrades>()._impl_._has_bits_);
  static void set_has_marketcenteridentifier(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_issuesymbol(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_securityclass(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_originaltradecontrolnumber(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_originalproxyprice(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_originalnavoffsetamount(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_originaltradesize(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_originalsaleconditionmodifier(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_consolidatedvolume(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
};

TradeCancelForNextsharesTrades::TradeCancelForNextsharesTrades(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:data.TradeCancelForNextsharesTrades)
}
TradeCancelForNextsharesTrades::TradeCancelForNextsharesTrades(const TradeCancelForNextsharesTrades& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TradeCancelForNextsharesTrades* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.issuesymbol_){}
    , decltype(_impl_.originaltradecontrolnumber_){}
    , decltype(_impl_.originalsaleconditionmodifier_){}
    , decltype(_impl_.marketcenteridentifier_){}
    , decltype(_impl_.securityclass_){}
    , decltype(_impl_.originalproxyprice_){}
    , decltype(_impl_.originalnavoffsetamount_){}
    , decltype(_impl_.originaltradesize_){}
    , decltype(_impl_.consolidatedvolume_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.issuesymbol_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.issuesymbol_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_issuesymbol()) {
    _this->_impl_.issuesymbol_.Set(from._internal_issuesymbol(), 
      _this->GetArenaForAllocation());
  }
  _impl_.originaltradecontrolnumber_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.originaltradecontrolnumber_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_originaltradecontrolnumber()) {
    _this->_impl_.originaltradecontrolnumber_.Set(from._internal_originaltradecontrolnumber(), 
      _this->GetArenaForAllocation());
  }
  _impl_.originalsaleconditionmodifier_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.originalsaleconditionmodifier_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_originalsaleconditionmodifier()) {
    _this->_impl_.originalsaleconditionmodifier_.Set(from._internal_originalsaleconditionmodifier(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.marketcenteridentifier_, &from._impl_.marketcenteridentifier_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.consolidatedvolume_) -
    reinterpret_cast<char*>(&_impl_.marketcenteridentifier_)) + sizeof(_impl_.consolidatedvolume_));
  // @@protoc_insertion_point(copy_constructor:data.TradeCancelForNextsharesTrades)
}

inline void TradeCancelForNextsharesTrades::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.issuesymbol_){}
    , decltype(_impl_.originaltradecontrolnumber_){}
    , decltype(_impl_.originalsaleconditionmodifier_){}
    , decltype(_impl_.marketcenteridentifier_){0}
    , decltype(_impl_.securityclass_){0}
    , decltype(_impl_.originalproxyprice_){0}
    , decltype(_impl_.originalnavoffsetamount_){0}
    , decltype(_impl_.originaltradesize_){int64_t{0}}
    , decltype(_impl_.consolidatedvolume_){int64_t{0}}
  };
  _impl_.issuesymbol_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.issuesymbol_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.originaltradecontrolnumber_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.originaltradecontrolnumber_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.originalsaleconditionmodifier_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.originalsaleconditionmodifier_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

TradeCancelForNextsharesTrades::~TradeCancelForNextsharesTrades() {
  // @@protoc_insertion_point(destructor:data.TradeCancelForNextsharesTrades)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TradeCancelForNextsharesTrades::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.issuesymbol_.Destroy();
  _impl_.originaltradecontrolnumber_.Destroy();
  _impl_.originalsaleconditionmodifier_.Destroy();
}

void TradeCancelForNextsharesTrades::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TradeCancelForNextsharesTrades::Clear() {
// @@protoc_insertion_point(message_clear_start:data.TradeCancelForNextsharesTrades)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.issuesymbol_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.originaltradecontrolnumber_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.originalsaleconditionmodifier_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x000000f8u) {
    ::memset(&_impl_.marketcenteridentifier_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.originaltradesize_) -
        reinterpret_cast<char*>(&_impl_.marketcenteridentifier_)) + sizeof(_impl_.originaltradesize_));
  }
  _impl_.consolidatedvolume_ = int64_t{0};
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TradeCancelForNextsharesTrades::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .data.OriginatingMarketCenterIdentifier marketCenterIdentifier = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_marketcenteridentifier(static_cast<::data::OriginatingMarketCenterIdentifier>(val));
        } else
          goto handle_unusual;
        continue;
      // optional string issueSymbol = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_issuesymbol();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "data.TradeCancelForNextsharesTrades.issueSymbol"));
        } else
          goto handle_unusual;
        continue;
      // optional .data.SecurityClass securityClass = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_securityclass(static_cast<::data::SecurityClass>(val));
        } else
          goto handle_unusual;
        continue;
      // optional string originalTradeControlNumber = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_originaltradecontrolnumber();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "data.TradeCancelForNextsharesTrades.originalTradeControlNumber"));
        } else
          goto handle_unusual;
        continue;
      // optional double originalProxyPrice = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 41)) {
          _Internal::set_has_originalproxyprice(&has_bits);
          _impl_.originalproxyprice_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double originalNAVOffsetAmount = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 49)) {
          _Internal::set_has_originalnavoffsetamount(&has_bits);
          _impl_.originalnavoffsetamount_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional int64 originalTradeSize = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_originaltradesize(&has_bits);
          _impl_.originaltradesize_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string originalSaleConditionModifier = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          auto str = _internal_mutable_originalsaleconditionmodifier();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "data.TradeCancelForNextsharesTrades.originalSaleConditionModifier"));
        } else
          goto handle_unusual;
        continue;
      // optional int64 consolidatedVolume = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_consolidatedvolume(&has_bits);
          _impl_.consolidatedvolume_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TradeCancelForNextsharesTrades::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:data.TradeCancelForNextsharesTrades)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional .data.OriginatingMarketCenterIdentifier marketCenterIdentifier = 1;
  if (_internal_has_marketcenteridentifier()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_marketcenteridentifier(), target);
  }

  // optional string issueSymbol = 2;
  if (_internal_has_issuesymbol()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_issuesymbol().data(), static_cast<int>(this->_internal_issuesymbol().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "data.TradeCancelForNextsharesTrades.issueSymbol");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_issuesymbol(), target);
  }

  // optional .data.SecurityClass securityClass = 3;
  if (_internal_has_securityclass()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      3, this->_internal_securityclass(), target);
  }

  // optional string originalTradeControlNumber = 4;
  if (_internal_has_originaltradecontrolnumber()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_originaltradecontrolnumber().data(), static_cast<int>(this->_internal_originaltradecontrolnumber().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "data.TradeCancelForNextsharesTrades.originalTradeControlNumber");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_originaltradecontrolnumber(), target);
  }

  // optional double originalProxyPrice = 5;
  if (_internal_has_originalproxyprice()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(5, this->_internal_originalproxyprice(), target);
  }

  // optional double originalNAVOffsetAmount = 6;
  if (_internal_has_originalnavoffsetamount()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(6, this->_internal_originalnavoffsetamount(), target);
  }

  // optional int64 originalTradeSize = 7;
  if (_internal_has_originaltradesize()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(7, this->_internal_originaltradesize(), target);
  }

  // optional string originalSaleConditionModifier = 8;
  if (_internal_has_originalsaleconditionmodifier()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_originalsaleconditionmodifier().data(), static_cast<int>(this->_internal_originalsaleconditionmodifier().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "data.TradeCancelForNextsharesTrades.originalSaleConditionModifier");
    target = stream->WriteStringMaybeAliased(
        8, this->_internal_originalsaleconditionmodifier(), target);
  }

  // optional int64 consolidatedVolume = 9;
  if (_internal_has_consolidatedvolume()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(9, this->_internal_consolidatedvolume(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:data.TradeCancelForNextsharesTrades)
  return target;
}

size_t TradeCancelForNextsharesTrades::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:data.TradeCancelForNextsharesTrades)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string issueSymbol = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_issuesymbol());
    }

    // optional string originalTradeControlNumber = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_originaltradecontrolnumber());
    }

    // optional string originalSaleConditionModifier = 8;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_originalsaleconditionmodifier());
    }

    // optional .data.OriginatingMarketCenterIdentifier marketCenterIdentifier = 1;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_marketcenteridentifier());
    }

    // optional .data.SecurityClass securityClass = 3;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_securityclass());
    }

    // optional double originalProxyPrice = 5;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 8;
    }

    // optional double originalNAVOffsetAmount = 6;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 8;
    }

    // optional int64 originalTradeSize = 7;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_originaltradesize());
    }

  }
  // optional int64 consolidatedVolume = 9;
  if (cached_has_bits & 0x00000100u) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_consolidatedvolume());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TradeCancelForNextsharesTrades::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TradeCancelForNextsharesTrades::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TradeCancelForNextsharesTrades::GetClassData() const { return &_class_data_; }


void TradeCancelForNextsharesTrades::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TradeCancelForNextsharesTrades*>(&to_msg);
  auto& from = static_cast<const TradeCancelForNextsharesTrades&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:data.TradeCancelForNextsharesTrades)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_issuesymbol(from._internal_issuesymbol());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_originaltradecontrolnumber(from._internal_originaltradecontrolnumber());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_originalsaleconditionmodifier(from._internal_originalsaleconditionmodifier());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.marketcenteridentifier_ = from._impl_.marketcenteridentifier_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.securityclass_ = from._impl_.securityclass_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.originalproxyprice_ = from._impl_.originalproxyprice_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.originalnavoffsetamount_ = from._impl_.originalnavoffsetamount_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.originaltradesize_ = from._impl_.originaltradesize_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000100u) {
    _this->_internal_set_consolidatedvolume(from._internal_consolidatedvolume());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TradeCancelForNextsharesTrades::CopyFrom(const TradeCancelForNextsharesTrades& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:data.TradeCancelForNextsharesTrades)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TradeCancelForNextsharesTrades::IsInitialized() const {
  return true;
}

void TradeCancelForNextsharesTrades::InternalSwap(TradeCancelForNextsharesTrades* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.issuesymbol_, lhs_arena,
      &other->_impl_.issuesymbol_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.originaltradecontrolnumber_, lhs_arena,
      &other->_impl_.originaltradecontrolnumber_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.originalsaleconditionmodifier_, lhs_arena,
      &other->_impl_.originalsaleconditionmodifier_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TradeCancelForNextsharesTrades, _impl_.consolidatedvolume_)
      + sizeof(TradeCancelForNextsharesTrades::_impl_.consolidatedvolume_)
      - PROTOBUF_FIELD_OFFSET(TradeCancelForNextsharesTrades, _impl_.marketcenteridentifier_)>(
          reinterpret_cast<char*>(&_impl_.marketcenteridentifier_),
          reinterpret_cast<char*>(&other->_impl_.marketcenteridentifier_));
}

::PROTOBUF_NAMESPACE_ID::Metadata TradeCancelForNextsharesTrades::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_data_2eproto_getter, &descriptor_table_data_2eproto_once,
      file_level_metadata_data_2eproto[14]);
}

// ===================================================================

class TradeCancelForNonNextSharesTrades::_Internal {
 public:
  using HasBits = decltype(std::declval<TradeCancelForNonNextSharesTrades>()._impl_._has_bits_);
  static void set_has_marketcenteridentifier(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_issuesymbol(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_securityclass(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_originalcontrolnumber(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_originaltradeprice(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_originaltradesize(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static const ::data::SaleConditionModifier& originalsaleconditionmodifier(const TradeCancelForNonNextSharesTrades* msg);
  static void set_has_originalsaleconditionmodifier(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_consolidatedvolume(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
};

const ::data::SaleConditionModifier&
TradeCancelForNonNextSharesTrades::_Internal::originalsaleconditionmodifier(const TradeCancelForNonNextSharesTrades* msg) {
  return *msg->_impl_.originalsaleconditionmodifier_;
}
TradeCancelForNonNextSharesTrades::TradeCancelForNonNextSharesTrades(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:data.TradeCancelForNonNextSharesTrades)
}
TradeCancelForNonNextSharesTrades::TradeCancelForNonNextSharesTrades(const TradeCancelForNonNextSharesTrades& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TradeCancelForNonNextSharesTrades* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.issuesymbol_){}
    , decltype(_impl_.originalcontrolnumber_){}
    , decltype(_impl_.originalsaleconditionmodifier_){nullptr}
    , decltype(_impl_.marketcenteridentifier_){}
    , decltype(_impl_.securityclass_){}
    , decltype(_impl_.originaltradeprice_){}
    , decltype(_impl_.originaltradesize_){}
    , decltype(_impl_.consolidatedvolume_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.issuesymbol_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.issuesymbol_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_issuesymbol()) {
    _this->_impl_.issuesymbol_.Set(from._internal_issuesymbol(), 
      _this->GetArenaForAllocation());
  }
  _impl_.originalcontrolnumber_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.originalcontrolnumber_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_originalcontrolnumber()) {
    _this->_impl_.originalcontrolnumber_.Set(from._internal_originalcontrolnumber(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_originalsaleconditionmodifier()) {
    _this->_impl_.originalsaleconditionmodifier_ = new ::data::SaleConditionModifier(*from._impl_.originalsaleconditionmodifier_);
  }
  ::memcpy(&_impl_.marketcenteridentifier_, &from._impl_.marketcenteridentifier_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.consolidatedvolume_) -
    reinterpret_cast<char*>(&_impl_.marketcenteridentifier_)) + sizeof(_impl_.consolidatedvolume_));
  // @@protoc_insertion_point(copy_constructor:data.TradeCancelForNonNextSharesTrades)
}

inline void TradeCancelForNonNextSharesTrades::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.issuesymbol_){}
    , decltype(_impl_.originalcontrolnumber_){}
    , decltype(_impl_.originalsaleconditionmodifier_){nullptr}
    , decltype(_impl_.marketcenteridentifier_){0}
    , decltype(_impl_.securityclass_){0}
    , decltype(_impl_.originaltradeprice_){0}
    , decltype(_impl_.originaltradesize_){int64_t{0}}
    , decltype(_impl_.consolidatedvolume_){int64_t{0}}
  };
  _impl_.issuesymbol_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.issuesymbol_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.originalcontrolnumber_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.originalcontrolnumber_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

TradeCancelForNonNextSharesTrades::~TradeCancelForNonNextSharesTrades() {
  // @@protoc_insertion_point(destructor:data.TradeCancelForNonNextSharesTrades)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TradeCancelForNonNextSharesTrades::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.issuesymbol_.Destroy();
  _impl_.originalcontrolnumber_.Destroy();
  if (this != internal_default_instance()) delete _impl_.originalsaleconditionmodifier_;
}

void TradeCancelForNonNextSharesTrades::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TradeCancelForNonNextSharesTrades::Clear() {
// @@protoc_insertion_point(message_clear_start:data.TradeCancelForNonNextSharesTrades)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.issuesymbol_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.originalcontrolnumber_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.originalsaleconditionmodifier_ != nullptr);
      _impl_.originalsaleconditionmodifier_->Clear();
    }
  }
  if (cached_has_bits & 0x000000f8u) {
    ::memset(&_impl_.marketcenteridentifier_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.consolidatedvolume_) -
        reinterpret_cast<char*>(&_impl_.marketcenteridentifier_)) + sizeof(_impl_.consolidatedvolume_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TradeCancelForNonNextSharesTrades::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .data.OriginatingMarketCenterIdentifier marketCenterIdentifier = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_marketcenteridentifier(static_cast<::data::OriginatingMarketCenterIdentifier>(val));
        } else
          goto handle_unusual;
        continue;
      // optional string issueSymbol = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_issuesymbol();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "data.TradeCancelForNonNextSharesTrades.issueSymbol"));
        } else
          goto handle_unusual;
        continue;
      // optional .data.SecurityClass securityClass = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_securityclass(static_cast<::data::SecurityClass>(val));
        } else
          goto handle_unusual;
        continue;
      // optional string originalControlNumber = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_originalcontrolnumber();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "data.TradeCancelForNonNextSharesTrades.originalControlNumber"));
        } else
          goto handle_unusual;
        continue;
      // optional double originalTradePrice = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 41)) {
          _Internal::set_has_originaltradeprice(&has_bits);
          _impl_.originaltradeprice_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional int64 originalTradeSize = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_originaltradesize(&has_bits);
          _impl_.originaltradesize_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .data.SaleConditionModifier originalSaleConditionModifier = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_originalsaleconditionmodifier(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 consolidatedVolume = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_consolidatedvolume(&has_bits);
          _impl_.consolidatedvolume_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TradeCancelForNonNextSharesTrades::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:data.TradeCancelForNonNextSharesTrades)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional .data.OriginatingMarketCenterIdentifier marketCenterIdentifier = 1;
  if (_internal_has_marketcenteridentifier()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_marketcenteridentifier(), target);
  }

  // optional string issueSymbol = 2;
  if (_internal_has_issuesymbol()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_issuesymbol().data(), static_cast<int>(this->_internal_issuesymbol().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "data.TradeCancelForNonNextSharesTrades.issueSymbol");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_issuesymbol(), target);
  }

  // optional .data.SecurityClass securityClass = 3;
  if (_internal_has_securityclass()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      3, this->_internal_securityclass(), target);
  }

  // optional string originalControlNumber = 4;
  if (_internal_has_originalcontrolnumber()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_originalcontrolnumber().data(), static_cast<int>(this->_internal_originalcontrolnumber().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "data.TradeCancelForNonNextSharesTrades.originalControlNumber");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_originalcontrolnumber(), target);
  }

  // optional double originalTradePrice = 5;
  if (_internal_has_originaltradeprice()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(5, this->_internal_originaltradeprice(), target);
  }

  // optional int64 originalTradeSize = 6;
  if (_internal_has_originaltradesize()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(6, this->_internal_originaltradesize(), target);
  }

  // optional .data.SaleConditionModifier originalSaleConditionModifier = 7;
  if (_internal_has_originalsaleconditionmodifier()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::originalsaleconditionmodifier(this),
        _Internal::originalsaleconditionmodifier(this).GetCachedSize(), target, stream);
  }

  // optional int64 consolidatedVolume = 8;
  if (_internal_has_consolidatedvolume()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(8, this->_internal_consolidatedvolume(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:data.TradeCancelForNonNextSharesTrades)
  return target;
}

size_t TradeCancelForNonNextSharesTrades::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:data.TradeCancelForNonNextSharesTrades)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string issueSymbol = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_issuesymbol());
    }

    // optional string originalControlNumber = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_originalcontrolnumber());
    }

    // optional .data.SaleConditionModifier originalSaleConditionModifier = 7;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.originalsaleconditionmodifier_);
    }

    // optional .data.OriginatingMarketCenterIdentifier marketCenterIdentifier = 1;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_marketcenteridentifier());
    }

    // optional .data.SecurityClass securityClass = 3;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_securityclass());
    }

    // optional double originalTradePrice = 5;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 8;
    }

    // optional int64 originalTradeSize = 6;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_originaltradesize());
    }

    // optional int64 consolidatedVolume = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_consolidatedvolume());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TradeCancelForNonNextSharesTrades::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TradeCancelForNonNextSharesTrades::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TradeCancelForNonNextSharesTrades::GetClassData() const { return &_class_data_; }


void TradeCancelForNonNextSharesTrades::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TradeCancelForNonNextSharesTrades*>(&to_msg);
  auto& from = static_cast<const TradeCancelForNonNextSharesTrades&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:data.TradeCancelForNonNextSharesTrades)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_issuesymbol(from._internal_issuesymbol());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_originalcontrolnumber(from._internal_originalcontrolnumber());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_originalsaleconditionmodifier()->::data::SaleConditionModifier::MergeFrom(
          from._internal_originalsaleconditionmodifier());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.marketcenteridentifier_ = from._impl_.marketcenteridentifier_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.securityclass_ = from._impl_.securityclass_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.originaltradeprice_ = from._impl_.originaltradeprice_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.originaltradesize_ = from._impl_.originaltradesize_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.consolidatedvolume_ = from._impl_.consolidatedvolume_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TradeCancelForNonNextSharesTrades::CopyFrom(const TradeCancelForNonNextSharesTrades& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:data.TradeCancelForNonNextSharesTrades)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TradeCancelForNonNextSharesTrades::IsInitialized() const {
  return true;
}

void TradeCancelForNonNextSharesTrades::InternalSwap(TradeCancelForNonNextSharesTrades* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.issuesymbol_, lhs_arena,
      &other->_impl_.issuesymbol_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.originalcontrolnumber_, lhs_arena,
      &other->_impl_.originalcontrolnumber_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TradeCancelForNonNextSharesTrades, _impl_.consolidatedvolume_)
      + sizeof(TradeCancelForNonNextSharesTrades::_impl_.consolidatedvolume_)
      - PROTOBUF_FIELD_OFFSET(TradeCancelForNonNextSharesTrades, _impl_.originalsaleconditionmodifier_)>(
          reinterpret_cast<char*>(&_impl_.originalsaleconditionmodifier_),
          reinterpret_cast<char*>(&other->_impl_.originalsaleconditionmodifier_));
}

::PROTOBUF_NAMESPACE_ID::Metadata TradeCancelForNonNextSharesTrades::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_data_2eproto_getter, &descriptor_table_data_2eproto_once,
      file_level_metadata_data_2eproto[15]);
}

// ===================================================================

class TradeCorrectionForNextsharesTrades::_Internal {
 public:
  using HasBits = decltype(std::declval<TradeCorrectionForNextsharesTrades>()._impl_._has_bits_);
  static void set_has_marketcenteridentifier(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_issuesymbol(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_securityclass(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_originalcontrolnumber(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_originalproxyprice(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_originalnavoffsetamount(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_originaltradesize(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_originalconditionmodifier(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_correctedtradecontrolnumber(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_correctedtradeprice(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_correctednavoffsetamount(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_correctedtradesize(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_correctedsaleconditionmodifier(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_consolidatedvolume(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
};

TradeCorrectionForNextsharesTrades::TradeCorrectionForNextsharesTrades(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:data.TradeCorrectionForNextsharesTrades)
}
TradeCorrectionForNextsharesTrades::TradeCorrectionForNextsharesTrades(const TradeCorrectionForNextsharesTrades& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TradeCorrectionForNextsharesTrades* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.issuesymbol_){}
    , decltype(_impl_.originalcontrolnumber_){}
    , decltype(_impl_.originalconditionmodifier_){}
    , decltype(_impl_.correctedtradecontrolnumber_){}
    , decltype(_impl_.correctedsaleconditionmodifier_){}
    , decltype(_impl_.marketcenteridentifier_){}
    , decltype(_impl_.securityclass_){}
    , decltype(_impl_.originalproxyprice_){}
    , decltype(_impl_.originalnavoffsetamount_){}
    , decltype(_impl_.originaltradesize_){}
    , decltype(_impl_.correctedtradeprice_){}
    , decltype(_impl_.correctednavoffsetamount_){}
    , decltype(_impl_.correctedtradesize_){}
    , decltype(_impl_.consolidatedvolume_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.issuesymbol_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.issuesymbol_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_issuesymbol()) {
    _this->_impl_.issuesymbol_.Set(from._internal_issuesymbol(), 
      _this->GetArenaForAllocation());
  }
  _impl_.originalcontrolnumber_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.originalcontrolnumber_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_originalcontrolnumber()) {
    _this->_impl_.originalcontrolnumber_.Set(from._internal_originalcontrolnumber(), 
      _this->GetArenaForAllocation());
  }
  _impl_.originalconditionmodifier_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.originalconditionmodifier_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_originalconditionmodifier()) {
    _this->_impl_.originalconditionmodifier_.Set(from._internal_originalconditionmodifier(), 
      _this->GetArenaForAllocation());
  }
  _impl_.correctedtradecontrolnumber_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.correctedtradecontrolnumber_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_correctedtradecontrolnumber()) {
    _this->_impl_.correctedtradecontrolnumber_.Set(from._internal_correctedtradecontrolnumber(), 
      _this->GetArenaForAllocation());
  }
  _impl_.correctedsaleconditionmodifier_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.correctedsaleconditionmodifier_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_correctedsaleconditionmodifier()) {
    _this->_impl_.correctedsaleconditionmodifier_.Set(from._internal_correctedsaleconditionmodifier(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.marketcenteridentifier_, &from._impl_.marketcenteridentifier_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.consolidatedvolume_) -
    reinterpret_cast<char*>(&_impl_.marketcenteridentifier_)) + sizeof(_impl_.consolidatedvolume_));
  // @@protoc_insertion_point(copy_constructor:data.TradeCorrectionForNextsharesTrades)
}

inline void TradeCorrectionForNextsharesTrades::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.issuesymbol_){}
    , decltype(_impl_.originalcontrolnumber_){}
    , decltype(_impl_.originalconditionmodifier_){}
    , decltype(_impl_.correctedtradecontrolnumber_){}
    , decltype(_impl_.correctedsaleconditionmodifier_){}
    , decltype(_impl_.marketcenteridentifier_){0}
    , decltype(_impl_.securityclass_){0}
    , decltype(_impl_.originalproxyprice_){0}
    , decltype(_impl_.originalnavoffsetamount_){0}
    , decltype(_impl_.originaltradesize_){int64_t{0}}
    , decltype(_impl_.correctedtradeprice_){0}
    , decltype(_impl_.correctednavoffsetamount_){0}
    , decltype(_impl_.correctedtradesize_){int64_t{0}}
    , decltype(_impl_.consolidatedvolume_){int64_t{0}}
  };
  _impl_.issuesymbol_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.issuesymbol_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.originalcontrolnumber_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.originalcontrolnumber_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.originalconditionmodifier_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.originalconditionmodifier_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.correctedtradecontrolnumber_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.correctedtradecontrolnumber_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.correctedsaleconditionmodifier_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.correctedsaleconditionmodifier_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

TradeCorrectionForNextsharesTrades::~TradeCorrectionForNextsharesTrades() {
  // @@protoc_insertion_point(destructor:data.TradeCorrectionForNextsharesTrades)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TradeCorrectionForNextsharesTrades::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.issuesymbol_.Destroy();
  _impl_.originalcontrolnumber_.Destroy();
  _impl_.originalconditionmodifier_.Destroy();
  _impl_.correctedtradecontrolnumber_.Destroy();
  _impl_.correctedsaleconditionmodifier_.Destroy();
}

void TradeCorrectionForNextsharesTrades::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TradeCorrectionForNextsharesTrades::Clear() {
// @@protoc_insertion_point(message_clear_start:data.TradeCorrectionForNextsharesTrades)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.issuesymbol_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.originalcontrolnumber_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.originalconditionmodifier_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.correctedtradecontrolnumber_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      _impl_.correctedsaleconditionmodifier_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x000000e0u) {
    ::memset(&_impl_.marketcenteridentifier_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.originalproxyprice_) -
        reinterpret_cast<char*>(&_impl_.marketcenteridentifier_)) + sizeof(_impl_.originalproxyprice_));
  }
  if (cached_has_bits & 0x00003f00u) {
    ::memset(&_impl_.originalnavoffsetamount_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.consolidatedvolume_) -
        reinterpret_cast<char*>(&_impl_.originalnavoffsetamount_)) + sizeof(_impl_.consolidatedvolume_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TradeCorrectionForNextsharesTrades::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .data.OriginatingMarketCenterIdentifier marketCenterIdentifier = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_marketcenteridentifier(static_cast<::data::OriginatingMarketCenterIdentifier>(val));
        } else
          goto handle_unusual;
        continue;
      // optional string issueSymbol = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_issuesymbol();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "data.TradeCorrectionForNextsharesTrades.issueSymbol"));
        } else
          goto handle_unusual;
        continue;
      // optional .data.SecurityClass securityClass = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_securityclass(static_cast<::data::SecurityClass>(val));
        } else
          goto handle_unusual;
        continue;
      // optional string originalControlNumber = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_originalcontrolnumber();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "data.TradeCorrectionForNextsharesTrades.originalControlNumber"));
        } else
          goto handle_unusual;
        continue;
      // optional double originalProxyPrice = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 41)) {
          _Internal::set_has_originalproxyprice(&has_bits);
          _impl_.originalproxyprice_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double originalNAVOffsetAmount = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 49)) {
          _Internal::set_has_originalnavoffsetamount(&has_bits);
          _impl_.originalnavoffsetamount_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional int64 originalTradeSize = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_originaltradesize(&has_bits);
          _impl_.originaltradesize_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string originalConditionModifier = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          auto str = _internal_mutable_originalconditionmodifier();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "data.TradeCorrectionForNextsharesTrades.originalConditionModifier"));
        } else
          goto handle_unusual;
        continue;
      // optional string correctedTradeControlNumber = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          auto str = _internal_mutable_correctedtradecontrolnumber();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "data.TradeCorrectionForNextsharesTrades.correctedTradeControlNumber"));
        } else
          goto handle_unusual;
        continue;
      // optional double correctedTradePrice = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 81)) {
          _Internal::set_has_correctedtradeprice(&has_bits);
          _impl_.correctedtradeprice_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double correctedNAVOffsetAmount = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 89)) {
          _Internal::set_has_correctednavoffsetamount(&has_bits);
          _impl_.correctednavoffsetamount_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional int64 CorrectedTradeSize = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _Internal::set_has_correctedtradesize(&has_bits);
          _impl_.correctedtradesize_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string CorrectedSaleConditionModifier = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
          auto str = _internal_mutable_correctedsaleconditionmodifier();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "data.TradeCorrectionForNextsharesTrades.CorrectedSaleConditionModifier"));
        } else
          goto handle_unusual;
        continue;
      // optional int64 consolidatedVolume = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
          _Internal::set_has_consolidatedvolume(&has_bits);
          _impl_.consolidatedvolume_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TradeCorrectionForNextsharesTrades::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:data.TradeCorrectionForNextsharesTrades)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional .data.OriginatingMarketCenterIdentifier marketCenterIdentifier = 1;
  if (_internal_has_marketcenteridentifier()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_marketcenteridentifier(), target);
  }

  // optional string issueSymbol = 2;
  if (_internal_has_issuesymbol()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_issuesymbol().data(), static_cast<int>(this->_internal_issuesymbol().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "data.TradeCorrectionForNextsharesTrades.issueSymbol");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_issuesymbol(), target);
  }

  // optional .data.SecurityClass securityClass = 3;
  if (_internal_has_securityclass()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      3, this->_internal_securityclass(), target);
  }

  // optional string originalControlNumber = 4;
  if (_internal_has_originalcontrolnumber()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_originalcontrolnumber().data(), static_cast<int>(this->_internal_originalcontrolnumber().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "data.TradeCorrectionForNextsharesTrades.originalControlNumber");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_originalcontrolnumber(), target);
  }

  // optional double originalProxyPrice = 5;
  if (_internal_has_originalproxyprice()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(5, this->_internal_originalproxyprice(), target);
  }

  // optional double originalNAVOffsetAmount = 6;
  if (_internal_has_originalnavoffsetamount()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(6, this->_internal_originalnavoffsetamount(), target);
  }

  // optional int64 originalTradeSize = 7;
  if (_internal_has_originaltradesize()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(7, this->_internal_originaltradesize(), target);
  }

  // optional string originalConditionModifier = 8;
  if (_internal_has_originalconditionmodifier()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_originalconditionmodifier().data(), static_cast<int>(this->_internal_originalconditionmodifier().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "data.TradeCorrectionForNextsharesTrades.originalConditionModifier");
    target = stream->WriteStringMaybeAliased(
        8, this->_internal_originalconditionmodifier(), target);
  }

  // optional string correctedTradeControlNumber = 9;
  if (_internal_has_correctedtradecontrolnumber()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_correctedtradecontrolnumber().data(), static_cast<int>(this->_internal_correctedtradecontrolnumber().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "data.TradeCorrectionForNextsharesTrades.correctedTradeControlNumber");
    target = stream->WriteStringMaybeAliased(
        9, this->_internal_correctedtradecontrolnumber(), target);
  }

  // optional double correctedTradePrice = 10;
  if (_internal_has_correctedtradeprice()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(10, this->_internal_correctedtradeprice(), target);
  }

  // optional double correctedNAVOffsetAmount = 11;
  if (_internal_has_correctednavoffsetamount()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(11, this->_internal_correctednavoffsetamount(), target);
  }

  // optional int64 CorrectedTradeSize = 12;
  if (_internal_has_correctedtradesize()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(12, this->_internal_correctedtradesize(), target);
  }

  // optional string CorrectedSaleConditionModifier = 13;
  if (_internal_has_correctedsaleconditionmodifier()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_correctedsaleconditionmodifier().data(), static_cast<int>(this->_internal_correctedsaleconditionmodifier().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "data.TradeCorrectionForNextsharesTrades.CorrectedSaleConditionModifier");
    target = stream->WriteStringMaybeAliased(
        13, this->_internal_correctedsaleconditionmodifier(), target);
  }

  // optional int64 consolidatedVolume = 14;
  if (_internal_has_consolidatedvolume()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(14, this->_internal_consolidatedvolume(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:data.TradeCorrectionForNextsharesTrades)
  return target;
}

size_t TradeCorrectionForNextsharesTrades::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:data.TradeCorrectionForNextsharesTrades)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string issueSymbol = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_issuesymbol());
    }

    // optional string originalControlNumber = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_originalcontrolnumber());
    }

    // optional string originalConditionModifier = 8;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_originalconditionmodifier());
    }

    // optional string correctedTradeControlNumber = 9;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_correctedtradecontrolnumber());
    }

    // optional string CorrectedSaleConditionModifier = 13;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_correctedsaleconditionmodifier());
    }

    // optional .data.OriginatingMarketCenterIdentifier marketCenterIdentifier = 1;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_marketcenteridentifier());
    }

    // optional .data.SecurityClass securityClass = 3;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_securityclass());
    }

    // optional double originalProxyPrice = 5;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 8;
    }

  }
  if (cached_has_bits & 0x00003f00u) {
    // optional double originalNAVOffsetAmount = 6;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 + 8;
    }

    // optional int64 originalTradeSize = 7;
    if (cached_has_bits & 0x00000200u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_originaltradesize());
    }

    // optional double correctedTradePrice = 10;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 + 8;
    }

    // optional double correctedNAVOffsetAmount = 11;
    if (cached_has_bits & 0x00000800u) {
      total_size += 1 + 8;
    }

    // optional int64 CorrectedTradeSize = 12;
    if (cached_has_bits & 0x00001000u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_correctedtradesize());
    }

    // optional int64 consolidatedVolume = 14;
    if (cached_has_bits & 0x00002000u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_consolidatedvolume());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TradeCorrectionForNextsharesTrades::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TradeCorrectionForNextsharesTrades::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TradeCorrectionForNextsharesTrades::GetClassData() const { return &_class_data_; }


void TradeCorrectionForNextsharesTrades::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TradeCorrectionForNextsharesTrades*>(&to_msg);
  auto& from = static_cast<const TradeCorrectionForNextsharesTrades&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:data.TradeCorrectionForNextsharesTrades)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_issuesymbol(from._internal_issuesymbol());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_originalcontrolnumber(from._internal_originalcontrolnumber());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_originalconditionmodifier(from._internal_originalconditionmodifier());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_set_correctedtradecontrolnumber(from._internal_correctedtradecontrolnumber());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_set_correctedsaleconditionmodifier(from._internal_correctedsaleconditionmodifier());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.marketcenteridentifier_ = from._impl_.marketcenteridentifier_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.securityclass_ = from._impl_.securityclass_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.originalproxyprice_ = from._impl_.originalproxyprice_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00003f00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.originalnavoffsetamount_ = from._impl_.originalnavoffsetamount_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.originaltradesize_ = from._impl_.originaltradesize_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.correctedtradeprice_ = from._impl_.correctedtradeprice_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.correctednavoffsetamount_ = from._impl_.correctednavoffsetamount_;
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_impl_.correctedtradesize_ = from._impl_.correctedtradesize_;
    }
    if (cached_has_bits & 0x00002000u) {
      _this->_impl_.consolidatedvolume_ = from._impl_.consolidatedvolume_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TradeCorrectionForNextsharesTrades::CopyFrom(const TradeCorrectionForNextsharesTrades& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:data.TradeCorrectionForNextsharesTrades)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TradeCorrectionForNextsharesTrades::IsInitialized() const {
  return true;
}

void TradeCorrectionForNextsharesTrades::InternalSwap(TradeCorrectionForNextsharesTrades* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.issuesymbol_, lhs_arena,
      &other->_impl_.issuesymbol_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.originalcontrolnumber_, lhs_arena,
      &other->_impl_.originalcontrolnumber_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.originalconditionmodifier_, lhs_arena,
      &other->_impl_.originalconditionmodifier_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.correctedtradecontrolnumber_, lhs_arena,
      &other->_impl_.correctedtradecontrolnumber_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.correctedsaleconditionmodifier_, lhs_arena,
      &other->_impl_.correctedsaleconditionmodifier_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TradeCorrectionForNextsharesTrades, _impl_.consolidatedvolume_)
      + sizeof(TradeCorrectionForNextsharesTrades::_impl_.consolidatedvolume_)
      - PROTOBUF_FIELD_OFFSET(TradeCorrectionForNextsharesTrades, _impl_.marketcenteridentifier_)>(
          reinterpret_cast<char*>(&_impl_.marketcenteridentifier_),
          reinterpret_cast<char*>(&other->_impl_.marketcenteridentifier_));
}

::PROTOBUF_NAMESPACE_ID::Metadata TradeCorrectionForNextsharesTrades::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_data_2eproto_getter, &descriptor_table_data_2eproto_once,
      file_level_metadata_data_2eproto[16]);
}

// ===================================================================

class TradeCorrectionForNonNextsharesTrades::_Internal {
 public:
  using HasBits = decltype(std::declval<TradeCorrectionForNonNextsharesTrades>()._impl_._has_bits_);
  static void set_has_marketcenteridentifier(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_issuesymbol(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_securityclass(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_originalcontrolnumber(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_originaltradeprice(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_originaltradesize(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_originalconditionmodifier(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_correctedtradecontrolnumber(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_correctedtradeprice(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_correctedtradesize(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_correctedsaleconditionmodifier(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_consolidatedvolume(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
};

TradeCorrectionForNonNextsharesTrades::TradeCorrectionForNonNextsharesTrades(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:data.TradeCorrectionForNonNextsharesTrades)
}
TradeCorrectionForNonNextsharesTrades::TradeCorrectionForNonNextsharesTrades(const TradeCorrectionForNonNextsharesTrades& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TradeCorrectionForNonNextsharesTrades* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.issuesymbol_){}
    , decltype(_impl_.originalcontrolnumber_){}
    , decltype(_impl_.originalconditionmodifier_){}
    , decltype(_impl_.correctedtradecontrolnumber_){}
    , decltype(_impl_.correctedsaleconditionmodifier_){}
    , decltype(_impl_.marketcenteridentifier_){}
    , decltype(_impl_.securityclass_){}
    , decltype(_impl_.originaltradeprice_){}
    , decltype(_impl_.originaltradesize_){}
    , decltype(_impl_.correctedtradeprice_){}
    , decltype(_impl_.correctedtradesize_){}
    , decltype(_impl_.consolidatedvolume_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.issuesymbol_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.issuesymbol_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_issuesymbol()) {
    _this->_impl_.issuesymbol_.Set(from._internal_issuesymbol(), 
      _this->GetArenaForAllocation());
  }
  _impl_.originalcontrolnumber_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.originalcontrolnumber_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_originalcontrolnumber()) {
    _this->_impl_.originalcontrolnumber_.Set(from._internal_originalcontrolnumber(), 
      _this->GetArenaForAllocation());
  }
  _impl_.originalconditionmodifier_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.originalconditionmodifier_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_originalconditionmodifier()) {
    _this->_impl_.originalconditionmodifier_.Set(from._internal_originalconditionmodifier(), 
      _this->GetArenaForAllocation());
  }
  _impl_.correctedtradecontrolnumber_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.correctedtradecontrolnumber_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_correctedtradecontrolnumber()) {
    _this->_impl_.correctedtradecontrolnumber_.Set(from._internal_correctedtradecontrolnumber(), 
      _this->GetArenaForAllocation());
  }
  _impl_.correctedsaleconditionmodifier_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.correctedsaleconditionmodifier_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_correctedsaleconditionmodifier()) {
    _this->_impl_.correctedsaleconditionmodifier_.Set(from._internal_correctedsaleconditionmodifier(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.marketcenteridentifier_, &from._impl_.marketcenteridentifier_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.consolidatedvolume_) -
    reinterpret_cast<char*>(&_impl_.marketcenteridentifier_)) + sizeof(_impl_.consolidatedvolume_));
  // @@protoc_insertion_point(copy_constructor:data.TradeCorrectionForNonNextsharesTrades)
}

inline void TradeCorrectionForNonNextsharesTrades::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.issuesymbol_){}
    , decltype(_impl_.originalcontrolnumber_){}
    , decltype(_impl_.originalconditionmodifier_){}
    , decltype(_impl_.correctedtradecontrolnumber_){}
    , decltype(_impl_.correctedsaleconditionmodifier_){}
    , decltype(_impl_.marketcenteridentifier_){0}
    , decltype(_impl_.securityclass_){0}
    , decltype(_impl_.originaltradeprice_){0}
    , decltype(_impl_.originaltradesize_){int64_t{0}}
    , decltype(_impl_.correctedtradeprice_){0}
    , decltype(_impl_.correctedtradesize_){int64_t{0}}
    , decltype(_impl_.consolidatedvolume_){int64_t{0}}
  };
  _impl_.issuesymbol_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.issuesymbol_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.originalcontrolnumber_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.originalcontrolnumber_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.originalconditionmodifier_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.originalconditionmodifier_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.correctedtradecontrolnumber_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.correctedtradecontrolnumber_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.correctedsaleconditionmodifier_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.correctedsaleconditionmodifier_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

TradeCorrectionForNonNextsharesTrades::~TradeCorrectionForNonNextsharesTrades() {
  // @@protoc_insertion_point(destructor:data.TradeCorrectionForNonNextsharesTrades)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TradeCorrectionForNonNextsharesTrades::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.issuesymbol_.Destroy();
  _impl_.originalcontrolnumber_.Destroy();
  _impl_.originalconditionmodifier_.Destroy();
  _impl_.correctedtradecontrolnumber_.Destroy();
  _impl_.correctedsaleconditionmodifier_.Destroy();
}

void TradeCorrectionForNonNextsharesTrades::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TradeCorrectionForNonNextsharesTrades::Clear() {
// @@protoc_insertion_point(message_clear_start:data.TradeCorrectionForNonNextsharesTrades)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.issuesymbol_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.originalcontrolnumber_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.originalconditionmodifier_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.correctedtradecontrolnumber_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      _impl_.correctedsaleconditionmodifier_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x000000e0u) {
    ::memset(&_impl_.marketcenteridentifier_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.originaltradeprice_) -
        reinterpret_cast<char*>(&_impl_.marketcenteridentifier_)) + sizeof(_impl_.originaltradeprice_));
  }
  if (cached_has_bits & 0x00000f00u) {
    ::memset(&_impl_.originaltradesize_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.consolidatedvolume_) -
        reinterpret_cast<char*>(&_impl_.originaltradesize_)) + sizeof(_impl_.consolidatedvolume_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TradeCorrectionForNonNextsharesTrades::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .data.OriginatingMarketCenterIdentifier marketCenterIdentifier = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_marketcenteridentifier(static_cast<::data::OriginatingMarketCenterIdentifier>(val));
        } else
          goto handle_unusual;
        continue;
      // optional string issueSymbol = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_issuesymbol();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "data.TradeCorrectionForNonNextsharesTrades.issueSymbol"));
        } else
          goto handle_unusual;
        continue;
      // optional .data.SecurityClass securityClass = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_securityclass(static_cast<::data::SecurityClass>(val));
        } else
          goto handle_unusual;
        continue;
      // optional string originalControlNumber = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_originalcontrolnumber();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "data.TradeCorrectionForNonNextsharesTrades.originalControlNumber"));
        } else
          goto handle_unusual;
        continue;
      // optional double originalTradePrice = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 41)) {
          _Internal::set_has_originaltradeprice(&has_bits);
          _impl_.originaltradeprice_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional int64 originalTradeSize = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_originaltradesize(&has_bits);
          _impl_.originaltradesize_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string originalConditionModifier = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_originalconditionmodifier();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "data.TradeCorrectionForNonNextsharesTrades.originalConditionModifier"));
        } else
          goto handle_unusual;
        continue;
      // optional string correctedTradeControlNumber = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          auto str = _internal_mutable_correctedtradecontrolnumber();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "data.TradeCorrectionForNonNextsharesTrades.correctedTradeControlNumber"));
        } else
          goto handle_unusual;
        continue;
      // optional double correctedTradePrice = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 73)) {
          _Internal::set_has_correctedtradeprice(&has_bits);
          _impl_.correctedtradeprice_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional int64 CorrectedTradeSize = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_correctedtradesize(&has_bits);
          _impl_.correctedtradesize_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string CorrectedSaleConditionModifier = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          auto str = _internal_mutable_correctedsaleconditionmodifier();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "data.TradeCorrectionForNonNextsharesTrades.CorrectedSaleConditionModifier"));
        } else
          goto handle_unusual;
        continue;
      // optional int64 consolidatedVolume = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _Internal::set_has_consolidatedvolume(&has_bits);
          _impl_.consolidatedvolume_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TradeCorrectionForNonNextsharesTrades::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:data.TradeCorrectionForNonNextsharesTrades)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional .data.OriginatingMarketCenterIdentifier marketCenterIdentifier = 1;
  if (_internal_has_marketcenteridentifier()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_marketcenteridentifier(), target);
  }

  // optional string issueSymbol = 2;
  if (_internal_has_issuesymbol()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_issuesymbol().data(), static_cast<int>(this->_internal_issuesymbol().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "data.TradeCorrectionForNonNextsharesTrades.issueSymbol");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_issuesymbol(), target);
  }

  // optional .data.SecurityClass securityClass = 3;
  if (_internal_has_securityclass()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      3, this->_internal_securityclass(), target);
  }

  // optional string originalControlNumber = 4;
  if (_internal_has_originalcontrolnumber()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_originalcontrolnumber().data(), static_cast<int>(this->_internal_originalcontrolnumber().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "data.TradeCorrectionForNonNextsharesTrades.originalControlNumber");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_originalcontrolnumber(), target);
  }

  // optional double originalTradePrice = 5;
  if (_internal_has_originaltradeprice()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(5, this->_internal_originaltradeprice(), target);
  }

  // optional int64 originalTradeSize = 6;
  if (_internal_has_originaltradesize()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(6, this->_internal_originaltradesize(), target);
  }

  // optional string originalConditionModifier = 7;
  if (_internal_has_originalconditionmodifier()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_originalconditionmodifier().data(), static_cast<int>(this->_internal_originalconditionmodifier().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "data.TradeCorrectionForNonNextsharesTrades.originalConditionModifier");
    target = stream->WriteStringMaybeAliased(
        7, this->_internal_originalconditionmodifier(), target);
  }

  // optional string correctedTradeControlNumber = 8;
  if (_internal_has_correctedtradecontrolnumber()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_correctedtradecontrolnumber().data(), static_cast<int>(this->_internal_correctedtradecontrolnumber().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "data.TradeCorrectionForNonNextsharesTrades.correctedTradeControlNumber");
    target = stream->WriteStringMaybeAliased(
        8, this->_internal_correctedtradecontrolnumber(), target);
  }

  // optional double correctedTradePrice = 9;
  if (_internal_has_correctedtradeprice()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(9, this->_internal_correctedtradeprice(), target);
  }

  // optional int64 CorrectedTradeSize = 10;
  if (_internal_has_correctedtradesize()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(10, this->_internal_correctedtradesize(), target);
  }

  // optional string CorrectedSaleConditionModifier = 11;
  if (_internal_has_correctedsaleconditionmodifier()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_correctedsaleconditionmodifier().data(), static_cast<int>(this->_internal_correctedsaleconditionmodifier().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "data.TradeCorrectionForNonNextsharesTrades.CorrectedSaleConditionModifier");
    target = stream->WriteStringMaybeAliased(
        11, this->_internal_correctedsaleconditionmodifier(), target);
  }

  // optional int64 consolidatedVolume = 12;
  if (_internal_has_consolidatedvolume()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(12, this->_internal_consolidatedvolume(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:data.TradeCorrectionForNonNextsharesTrades)
  return target;
}

size_t TradeCorrectionForNonNextsharesTrades::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:data.TradeCorrectionForNonNextsharesTrades)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string issueSymbol = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_issuesymbol());
    }

    // optional string originalControlNumber = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_originalcontrolnumber());
    }

    // optional string originalConditionModifier = 7;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_originalconditionmodifier());
    }

    // optional string correctedTradeControlNumber = 8;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_correctedtradecontrolnumber());
    }

    // optional string CorrectedSaleConditionModifier = 11;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_correctedsaleconditionmodifier());
    }

    // optional .data.OriginatingMarketCenterIdentifier marketCenterIdentifier = 1;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_marketcenteridentifier());
    }

    // optional .data.SecurityClass securityClass = 3;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_securityclass());
    }

    // optional double originalTradePrice = 5;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 8;
    }

  }
  if (cached_has_bits & 0x00000f00u) {
    // optional int64 originalTradeSize = 6;
    if (cached_has_bits & 0x00000100u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_originaltradesize());
    }

    // optional double correctedTradePrice = 9;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 + 8;
    }

    // optional int64 CorrectedTradeSize = 10;
    if (cached_has_bits & 0x00000400u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_correctedtradesize());
    }

    // optional int64 consolidatedVolume = 12;
    if (cached_has_bits & 0x00000800u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_consolidatedvolume());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TradeCorrectionForNonNextsharesTrades::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TradeCorrectionForNonNextsharesTrades::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TradeCorrectionForNonNextsharesTrades::GetClassData() const { return &_class_data_; }


void TradeCorrectionForNonNextsharesTrades::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TradeCorrectionForNonNextsharesTrades*>(&to_msg);
  auto& from = static_cast<const TradeCorrectionForNonNextsharesTrades&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:data.TradeCorrectionForNonNextsharesTrades)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_issuesymbol(from._internal_issuesymbol());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_originalcontrolnumber(from._internal_originalcontrolnumber());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_originalconditionmodifier(from._internal_originalconditionmodifier());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_set_correctedtradecontrolnumber(from._internal_correctedtradecontrolnumber());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_set_correctedsaleconditionmodifier(from._internal_correctedsaleconditionmodifier());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.marketcenteridentifier_ = from._impl_.marketcenteridentifier_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.securityclass_ = from._impl_.securityclass_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.originaltradeprice_ = from._impl_.originaltradeprice_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000f00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.originaltradesize_ = from._impl_.originaltradesize_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.correctedtradeprice_ = from._impl_.correctedtradeprice_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.correctedtradesize_ = from._impl_.correctedtradesize_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.consolidatedvolume_ = from._impl_.consolidatedvolume_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TradeCorrectionForNonNextsharesTrades::CopyFrom(const TradeCorrectionForNonNextsharesTrades& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:data.TradeCorrectionForNonNextsharesTrades)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TradeCorrectionForNonNextsharesTrades::IsInitialized() const {
  return true;
}

void TradeCorrectionForNonNextsharesTrades::InternalSwap(TradeCorrectionForNonNextsharesTrades* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.issuesymbol_, lhs_arena,
      &other->_impl_.issuesymbol_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.originalcontrolnumber_, lhs_arena,
      &other->_impl_.originalcontrolnumber_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.originalconditionmodifier_, lhs_arena,
      &other->_impl_.originalconditionmodifier_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.correctedtradecontrolnumber_, lhs_arena,
      &other->_impl_.correctedtradecontrolnumber_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.correctedsaleconditionmodifier_, lhs_arena,
      &other->_impl_.correctedsaleconditionmodifier_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TradeCorrectionForNonNextsharesTrades, _impl_.consolidatedvolume_)
      + sizeof(TradeCorrectionForNonNextsharesTrades::_impl_.consolidatedvolume_)
      - PROTOBUF_FIELD_OFFSET(TradeCorrectionForNonNextsharesTrades, _impl_.marketcenteridentifier_)>(
          reinterpret_cast<char*>(&_impl_.marketcenteridentifier_),
          reinterpret_cast<char*>(&other->_impl_.marketcenteridentifier_));
}

::PROTOBUF_NAMESPACE_ID::Metadata TradeCorrectionForNonNextsharesTrades::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_data_2eproto_getter, &descriptor_table_data_2eproto_once,
      file_level_metadata_data_2eproto[17]);
}

// ===================================================================

class TradeReportForNextshares::_Internal {
 public:
  using HasBits = decltype(std::declval<TradeReportForNextshares>()._impl_._has_bits_);
  static void set_has_originatingmarketcenteridentifier(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_nextsharessymbol(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_securityclass(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_tradecontrolnumber(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_proxyprice(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_tradesize(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_navoffsetamount(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static const ::data::SaleConditionModifier& saleconditionmodifier(const TradeReportForNextshares* msg);
  static void set_has_saleconditionmodifier(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_consolidatedvolume(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
};

const ::data::SaleConditionModifier&
TradeReportForNextshares::_Internal::saleconditionmodifier(const TradeReportForNextshares* msg) {
  return *msg->_impl_.saleconditionmodifier_;
}
TradeReportForNextshares::TradeReportForNextshares(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:data.TradeReportForNextshares)
}
TradeReportForNextshares::TradeReportForNextshares(const TradeReportForNextshares& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TradeReportForNextshares* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.nextsharessymbol_){}
    , decltype(_impl_.tradecontrolnumber_){}
    , decltype(_impl_.saleconditionmodifier_){nullptr}
    , decltype(_impl_.originatingmarketcenteridentifier_){}
    , decltype(_impl_.securityclass_){}
    , decltype(_impl_.proxyprice_){}
    , decltype(_impl_.tradesize_){}
    , decltype(_impl_.navoffsetamount_){}
    , decltype(_impl_.consolidatedvolume_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.nextsharessymbol_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.nextsharessymbol_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_nextsharessymbol()) {
    _this->_impl_.nextsharessymbol_.Set(from._internal_nextsharessymbol(), 
      _this->GetArenaForAllocation());
  }
  _impl_.tradecontrolnumber_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.tradecontrolnumber_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_tradecontrolnumber()) {
    _this->_impl_.tradecontrolnumber_.Set(from._internal_tradecontrolnumber(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_saleconditionmodifier()) {
    _this->_impl_.saleconditionmodifier_ = new ::data::SaleConditionModifier(*from._impl_.saleconditionmodifier_);
  }
  ::memcpy(&_impl_.originatingmarketcenteridentifier_, &from._impl_.originatingmarketcenteridentifier_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.consolidatedvolume_) -
    reinterpret_cast<char*>(&_impl_.originatingmarketcenteridentifier_)) + sizeof(_impl_.consolidatedvolume_));
  // @@protoc_insertion_point(copy_constructor:data.TradeReportForNextshares)
}

inline void TradeReportForNextshares::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.nextsharessymbol_){}
    , decltype(_impl_.tradecontrolnumber_){}
    , decltype(_impl_.saleconditionmodifier_){nullptr}
    , decltype(_impl_.originatingmarketcenteridentifier_){0}
    , decltype(_impl_.securityclass_){0}
    , decltype(_impl_.proxyprice_){0}
    , decltype(_impl_.tradesize_){int64_t{0}}
    , decltype(_impl_.navoffsetamount_){0}
    , decltype(_impl_.consolidatedvolume_){0}
  };
  _impl_.nextsharessymbol_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.nextsharessymbol_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.tradecontrolnumber_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.tradecontrolnumber_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

TradeReportForNextshares::~TradeReportForNextshares() {
  // @@protoc_insertion_point(destructor:data.TradeReportForNextshares)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TradeReportForNextshares::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.nextsharessymbol_.Destroy();
  _impl_.tradecontrolnumber_.Destroy();
  if (this != internal_default_instance()) delete _impl_.saleconditionmodifier_;
}

void TradeReportForNextshares::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TradeReportForNextshares::Clear() {
// @@protoc_insertion_point(message_clear_start:data.TradeReportForNextshares)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.nextsharessymbol_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.tradecontrolnumber_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.saleconditionmodifier_ != nullptr);
      _impl_.saleconditionmodifier_->Clear();
    }
  }
  if (cached_has_bits & 0x000000f8u) {
    ::memset(&_impl_.originatingmarketcenteridentifier_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.navoffsetamount_) -
        reinterpret_cast<char*>(&_impl_.originatingmarketcenteridentifier_)) + sizeof(_impl_.navoffsetamount_));
  }
  _impl_.consolidatedvolume_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TradeReportForNextshares::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .data.OriginatingMarketCenterIdentifier originatingMarketCenterIdentifier = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_originatingmarketcenteridentifier(static_cast<::data::OriginatingMarketCenterIdentifier>(val));
        } else
          goto handle_unusual;
        continue;
      // optional string nextsharesSymbol = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_nextsharessymbol();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "data.TradeReportForNextshares.nextsharesSymbol"));
        } else
          goto handle_unusual;
        continue;
      // optional .data.SecurityClass securityClass = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_securityclass(static_cast<::data::SecurityClass>(val));
        } else
          goto handle_unusual;
        continue;
      // optional string tradeControlNumber = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_tradecontrolnumber();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "data.TradeReportForNextshares.tradeControlNumber"));
        } else
          goto handle_unusual;
        continue;
      // optional double proxyPrice = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 41)) {
          _Internal::set_has_proxyprice(&has_bits);
          _impl_.proxyprice_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional int64 tradeSize = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_tradesize(&has_bits);
          _impl_.tradesize_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional double NAVOffsetAmount = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 57)) {
          _Internal::set_has_navoffsetamount(&has_bits);
          _impl_.navoffsetamount_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional .data.SaleConditionModifier saleConditionModifier = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_saleconditionmodifier(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 consolidatedVolume = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_consolidatedvolume(&has_bits);
          _impl_.consolidatedvolume_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TradeReportForNextshares::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:data.TradeReportForNextshares)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional .data.OriginatingMarketCenterIdentifier originatingMarketCenterIdentifier = 1;
  if (_internal_has_originatingmarketcenteridentifier()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_originatingmarketcenteridentifier(), target);
  }

  // optional string nextsharesSymbol = 2;
  if (_internal_has_nextsharessymbol()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_nextsharessymbol().data(), static_cast<int>(this->_internal_nextsharessymbol().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "data.TradeReportForNextshares.nextsharesSymbol");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_nextsharessymbol(), target);
  }

  // optional .data.SecurityClass securityClass = 3;
  if (_internal_has_securityclass()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      3, this->_internal_securityclass(), target);
  }

  // optional string tradeControlNumber = 4;
  if (_internal_has_tradecontrolnumber()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_tradecontrolnumber().data(), static_cast<int>(this->_internal_tradecontrolnumber().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "data.TradeReportForNextshares.tradeControlNumber");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_tradecontrolnumber(), target);
  }

  // optional double proxyPrice = 5;
  if (_internal_has_proxyprice()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(5, this->_internal_proxyprice(), target);
  }

  // optional int64 tradeSize = 6;
  if (_internal_has_tradesize()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(6, this->_internal_tradesize(), target);
  }

  // optional double NAVOffsetAmount = 7;
  if (_internal_has_navoffsetamount()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(7, this->_internal_navoffsetamount(), target);
  }

  // optional .data.SaleConditionModifier saleConditionModifier = 8;
  if (_internal_has_saleconditionmodifier()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(8, _Internal::saleconditionmodifier(this),
        _Internal::saleconditionmodifier(this).GetCachedSize(), target, stream);
  }

  // optional int32 consolidatedVolume = 9;
  if (_internal_has_consolidatedvolume()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(9, this->_internal_consolidatedvolume(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:data.TradeReportForNextshares)
  return target;
}

size_t TradeReportForNextshares::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:data.TradeReportForNextshares)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string nextsharesSymbol = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_nextsharessymbol());
    }

    // optional string tradeControlNumber = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_tradecontrolnumber());
    }

    // optional .data.SaleConditionModifier saleConditionModifier = 8;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.saleconditionmodifier_);
    }

    // optional .data.OriginatingMarketCenterIdentifier originatingMarketCenterIdentifier = 1;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_originatingmarketcenteridentifier());
    }

    // optional .data.SecurityClass securityClass = 3;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_securityclass());
    }

    // optional double proxyPrice = 5;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 8;
    }

    // optional int64 tradeSize = 6;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_tradesize());
    }

    // optional double NAVOffsetAmount = 7;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 8;
    }

  }
  // optional int32 consolidatedVolume = 9;
  if (cached_has_bits & 0x00000100u) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_consolidatedvolume());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TradeReportForNextshares::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TradeReportForNextshares::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TradeReportForNextshares::GetClassData() const { return &_class_data_; }


void TradeReportForNextshares::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TradeReportForNextshares*>(&to_msg);
  auto& from = static_cast<const TradeReportForNextshares&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:data.TradeReportForNextshares)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_nextsharessymbol(from._internal_nextsharessymbol());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_tradecontrolnumber(from._internal_tradecontrolnumber());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_saleconditionmodifier()->::data::SaleConditionModifier::MergeFrom(
          from._internal_saleconditionmodifier());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.originatingmarketcenteridentifier_ = from._impl_.originatingmarketcenteridentifier_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.securityclass_ = from._impl_.securityclass_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.proxyprice_ = from._impl_.proxyprice_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.tradesize_ = from._impl_.tradesize_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.navoffsetamount_ = from._impl_.navoffsetamount_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000100u) {
    _this->_internal_set_consolidatedvolume(from._internal_consolidatedvolume());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TradeReportForNextshares::CopyFrom(const TradeReportForNextshares& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:data.TradeReportForNextshares)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TradeReportForNextshares::IsInitialized() const {
  return true;
}

void TradeReportForNextshares::InternalSwap(TradeReportForNextshares* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.nextsharessymbol_, lhs_arena,
      &other->_impl_.nextsharessymbol_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.tradecontrolnumber_, lhs_arena,
      &other->_impl_.tradecontrolnumber_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TradeReportForNextshares, _impl_.consolidatedvolume_)
      + sizeof(TradeReportForNextshares::_impl_.consolidatedvolume_)
      - PROTOBUF_FIELD_OFFSET(TradeReportForNextshares, _impl_.saleconditionmodifier_)>(
          reinterpret_cast<char*>(&_impl_.saleconditionmodifier_),
          reinterpret_cast<char*>(&other->_impl_.saleconditionmodifier_));
}

::PROTOBUF_NAMESPACE_ID::Metadata TradeReportForNextshares::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_data_2eproto_getter, &descriptor_table_data_2eproto_once,
      file_level_metadata_data_2eproto[18]);
}

// ===================================================================

class TradeReportForNonNextshares::_Internal {
 public:
  using HasBits = decltype(std::declval<TradeReportForNonNextshares>()._impl_._has_bits_);
  static void set_has_originatingmarketcenteridentifier(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_issuesymbol(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_securityclass(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_tradecontrolnumber(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_tradeprice(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_tradesize(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static const ::data::SaleConditionModifier& saleconditionmodifier(const TradeReportForNonNextshares* msg);
  static void set_has_saleconditionmodifier(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_consolidatedvolume(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
};

const ::data::SaleConditionModifier&
TradeReportForNonNextshares::_Internal::saleconditionmodifier(const TradeReportForNonNextshares* msg) {
  return *msg->_impl_.saleconditionmodifier_;
}
TradeReportForNonNextshares::TradeReportForNonNextshares(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:data.TradeReportForNonNextshares)
}
TradeReportForNonNextshares::TradeReportForNonNextshares(const TradeReportForNonNextshares& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TradeReportForNonNextshares* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.issuesymbol_){}
    , decltype(_impl_.tradecontrolnumber_){}
    , decltype(_impl_.saleconditionmodifier_){nullptr}
    , decltype(_impl_.originatingmarketcenteridentifier_){}
    , decltype(_impl_.securityclass_){}
    , decltype(_impl_.tradeprice_){}
    , decltype(_impl_.tradesize_){}
    , decltype(_impl_.consolidatedvolume_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.issuesymbol_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.issuesymbol_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_issuesymbol()) {
    _this->_impl_.issuesymbol_.Set(from._internal_issuesymbol(), 
      _this->GetArenaForAllocation());
  }
  _impl_.tradecontrolnumber_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.tradecontrolnumber_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_tradecontrolnumber()) {
    _this->_impl_.tradecontrolnumber_.Set(from._internal_tradecontrolnumber(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_saleconditionmodifier()) {
    _this->_impl_.saleconditionmodifier_ = new ::data::SaleConditionModifier(*from._impl_.saleconditionmodifier_);
  }
  ::memcpy(&_impl_.originatingmarketcenteridentifier_, &from._impl_.originatingmarketcenteridentifier_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.consolidatedvolume_) -
    reinterpret_cast<char*>(&_impl_.originatingmarketcenteridentifier_)) + sizeof(_impl_.consolidatedvolume_));
  // @@protoc_insertion_point(copy_constructor:data.TradeReportForNonNextshares)
}

inline void TradeReportForNonNextshares::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.issuesymbol_){}
    , decltype(_impl_.tradecontrolnumber_){}
    , decltype(_impl_.saleconditionmodifier_){nullptr}
    , decltype(_impl_.originatingmarketcenteridentifier_){0}
    , decltype(_impl_.securityclass_){0}
    , decltype(_impl_.tradeprice_){0}
    , decltype(_impl_.tradesize_){int64_t{0}}
    , decltype(_impl_.consolidatedvolume_){int64_t{0}}
  };
  _impl_.issuesymbol_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.issuesymbol_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.tradecontrolnumber_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.tradecontrolnumber_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

TradeReportForNonNextshares::~TradeReportForNonNextshares() {
  // @@protoc_insertion_point(destructor:data.TradeReportForNonNextshares)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TradeReportForNonNextshares::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.issuesymbol_.Destroy();
  _impl_.tradecontrolnumber_.Destroy();
  if (this != internal_default_instance()) delete _impl_.saleconditionmodifier_;
}

void TradeReportForNonNextshares::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TradeReportForNonNextshares::Clear() {
// @@protoc_insertion_point(message_clear_start:data.TradeReportForNonNextshares)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.issuesymbol_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.tradecontrolnumber_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.saleconditionmodifier_ != nullptr);
      _impl_.saleconditionmodifier_->Clear();
    }
  }
  if (cached_has_bits & 0x000000f8u) {
    ::memset(&_impl_.originatingmarketcenteridentifier_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.consolidatedvolume_) -
        reinterpret_cast<char*>(&_impl_.originatingmarketcenteridentifier_)) + sizeof(_impl_.consolidatedvolume_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TradeReportForNonNextshares::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .data.OriginatingMarketCenterIdentifier originatingMarketCenterIdentifier = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_originatingmarketcenteridentifier(static_cast<::data::OriginatingMarketCenterIdentifier>(val));
        } else
          goto handle_unusual;
        continue;
      // optional string issueSymbol = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_issuesymbol();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "data.TradeReportForNonNextshares.issueSymbol"));
        } else
          goto handle_unusual;
        continue;
      // optional .data.SecurityClass securityClass = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_securityclass(static_cast<::data::SecurityClass>(val));
        } else
          goto handle_unusual;
        continue;
      // optional string tradeControlNumber = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_tradecontrolnumber();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "data.TradeReportForNonNextshares.tradeControlNumber"));
        } else
          goto handle_unusual;
        continue;
      // optional double tradePrice = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 41)) {
          _Internal::set_has_tradeprice(&has_bits);
          _impl_.tradeprice_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional int64 tradeSize = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_tradesize(&has_bits);
          _impl_.tradesize_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .data.SaleConditionModifier saleConditionModifier = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_saleconditionmodifier(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 consolidatedVolume = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_consolidatedvolume(&has_bits);
          _impl_.consolidatedvolume_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TradeReportForNonNextshares::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:data.TradeReportForNonNextshares)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional .data.OriginatingMarketCenterIdentifier originatingMarketCenterIdentifier = 1;
  if (_internal_has_originatingmarketcenteridentifier()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_originatingmarketcenteridentifier(), target);
  }

  // optional string issueSymbol = 2;
  if (_internal_has_issuesymbol()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_issuesymbol().data(), static_cast<int>(this->_internal_issuesymbol().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "data.TradeReportForNonNextshares.issueSymbol");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_issuesymbol(), target);
  }

  // optional .data.SecurityClass securityClass = 3;
  if (_internal_has_securityclass()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      3, this->_internal_securityclass(), target);
  }

  // optional string tradeControlNumber = 4;
  if (_internal_has_tradecontrolnumber()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_tradecontrolnumber().data(), static_cast<int>(this->_internal_tradecontrolnumber().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "data.TradeReportForNonNextshares.tradeControlNumber");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_tradecontrolnumber(), target);
  }

  // optional double tradePrice = 5;
  if (_internal_has_tradeprice()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(5, this->_internal_tradeprice(), target);
  }

  // optional int64 tradeSize = 6;
  if (_internal_has_tradesize()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(6, this->_internal_tradesize(), target);
  }

  // optional .data.SaleConditionModifier saleConditionModifier = 7;
  if (_internal_has_saleconditionmodifier()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::saleconditionmodifier(this),
        _Internal::saleconditionmodifier(this).GetCachedSize(), target, stream);
  }

  // optional int64 consolidatedVolume = 8;
  if (_internal_has_consolidatedvolume()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(8, this->_internal_consolidatedvolume(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:data.TradeReportForNonNextshares)
  return target;
}

size_t TradeReportForNonNextshares::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:data.TradeReportForNonNextshares)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string issueSymbol = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_issuesymbol());
    }

    // optional string tradeControlNumber = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_tradecontrolnumber());
    }

    // optional .data.SaleConditionModifier saleConditionModifier = 7;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.saleconditionmodifier_);
    }

    // optional .data.OriginatingMarketCenterIdentifier originatingMarketCenterIdentifier = 1;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_originatingmarketcenteridentifier());
    }

    // optional .data.SecurityClass securityClass = 3;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_securityclass());
    }

    // optional double tradePrice = 5;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 8;
    }

    // optional int64 tradeSize = 6;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_tradesize());
    }

    // optional int64 consolidatedVolume = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_consolidatedvolume());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TradeReportForNonNextshares::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TradeReportForNonNextshares::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TradeReportForNonNextshares::GetClassData() const { return &_class_data_; }


void TradeReportForNonNextshares::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TradeReportForNonNextshares*>(&to_msg);
  auto& from = static_cast<const TradeReportForNonNextshares&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:data.TradeReportForNonNextshares)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_issuesymbol(from._internal_issuesymbol());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_tradecontrolnumber(from._internal_tradecontrolnumber());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_saleconditionmodifier()->::data::SaleConditionModifier::MergeFrom(
          from._internal_saleconditionmodifier());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.originatingmarketcenteridentifier_ = from._impl_.originatingmarketcenteridentifier_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.securityclass_ = from._impl_.securityclass_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.tradeprice_ = from._impl_.tradeprice_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.tradesize_ = from._impl_.tradesize_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.consolidatedvolume_ = from._impl_.consolidatedvolume_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TradeReportForNonNextshares::CopyFrom(const TradeReportForNonNextshares& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:data.TradeReportForNonNextshares)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TradeReportForNonNextshares::IsInitialized() const {
  return true;
}

void TradeReportForNonNextshares::InternalSwap(TradeReportForNonNextshares* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.issuesymbol_, lhs_arena,
      &other->_impl_.issuesymbol_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.tradecontrolnumber_, lhs_arena,
      &other->_impl_.tradecontrolnumber_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TradeReportForNonNextshares, _impl_.consolidatedvolume_)
      + sizeof(TradeReportForNonNextshares::_impl_.consolidatedvolume_)
      - PROTOBUF_FIELD_OFFSET(TradeReportForNonNextshares, _impl_.saleconditionmodifier_)>(
          reinterpret_cast<char*>(&_impl_.saleconditionmodifier_),
          reinterpret_cast<char*>(&other->_impl_.saleconditionmodifier_));
}

::PROTOBUF_NAMESPACE_ID::Metadata TradeReportForNonNextshares::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_data_2eproto_getter, &descriptor_table_data_2eproto_once,
      file_level_metadata_data_2eproto[19]);
}

// ===================================================================

class QBBOMWCBBreachMessage::_Internal {
 public:
  using HasBits = decltype(std::declval<QBBOMWCBBreachMessage>()._impl_._has_bits_);
  static void set_has_breachedlevel(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

QBBOMWCBBreachMessage::QBBOMWCBBreachMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:data.QBBOMWCBBreachMessage)
}
QBBOMWCBBreachMessage::QBBOMWCBBreachMessage(const QBBOMWCBBreachMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  QBBOMWCBBreachMessage* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.breachedlevel_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.breachedlevel_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.breachedlevel_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_breachedlevel()) {
    _this->_impl_.breachedlevel_.Set(from._internal_breachedlevel(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:data.QBBOMWCBBreachMessage)
}

inline void QBBOMWCBBreachMessage::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.breachedlevel_){}
  };
  _impl_.breachedlevel_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.breachedlevel_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

QBBOMWCBBreachMessage::~QBBOMWCBBreachMessage() {
  // @@protoc_insertion_point(destructor:data.QBBOMWCBBreachMessage)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void QBBOMWCBBreachMessage::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.breachedlevel_.Destroy();
}

void QBBOMWCBBreachMessage::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void QBBOMWCBBreachMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:data.QBBOMWCBBreachMessage)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.breachedlevel_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* QBBOMWCBBreachMessage::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string breachedLevel = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_breachedlevel();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "data.QBBOMWCBBreachMessage.breachedLevel"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* QBBOMWCBBreachMessage::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:data.QBBOMWCBBreachMessage)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional string breachedLevel = 1;
  if (_internal_has_breachedlevel()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_breachedlevel().data(), static_cast<int>(this->_internal_breachedlevel().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "data.QBBOMWCBBreachMessage.breachedLevel");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_breachedlevel(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:data.QBBOMWCBBreachMessage)
  return target;
}

size_t QBBOMWCBBreachMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:data.QBBOMWCBBreachMessage)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string breachedLevel = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_breachedlevel());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData QBBOMWCBBreachMessage::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    QBBOMWCBBreachMessage::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*QBBOMWCBBreachMessage::GetClassData() const { return &_class_data_; }


void QBBOMWCBBreachMessage::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<QBBOMWCBBreachMessage*>(&to_msg);
  auto& from = static_cast<const QBBOMWCBBreachMessage&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:data.QBBOMWCBBreachMessage)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_breachedlevel()) {
    _this->_internal_set_breachedlevel(from._internal_breachedlevel());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void QBBOMWCBBreachMessage::CopyFrom(const QBBOMWCBBreachMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:data.QBBOMWCBBreachMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool QBBOMWCBBreachMessage::IsInitialized() const {
  return true;
}

void QBBOMWCBBreachMessage::InternalSwap(QBBOMWCBBreachMessage* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.breachedlevel_, lhs_arena,
      &other->_impl_.breachedlevel_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata QBBOMWCBBreachMessage::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_data_2eproto_getter, &descriptor_table_data_2eproto_once,
      file_level_metadata_data_2eproto[20]);
}

// ===================================================================

class QBBOMWCBDeclineLevelMessage::_Internal {
 public:
  using HasBits = decltype(std::declval<QBBOMWCBDeclineLevelMessage>()._impl_._has_bits_);
  static void set_has_level1(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_level2(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_level3(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

QBBOMWCBDeclineLevelMessage::QBBOMWCBDeclineLevelMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:data.QBBOMWCBDeclineLevelMessage)
}
QBBOMWCBDeclineLevelMessage::QBBOMWCBDeclineLevelMessage(const QBBOMWCBDeclineLevelMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  QBBOMWCBDeclineLevelMessage* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.level1_){}
    , decltype(_impl_.level2_){}
    , decltype(_impl_.level3_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.level1_, &from._impl_.level1_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.level3_) -
    reinterpret_cast<char*>(&_impl_.level1_)) + sizeof(_impl_.level3_));
  // @@protoc_insertion_point(copy_constructor:data.QBBOMWCBDeclineLevelMessage)
}

inline void QBBOMWCBDeclineLevelMessage::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.level1_){0}
    , decltype(_impl_.level2_){0}
    , decltype(_impl_.level3_){0}
  };
}

QBBOMWCBDeclineLevelMessage::~QBBOMWCBDeclineLevelMessage() {
  // @@protoc_insertion_point(destructor:data.QBBOMWCBDeclineLevelMessage)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void QBBOMWCBDeclineLevelMessage::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void QBBOMWCBDeclineLevelMessage::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void QBBOMWCBDeclineLevelMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:data.QBBOMWCBDeclineLevelMessage)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.level1_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.level3_) -
        reinterpret_cast<char*>(&_impl_.level1_)) + sizeof(_impl_.level3_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* QBBOMWCBDeclineLevelMessage::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional double Level1 = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _Internal::set_has_level1(&has_bits);
          _impl_.level1_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double Level2 = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _Internal::set_has_level2(&has_bits);
          _impl_.level2_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double Level3 = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          _Internal::set_has_level3(&has_bits);
          _impl_.level3_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* QBBOMWCBDeclineLevelMessage::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:data.QBBOMWCBDeclineLevelMessage)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional double Level1 = 1;
  if (_internal_has_level1()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(1, this->_internal_level1(), target);
  }

  // optional double Level2 = 2;
  if (_internal_has_level2()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(2, this->_internal_level2(), target);
  }

  // optional double Level3 = 3;
  if (_internal_has_level3()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(3, this->_internal_level3(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:data.QBBOMWCBDeclineLevelMessage)
  return target;
}

size_t QBBOMWCBDeclineLevelMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:data.QBBOMWCBDeclineLevelMessage)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional double Level1 = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 8;
    }

    // optional double Level2 = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 8;
    }

    // optional double Level3 = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 8;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData QBBOMWCBDeclineLevelMessage::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    QBBOMWCBDeclineLevelMessage::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*QBBOMWCBDeclineLevelMessage::GetClassData() const { return &_class_data_; }


void QBBOMWCBDeclineLevelMessage::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<QBBOMWCBDeclineLevelMessage*>(&to_msg);
  auto& from = static_cast<const QBBOMWCBDeclineLevelMessage&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:data.QBBOMWCBDeclineLevelMessage)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.level1_ = from._impl_.level1_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.level2_ = from._impl_.level2_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.level3_ = from._impl_.level3_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void QBBOMWCBDeclineLevelMessage::CopyFrom(const QBBOMWCBDeclineLevelMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:data.QBBOMWCBDeclineLevelMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool QBBOMWCBDeclineLevelMessage::IsInitialized() const {
  return true;
}

void QBBOMWCBDeclineLevelMessage::InternalSwap(QBBOMWCBDeclineLevelMessage* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(QBBOMWCBDeclineLevelMessage, _impl_.level3_)
      + sizeof(QBBOMWCBDeclineLevelMessage::_impl_.level3_)
      - PROTOBUF_FIELD_OFFSET(QBBOMWCBDeclineLevelMessage, _impl_.level1_)>(
          reinterpret_cast<char*>(&_impl_.level1_),
          reinterpret_cast<char*>(&other->_impl_.level1_));
}

::PROTOBUF_NAMESPACE_ID::Metadata QBBOMWCBDeclineLevelMessage::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_data_2eproto_getter, &descriptor_table_data_2eproto_once,
      file_level_metadata_data_2eproto[21]);
}

// ===================================================================

class QBBOMessageHeader::_Internal {
 public:
  using HasBits = decltype(std::declval<QBBOMessageHeader>()._impl_._has_bits_);
  static void set_has_messagetype(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_trackingnumber(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_timestamp(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

QBBOMessageHeader::QBBOMessageHeader(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:data.QBBOMessageHeader)
}
QBBOMessageHeader::QBBOMessageHeader(const QBBOMessageHeader& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  QBBOMessageHeader* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.messagetype_){}
    , decltype(_impl_.trackingnumber_){}
    , decltype(_impl_.timestamp_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.messagetype_, &from._impl_.messagetype_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.timestamp_) -
    reinterpret_cast<char*>(&_impl_.messagetype_)) + sizeof(_impl_.timestamp_));
  // @@protoc_insertion_point(copy_constructor:data.QBBOMessageHeader)
}

inline void QBBOMessageHeader::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.messagetype_){0}
    , decltype(_impl_.trackingnumber_){0}
    , decltype(_impl_.timestamp_){int64_t{0}}
  };
}

QBBOMessageHeader::~QBBOMessageHeader() {
  // @@protoc_insertion_point(destructor:data.QBBOMessageHeader)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void QBBOMessageHeader::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void QBBOMessageHeader::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void QBBOMessageHeader::Clear() {
// @@protoc_insertion_point(message_clear_start:data.QBBOMessageHeader)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.messagetype_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.timestamp_) -
        reinterpret_cast<char*>(&_impl_.messagetype_)) + sizeof(_impl_.timestamp_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* QBBOMessageHeader::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .data.QBBOMessageType messageType = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_messagetype(static_cast<::data::QBBOMessageType>(val));
        } else
          goto handle_unusual;
        continue;
      // optional int32 trackingNumber = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_trackingnumber(&has_bits);
          _impl_.trackingnumber_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 timestamp = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_timestamp(&has_bits);
          _impl_.timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* QBBOMessageHeader::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:data.QBBOMessageHeader)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional .data.QBBOMessageType messageType = 1;
  if (_internal_has_messagetype()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_messagetype(), target);
  }

  // optional int32 trackingNumber = 2;
  if (_internal_has_trackingnumber()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_trackingnumber(), target);
  }

  // optional int64 timestamp = 3;
  if (_internal_has_timestamp()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(3, this->_internal_timestamp(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:data.QBBOMessageHeader)
  return target;
}

size_t QBBOMessageHeader::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:data.QBBOMessageHeader)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .data.QBBOMessageType messageType = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_messagetype());
    }

    // optional int32 trackingNumber = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_trackingnumber());
    }

    // optional int64 timestamp = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_timestamp());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData QBBOMessageHeader::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    QBBOMessageHeader::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*QBBOMessageHeader::GetClassData() const { return &_class_data_; }


void QBBOMessageHeader::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<QBBOMessageHeader*>(&to_msg);
  auto& from = static_cast<const QBBOMessageHeader&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:data.QBBOMessageHeader)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.messagetype_ = from._impl_.messagetype_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.trackingnumber_ = from._impl_.trackingnumber_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.timestamp_ = from._impl_.timestamp_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void QBBOMessageHeader::CopyFrom(const QBBOMessageHeader& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:data.QBBOMessageHeader)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool QBBOMessageHeader::IsInitialized() const {
  return true;
}

void QBBOMessageHeader::InternalSwap(QBBOMessageHeader* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(QBBOMessageHeader, _impl_.timestamp_)
      + sizeof(QBBOMessageHeader::_impl_.timestamp_)
      - PROTOBUF_FIELD_OFFSET(QBBOMessageHeader, _impl_.messagetype_)>(
          reinterpret_cast<char*>(&_impl_.messagetype_),
          reinterpret_cast<char*>(&other->_impl_.messagetype_));
}

::PROTOBUF_NAMESPACE_ID::Metadata QBBOMessageHeader::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_data_2eproto_getter, &descriptor_table_data_2eproto_once,
      file_level_metadata_data_2eproto[22]);
}

// ===================================================================

class QBBONextSharesQuotationMessage::_Internal {
 public:
  using HasBits = decltype(std::declval<QBBONextSharesQuotationMessage>()._impl_._has_bits_);
  static void set_has_nextsharessymbol(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_securityclass(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_nasdaqbestbid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_nasdaqbestbidsize(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_nasdaqbestbiddiscountamount(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_nasdaqbestofferproxyprice(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_nasdaqbestoffersize(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_nasdaqbestofferdiscountamount(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
};

QBBONextSharesQuotationMessage::QBBONextSharesQuotationMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:data.QBBONextSharesQuotationMessage)
}
QBBONextSharesQuotationMessage::QBBONextSharesQuotationMessage(const QBBONextSharesQuotationMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  QBBONextSharesQuotationMessage* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.nextsharessymbol_){}
    , decltype(_impl_.nasdaqbestbid_){}
    , decltype(_impl_.nasdaqbestbidsize_){}
    , decltype(_impl_.nasdaqbestbiddiscountamount_){}
    , decltype(_impl_.nasdaqbestofferproxyprice_){}
    , decltype(_impl_.nasdaqbestoffersize_){}
    , decltype(_impl_.nasdaqbestofferdiscountamount_){}
    , decltype(_impl_.securityclass_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.nextsharessymbol_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.nextsharessymbol_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_nextsharessymbol()) {
    _this->_impl_.nextsharessymbol_.Set(from._internal_nextsharessymbol(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.nasdaqbestbid_, &from._impl_.nasdaqbestbid_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.securityclass_) -
    reinterpret_cast<char*>(&_impl_.nasdaqbestbid_)) + sizeof(_impl_.securityclass_));
  // @@protoc_insertion_point(copy_constructor:data.QBBONextSharesQuotationMessage)
}

inline void QBBONextSharesQuotationMessage::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.nextsharessymbol_){}
    , decltype(_impl_.nasdaqbestbid_){0}
    , decltype(_impl_.nasdaqbestbidsize_){int64_t{0}}
    , decltype(_impl_.nasdaqbestbiddiscountamount_){0}
    , decltype(_impl_.nasdaqbestofferproxyprice_){0}
    , decltype(_impl_.nasdaqbestoffersize_){int64_t{0}}
    , decltype(_impl_.nasdaqbestofferdiscountamount_){0}
    , decltype(_impl_.securityclass_){0}
  };
  _impl_.nextsharessymbol_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.nextsharessymbol_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

QBBONextSharesQuotationMessage::~QBBONextSharesQuotationMessage() {
  // @@protoc_insertion_point(destructor:data.QBBONextSharesQuotationMessage)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void QBBONextSharesQuotationMessage::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.nextsharessymbol_.Destroy();
}

void QBBONextSharesQuotationMessage::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void QBBONextSharesQuotationMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:data.QBBONextSharesQuotationMessage)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.nextsharessymbol_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x000000feu) {
    ::memset(&_impl_.nasdaqbestbid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.securityclass_) -
        reinterpret_cast<char*>(&_impl_.nasdaqbestbid_)) + sizeof(_impl_.securityclass_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* QBBONextSharesQuotationMessage::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string nextsharesSymbol = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_nextsharessymbol();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "data.QBBONextSharesQuotationMessage.nextsharesSymbol"));
        } else
          goto handle_unusual;
        continue;
      // optional .data.SecurityClass securityClass = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_securityclass(static_cast<::data::SecurityClass>(val));
        } else
          goto handle_unusual;
        continue;
      // optional double nasdaqBestBid = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          _Internal::set_has_nasdaqbestbid(&has_bits);
          _impl_.nasdaqbestbid_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional int64 nasdaqBestBidSize = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_nasdaqbestbidsize(&has_bits);
          _impl_.nasdaqbestbidsize_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional double nasdaqBestBidDiscountAmount = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 41)) {
          _Internal::set_has_nasdaqbestbiddiscountamount(&has_bits);
          _impl_.nasdaqbestbiddiscountamount_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double nasdaqBestOfferProxyPrice = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 49)) {
          _Internal::set_has_nasdaqbestofferproxyprice(&has_bits);
          _impl_.nasdaqbestofferproxyprice_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional int64 nasdaqBestOfferSize = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_nasdaqbestoffersize(&has_bits);
          _impl_.nasdaqbestoffersize_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional double nasdaqBestOfferDiscountAmount = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 65)) {
          _Internal::set_has_nasdaqbestofferdiscountamount(&has_bits);
          _impl_.nasdaqbestofferdiscountamount_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* QBBONextSharesQuotationMessage::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:data.QBBONextSharesQuotationMessage)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional string nextsharesSymbol = 1;
  if (_internal_has_nextsharessymbol()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_nextsharessymbol().data(), static_cast<int>(this->_internal_nextsharessymbol().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "data.QBBONextSharesQuotationMessage.nextsharesSymbol");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_nextsharessymbol(), target);
  }

  // optional .data.SecurityClass securityClass = 2;
  if (_internal_has_securityclass()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_securityclass(), target);
  }

  // optional double nasdaqBestBid = 3;
  if (_internal_has_nasdaqbestbid()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(3, this->_internal_nasdaqbestbid(), target);
  }

  // optional int64 nasdaqBestBidSize = 4;
  if (_internal_has_nasdaqbestbidsize()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(4, this->_internal_nasdaqbestbidsize(), target);
  }

  // optional double nasdaqBestBidDiscountAmount = 5;
  if (_internal_has_nasdaqbestbiddiscountamount()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(5, this->_internal_nasdaqbestbiddiscountamount(), target);
  }

  // optional double nasdaqBestOfferProxyPrice = 6;
  if (_internal_has_nasdaqbestofferproxyprice()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(6, this->_internal_nasdaqbestofferproxyprice(), target);
  }

  // optional int64 nasdaqBestOfferSize = 7;
  if (_internal_has_nasdaqbestoffersize()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(7, this->_internal_nasdaqbestoffersize(), target);
  }

  // optional double nasdaqBestOfferDiscountAmount = 8;
  if (_internal_has_nasdaqbestofferdiscountamount()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(8, this->_internal_nasdaqbestofferdiscountamount(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:data.QBBONextSharesQuotationMessage)
  return target;
}

size_t QBBONextSharesQuotationMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:data.QBBONextSharesQuotationMessage)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string nextsharesSymbol = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_nextsharessymbol());
    }

    // optional double nasdaqBestBid = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 8;
    }

    // optional int64 nasdaqBestBidSize = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_nasdaqbestbidsize());
    }

    // optional double nasdaqBestBidDiscountAmount = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 8;
    }

    // optional double nasdaqBestOfferProxyPrice = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 8;
    }

    // optional int64 nasdaqBestOfferSize = 7;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_nasdaqbestoffersize());
    }

    // optional double nasdaqBestOfferDiscountAmount = 8;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 8;
    }

    // optional .data.SecurityClass securityClass = 2;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_securityclass());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData QBBONextSharesQuotationMessage::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    QBBONextSharesQuotationMessage::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*QBBONextSharesQuotationMessage::GetClassData() const { return &_class_data_; }


void QBBONextSharesQuotationMessage::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<QBBONextSharesQuotationMessage*>(&to_msg);
  auto& from = static_cast<const QBBONextSharesQuotationMessage&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:data.QBBONextSharesQuotationMessage)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_nextsharessymbol(from._internal_nextsharessymbol());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.nasdaqbestbid_ = from._impl_.nasdaqbestbid_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.nasdaqbestbidsize_ = from._impl_.nasdaqbestbidsize_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.nasdaqbestbiddiscountamount_ = from._impl_.nasdaqbestbiddiscountamount_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.nasdaqbestofferproxyprice_ = from._impl_.nasdaqbestofferproxyprice_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.nasdaqbestoffersize_ = from._impl_.nasdaqbestoffersize_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.nasdaqbestofferdiscountamount_ = from._impl_.nasdaqbestofferdiscountamount_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.securityclass_ = from._impl_.securityclass_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void QBBONextSharesQuotationMessage::CopyFrom(const QBBONextSharesQuotationMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:data.QBBONextSharesQuotationMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool QBBONextSharesQuotationMessage::IsInitialized() const {
  return true;
}

void QBBONextSharesQuotationMessage::InternalSwap(QBBONextSharesQuotationMessage* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.nextsharessymbol_, lhs_arena,
      &other->_impl_.nextsharessymbol_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(QBBONextSharesQuotationMessage, _impl_.securityclass_)
      + sizeof(QBBONextSharesQuotationMessage::_impl_.securityclass_)
      - PROTOBUF_FIELD_OFFSET(QBBONextSharesQuotationMessage, _impl_.nasdaqbestbid_)>(
          reinterpret_cast<char*>(&_impl_.nasdaqbestbid_),
          reinterpret_cast<char*>(&other->_impl_.nasdaqbestbid_));
}

::PROTOBUF_NAMESPACE_ID::Metadata QBBONextSharesQuotationMessage::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_data_2eproto_getter, &descriptor_table_data_2eproto_once,
      file_level_metadata_data_2eproto[23]);
}

// ===================================================================

class QBBOOperationalHalt::_Internal {
 public:
  using HasBits = decltype(std::declval<QBBOOperationalHalt>()._impl_._has_bits_);
  static void set_has_stock(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_marketcode(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_operationalhaltaction(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

QBBOOperationalHalt::QBBOOperationalHalt(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:data.QBBOOperationalHalt)
}
QBBOOperationalHalt::QBBOOperationalHalt(const QBBOOperationalHalt& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  QBBOOperationalHalt* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.stock_){}
    , decltype(_impl_.marketcode_){}
    , decltype(_impl_.operationalhaltaction_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.stock_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.stock_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_stock()) {
    _this->_impl_.stock_.Set(from._internal_stock(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.marketcode_, &from._impl_.marketcode_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.operationalhaltaction_) -
    reinterpret_cast<char*>(&_impl_.marketcode_)) + sizeof(_impl_.operationalhaltaction_));
  // @@protoc_insertion_point(copy_constructor:data.QBBOOperationalHalt)
}

inline void QBBOOperationalHalt::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.stock_){}
    , decltype(_impl_.marketcode_){0}
    , decltype(_impl_.operationalhaltaction_){0}
  };
  _impl_.stock_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.stock_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

QBBOOperationalHalt::~QBBOOperationalHalt() {
  // @@protoc_insertion_point(destructor:data.QBBOOperationalHalt)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void QBBOOperationalHalt::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.stock_.Destroy();
}

void QBBOOperationalHalt::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void QBBOOperationalHalt::Clear() {
// @@protoc_insertion_point(message_clear_start:data.QBBOOperationalHalt)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.stock_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&_impl_.marketcode_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.operationalhaltaction_) -
        reinterpret_cast<char*>(&_impl_.marketcode_)) + sizeof(_impl_.operationalhaltaction_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* QBBOOperationalHalt::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string stock = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_stock();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "data.QBBOOperationalHalt.stock"));
        } else
          goto handle_unusual;
        continue;
      // optional .data.MarketCode marketCode = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_marketcode(static_cast<::data::MarketCode>(val));
        } else
          goto handle_unusual;
        continue;
      // optional .data.HaltAction operationalHaltAction = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_operationalhaltaction(static_cast<::data::HaltAction>(val));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* QBBOOperationalHalt::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:data.QBBOOperationalHalt)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional string stock = 1;
  if (_internal_has_stock()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_stock().data(), static_cast<int>(this->_internal_stock().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "data.QBBOOperationalHalt.stock");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_stock(), target);
  }

  // optional .data.MarketCode marketCode = 2;
  if (_internal_has_marketcode()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_marketcode(), target);
  }

  // optional .data.HaltAction operationalHaltAction = 3;
  if (_internal_has_operationalhaltaction()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      3, this->_internal_operationalhaltaction(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:data.QBBOOperationalHalt)
  return target;
}

size_t QBBOOperationalHalt::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:data.QBBOOperationalHalt)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string stock = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_stock());
    }

    // optional .data.MarketCode marketCode = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_marketcode());
    }

    // optional .data.HaltAction operationalHaltAction = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_operationalhaltaction());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData QBBOOperationalHalt::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    QBBOOperationalHalt::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*QBBOOperationalHalt::GetClassData() const { return &_class_data_; }


void QBBOOperationalHalt::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<QBBOOperationalHalt*>(&to_msg);
  auto& from = static_cast<const QBBOOperationalHalt&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:data.QBBOOperationalHalt)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_stock(from._internal_stock());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.marketcode_ = from._impl_.marketcode_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.operationalhaltaction_ = from._impl_.operationalhaltaction_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void QBBOOperationalHalt::CopyFrom(const QBBOOperationalHalt& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:data.QBBOOperationalHalt)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool QBBOOperationalHalt::IsInitialized() const {
  return true;
}

void QBBOOperationalHalt::InternalSwap(QBBOOperationalHalt* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.stock_, lhs_arena,
      &other->_impl_.stock_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(QBBOOperationalHalt, _impl_.operationalhaltaction_)
      + sizeof(QBBOOperationalHalt::_impl_.operationalhaltaction_)
      - PROTOBUF_FIELD_OFFSET(QBBOOperationalHalt, _impl_.marketcode_)>(
          reinterpret_cast<char*>(&_impl_.marketcode_),
          reinterpret_cast<char*>(&other->_impl_.marketcode_));
}

::PROTOBUF_NAMESPACE_ID::Metadata QBBOOperationalHalt::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_data_2eproto_getter, &descriptor_table_data_2eproto_once,
      file_level_metadata_data_2eproto[24]);
}

// ===================================================================

class QBBOQuotationMessage::_Internal {
 public:
  using HasBits = decltype(std::declval<QBBOQuotationMessage>()._impl_._has_bits_);
  static void set_has_stock(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_securityclass(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_nasdaqbestbidprice(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_nasdaqbestbidsize(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_nasdaqbestofferprice(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_nasdaqbestoffersize(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

QBBOQuotationMessage::QBBOQuotationMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:data.QBBOQuotationMessage)
}
QBBOQuotationMessage::QBBOQuotationMessage(const QBBOQuotationMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  QBBOQuotationMessage* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.stock_){}
    , decltype(_impl_.nasdaqbestbidprice_){}
    , decltype(_impl_.nasdaqbestbidsize_){}
    , decltype(_impl_.nasdaqbestofferprice_){}
    , decltype(_impl_.nasdaqbestoffersize_){}
    , decltype(_impl_.securityclass_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.stock_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.stock_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_stock()) {
    _this->_impl_.stock_.Set(from._internal_stock(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.nasdaqbestbidprice_, &from._impl_.nasdaqbestbidprice_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.securityclass_) -
    reinterpret_cast<char*>(&_impl_.nasdaqbestbidprice_)) + sizeof(_impl_.securityclass_));
  // @@protoc_insertion_point(copy_constructor:data.QBBOQuotationMessage)
}

inline void QBBOQuotationMessage::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.stock_){}
    , decltype(_impl_.nasdaqbestbidprice_){0}
    , decltype(_impl_.nasdaqbestbidsize_){int64_t{0}}
    , decltype(_impl_.nasdaqbestofferprice_){0}
    , decltype(_impl_.nasdaqbestoffersize_){int64_t{0}}
    , decltype(_impl_.securityclass_){0}
  };
  _impl_.stock_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.stock_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

QBBOQuotationMessage::~QBBOQuotationMessage() {
  // @@protoc_insertion_point(destructor:data.QBBOQuotationMessage)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void QBBOQuotationMessage::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.stock_.Destroy();
}

void QBBOQuotationMessage::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void QBBOQuotationMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:data.QBBOQuotationMessage)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.stock_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000003eu) {
    ::memset(&_impl_.nasdaqbestbidprice_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.securityclass_) -
        reinterpret_cast<char*>(&_impl_.nasdaqbestbidprice_)) + sizeof(_impl_.securityclass_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* QBBOQuotationMessage::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string stock = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_stock();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "data.QBBOQuotationMessage.stock"));
        } else
          goto handle_unusual;
        continue;
      // optional .data.SecurityClass securityClass = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_securityclass(static_cast<::data::SecurityClass>(val));
        } else
          goto handle_unusual;
        continue;
      // optional double nasdaqBestBidPrice = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          _Internal::set_has_nasdaqbestbidprice(&has_bits);
          _impl_.nasdaqbestbidprice_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional int64 nasdaqBestBidSize = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_nasdaqbestbidsize(&has_bits);
          _impl_.nasdaqbestbidsize_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional double nasdaqBestOfferPrice = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 41)) {
          _Internal::set_has_nasdaqbestofferprice(&has_bits);
          _impl_.nasdaqbestofferprice_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional int64 nasdaqBestOfferSize = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_nasdaqbestoffersize(&has_bits);
          _impl_.nasdaqbestoffersize_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* QBBOQuotationMessage::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:data.QBBOQuotationMessage)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional string stock = 1;
  if (_internal_has_stock()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_stock().data(), static_cast<int>(this->_internal_stock().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "data.QBBOQuotationMessage.stock");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_stock(), target);
  }

  // optional .data.SecurityClass securityClass = 2;
  if (_internal_has_securityclass()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_securityclass(), target);
  }

  // optional double nasdaqBestBidPrice = 3;
  if (_internal_has_nasdaqbestbidprice()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(3, this->_internal_nasdaqbestbidprice(), target);
  }

  // optional int64 nasdaqBestBidSize = 4;
  if (_internal_has_nasdaqbestbidsize()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(4, this->_internal_nasdaqbestbidsize(), target);
  }

  // optional double nasdaqBestOfferPrice = 5;
  if (_internal_has_nasdaqbestofferprice()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(5, this->_internal_nasdaqbestofferprice(), target);
  }

  // optional int64 nasdaqBestOfferSize = 6;
  if (_internal_has_nasdaqbestoffersize()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(6, this->_internal_nasdaqbestoffersize(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:data.QBBOQuotationMessage)
  return target;
}

size_t QBBOQuotationMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:data.QBBOQuotationMessage)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional string stock = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_stock());
    }

    // optional double nasdaqBestBidPrice = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 8;
    }

    // optional int64 nasdaqBestBidSize = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_nasdaqbestbidsize());
    }

    // optional double nasdaqBestOfferPrice = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 8;
    }

    // optional int64 nasdaqBestOfferSize = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_nasdaqbestoffersize());
    }

    // optional .data.SecurityClass securityClass = 2;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_securityclass());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData QBBOQuotationMessage::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    QBBOQuotationMessage::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*QBBOQuotationMessage::GetClassData() const { return &_class_data_; }


void QBBOQuotationMessage::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<QBBOQuotationMessage*>(&to_msg);
  auto& from = static_cast<const QBBOQuotationMessage&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:data.QBBOQuotationMessage)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_stock(from._internal_stock());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.nasdaqbestbidprice_ = from._impl_.nasdaqbestbidprice_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.nasdaqbestbidsize_ = from._impl_.nasdaqbestbidsize_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.nasdaqbestofferprice_ = from._impl_.nasdaqbestofferprice_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.nasdaqbestoffersize_ = from._impl_.nasdaqbestoffersize_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.securityclass_ = from._impl_.securityclass_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void QBBOQuotationMessage::CopyFrom(const QBBOQuotationMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:data.QBBOQuotationMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool QBBOQuotationMessage::IsInitialized() const {
  return true;
}

void QBBOQuotationMessage::InternalSwap(QBBOQuotationMessage* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.stock_, lhs_arena,
      &other->_impl_.stock_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(QBBOQuotationMessage, _impl_.securityclass_)
      + sizeof(QBBOQuotationMessage::_impl_.securityclass_)
      - PROTOBUF_FIELD_OFFSET(QBBOQuotationMessage, _impl_.nasdaqbestbidprice_)>(
          reinterpret_cast<char*>(&_impl_.nasdaqbestbidprice_),
          reinterpret_cast<char*>(&other->_impl_.nasdaqbestbidprice_));
}

::PROTOBUF_NAMESPACE_ID::Metadata QBBOQuotationMessage::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_data_2eproto_getter, &descriptor_table_data_2eproto_once,
      file_level_metadata_data_2eproto[25]);
}

// ===================================================================

class QBBORegShoRestriction::_Internal {
 public:
  using HasBits = decltype(std::declval<QBBORegShoRestriction>()._impl_._has_bits_);
  static void set_has_stock(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_regshoaction(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

QBBORegShoRestriction::QBBORegShoRestriction(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:data.QBBORegShoRestriction)
}
QBBORegShoRestriction::QBBORegShoRestriction(const QBBORegShoRestriction& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  QBBORegShoRestriction* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.stock_){}
    , decltype(_impl_.regshoaction_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.stock_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.stock_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_stock()) {
    _this->_impl_.stock_.Set(from._internal_stock(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.regshoaction_ = from._impl_.regshoaction_;
  // @@protoc_insertion_point(copy_constructor:data.QBBORegShoRestriction)
}

inline void QBBORegShoRestriction::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.stock_){}
    , decltype(_impl_.regshoaction_){0}
  };
  _impl_.stock_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.stock_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

QBBORegShoRestriction::~QBBORegShoRestriction() {
  // @@protoc_insertion_point(destructor:data.QBBORegShoRestriction)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void QBBORegShoRestriction::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.stock_.Destroy();
}

void QBBORegShoRestriction::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void QBBORegShoRestriction::Clear() {
// @@protoc_insertion_point(message_clear_start:data.QBBORegShoRestriction)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.stock_.ClearNonDefaultToEmpty();
  }
  _impl_.regshoaction_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* QBBORegShoRestriction::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string stock = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_stock();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "data.QBBORegShoRestriction.stock"));
        } else
          goto handle_unusual;
        continue;
      // optional .data.RegSHOAction regSHOAction = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_regshoaction(static_cast<::data::RegSHOAction>(val));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* QBBORegShoRestriction::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:data.QBBORegShoRestriction)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional string stock = 1;
  if (_internal_has_stock()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_stock().data(), static_cast<int>(this->_internal_stock().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "data.QBBORegShoRestriction.stock");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_stock(), target);
  }

  // optional .data.RegSHOAction regSHOAction = 2;
  if (_internal_has_regshoaction()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_regshoaction(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:data.QBBORegShoRestriction)
  return target;
}

size_t QBBORegShoRestriction::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:data.QBBORegShoRestriction)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string stock = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_stock());
    }

    // optional .data.RegSHOAction regSHOAction = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_regshoaction());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData QBBORegShoRestriction::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    QBBORegShoRestriction::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*QBBORegShoRestriction::GetClassData() const { return &_class_data_; }


void QBBORegShoRestriction::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<QBBORegShoRestriction*>(&to_msg);
  auto& from = static_cast<const QBBORegShoRestriction&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:data.QBBORegShoRestriction)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_stock(from._internal_stock());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.regshoaction_ = from._impl_.regshoaction_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void QBBORegShoRestriction::CopyFrom(const QBBORegShoRestriction& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:data.QBBORegShoRestriction)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool QBBORegShoRestriction::IsInitialized() const {
  return true;
}

void QBBORegShoRestriction::InternalSwap(QBBORegShoRestriction* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.stock_, lhs_arena,
      &other->_impl_.stock_, rhs_arena
  );
  swap(_impl_.regshoaction_, other->_impl_.regshoaction_);
}

::PROTOBUF_NAMESPACE_ID::Metadata QBBORegShoRestriction::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_data_2eproto_getter, &descriptor_table_data_2eproto_once,
      file_level_metadata_data_2eproto[26]);
}

// ===================================================================

class QBBOStockDirectory::_Internal {
 public:
  using HasBits = decltype(std::declval<QBBOStockDirectory>()._impl_._has_bits_);
  static void set_has_stock(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_marketcategory(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_financialstatusindicator(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_roundlotsize(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_roundlotonly(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_issueclassification(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_issuesubtype(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_authenticity(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_shortsalethresholdindicator(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_ipoflag(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_luldreferencepricetier(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_etplag(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_etpleveragefactor(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_inverseindicator(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
};

QBBOStockDirectory::QBBOStockDirectory(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:data.QBBOStockDirectory)
}
QBBOStockDirectory::QBBOStockDirectory(const QBBOStockDirectory& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  QBBOStockDirectory* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.stock_){}
    , decltype(_impl_.issueclassification_){}
    , decltype(_impl_.issuesubtype_){}
    , decltype(_impl_.marketcategory_){}
    , decltype(_impl_.financialstatusindicator_){}
    , decltype(_impl_.roundlotsize_){}
    , decltype(_impl_.roundlotonly_){}
    , decltype(_impl_.authenticity_){}
    , decltype(_impl_.shortsalethresholdindicator_){}
    , decltype(_impl_.ipoflag_){}
    , decltype(_impl_.luldreferencepricetier_){}
    , decltype(_impl_.etplag_){}
    , decltype(_impl_.etpleveragefactor_){}
    , decltype(_impl_.inverseindicator_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.stock_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.stock_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_stock()) {
    _this->_impl_.stock_.Set(from._internal_stock(), 
      _this->GetArenaForAllocation());
  }
  _impl_.issueclassification_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.issueclassification_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_issueclassification()) {
    _this->_impl_.issueclassification_.Set(from._internal_issueclassification(), 
      _this->GetArenaForAllocation());
  }
  _impl_.issuesubtype_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.issuesubtype_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_issuesubtype()) {
    _this->_impl_.issuesubtype_.Set(from._internal_issuesubtype(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.marketcategory_, &from._impl_.marketcategory_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.inverseindicator_) -
    reinterpret_cast<char*>(&_impl_.marketcategory_)) + sizeof(_impl_.inverseindicator_));
  // @@protoc_insertion_point(copy_constructor:data.QBBOStockDirectory)
}

inline void QBBOStockDirectory::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.stock_){}
    , decltype(_impl_.issueclassification_){}
    , decltype(_impl_.issuesubtype_){}
    , decltype(_impl_.marketcategory_){0}
    , decltype(_impl_.financialstatusindicator_){0}
    , decltype(_impl_.roundlotsize_){int64_t{0}}
    , decltype(_impl_.roundlotonly_){0}
    , decltype(_impl_.authenticity_){0}
    , decltype(_impl_.shortsalethresholdindicator_){0}
    , decltype(_impl_.ipoflag_){0}
    , decltype(_impl_.luldreferencepricetier_){0}
    , decltype(_impl_.etplag_){0}
    , decltype(_impl_.etpleveragefactor_){int64_t{0}}
    , decltype(_impl_.inverseindicator_){0}
  };
  _impl_.stock_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.stock_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.issueclassification_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.issueclassification_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.issuesubtype_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.issuesubtype_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

QBBOStockDirectory::~QBBOStockDirectory() {
  // @@protoc_insertion_point(destructor:data.QBBOStockDirectory)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void QBBOStockDirectory::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.stock_.Destroy();
  _impl_.issueclassification_.Destroy();
  _impl_.issuesubtype_.Destroy();
}

void QBBOStockDirectory::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void QBBOStockDirectory::Clear() {
// @@protoc_insertion_point(message_clear_start:data.QBBOStockDirectory)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.stock_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.issueclassification_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.issuesubtype_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x000000f8u) {
    ::memset(&_impl_.marketcategory_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.authenticity_) -
        reinterpret_cast<char*>(&_impl_.marketcategory_)) + sizeof(_impl_.authenticity_));
  }
  if (cached_has_bits & 0x00003f00u) {
    ::memset(&_impl_.shortsalethresholdindicator_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.inverseindicator_) -
        reinterpret_cast<char*>(&_impl_.shortsalethresholdindicator_)) + sizeof(_impl_.inverseindicator_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* QBBOStockDirectory::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string stock = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_stock();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "data.QBBOStockDirectory.stock"));
        } else
          goto handle_unusual;
        continue;
      // optional .data.MarketCategory marketCategory = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_marketcategory(static_cast<::data::MarketCategory>(val));
        } else
          goto handle_unusual;
        continue;
      // optional .data.FinancialStatusIndicator financialStatusIndicator = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_financialstatusindicator(static_cast<::data::FinancialStatusIndicator>(val));
        } else
          goto handle_unusual;
        continue;
      // optional int64 roundLotsize = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_roundlotsize(&has_bits);
          _impl_.roundlotsize_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .data.IndicatesIf roundLotOnly = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_roundlotonly(static_cast<::data::IndicatesIf>(val));
        } else
          goto handle_unusual;
        continue;
      // optional string issueClassification = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_issueclassification();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "data.QBBOStockDirectory.issueClassification"));
        } else
          goto handle_unusual;
        continue;
      // optional string issueSubType = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_issuesubtype();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "data.QBBOStockDirectory.issueSubType"));
        } else
          goto handle_unusual;
        continue;
      // optional .data.Authenticity authenticity = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_authenticity(static_cast<::data::Authenticity>(val));
        } else
          goto handle_unusual;
        continue;
      // optional .data.IndicatesIf shortSaleThresholdIndicator = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_shortsalethresholdindicator(static_cast<::data::IndicatesIf>(val));
        } else
          goto handle_unusual;
        continue;
      // optional .data.IndicatesIf IPOFlag = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_ipoflag(static_cast<::data::IndicatesIf>(val));
        } else
          goto handle_unusual;
        continue;
      // optional .data.LULDRule lULDReferencePriceTier = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_luldreferencepricetier(static_cast<::data::LULDRule>(val));
        } else
          goto handle_unusual;
        continue;
      // optional .data.IndicatesIf ETPlag = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_etplag(static_cast<::data::IndicatesIf>(val));
        } else
          goto handle_unusual;
        continue;
      // optional int64 ETPLeverageFactor = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          _Internal::set_has_etpleveragefactor(&has_bits);
          _impl_.etpleveragefactor_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .data.IndicatesIf inverseIndicator = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_inverseindicator(static_cast<::data::IndicatesIf>(val));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* QBBOStockDirectory::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:data.QBBOStockDirectory)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional string stock = 1;
  if (_internal_has_stock()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_stock().data(), static_cast<int>(this->_internal_stock().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "data.QBBOStockDirectory.stock");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_stock(), target);
  }

  // optional .data.MarketCategory marketCategory = 2;
  if (_internal_has_marketcategory()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_marketcategory(), target);
  }

  // optional .data.FinancialStatusIndicator financialStatusIndicator = 3;
  if (_internal_has_financialstatusindicator()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      3, this->_internal_financialstatusindicator(), target);
  }

  // optional int64 roundLotsize = 4;
  if (_internal_has_roundlotsize()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(4, this->_internal_roundlotsize(), target);
  }

  // optional .data.IndicatesIf roundLotOnly = 5;
  if (_internal_has_roundlotonly()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      5, this->_internal_roundlotonly(), target);
  }

  // optional string issueClassification = 6;
  if (_internal_has_issueclassification()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_issueclassification().data(), static_cast<int>(this->_internal_issueclassification().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "data.QBBOStockDirectory.issueClassification");
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_issueclassification(), target);
  }

  // optional string issueSubType = 7;
  if (_internal_has_issuesubtype()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_issuesubtype().data(), static_cast<int>(this->_internal_issuesubtype().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "data.QBBOStockDirectory.issueSubType");
    target = stream->WriteStringMaybeAliased(
        7, this->_internal_issuesubtype(), target);
  }

  // optional .data.Authenticity authenticity = 8;
  if (_internal_has_authenticity()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      8, this->_internal_authenticity(), target);
  }

  // optional .data.IndicatesIf shortSaleThresholdIndicator = 9;
  if (_internal_has_shortsalethresholdindicator()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      9, this->_internal_shortsalethresholdindicator(), target);
  }

  // optional .data.IndicatesIf IPOFlag = 10;
  if (_internal_has_ipoflag()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      10, this->_internal_ipoflag(), target);
  }

  // optional .data.LULDRule lULDReferencePriceTier = 11;
  if (_internal_has_luldreferencepricetier()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      11, this->_internal_luldreferencepricetier(), target);
  }

  // optional .data.IndicatesIf ETPlag = 12;
  if (_internal_has_etplag()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      12, this->_internal_etplag(), target);
  }

  // optional int64 ETPLeverageFactor = 13;
  if (_internal_has_etpleveragefactor()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(13, this->_internal_etpleveragefactor(), target);
  }

  // optional .data.IndicatesIf inverseIndicator = 14;
  if (_internal_has_inverseindicator()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      14, this->_internal_inverseindicator(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:data.QBBOStockDirectory)
  return target;
}

size_t QBBOStockDirectory::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:data.QBBOStockDirectory)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string stock = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_stock());
    }

    // optional string issueClassification = 6;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_issueclassification());
    }

    // optional string issueSubType = 7;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_issuesubtype());
    }

    // optional .data.MarketCategory marketCategory = 2;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_marketcategory());
    }

    // optional .data.FinancialStatusIndicator financialStatusIndicator = 3;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_financialstatusindicator());
    }

    // optional int64 roundLotsize = 4;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_roundlotsize());
    }

    // optional .data.IndicatesIf roundLotOnly = 5;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_roundlotonly());
    }

    // optional .data.Authenticity authenticity = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_authenticity());
    }

  }
  if (cached_has_bits & 0x00003f00u) {
    // optional .data.IndicatesIf shortSaleThresholdIndicator = 9;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_shortsalethresholdindicator());
    }

    // optional .data.IndicatesIf IPOFlag = 10;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_ipoflag());
    }

    // optional .data.LULDRule lULDReferencePriceTier = 11;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_luldreferencepricetier());
    }

    // optional .data.IndicatesIf ETPlag = 12;
    if (cached_has_bits & 0x00000800u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_etplag());
    }

    // optional int64 ETPLeverageFactor = 13;
    if (cached_has_bits & 0x00001000u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_etpleveragefactor());
    }

    // optional .data.IndicatesIf inverseIndicator = 14;
    if (cached_has_bits & 0x00002000u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_inverseindicator());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData QBBOStockDirectory::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    QBBOStockDirectory::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*QBBOStockDirectory::GetClassData() const { return &_class_data_; }


void QBBOStockDirectory::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<QBBOStockDirectory*>(&to_msg);
  auto& from = static_cast<const QBBOStockDirectory&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:data.QBBOStockDirectory)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_stock(from._internal_stock());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_issueclassification(from._internal_issueclassification());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_issuesubtype(from._internal_issuesubtype());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.marketcategory_ = from._impl_.marketcategory_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.financialstatusindicator_ = from._impl_.financialstatusindicator_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.roundlotsize_ = from._impl_.roundlotsize_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.roundlotonly_ = from._impl_.roundlotonly_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.authenticity_ = from._impl_.authenticity_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00003f00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.shortsalethresholdindicator_ = from._impl_.shortsalethresholdindicator_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.ipoflag_ = from._impl_.ipoflag_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.luldreferencepricetier_ = from._impl_.luldreferencepricetier_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.etplag_ = from._impl_.etplag_;
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_impl_.etpleveragefactor_ = from._impl_.etpleveragefactor_;
    }
    if (cached_has_bits & 0x00002000u) {
      _this->_impl_.inverseindicator_ = from._impl_.inverseindicator_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void QBBOStockDirectory::CopyFrom(const QBBOStockDirectory& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:data.QBBOStockDirectory)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool QBBOStockDirectory::IsInitialized() const {
  return true;
}

void QBBOStockDirectory::InternalSwap(QBBOStockDirectory* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.stock_, lhs_arena,
      &other->_impl_.stock_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.issueclassification_, lhs_arena,
      &other->_impl_.issueclassification_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.issuesubtype_, lhs_arena,
      &other->_impl_.issuesubtype_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(QBBOStockDirectory, _impl_.inverseindicator_)
      + sizeof(QBBOStockDirectory::_impl_.inverseindicator_)
      - PROTOBUF_FIELD_OFFSET(QBBOStockDirectory, _impl_.marketcategory_)>(
          reinterpret_cast<char*>(&_impl_.marketcategory_),
          reinterpret_cast<char*>(&other->_impl_.marketcategory_));
}

::PROTOBUF_NAMESPACE_ID::Metadata QBBOStockDirectory::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_data_2eproto_getter, &descriptor_table_data_2eproto_once,
      file_level_metadata_data_2eproto[27]);
}

// ===================================================================

class QBBOStockTradingAction::_Internal {
 public:
  using HasBits = decltype(std::declval<QBBOStockTradingAction>()._impl_._has_bits_);
  static void set_has_stock(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_securityclass(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_currenttradingstate(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_reason(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

QBBOStockTradingAction::QBBOStockTradingAction(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:data.QBBOStockTradingAction)
}
QBBOStockTradingAction::QBBOStockTradingAction(const QBBOStockTradingAction& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  QBBOStockTradingAction* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.stock_){}
    , decltype(_impl_.reason_){}
    , decltype(_impl_.securityclass_){}
    , decltype(_impl_.currenttradingstate_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.stock_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.stock_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_stock()) {
    _this->_impl_.stock_.Set(from._internal_stock(), 
      _this->GetArenaForAllocation());
  }
  _impl_.reason_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.reason_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_reason()) {
    _this->_impl_.reason_.Set(from._internal_reason(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.securityclass_, &from._impl_.securityclass_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.currenttradingstate_) -
    reinterpret_cast<char*>(&_impl_.securityclass_)) + sizeof(_impl_.currenttradingstate_));
  // @@protoc_insertion_point(copy_constructor:data.QBBOStockTradingAction)
}

inline void QBBOStockTradingAction::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.stock_){}
    , decltype(_impl_.reason_){}
    , decltype(_impl_.securityclass_){0}
    , decltype(_impl_.currenttradingstate_){0}
  };
  _impl_.stock_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.stock_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.reason_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.reason_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

QBBOStockTradingAction::~QBBOStockTradingAction() {
  // @@protoc_insertion_point(destructor:data.QBBOStockTradingAction)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void QBBOStockTradingAction::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.stock_.Destroy();
  _impl_.reason_.Destroy();
}

void QBBOStockTradingAction::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void QBBOStockTradingAction::Clear() {
// @@protoc_insertion_point(message_clear_start:data.QBBOStockTradingAction)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.stock_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.reason_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x0000000cu) {
    ::memset(&_impl_.securityclass_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.currenttradingstate_) -
        reinterpret_cast<char*>(&_impl_.securityclass_)) + sizeof(_impl_.currenttradingstate_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* QBBOStockTradingAction::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string stock = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_stock();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "data.QBBOStockTradingAction.stock"));
        } else
          goto handle_unusual;
        continue;
      // optional .data.SecurityClass securityClass = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_securityclass(static_cast<::data::SecurityClass>(val));
        } else
          goto handle_unusual;
        continue;
      // optional .data.CurrentTradingState currentTradingState = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_currenttradingstate(static_cast<::data::CurrentTradingState>(val));
        } else
          goto handle_unusual;
        continue;
      // optional string reason = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_reason();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "data.QBBOStockTradingAction.reason"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* QBBOStockTradingAction::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:data.QBBOStockTradingAction)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional string stock = 1;
  if (_internal_has_stock()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_stock().data(), static_cast<int>(this->_internal_stock().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "data.QBBOStockTradingAction.stock");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_stock(), target);
  }

  // optional .data.SecurityClass securityClass = 2;
  if (_internal_has_securityclass()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_securityclass(), target);
  }

  // optional .data.CurrentTradingState currentTradingState = 3;
  if (_internal_has_currenttradingstate()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      3, this->_internal_currenttradingstate(), target);
  }

  // optional string reason = 4;
  if (_internal_has_reason()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_reason().data(), static_cast<int>(this->_internal_reason().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "data.QBBOStockTradingAction.reason");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_reason(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:data.QBBOStockTradingAction)
  return target;
}

size_t QBBOStockTradingAction::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:data.QBBOStockTradingAction)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string stock = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_stock());
    }

    // optional string reason = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_reason());
    }

    // optional .data.SecurityClass securityClass = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_securityclass());
    }

    // optional .data.CurrentTradingState currentTradingState = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_currenttradingstate());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData QBBOStockTradingAction::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    QBBOStockTradingAction::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*QBBOStockTradingAction::GetClassData() const { return &_class_data_; }


void QBBOStockTradingAction::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<QBBOStockTradingAction*>(&to_msg);
  auto& from = static_cast<const QBBOStockTradingAction&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:data.QBBOStockTradingAction)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_stock(from._internal_stock());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_reason(from._internal_reason());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.securityclass_ = from._impl_.securityclass_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.currenttradingstate_ = from._impl_.currenttradingstate_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void QBBOStockTradingAction::CopyFrom(const QBBOStockTradingAction& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:data.QBBOStockTradingAction)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool QBBOStockTradingAction::IsInitialized() const {
  return true;
}

void QBBOStockTradingAction::InternalSwap(QBBOStockTradingAction* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.stock_, lhs_arena,
      &other->_impl_.stock_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.reason_, lhs_arena,
      &other->_impl_.reason_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(QBBOStockTradingAction, _impl_.currenttradingstate_)
      + sizeof(QBBOStockTradingAction::_impl_.currenttradingstate_)
      - PROTOBUF_FIELD_OFFSET(QBBOStockTradingAction, _impl_.securityclass_)>(
          reinterpret_cast<char*>(&_impl_.securityclass_),
          reinterpret_cast<char*>(&other->_impl_.securityclass_));
}

::PROTOBUF_NAMESPACE_ID::Metadata QBBOStockTradingAction::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_data_2eproto_getter, &descriptor_table_data_2eproto_once,
      file_level_metadata_data_2eproto[28]);
}

// ===================================================================

class QBBOSystemEventMessage::_Internal {
 public:
  using HasBits = decltype(std::declval<QBBOSystemEventMessage>()._impl_._has_bits_);
  static void set_has_eventcode(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

QBBOSystemEventMessage::QBBOSystemEventMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:data.QBBOSystemEventMessage)
}
QBBOSystemEventMessage::QBBOSystemEventMessage(const QBBOSystemEventMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  QBBOSystemEventMessage* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.eventcode_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.eventcode_ = from._impl_.eventcode_;
  // @@protoc_insertion_point(copy_constructor:data.QBBOSystemEventMessage)
}

inline void QBBOSystemEventMessage::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.eventcode_){0}
  };
}

QBBOSystemEventMessage::~QBBOSystemEventMessage() {
  // @@protoc_insertion_point(destructor:data.QBBOSystemEventMessage)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void QBBOSystemEventMessage::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void QBBOSystemEventMessage::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void QBBOSystemEventMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:data.QBBOSystemEventMessage)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.eventcode_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* QBBOSystemEventMessage::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .data.EventCode eventCode = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_eventcode(static_cast<::data::EventCode>(val));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* QBBOSystemEventMessage::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:data.QBBOSystemEventMessage)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional .data.EventCode eventCode = 1;
  if (_internal_has_eventcode()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_eventcode(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:data.QBBOSystemEventMessage)
  return target;
}

size_t QBBOSystemEventMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:data.QBBOSystemEventMessage)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .data.EventCode eventCode = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_eventcode());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData QBBOSystemEventMessage::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    QBBOSystemEventMessage::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*QBBOSystemEventMessage::GetClassData() const { return &_class_data_; }


void QBBOSystemEventMessage::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<QBBOSystemEventMessage*>(&to_msg);
  auto& from = static_cast<const QBBOSystemEventMessage&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:data.QBBOSystemEventMessage)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_eventcode()) {
    _this->_internal_set_eventcode(from._internal_eventcode());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void QBBOSystemEventMessage::CopyFrom(const QBBOSystemEventMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:data.QBBOSystemEventMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool QBBOSystemEventMessage::IsInitialized() const {
  return true;
}

void QBBOSystemEventMessage::InternalSwap(QBBOSystemEventMessage* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.eventcode_, other->_impl_.eventcode_);
}

::PROTOBUF_NAMESPACE_ID::Metadata QBBOSystemEventMessage::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_data_2eproto_getter, &descriptor_table_data_2eproto_once,
      file_level_metadata_data_2eproto[29]);
}

// ===================================================================

class AddOddLotOrder::_Internal {
 public:
  using HasBits = decltype(std::declval<AddOddLotOrder>()._impl_._has_bits_);
  static void set_has_securitycode(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_orderid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_price(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_quantity(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_brokerid(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_side(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

AddOddLotOrder::AddOddLotOrder(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:data.AddOddLotOrder)
}
AddOddLotOrder::AddOddLotOrder(const AddOddLotOrder& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  AddOddLotOrder* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.securitycode_){}
    , decltype(_impl_.orderid_){}
    , decltype(_impl_.price_){}
    , decltype(_impl_.quantity_){}
    , decltype(_impl_.brokerid_){}
    , decltype(_impl_.side_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.securitycode_, &from._impl_.securitycode_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.side_) -
    reinterpret_cast<char*>(&_impl_.securitycode_)) + sizeof(_impl_.side_));
  // @@protoc_insertion_point(copy_constructor:data.AddOddLotOrder)
}

inline void AddOddLotOrder::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.securitycode_){int64_t{0}}
    , decltype(_impl_.orderid_){int64_t{0}}
    , decltype(_impl_.price_){0}
    , decltype(_impl_.quantity_){int64_t{0}}
    , decltype(_impl_.brokerid_){0}
    , decltype(_impl_.side_){0}
  };
}

AddOddLotOrder::~AddOddLotOrder() {
  // @@protoc_insertion_point(destructor:data.AddOddLotOrder)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AddOddLotOrder::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void AddOddLotOrder::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AddOddLotOrder::Clear() {
// @@protoc_insertion_point(message_clear_start:data.AddOddLotOrder)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    ::memset(&_impl_.securitycode_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.side_) -
        reinterpret_cast<char*>(&_impl_.securitycode_)) + sizeof(_impl_.side_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AddOddLotOrder::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int64 securityCode = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_securitycode(&has_bits);
          _impl_.securitycode_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 orderId = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_orderid(&has_bits);
          _impl_.orderid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional double price = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          _Internal::set_has_price(&has_bits);
          _impl_.price_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional int64 quantity = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_quantity(&has_bits);
          _impl_.quantity_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 brokerID = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_brokerid(&has_bits);
          _impl_.brokerid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .data.Side side = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_side(static_cast<::data::Side>(val));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AddOddLotOrder::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:data.AddOddLotOrder)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional int64 securityCode = 1;
  if (_internal_has_securitycode()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_securitycode(), target);
  }

  // optional int64 orderId = 2;
  if (_internal_has_orderid()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(2, this->_internal_orderid(), target);
  }

  // optional double price = 3;
  if (_internal_has_price()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(3, this->_internal_price(), target);
  }

  // optional int64 quantity = 4;
  if (_internal_has_quantity()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(4, this->_internal_quantity(), target);
  }

  // optional int32 brokerID = 5;
  if (_internal_has_brokerid()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(5, this->_internal_brokerid(), target);
  }

  // optional .data.Side side = 6;
  if (_internal_has_side()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      6, this->_internal_side(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:data.AddOddLotOrder)
  return target;
}

size_t AddOddLotOrder::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:data.AddOddLotOrder)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional int64 securityCode = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_securitycode());
    }

    // optional int64 orderId = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_orderid());
    }

    // optional double price = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 8;
    }

    // optional int64 quantity = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_quantity());
    }

    // optional int32 brokerID = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_brokerid());
    }

    // optional .data.Side side = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_side());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AddOddLotOrder::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    AddOddLotOrder::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AddOddLotOrder::GetClassData() const { return &_class_data_; }


void AddOddLotOrder::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<AddOddLotOrder*>(&to_msg);
  auto& from = static_cast<const AddOddLotOrder&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:data.AddOddLotOrder)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.securitycode_ = from._impl_.securitycode_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.orderid_ = from._impl_.orderid_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.price_ = from._impl_.price_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.quantity_ = from._impl_.quantity_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.brokerid_ = from._impl_.brokerid_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.side_ = from._impl_.side_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AddOddLotOrder::CopyFrom(const AddOddLotOrder& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:data.AddOddLotOrder)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AddOddLotOrder::IsInitialized() const {
  return true;
}

void AddOddLotOrder::InternalSwap(AddOddLotOrder* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AddOddLotOrder, _impl_.side_)
      + sizeof(AddOddLotOrder::_impl_.side_)
      - PROTOBUF_FIELD_OFFSET(AddOddLotOrder, _impl_.securitycode_)>(
          reinterpret_cast<char*>(&_impl_.securitycode_),
          reinterpret_cast<char*>(&other->_impl_.securitycode_));
}

::PROTOBUF_NAMESPACE_ID::Metadata AddOddLotOrder::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_data_2eproto_getter, &descriptor_table_data_2eproto_once,
      file_level_metadata_data_2eproto[30]);
}

// ===================================================================

class AggregateOrderBookUpdate::_Internal {
 public:
  using HasBits = decltype(std::declval<AggregateOrderBookUpdate>()._impl_._has_bits_);
  static void set_has_securitycode(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

AggregateOrderBookUpdate::AggregateOrderBookUpdate(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:data.AggregateOrderBookUpdate)
}
AggregateOrderBookUpdate::AggregateOrderBookUpdate(const AggregateOrderBookUpdate& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  AggregateOrderBookUpdate* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.noentries_){from._impl_.noentries_}
    , decltype(_impl_.securitycode_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.securitycode_ = from._impl_.securitycode_;
  // @@protoc_insertion_point(copy_constructor:data.AggregateOrderBookUpdate)
}

inline void AggregateOrderBookUpdate::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.noentries_){arena}
    , decltype(_impl_.securitycode_){int64_t{0}}
  };
}

AggregateOrderBookUpdate::~AggregateOrderBookUpdate() {
  // @@protoc_insertion_point(destructor:data.AggregateOrderBookUpdate)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AggregateOrderBookUpdate::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.noentries_.~RepeatedPtrField();
}

void AggregateOrderBookUpdate::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AggregateOrderBookUpdate::Clear() {
// @@protoc_insertion_point(message_clear_start:data.AggregateOrderBookUpdate)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.noentries_.Clear();
  _impl_.securitycode_ = int64_t{0};
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AggregateOrderBookUpdate::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int64 securityCode = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_securitycode(&has_bits);
          _impl_.securitycode_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .data.NoEntry noEntries = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_noentries(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AggregateOrderBookUpdate::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:data.AggregateOrderBookUpdate)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional int64 securityCode = 1;
  if (_internal_has_securitycode()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_securitycode(), target);
  }

  // repeated .data.NoEntry noEntries = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_noentries_size()); i < n; i++) {
    const auto& repfield = this->_internal_noentries(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:data.AggregateOrderBookUpdate)
  return target;
}

size_t AggregateOrderBookUpdate::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:data.AggregateOrderBookUpdate)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .data.NoEntry noEntries = 2;
  total_size += 1UL * this->_internal_noentries_size();
  for (const auto& msg : this->_impl_.noentries_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional int64 securityCode = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_securitycode());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AggregateOrderBookUpdate::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    AggregateOrderBookUpdate::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AggregateOrderBookUpdate::GetClassData() const { return &_class_data_; }


void AggregateOrderBookUpdate::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<AggregateOrderBookUpdate*>(&to_msg);
  auto& from = static_cast<const AggregateOrderBookUpdate&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:data.AggregateOrderBookUpdate)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.noentries_.MergeFrom(from._impl_.noentries_);
  if (from._internal_has_securitycode()) {
    _this->_internal_set_securitycode(from._internal_securitycode());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AggregateOrderBookUpdate::CopyFrom(const AggregateOrderBookUpdate& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:data.AggregateOrderBookUpdate)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AggregateOrderBookUpdate::IsInitialized() const {
  return true;
}

void AggregateOrderBookUpdate::InternalSwap(AggregateOrderBookUpdate* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.noentries_.InternalSwap(&other->_impl_.noentries_);
  swap(_impl_.securitycode_, other->_impl_.securitycode_);
}

::PROTOBUF_NAMESPACE_ID::Metadata AggregateOrderBookUpdate::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_data_2eproto_getter, &descriptor_table_data_2eproto_once,
      file_level_metadata_data_2eproto[31]);
}

// ===================================================================

class BQMoreItem::_Internal {
 public:
  using HasBits = decltype(std::declval<BQMoreItem>()._impl_._has_bits_);
  static void set_has_item(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

BQMoreItem::BQMoreItem(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:data.BQMoreItem)
}
BQMoreItem::BQMoreItem(const BQMoreItem& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  BQMoreItem* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.item_){}
    , decltype(_impl_.type_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.item_, &from._impl_.item_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.type_) -
    reinterpret_cast<char*>(&_impl_.item_)) + sizeof(_impl_.type_));
  // @@protoc_insertion_point(copy_constructor:data.BQMoreItem)
}

inline void BQMoreItem::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.item_){0}
    , decltype(_impl_.type_){0}
  };
}

BQMoreItem::~BQMoreItem() {
  // @@protoc_insertion_point(destructor:data.BQMoreItem)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void BQMoreItem::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void BQMoreItem::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void BQMoreItem::Clear() {
// @@protoc_insertion_point(message_clear_start:data.BQMoreItem)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.item_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.type_) -
        reinterpret_cast<char*>(&_impl_.item_)) + sizeof(_impl_.type_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* BQMoreItem::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 item = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_item(&has_bits);
          _impl_.item_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .data.IndicatesType type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_type(static_cast<::data::IndicatesType>(val));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* BQMoreItem::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:data.BQMoreItem)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional int32 item = 1;
  if (_internal_has_item()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_item(), target);
  }

  // optional .data.IndicatesType type = 2;
  if (_internal_has_type()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_type(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:data.BQMoreItem)
  return target;
}

size_t BQMoreItem::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:data.BQMoreItem)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional int32 item = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_item());
    }

    // optional .data.IndicatesType type = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData BQMoreItem::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    BQMoreItem::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*BQMoreItem::GetClassData() const { return &_class_data_; }


void BQMoreItem::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<BQMoreItem*>(&to_msg);
  auto& from = static_cast<const BQMoreItem&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:data.BQMoreItem)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.item_ = from._impl_.item_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.type_ = from._impl_.type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void BQMoreItem::CopyFrom(const BQMoreItem& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:data.BQMoreItem)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BQMoreItem::IsInitialized() const {
  return true;
}

void BQMoreItem::InternalSwap(BQMoreItem* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(BQMoreItem, _impl_.type_)
      + sizeof(BQMoreItem::_impl_.type_)
      - PROTOBUF_FIELD_OFFSET(BQMoreItem, _impl_.item_)>(
          reinterpret_cast<char*>(&_impl_.item_),
          reinterpret_cast<char*>(&other->_impl_.item_));
}

::PROTOBUF_NAMESPACE_ID::Metadata BQMoreItem::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_data_2eproto_getter, &descriptor_table_data_2eproto_once,
      file_level_metadata_data_2eproto[32]);
}

// ===================================================================

class BrokerQueue::_Internal {
 public:
  using HasBits = decltype(std::declval<BrokerQueue>()._impl_._has_bits_);
  static void set_has_securitycode(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_itemcount(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_side(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_bqmoreflag(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

BrokerQueue::BrokerQueue(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:data.BrokerQueue)
}
BrokerQueue::BrokerQueue(const BrokerQueue& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  BrokerQueue* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.items_){from._impl_.items_}
    , decltype(_impl_.securitycode_){}
    , decltype(_impl_.itemcount_){}
    , decltype(_impl_.side_){}
    , decltype(_impl_.bqmoreflag_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.securitycode_, &from._impl_.securitycode_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.bqmoreflag_) -
    reinterpret_cast<char*>(&_impl_.securitycode_)) + sizeof(_impl_.bqmoreflag_));
  // @@protoc_insertion_point(copy_constructor:data.BrokerQueue)
}

inline void BrokerQueue::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.items_){arena}
    , decltype(_impl_.securitycode_){int64_t{0}}
    , decltype(_impl_.itemcount_){0}
    , decltype(_impl_.side_){0}
    , decltype(_impl_.bqmoreflag_){0}
  };
}

BrokerQueue::~BrokerQueue() {
  // @@protoc_insertion_point(destructor:data.BrokerQueue)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void BrokerQueue::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.items_.~RepeatedPtrField();
}

void BrokerQueue::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void BrokerQueue::Clear() {
// @@protoc_insertion_point(message_clear_start:data.BrokerQueue)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.items_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&_impl_.securitycode_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.bqmoreflag_) -
        reinterpret_cast<char*>(&_impl_.securitycode_)) + sizeof(_impl_.bqmoreflag_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* BrokerQueue::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int64 securityCode = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_securitycode(&has_bits);
          _impl_.securitycode_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 itemCount = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_itemcount(&has_bits);
          _impl_.itemcount_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .data.BrokerSide side = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_side(static_cast<::data::BrokerSide>(val));
        } else
          goto handle_unusual;
        continue;
      // optional .data.BQMoreFlag bQMoreFlag = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_bqmoreflag(static_cast<::data::BQMoreFlag>(val));
        } else
          goto handle_unusual;
        continue;
      // repeated .data.BQMoreItem items = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_items(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* BrokerQueue::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:data.BrokerQueue)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional int64 securityCode = 1;
  if (_internal_has_securitycode()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_securitycode(), target);
  }

  // optional int32 itemCount = 2;
  if (_internal_has_itemcount()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_itemcount(), target);
  }

  // optional .data.BrokerSide side = 3;
  if (_internal_has_side()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      3, this->_internal_side(), target);
  }

  // optional .data.BQMoreFlag bQMoreFlag = 4;
  if (_internal_has_bqmoreflag()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      4, this->_internal_bqmoreflag(), target);
  }

  // repeated .data.BQMoreItem items = 5;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_items_size()); i < n; i++) {
    const auto& repfield = this->_internal_items(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(5, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:data.BrokerQueue)
  return target;
}

size_t BrokerQueue::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:data.BrokerQueue)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .data.BQMoreItem items = 5;
  total_size += 1UL * this->_internal_items_size();
  for (const auto& msg : this->_impl_.items_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional int64 securityCode = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_securitycode());
    }

    // optional int32 itemCount = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_itemcount());
    }

    // optional .data.BrokerSide side = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_side());
    }

    // optional .data.BQMoreFlag bQMoreFlag = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_bqmoreflag());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData BrokerQueue::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    BrokerQueue::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*BrokerQueue::GetClassData() const { return &_class_data_; }


void BrokerQueue::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<BrokerQueue*>(&to_msg);
  auto& from = static_cast<const BrokerQueue&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:data.BrokerQueue)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.items_.MergeFrom(from._impl_.items_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.securitycode_ = from._impl_.securitycode_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.itemcount_ = from._impl_.itemcount_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.side_ = from._impl_.side_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.bqmoreflag_ = from._impl_.bqmoreflag_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void BrokerQueue::CopyFrom(const BrokerQueue& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:data.BrokerQueue)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BrokerQueue::IsInitialized() const {
  return true;
}

void BrokerQueue::InternalSwap(BrokerQueue* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.items_.InternalSwap(&other->_impl_.items_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(BrokerQueue, _impl_.bqmoreflag_)
      + sizeof(BrokerQueue::_impl_.bqmoreflag_)
      - PROTOBUF_FIELD_OFFSET(BrokerQueue, _impl_.securitycode_)>(
          reinterpret_cast<char*>(&_impl_.securitycode_),
          reinterpret_cast<char*>(&other->_impl_.securitycode_));
}

::PROTOBUF_NAMESPACE_ID::Metadata BrokerQueue::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_data_2eproto_getter, &descriptor_table_data_2eproto_once,
      file_level_metadata_data_2eproto[33]);
}

// ===================================================================

class ClosingPrice::_Internal {
 public:
  using HasBits = decltype(std::declval<ClosingPrice>()._impl_._has_bits_);
  static void set_has_securitycode(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_closingprice(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_numberoftrades(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

ClosingPrice::ClosingPrice(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:data.ClosingPrice)
}
ClosingPrice::ClosingPrice(const ClosingPrice& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ClosingPrice* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.securitycode_){}
    , decltype(_impl_.closingprice_){}
    , decltype(_impl_.numberoftrades_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.securitycode_, &from._impl_.securitycode_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.numberoftrades_) -
    reinterpret_cast<char*>(&_impl_.securitycode_)) + sizeof(_impl_.numberoftrades_));
  // @@protoc_insertion_point(copy_constructor:data.ClosingPrice)
}

inline void ClosingPrice::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.securitycode_){int64_t{0}}
    , decltype(_impl_.closingprice_){0}
    , decltype(_impl_.numberoftrades_){int64_t{0}}
  };
}

ClosingPrice::~ClosingPrice() {
  // @@protoc_insertion_point(destructor:data.ClosingPrice)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ClosingPrice::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ClosingPrice::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ClosingPrice::Clear() {
// @@protoc_insertion_point(message_clear_start:data.ClosingPrice)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.securitycode_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.numberoftrades_) -
        reinterpret_cast<char*>(&_impl_.securitycode_)) + sizeof(_impl_.numberoftrades_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ClosingPrice::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int64 securityCode = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_securitycode(&has_bits);
          _impl_.securitycode_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional double closingPrice = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _Internal::set_has_closingprice(&has_bits);
          _impl_.closingprice_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional int64 numberOfTrades = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_numberoftrades(&has_bits);
          _impl_.numberoftrades_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ClosingPrice::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:data.ClosingPrice)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional int64 securityCode = 1;
  if (_internal_has_securitycode()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_securitycode(), target);
  }

  // optional double closingPrice = 2;
  if (_internal_has_closingprice()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(2, this->_internal_closingprice(), target);
  }

  // optional int64 numberOfTrades = 3;
  if (_internal_has_numberoftrades()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(3, this->_internal_numberoftrades(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:data.ClosingPrice)
  return target;
}

size_t ClosingPrice::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:data.ClosingPrice)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional int64 securityCode = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_securitycode());
    }

    // optional double closingPrice = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 8;
    }

    // optional int64 numberOfTrades = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_numberoftrades());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ClosingPrice::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ClosingPrice::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ClosingPrice::GetClassData() const { return &_class_data_; }


void ClosingPrice::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ClosingPrice*>(&to_msg);
  auto& from = static_cast<const ClosingPrice&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:data.ClosingPrice)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.securitycode_ = from._impl_.securitycode_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.closingprice_ = from._impl_.closingprice_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.numberoftrades_ = from._impl_.numberoftrades_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ClosingPrice::CopyFrom(const ClosingPrice& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:data.ClosingPrice)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClosingPrice::IsInitialized() const {
  return true;
}

void ClosingPrice::InternalSwap(ClosingPrice* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ClosingPrice, _impl_.numberoftrades_)
      + sizeof(ClosingPrice::_impl_.numberoftrades_)
      - PROTOBUF_FIELD_OFFSET(ClosingPrice, _impl_.securitycode_)>(
          reinterpret_cast<char*>(&_impl_.securitycode_),
          reinterpret_cast<char*>(&other->_impl_.securitycode_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ClosingPrice::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_data_2eproto_getter, &descriptor_table_data_2eproto_once,
      file_level_metadata_data_2eproto[34]);
}

// ===================================================================

class CurrencyRate::_Internal {
 public:
  using HasBits = decltype(std::declval<CurrencyRate>()._impl_._has_bits_);
  static void set_has_currencycode(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_currencyfactor(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_currencyrate(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

CurrencyRate::CurrencyRate(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:data.CurrencyRate)
}
CurrencyRate::CurrencyRate(const CurrencyRate& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CurrencyRate* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.currencycode_){}
    , decltype(_impl_.currencyfactor_){}
    , decltype(_impl_.currencyrate_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.currencycode_, &from._impl_.currencycode_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.currencyrate_) -
    reinterpret_cast<char*>(&_impl_.currencycode_)) + sizeof(_impl_.currencyrate_));
  // @@protoc_insertion_point(copy_constructor:data.CurrencyRate)
}

inline void CurrencyRate::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.currencycode_){0}
    , decltype(_impl_.currencyfactor_){0}
    , decltype(_impl_.currencyrate_){0}
  };
}

CurrencyRate::~CurrencyRate() {
  // @@protoc_insertion_point(destructor:data.CurrencyRate)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CurrencyRate::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CurrencyRate::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CurrencyRate::Clear() {
// @@protoc_insertion_point(message_clear_start:data.CurrencyRate)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.currencycode_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.currencyrate_) -
        reinterpret_cast<char*>(&_impl_.currencycode_)) + sizeof(_impl_.currencyrate_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CurrencyRate::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .data.CurrencyType currencyCode = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_currencycode(static_cast<::data::CurrencyType>(val));
        } else
          goto handle_unusual;
        continue;
      // optional int32 currencyFactor = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_currencyfactor(&has_bits);
          _impl_.currencyfactor_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional double currencyRate = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          _Internal::set_has_currencyrate(&has_bits);
          _impl_.currencyrate_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CurrencyRate::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:data.CurrencyRate)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional .data.CurrencyType currencyCode = 1;
  if (_internal_has_currencycode()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_currencycode(), target);
  }

  // optional int32 currencyFactor = 2;
  if (_internal_has_currencyfactor()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_currencyfactor(), target);
  }

  // optional double currencyRate = 3;
  if (_internal_has_currencyrate()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(3, this->_internal_currencyrate(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:data.CurrencyRate)
  return target;
}

size_t CurrencyRate::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:data.CurrencyRate)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .data.CurrencyType currencyCode = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_currencycode());
    }

    // optional int32 currencyFactor = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_currencyfactor());
    }

    // optional double currencyRate = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 8;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CurrencyRate::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CurrencyRate::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CurrencyRate::GetClassData() const { return &_class_data_; }


void CurrencyRate::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CurrencyRate*>(&to_msg);
  auto& from = static_cast<const CurrencyRate&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:data.CurrencyRate)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.currencycode_ = from._impl_.currencycode_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.currencyfactor_ = from._impl_.currencyfactor_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.currencyrate_ = from._impl_.currencyrate_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CurrencyRate::CopyFrom(const CurrencyRate& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:data.CurrencyRate)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CurrencyRate::IsInitialized() const {
  return true;
}

void CurrencyRate::InternalSwap(CurrencyRate* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CurrencyRate, _impl_.currencyrate_)
      + sizeof(CurrencyRate::_impl_.currencyrate_)
      - PROTOBUF_FIELD_OFFSET(CurrencyRate, _impl_.currencycode_)>(
          reinterpret_cast<char*>(&_impl_.currencycode_),
          reinterpret_cast<char*>(&other->_impl_.currencycode_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CurrencyRate::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_data_2eproto_getter, &descriptor_table_data_2eproto_once,
      file_level_metadata_data_2eproto[35]);
}

// ===================================================================

class DeleteOddLotOrder::_Internal {
 public:
  using HasBits = decltype(std::declval<DeleteOddLotOrder>()._impl_._has_bits_);
  static void set_has_securitycode(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_orderid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_brokerid(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_side(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

DeleteOddLotOrder::DeleteOddLotOrder(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:data.DeleteOddLotOrder)
}
DeleteOddLotOrder::DeleteOddLotOrder(const DeleteOddLotOrder& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  DeleteOddLotOrder* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.securitycode_){}
    , decltype(_impl_.orderid_){}
    , decltype(_impl_.brokerid_){}
    , decltype(_impl_.side_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.securitycode_, &from._impl_.securitycode_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.side_) -
    reinterpret_cast<char*>(&_impl_.securitycode_)) + sizeof(_impl_.side_));
  // @@protoc_insertion_point(copy_constructor:data.DeleteOddLotOrder)
}

inline void DeleteOddLotOrder::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.securitycode_){int64_t{0}}
    , decltype(_impl_.orderid_){int64_t{0}}
    , decltype(_impl_.brokerid_){0}
    , decltype(_impl_.side_){0}
  };
}

DeleteOddLotOrder::~DeleteOddLotOrder() {
  // @@protoc_insertion_point(destructor:data.DeleteOddLotOrder)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DeleteOddLotOrder::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void DeleteOddLotOrder::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DeleteOddLotOrder::Clear() {
// @@protoc_insertion_point(message_clear_start:data.DeleteOddLotOrder)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&_impl_.securitycode_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.side_) -
        reinterpret_cast<char*>(&_impl_.securitycode_)) + sizeof(_impl_.side_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DeleteOddLotOrder::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int64 securityCode = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_securitycode(&has_bits);
          _impl_.securitycode_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 orderId = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_orderid(&has_bits);
          _impl_.orderid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 brokerID = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_brokerid(&has_bits);
          _impl_.brokerid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .data.Side side = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_side(static_cast<::data::Side>(val));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DeleteOddLotOrder::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:data.DeleteOddLotOrder)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional int64 securityCode = 1;
  if (_internal_has_securitycode()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_securitycode(), target);
  }

  // optional int64 orderId = 2;
  if (_internal_has_orderid()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(2, this->_internal_orderid(), target);
  }

  // optional int32 brokerID = 3;
  if (_internal_has_brokerid()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_brokerid(), target);
  }

  // optional .data.Side side = 4;
  if (_internal_has_side()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      4, this->_internal_side(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:data.DeleteOddLotOrder)
  return target;
}

size_t DeleteOddLotOrder::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:data.DeleteOddLotOrder)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional int64 securityCode = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_securitycode());
    }

    // optional int64 orderId = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_orderid());
    }

    // optional int32 brokerID = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_brokerid());
    }

    // optional .data.Side side = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_side());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DeleteOddLotOrder::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    DeleteOddLotOrder::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DeleteOddLotOrder::GetClassData() const { return &_class_data_; }


void DeleteOddLotOrder::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<DeleteOddLotOrder*>(&to_msg);
  auto& from = static_cast<const DeleteOddLotOrder&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:data.DeleteOddLotOrder)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.securitycode_ = from._impl_.securitycode_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.orderid_ = from._impl_.orderid_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.brokerid_ = from._impl_.brokerid_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.side_ = from._impl_.side_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DeleteOddLotOrder::CopyFrom(const DeleteOddLotOrder& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:data.DeleteOddLotOrder)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DeleteOddLotOrder::IsInitialized() const {
  return true;
}

void DeleteOddLotOrder::InternalSwap(DeleteOddLotOrder* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(DeleteOddLotOrder, _impl_.side_)
      + sizeof(DeleteOddLotOrder::_impl_.side_)
      - PROTOBUF_FIELD_OFFSET(DeleteOddLotOrder, _impl_.securitycode_)>(
          reinterpret_cast<char*>(&_impl_.securitycode_),
          reinterpret_cast<char*>(&other->_impl_.securitycode_));
}

::PROTOBUF_NAMESPACE_ID::Metadata DeleteOddLotOrder::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_data_2eproto_getter, &descriptor_table_data_2eproto_once,
      file_level_metadata_data_2eproto[36]);
}

// ===================================================================

class IndexData::_Internal {
 public:
  using HasBits = decltype(std::declval<IndexData>()._impl_._has_bits_);
  static void set_has_indexcode(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_indexstatus(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static void set_has_indextime(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_indexvalue(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_netchgprevday(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_highvalue(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_lowvalue(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_easvalue(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_indexturnover(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_openingvalue(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_closingvalue(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_previoussesclose(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_indexvolume(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_netchgprevdaypct(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_exception(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

IndexData::IndexData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:data.IndexData)
}
IndexData::IndexData(const IndexData& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  IndexData* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.indexcode_){}
    , decltype(_impl_.exception_){}
    , decltype(_impl_.indextime_){}
    , decltype(_impl_.indexvalue_){}
    , decltype(_impl_.netchgprevday_){}
    , decltype(_impl_.highvalue_){}
    , decltype(_impl_.lowvalue_){}
    , decltype(_impl_.easvalue_){}
    , decltype(_impl_.indexturnover_){}
    , decltype(_impl_.openingvalue_){}
    , decltype(_impl_.closingvalue_){}
    , decltype(_impl_.previoussesclose_){}
    , decltype(_impl_.indexvolume_){}
    , decltype(_impl_.netchgprevdaypct_){}
    , decltype(_impl_.indexstatus_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.indexcode_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.indexcode_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_indexcode()) {
    _this->_impl_.indexcode_.Set(from._internal_indexcode(), 
      _this->GetArenaForAllocation());
  }
  _impl_.exception_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.exception_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_exception()) {
    _this->_impl_.exception_.Set(from._internal_exception(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.indextime_, &from._impl_.indextime_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.indexstatus_) -
    reinterpret_cast<char*>(&_impl_.indextime_)) + sizeof(_impl_.indexstatus_));
  // @@protoc_insertion_point(copy_constructor:data.IndexData)
}

inline void IndexData::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.indexcode_){}
    , decltype(_impl_.exception_){}
    , decltype(_impl_.indextime_){int64_t{0}}
    , decltype(_impl_.indexvalue_){0}
    , decltype(_impl_.netchgprevday_){0}
    , decltype(_impl_.highvalue_){0}
    , decltype(_impl_.lowvalue_){0}
    , decltype(_impl_.easvalue_){0}
    , decltype(_impl_.indexturnover_){0}
    , decltype(_impl_.openingvalue_){0}
    , decltype(_impl_.closingvalue_){0}
    , decltype(_impl_.previoussesclose_){0}
    , decltype(_impl_.indexvolume_){int64_t{0}}
    , decltype(_impl_.netchgprevdaypct_){0}
    , decltype(_impl_.indexstatus_){0}
  };
  _impl_.indexcode_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.indexcode_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.exception_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.exception_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

IndexData::~IndexData() {
  // @@protoc_insertion_point(destructor:data.IndexData)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void IndexData::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.indexcode_.Destroy();
  _impl_.exception_.Destroy();
}

void IndexData::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void IndexData::Clear() {
// @@protoc_insertion_point(message_clear_start:data.IndexData)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.indexcode_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.exception_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x000000fcu) {
    ::memset(&_impl_.indextime_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.easvalue_) -
        reinterpret_cast<char*>(&_impl_.indextime_)) + sizeof(_impl_.easvalue_));
  }
  if (cached_has_bits & 0x00007f00u) {
    ::memset(&_impl_.indexturnover_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.indexstatus_) -
        reinterpret_cast<char*>(&_impl_.indexturnover_)) + sizeof(_impl_.indexstatus_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* IndexData::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string indexCode = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_indexcode();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "data.IndexData.indexCode"));
        } else
          goto handle_unusual;
        continue;
      // optional .data.IndexStatus indexStatus = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_indexstatus(static_cast<::data::IndexStatus>(val));
        } else
          goto handle_unusual;
        continue;
      // optional int64 indexTime = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_indextime(&has_bits);
          _impl_.indextime_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional double indexValue = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 33)) {
          _Internal::set_has_indexvalue(&has_bits);
          _impl_.indexvalue_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double netChgPrevDay = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 41)) {
          _Internal::set_has_netchgprevday(&has_bits);
          _impl_.netchgprevday_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double highValue = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 49)) {
          _Internal::set_has_highvalue(&has_bits);
          _impl_.highvalue_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double lowValue = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 57)) {
          _Internal::set_has_lowvalue(&has_bits);
          _impl_.lowvalue_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double eASValue = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 65)) {
          _Internal::set_has_easvalue(&has_bits);
          _impl_.easvalue_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double indexTurnover = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 73)) {
          _Internal::set_has_indexturnover(&has_bits);
          _impl_.indexturnover_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double openingValue = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 81)) {
          _Internal::set_has_openingvalue(&has_bits);
          _impl_.openingvalue_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double closingValue = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 89)) {
          _Internal::set_has_closingvalue(&has_bits);
          _impl_.closingvalue_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double previousSesClose = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 97)) {
          _Internal::set_has_previoussesclose(&has_bits);
          _impl_.previoussesclose_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional int64 indexVolume = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          _Internal::set_has_indexvolume(&has_bits);
          _impl_.indexvolume_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional double netChgPrevDayPct = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 113)) {
          _Internal::set_has_netchgprevdaypct(&has_bits);
          _impl_.netchgprevdaypct_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional string exception = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 122)) {
          auto str = _internal_mutable_exception();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "data.IndexData.exception"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* IndexData::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:data.IndexData)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional string indexCode = 1;
  if (_internal_has_indexcode()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_indexcode().data(), static_cast<int>(this->_internal_indexcode().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "data.IndexData.indexCode");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_indexcode(), target);
  }

  // optional .data.IndexStatus indexStatus = 2;
  if (_internal_has_indexstatus()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_indexstatus(), target);
  }

  // optional int64 indexTime = 3;
  if (_internal_has_indextime()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(3, this->_internal_indextime(), target);
  }

  // optional double indexValue = 4;
  if (_internal_has_indexvalue()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(4, this->_internal_indexvalue(), target);
  }

  // optional double netChgPrevDay = 5;
  if (_internal_has_netchgprevday()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(5, this->_internal_netchgprevday(), target);
  }

  // optional double highValue = 6;
  if (_internal_has_highvalue()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(6, this->_internal_highvalue(), target);
  }

  // optional double lowValue = 7;
  if (_internal_has_lowvalue()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(7, this->_internal_lowvalue(), target);
  }

  // optional double eASValue = 8;
  if (_internal_has_easvalue()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(8, this->_internal_easvalue(), target);
  }

  // optional double indexTurnover = 9;
  if (_internal_has_indexturnover()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(9, this->_internal_indexturnover(), target);
  }

  // optional double openingValue = 10;
  if (_internal_has_openingvalue()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(10, this->_internal_openingvalue(), target);
  }

  // optional double closingValue = 11;
  if (_internal_has_closingvalue()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(11, this->_internal_closingvalue(), target);
  }

  // optional double previousSesClose = 12;
  if (_internal_has_previoussesclose()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(12, this->_internal_previoussesclose(), target);
  }

  // optional int64 indexVolume = 13;
  if (_internal_has_indexvolume()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(13, this->_internal_indexvolume(), target);
  }

  // optional double netChgPrevDayPct = 14;
  if (_internal_has_netchgprevdaypct()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(14, this->_internal_netchgprevdaypct(), target);
  }

  // optional string exception = 15;
  if (_internal_has_exception()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_exception().data(), static_cast<int>(this->_internal_exception().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "data.IndexData.exception");
    target = stream->WriteStringMaybeAliased(
        15, this->_internal_exception(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:data.IndexData)
  return target;
}

size_t IndexData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:data.IndexData)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string indexCode = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_indexcode());
    }

    // optional string exception = 15;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_exception());
    }

    // optional int64 indexTime = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_indextime());
    }

    // optional double indexValue = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 8;
    }

    // optional double netChgPrevDay = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 8;
    }

    // optional double highValue = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 8;
    }

    // optional double lowValue = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 8;
    }

    // optional double eASValue = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 8;
    }

  }
  if (cached_has_bits & 0x00007f00u) {
    // optional double indexTurnover = 9;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 + 8;
    }

    // optional double openingValue = 10;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 + 8;
    }

    // optional double closingValue = 11;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 + 8;
    }

    // optional double previousSesClose = 12;
    if (cached_has_bits & 0x00000800u) {
      total_size += 1 + 8;
    }

    // optional int64 indexVolume = 13;
    if (cached_has_bits & 0x00001000u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_indexvolume());
    }

    // optional double netChgPrevDayPct = 14;
    if (cached_has_bits & 0x00002000u) {
      total_size += 1 + 8;
    }

    // optional .data.IndexStatus indexStatus = 2;
    if (cached_has_bits & 0x00004000u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_indexstatus());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData IndexData::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    IndexData::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*IndexData::GetClassData() const { return &_class_data_; }


void IndexData::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<IndexData*>(&to_msg);
  auto& from = static_cast<const IndexData&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:data.IndexData)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_indexcode(from._internal_indexcode());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_exception(from._internal_exception());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.indextime_ = from._impl_.indextime_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.indexvalue_ = from._impl_.indexvalue_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.netchgprevday_ = from._impl_.netchgprevday_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.highvalue_ = from._impl_.highvalue_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.lowvalue_ = from._impl_.lowvalue_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.easvalue_ = from._impl_.easvalue_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00007f00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.indexturnover_ = from._impl_.indexturnover_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.openingvalue_ = from._impl_.openingvalue_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.closingvalue_ = from._impl_.closingvalue_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.previoussesclose_ = from._impl_.previoussesclose_;
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_impl_.indexvolume_ = from._impl_.indexvolume_;
    }
    if (cached_has_bits & 0x00002000u) {
      _this->_impl_.netchgprevdaypct_ = from._impl_.netchgprevdaypct_;
    }
    if (cached_has_bits & 0x00004000u) {
      _this->_impl_.indexstatus_ = from._impl_.indexstatus_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void IndexData::CopyFrom(const IndexData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:data.IndexData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IndexData::IsInitialized() const {
  return true;
}

void IndexData::InternalSwap(IndexData* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.indexcode_, lhs_arena,
      &other->_impl_.indexcode_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.exception_, lhs_arena,
      &other->_impl_.exception_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(IndexData, _impl_.indexstatus_)
      + sizeof(IndexData::_impl_.indexstatus_)
      - PROTOBUF_FIELD_OFFSET(IndexData, _impl_.indextime_)>(
          reinterpret_cast<char*>(&_impl_.indextime_),
          reinterpret_cast<char*>(&other->_impl_.indextime_));
}

::PROTOBUF_NAMESPACE_ID::Metadata IndexData::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_data_2eproto_getter, &descriptor_table_data_2eproto_once,
      file_level_metadata_data_2eproto[37]);
}

// ===================================================================

class IndexDefinition::_Internal {
 public:
  using HasBits = decltype(std::declval<IndexDefinition>()._impl_._has_bits_);
  static void set_has_indexcode(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_indexsource(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_currencycode(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

IndexDefinition::IndexDefinition(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:data.IndexDefinition)
}
IndexDefinition::IndexDefinition(const IndexDefinition& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  IndexDefinition* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.indexcode_){}
    , decltype(_impl_.indexsource_){}
    , decltype(_impl_.currencycode_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.indexcode_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.indexcode_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_indexcode()) {
    _this->_impl_.indexcode_.Set(from._internal_indexcode(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.indexsource_, &from._impl_.indexsource_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.currencycode_) -
    reinterpret_cast<char*>(&_impl_.indexsource_)) + sizeof(_impl_.currencycode_));
  // @@protoc_insertion_point(copy_constructor:data.IndexDefinition)
}

inline void IndexDefinition::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.indexcode_){}
    , decltype(_impl_.indexsource_){0}
    , decltype(_impl_.currencycode_){0}
  };
  _impl_.indexcode_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.indexcode_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

IndexDefinition::~IndexDefinition() {
  // @@protoc_insertion_point(destructor:data.IndexDefinition)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void IndexDefinition::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.indexcode_.Destroy();
}

void IndexDefinition::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void IndexDefinition::Clear() {
// @@protoc_insertion_point(message_clear_start:data.IndexDefinition)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.indexcode_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&_impl_.indexsource_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.currencycode_) -
        reinterpret_cast<char*>(&_impl_.indexsource_)) + sizeof(_impl_.currencycode_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* IndexDefinition::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string indexCode = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_indexcode();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "data.IndexDefinition.indexCode"));
        } else
          goto handle_unusual;
        continue;
      // optional .data.IndexSource indexSource = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_indexsource(static_cast<::data::IndexSource>(val));
        } else
          goto handle_unusual;
        continue;
      // optional .data.CurrencyType currencyCode = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_currencycode(static_cast<::data::CurrencyType>(val));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* IndexDefinition::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:data.IndexDefinition)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional string indexCode = 1;
  if (_internal_has_indexcode()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_indexcode().data(), static_cast<int>(this->_internal_indexcode().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "data.IndexDefinition.indexCode");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_indexcode(), target);
  }

  // optional .data.IndexSource indexSource = 2;
  if (_internal_has_indexsource()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_indexsource(), target);
  }

  // optional .data.CurrencyType currencyCode = 3;
  if (_internal_has_currencycode()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      3, this->_internal_currencycode(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:data.IndexDefinition)
  return target;
}

size_t IndexDefinition::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:data.IndexDefinition)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string indexCode = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_indexcode());
    }

    // optional .data.IndexSource indexSource = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_indexsource());
    }

    // optional .data.CurrencyType currencyCode = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_currencycode());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData IndexDefinition::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    IndexDefinition::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*IndexDefinition::GetClassData() const { return &_class_data_; }


void IndexDefinition::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<IndexDefinition*>(&to_msg);
  auto& from = static_cast<const IndexDefinition&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:data.IndexDefinition)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_indexcode(from._internal_indexcode());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.indexsource_ = from._impl_.indexsource_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.currencycode_ = from._impl_.currencycode_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void IndexDefinition::CopyFrom(const IndexDefinition& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:data.IndexDefinition)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IndexDefinition::IsInitialized() const {
  return true;
}

void IndexDefinition::InternalSwap(IndexDefinition* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.indexcode_, lhs_arena,
      &other->_impl_.indexcode_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(IndexDefinition, _impl_.currencycode_)
      + sizeof(IndexDefinition::_impl_.currencycode_)
      - PROTOBUF_FIELD_OFFSET(IndexDefinition, _impl_.indexsource_)>(
          reinterpret_cast<char*>(&_impl_.indexsource_),
          reinterpret_cast<char*>(&other->_impl_.indexsource_));
}

::PROTOBUF_NAMESPACE_ID::Metadata IndexDefinition::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_data_2eproto_getter, &descriptor_table_data_2eproto_once,
      file_level_metadata_data_2eproto[38]);
}

// ===================================================================

class IndicativeEquilibriumPrice::_Internal {
 public:
  using HasBits = decltype(std::declval<IndicativeEquilibriumPrice>()._impl_._has_bits_);
  static void set_has_securitycode(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_price(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_aggregatequantity(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

IndicativeEquilibriumPrice::IndicativeEquilibriumPrice(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:data.IndicativeEquilibriumPrice)
}
IndicativeEquilibriumPrice::IndicativeEquilibriumPrice(const IndicativeEquilibriumPrice& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  IndicativeEquilibriumPrice* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.securitycode_){}
    , decltype(_impl_.price_){}
    , decltype(_impl_.aggregatequantity_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.securitycode_, &from._impl_.securitycode_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.aggregatequantity_) -
    reinterpret_cast<char*>(&_impl_.securitycode_)) + sizeof(_impl_.aggregatequantity_));
  // @@protoc_insertion_point(copy_constructor:data.IndicativeEquilibriumPrice)
}

inline void IndicativeEquilibriumPrice::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.securitycode_){int64_t{0}}
    , decltype(_impl_.price_){0}
    , decltype(_impl_.aggregatequantity_){int64_t{0}}
  };
}

IndicativeEquilibriumPrice::~IndicativeEquilibriumPrice() {
  // @@protoc_insertion_point(destructor:data.IndicativeEquilibriumPrice)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void IndicativeEquilibriumPrice::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void IndicativeEquilibriumPrice::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void IndicativeEquilibriumPrice::Clear() {
// @@protoc_insertion_point(message_clear_start:data.IndicativeEquilibriumPrice)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.securitycode_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.aggregatequantity_) -
        reinterpret_cast<char*>(&_impl_.securitycode_)) + sizeof(_impl_.aggregatequantity_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* IndicativeEquilibriumPrice::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int64 securityCode = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_securitycode(&has_bits);
          _impl_.securitycode_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional double price = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _Internal::set_has_price(&has_bits);
          _impl_.price_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional int64 aggregateQuantity = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_aggregatequantity(&has_bits);
          _impl_.aggregatequantity_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* IndicativeEquilibriumPrice::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:data.IndicativeEquilibriumPrice)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional int64 securityCode = 1;
  if (_internal_has_securitycode()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_securitycode(), target);
  }

  // optional double price = 2;
  if (_internal_has_price()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(2, this->_internal_price(), target);
  }

  // optional int64 aggregateQuantity = 3;
  if (_internal_has_aggregatequantity()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(3, this->_internal_aggregatequantity(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:data.IndicativeEquilibriumPrice)
  return target;
}

size_t IndicativeEquilibriumPrice::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:data.IndicativeEquilibriumPrice)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional int64 securityCode = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_securitycode());
    }

    // optional double price = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 8;
    }

    // optional int64 aggregateQuantity = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_aggregatequantity());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData IndicativeEquilibriumPrice::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    IndicativeEquilibriumPrice::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*IndicativeEquilibriumPrice::GetClassData() const { return &_class_data_; }


void IndicativeEquilibriumPrice::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<IndicativeEquilibriumPrice*>(&to_msg);
  auto& from = static_cast<const IndicativeEquilibriumPrice&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:data.IndicativeEquilibriumPrice)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.securitycode_ = from._impl_.securitycode_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.price_ = from._impl_.price_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.aggregatequantity_ = from._impl_.aggregatequantity_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void IndicativeEquilibriumPrice::CopyFrom(const IndicativeEquilibriumPrice& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:data.IndicativeEquilibriumPrice)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IndicativeEquilibriumPrice::IsInitialized() const {
  return true;
}

void IndicativeEquilibriumPrice::InternalSwap(IndicativeEquilibriumPrice* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(IndicativeEquilibriumPrice, _impl_.aggregatequantity_)
      + sizeof(IndicativeEquilibriumPrice::_impl_.aggregatequantity_)
      - PROTOBUF_FIELD_OFFSET(IndicativeEquilibriumPrice, _impl_.securitycode_)>(
          reinterpret_cast<char*>(&_impl_.securitycode_),
          reinterpret_cast<char*>(&other->_impl_.securitycode_));
}

::PROTOBUF_NAMESPACE_ID::Metadata IndicativeEquilibriumPrice::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_data_2eproto_getter, &descriptor_table_data_2eproto_once,
      file_level_metadata_data_2eproto[39]);
}

// ===================================================================

class LiquidityProvider::_Internal {
 public:
  using HasBits = decltype(std::declval<LiquidityProvider>()._impl_._has_bits_);
  static void set_has_securitycode(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

LiquidityProvider::LiquidityProvider(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:data.LiquidityProvider)
}
LiquidityProvider::LiquidityProvider(const LiquidityProvider& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  LiquidityProvider* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.noliquidityproviders_){from._impl_.noliquidityproviders_}
    , decltype(_impl_.securitycode_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.securitycode_ = from._impl_.securitycode_;
  // @@protoc_insertion_point(copy_constructor:data.LiquidityProvider)
}

inline void LiquidityProvider::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.noliquidityproviders_){arena}
    , decltype(_impl_.securitycode_){int64_t{0}}
  };
}

LiquidityProvider::~LiquidityProvider() {
  // @@protoc_insertion_point(destructor:data.LiquidityProvider)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LiquidityProvider::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.noliquidityproviders_.~RepeatedPtrField();
}

void LiquidityProvider::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LiquidityProvider::Clear() {
// @@protoc_insertion_point(message_clear_start:data.LiquidityProvider)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.noliquidityproviders_.Clear();
  _impl_.securitycode_ = int64_t{0};
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LiquidityProvider::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int64 securityCode = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_securitycode(&has_bits);
          _impl_.securitycode_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .data.NoLiquidityProvider noLiquidityProviders = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_noliquidityproviders(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LiquidityProvider::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:data.LiquidityProvider)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional int64 securityCode = 1;
  if (_internal_has_securitycode()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_securitycode(), target);
  }

  // repeated .data.NoLiquidityProvider noLiquidityProviders = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_noliquidityproviders_size()); i < n; i++) {
    const auto& repfield = this->_internal_noliquidityproviders(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:data.LiquidityProvider)
  return target;
}

size_t LiquidityProvider::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:data.LiquidityProvider)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .data.NoLiquidityProvider noLiquidityProviders = 2;
  total_size += 1UL * this->_internal_noliquidityproviders_size();
  for (const auto& msg : this->_impl_.noliquidityproviders_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional int64 securityCode = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_securitycode());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LiquidityProvider::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    LiquidityProvider::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LiquidityProvider::GetClassData() const { return &_class_data_; }


void LiquidityProvider::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<LiquidityProvider*>(&to_msg);
  auto& from = static_cast<const LiquidityProvider&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:data.LiquidityProvider)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.noliquidityproviders_.MergeFrom(from._impl_.noliquidityproviders_);
  if (from._internal_has_securitycode()) {
    _this->_internal_set_securitycode(from._internal_securitycode());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LiquidityProvider::CopyFrom(const LiquidityProvider& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:data.LiquidityProvider)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LiquidityProvider::IsInitialized() const {
  return true;
}

void LiquidityProvider::InternalSwap(LiquidityProvider* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.noliquidityproviders_.InternalSwap(&other->_impl_.noliquidityproviders_);
  swap(_impl_.securitycode_, other->_impl_.securitycode_);
}

::PROTOBUF_NAMESPACE_ID::Metadata LiquidityProvider::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_data_2eproto_getter, &descriptor_table_data_2eproto_once,
      file_level_metadata_data_2eproto[40]);
}

// ===================================================================

class MarketDefinition::_Internal {
 public:
  using HasBits = decltype(std::declval<MarketDefinition>()._impl_._has_bits_);
  static void set_has_marketcode(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_marketname(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_currencycode(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_numberofsecurities(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

MarketDefinition::MarketDefinition(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:data.MarketDefinition)
}
MarketDefinition::MarketDefinition(const MarketDefinition& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  MarketDefinition* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.marketname_){}
    , decltype(_impl_.marketcode_){}
    , decltype(_impl_.currencycode_){}
    , decltype(_impl_.numberofsecurities_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.marketname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.marketname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_marketname()) {
    _this->_impl_.marketname_.Set(from._internal_marketname(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.marketcode_, &from._impl_.marketcode_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.numberofsecurities_) -
    reinterpret_cast<char*>(&_impl_.marketcode_)) + sizeof(_impl_.numberofsecurities_));
  // @@protoc_insertion_point(copy_constructor:data.MarketDefinition)
}

inline void MarketDefinition::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.marketname_){}
    , decltype(_impl_.marketcode_){0}
    , decltype(_impl_.currencycode_){0}
    , decltype(_impl_.numberofsecurities_){int64_t{0}}
  };
  _impl_.marketname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.marketname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

MarketDefinition::~MarketDefinition() {
  // @@protoc_insertion_point(destructor:data.MarketDefinition)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MarketDefinition::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.marketname_.Destroy();
}

void MarketDefinition::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MarketDefinition::Clear() {
// @@protoc_insertion_point(message_clear_start:data.MarketDefinition)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.marketname_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(&_impl_.marketcode_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.numberofsecurities_) -
        reinterpret_cast<char*>(&_impl_.marketcode_)) + sizeof(_impl_.numberofsecurities_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MarketDefinition::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .data.MarketCode marketCode = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_marketcode(static_cast<::data::MarketCode>(val));
        } else
          goto handle_unusual;
        continue;
      // optional string marketName = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_marketname();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "data.MarketDefinition.marketName"));
        } else
          goto handle_unusual;
        continue;
      // optional .data.CurrencyType currencyCode = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_currencycode(static_cast<::data::CurrencyType>(val));
        } else
          goto handle_unusual;
        continue;
      // optional int64 numberOfSecurities = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_numberofsecurities(&has_bits);
          _impl_.numberofsecurities_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MarketDefinition::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:data.MarketDefinition)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional .data.MarketCode marketCode = 1;
  if (_internal_has_marketcode()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_marketcode(), target);
  }

  // optional string marketName = 2;
  if (_internal_has_marketname()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_marketname().data(), static_cast<int>(this->_internal_marketname().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "data.MarketDefinition.marketName");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_marketname(), target);
  }

  // optional .data.CurrencyType currencyCode = 3;
  if (_internal_has_currencycode()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      3, this->_internal_currencycode(), target);
  }

  // optional int64 numberOfSecurities = 4;
  if (_internal_has_numberofsecurities()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(4, this->_internal_numberofsecurities(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:data.MarketDefinition)
  return target;
}

size_t MarketDefinition::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:data.MarketDefinition)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string marketName = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_marketname());
    }

    // optional .data.MarketCode marketCode = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_marketcode());
    }

    // optional .data.CurrencyType currencyCode = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_currencycode());
    }

    // optional int64 numberOfSecurities = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_numberofsecurities());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MarketDefinition::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    MarketDefinition::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MarketDefinition::GetClassData() const { return &_class_data_; }


void MarketDefinition::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<MarketDefinition*>(&to_msg);
  auto& from = static_cast<const MarketDefinition&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:data.MarketDefinition)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_marketname(from._internal_marketname());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.marketcode_ = from._impl_.marketcode_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.currencycode_ = from._impl_.currencycode_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.numberofsecurities_ = from._impl_.numberofsecurities_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MarketDefinition::CopyFrom(const MarketDefinition& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:data.MarketDefinition)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MarketDefinition::IsInitialized() const {
  return true;
}

void MarketDefinition::InternalSwap(MarketDefinition* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.marketname_, lhs_arena,
      &other->_impl_.marketname_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MarketDefinition, _impl_.numberofsecurities_)
      + sizeof(MarketDefinition::_impl_.numberofsecurities_)
      - PROTOBUF_FIELD_OFFSET(MarketDefinition, _impl_.marketcode_)>(
          reinterpret_cast<char*>(&_impl_.marketcode_),
          reinterpret_cast<char*>(&other->_impl_.marketcode_));
}

::PROTOBUF_NAMESPACE_ID::Metadata MarketDefinition::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_data_2eproto_getter, &descriptor_table_data_2eproto_once,
      file_level_metadata_data_2eproto[41]);
}

// ===================================================================

class MarketTurnover::_Internal {
 public:
  using HasBits = decltype(std::declval<MarketTurnover>()._impl_._has_bits_);
  static void set_has_marketcode(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_currencycode(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_turnover(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

MarketTurnover::MarketTurnover(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:data.MarketTurnover)
}
MarketTurnover::MarketTurnover(const MarketTurnover& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  MarketTurnover* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.marketcode_){}
    , decltype(_impl_.currencycode_){}
    , decltype(_impl_.turnover_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.marketcode_, &from._impl_.marketcode_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.turnover_) -
    reinterpret_cast<char*>(&_impl_.marketcode_)) + sizeof(_impl_.turnover_));
  // @@protoc_insertion_point(copy_constructor:data.MarketTurnover)
}

inline void MarketTurnover::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.marketcode_){0}
    , decltype(_impl_.currencycode_){0}
    , decltype(_impl_.turnover_){0}
  };
}

MarketTurnover::~MarketTurnover() {
  // @@protoc_insertion_point(destructor:data.MarketTurnover)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MarketTurnover::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void MarketTurnover::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MarketTurnover::Clear() {
// @@protoc_insertion_point(message_clear_start:data.MarketTurnover)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.marketcode_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.turnover_) -
        reinterpret_cast<char*>(&_impl_.marketcode_)) + sizeof(_impl_.turnover_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MarketTurnover::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .data.MarketCode marketCode = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_marketcode(static_cast<::data::MarketCode>(val));
        } else
          goto handle_unusual;
        continue;
      // optional .data.CurrencyType currencyCode = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_currencycode(static_cast<::data::CurrencyType>(val));
        } else
          goto handle_unusual;
        continue;
      // optional double turnover = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          _Internal::set_has_turnover(&has_bits);
          _impl_.turnover_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MarketTurnover::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:data.MarketTurnover)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional .data.MarketCode marketCode = 1;
  if (_internal_has_marketcode()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_marketcode(), target);
  }

  // optional .data.CurrencyType currencyCode = 2;
  if (_internal_has_currencycode()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_currencycode(), target);
  }

  // optional double turnover = 3;
  if (_internal_has_turnover()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(3, this->_internal_turnover(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:data.MarketTurnover)
  return target;
}

size_t MarketTurnover::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:data.MarketTurnover)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .data.MarketCode marketCode = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_marketcode());
    }

    // optional .data.CurrencyType currencyCode = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_currencycode());
    }

    // optional double turnover = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 8;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MarketTurnover::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    MarketTurnover::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MarketTurnover::GetClassData() const { return &_class_data_; }


void MarketTurnover::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<MarketTurnover*>(&to_msg);
  auto& from = static_cast<const MarketTurnover&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:data.MarketTurnover)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.marketcode_ = from._impl_.marketcode_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.currencycode_ = from._impl_.currencycode_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.turnover_ = from._impl_.turnover_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MarketTurnover::CopyFrom(const MarketTurnover& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:data.MarketTurnover)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MarketTurnover::IsInitialized() const {
  return true;
}

void MarketTurnover::InternalSwap(MarketTurnover* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MarketTurnover, _impl_.turnover_)
      + sizeof(MarketTurnover::_impl_.turnover_)
      - PROTOBUF_FIELD_OFFSET(MarketTurnover, _impl_.marketcode_)>(
          reinterpret_cast<char*>(&_impl_.marketcode_),
          reinterpret_cast<char*>(&other->_impl_.marketcode_));
}

::PROTOBUF_NAMESPACE_ID::Metadata MarketTurnover::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_data_2eproto_getter, &descriptor_table_data_2eproto_once,
      file_level_metadata_data_2eproto[42]);
}

// ===================================================================

class News::_Internal {
 public:
  using HasBits = decltype(std::declval<News>()._impl_._has_bits_);
  static void set_has_newstype(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_newsid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_headline(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_cancelflag(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_lastfragment(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_releasetime(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

News::News(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:data.News)
}
News::News(const News& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  News* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.nomarketcodes_){from._impl_.nomarketcodes_}
    , decltype(_impl_.nosecuritycodes_){from._impl_.nosecuritycodes_}
    , decltype(_impl_.nonewslines_){from._impl_.nonewslines_}
    , decltype(_impl_.newsid_){}
    , decltype(_impl_.headline_){}
    , decltype(_impl_.newstype_){}
    , decltype(_impl_.cancelflag_){}
    , decltype(_impl_.releasetime_){}
    , decltype(_impl_.lastfragment_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.newsid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.newsid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_newsid()) {
    _this->_impl_.newsid_.Set(from._internal_newsid(), 
      _this->GetArenaForAllocation());
  }
  _impl_.headline_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.headline_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_headline()) {
    _this->_impl_.headline_.Set(from._internal_headline(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.newstype_, &from._impl_.newstype_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.lastfragment_) -
    reinterpret_cast<char*>(&_impl_.newstype_)) + sizeof(_impl_.lastfragment_));
  // @@protoc_insertion_point(copy_constructor:data.News)
}

inline void News::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.nomarketcodes_){arena}
    , decltype(_impl_.nosecuritycodes_){arena}
    , decltype(_impl_.nonewslines_){arena}
    , decltype(_impl_.newsid_){}
    , decltype(_impl_.headline_){}
    , decltype(_impl_.newstype_){0}
    , decltype(_impl_.cancelflag_){0}
    , decltype(_impl_.releasetime_){int64_t{0}}
    , decltype(_impl_.lastfragment_){0}
  };
  _impl_.newsid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.newsid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.headline_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.headline_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

News::~News() {
  // @@protoc_insertion_point(destructor:data.News)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void News::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.nomarketcodes_.~RepeatedPtrField();
  _impl_.nosecuritycodes_.~RepeatedPtrField();
  _impl_.nonewslines_.~RepeatedPtrField();
  _impl_.newsid_.Destroy();
  _impl_.headline_.Destroy();
}

void News::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void News::Clear() {
// @@protoc_insertion_point(message_clear_start:data.News)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.nomarketcodes_.Clear();
  _impl_.nosecuritycodes_.Clear();
  _impl_.nonewslines_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.newsid_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.headline_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x0000003cu) {
    ::memset(&_impl_.newstype_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.lastfragment_) -
        reinterpret_cast<char*>(&_impl_.newstype_)) + sizeof(_impl_.lastfragment_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* News::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .data.NewsType newsType = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_newstype(static_cast<::data::NewsType>(val));
        } else
          goto handle_unusual;
        continue;
      // optional string newsID = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_newsid();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "data.News.newsID"));
        } else
          goto handle_unusual;
        continue;
      // optional string headline = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_headline();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "data.News.headline"));
        } else
          goto handle_unusual;
        continue;
      // optional .data.CancelFlag cancelFlag = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_cancelflag(static_cast<::data::CancelFlag>(val));
        } else
          goto handle_unusual;
        continue;
      // optional .data.LastFragment lastFragment = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_lastfragment(static_cast<::data::LastFragment>(val));
        } else
          goto handle_unusual;
        continue;
      // optional int64 releaseTime = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_releasetime(&has_bits);
          _impl_.releasetime_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .data.NoMarketCode noMarketCodes = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_nomarketcodes(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<58>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .data.NoSecurityCode noSecurityCodes = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_nosecuritycodes(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<66>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .data.NoNewsLine noNewsLines = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_nonewslines(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<74>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* News::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:data.News)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional .data.NewsType newsType = 1;
  if (_internal_has_newstype()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_newstype(), target);
  }

  // optional string newsID = 2;
  if (_internal_has_newsid()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_newsid().data(), static_cast<int>(this->_internal_newsid().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "data.News.newsID");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_newsid(), target);
  }

  // optional string headline = 3;
  if (_internal_has_headline()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_headline().data(), static_cast<int>(this->_internal_headline().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "data.News.headline");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_headline(), target);
  }

  // optional .data.CancelFlag cancelFlag = 4;
  if (_internal_has_cancelflag()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      4, this->_internal_cancelflag(), target);
  }

  // optional .data.LastFragment lastFragment = 5;
  if (_internal_has_lastfragment()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      5, this->_internal_lastfragment(), target);
  }

  // optional int64 releaseTime = 6;
  if (_internal_has_releasetime()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(6, this->_internal_releasetime(), target);
  }

  // repeated .data.NoMarketCode noMarketCodes = 7;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_nomarketcodes_size()); i < n; i++) {
    const auto& repfield = this->_internal_nomarketcodes(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(7, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .data.NoSecurityCode noSecurityCodes = 8;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_nosecuritycodes_size()); i < n; i++) {
    const auto& repfield = this->_internal_nosecuritycodes(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(8, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .data.NoNewsLine noNewsLines = 9;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_nonewslines_size()); i < n; i++) {
    const auto& repfield = this->_internal_nonewslines(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(9, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:data.News)
  return target;
}

size_t News::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:data.News)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .data.NoMarketCode noMarketCodes = 7;
  total_size += 1UL * this->_internal_nomarketcodes_size();
  for (const auto& msg : this->_impl_.nomarketcodes_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .data.NoSecurityCode noSecurityCodes = 8;
  total_size += 1UL * this->_internal_nosecuritycodes_size();
  for (const auto& msg : this->_impl_.nosecuritycodes_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .data.NoNewsLine noNewsLines = 9;
  total_size += 1UL * this->_internal_nonewslines_size();
  for (const auto& msg : this->_impl_.nonewslines_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional string newsID = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_newsid());
    }

    // optional string headline = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_headline());
    }

    // optional .data.NewsType newsType = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_newstype());
    }

    // optional .data.CancelFlag cancelFlag = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_cancelflag());
    }

    // optional int64 releaseTime = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_releasetime());
    }

    // optional .data.LastFragment lastFragment = 5;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_lastfragment());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData News::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    News::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*News::GetClassData() const { return &_class_data_; }


void News::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<News*>(&to_msg);
  auto& from = static_cast<const News&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:data.News)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.nomarketcodes_.MergeFrom(from._impl_.nomarketcodes_);
  _this->_impl_.nosecuritycodes_.MergeFrom(from._impl_.nosecuritycodes_);
  _this->_impl_.nonewslines_.MergeFrom(from._impl_.nonewslines_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_newsid(from._internal_newsid());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_headline(from._internal_headline());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.newstype_ = from._impl_.newstype_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.cancelflag_ = from._impl_.cancelflag_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.releasetime_ = from._impl_.releasetime_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.lastfragment_ = from._impl_.lastfragment_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void News::CopyFrom(const News& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:data.News)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool News::IsInitialized() const {
  return true;
}

void News::InternalSwap(News* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.nomarketcodes_.InternalSwap(&other->_impl_.nomarketcodes_);
  _impl_.nosecuritycodes_.InternalSwap(&other->_impl_.nosecuritycodes_);
  _impl_.nonewslines_.InternalSwap(&other->_impl_.nonewslines_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.newsid_, lhs_arena,
      &other->_impl_.newsid_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.headline_, lhs_arena,
      &other->_impl_.headline_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(News, _impl_.lastfragment_)
      + sizeof(News::_impl_.lastfragment_)
      - PROTOBUF_FIELD_OFFSET(News, _impl_.newstype_)>(
          reinterpret_cast<char*>(&_impl_.newstype_),
          reinterpret_cast<char*>(&other->_impl_.newstype_));
}

::PROTOBUF_NAMESPACE_ID::Metadata News::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_data_2eproto_getter, &descriptor_table_data_2eproto_once,
      file_level_metadata_data_2eproto[43]);
}

// ===================================================================

class NoEntry::_Internal {
 public:
  using HasBits = decltype(std::declval<NoEntry>()._impl_._has_bits_);
  static void set_has_aggregatequantity(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_price(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_numberoforders(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_side(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_pricelevel(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_updateaction(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

NoEntry::NoEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:data.NoEntry)
}
NoEntry::NoEntry(const NoEntry& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  NoEntry* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.aggregatequantity_){}
    , decltype(_impl_.price_){}
    , decltype(_impl_.numberoforders_){}
    , decltype(_impl_.side_){}
    , decltype(_impl_.pricelevel_){}
    , decltype(_impl_.updateaction_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.aggregatequantity_, &from._impl_.aggregatequantity_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.updateaction_) -
    reinterpret_cast<char*>(&_impl_.aggregatequantity_)) + sizeof(_impl_.updateaction_));
  // @@protoc_insertion_point(copy_constructor:data.NoEntry)
}

inline void NoEntry::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.aggregatequantity_){int64_t{0}}
    , decltype(_impl_.price_){0}
    , decltype(_impl_.numberoforders_){int64_t{0}}
    , decltype(_impl_.side_){0}
    , decltype(_impl_.pricelevel_){0}
    , decltype(_impl_.updateaction_){0}
  };
}

NoEntry::~NoEntry() {
  // @@protoc_insertion_point(destructor:data.NoEntry)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void NoEntry::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void NoEntry::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void NoEntry::Clear() {
// @@protoc_insertion_point(message_clear_start:data.NoEntry)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    ::memset(&_impl_.aggregatequantity_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.updateaction_) -
        reinterpret_cast<char*>(&_impl_.aggregatequantity_)) + sizeof(_impl_.updateaction_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NoEntry::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int64 aggregateQuantity = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_aggregatequantity(&has_bits);
          _impl_.aggregatequantity_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional double price = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _Internal::set_has_price(&has_bits);
          _impl_.price_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional int64 numberOfOrders = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_numberoforders(&has_bits);
          _impl_.numberoforders_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .data.Side side = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_side(static_cast<::data::Side>(val));
        } else
          goto handle_unusual;
        continue;
      // optional int32 priceLevel = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_pricelevel(&has_bits);
          _impl_.pricelevel_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .data.UpdateAction updateAction = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_updateaction(static_cast<::data::UpdateAction>(val));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NoEntry::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:data.NoEntry)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional int64 aggregateQuantity = 1;
  if (_internal_has_aggregatequantity()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_aggregatequantity(), target);
  }

  // optional double price = 2;
  if (_internal_has_price()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(2, this->_internal_price(), target);
  }

  // optional int64 numberOfOrders = 3;
  if (_internal_has_numberoforders()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(3, this->_internal_numberoforders(), target);
  }

  // optional .data.Side side = 4;
  if (_internal_has_side()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      4, this->_internal_side(), target);
  }

  // optional int32 priceLevel = 5;
  if (_internal_has_pricelevel()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(5, this->_internal_pricelevel(), target);
  }

  // optional .data.UpdateAction updateAction = 6;
  if (_internal_has_updateaction()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      6, this->_internal_updateaction(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:data.NoEntry)
  return target;
}

size_t NoEntry::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:data.NoEntry)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional int64 aggregateQuantity = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_aggregatequantity());
    }

    // optional double price = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 8;
    }

    // optional int64 numberOfOrders = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_numberoforders());
    }

    // optional .data.Side side = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_side());
    }

    // optional int32 priceLevel = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_pricelevel());
    }

    // optional .data.UpdateAction updateAction = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_updateaction());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NoEntry::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    NoEntry::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NoEntry::GetClassData() const { return &_class_data_; }


void NoEntry::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<NoEntry*>(&to_msg);
  auto& from = static_cast<const NoEntry&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:data.NoEntry)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.aggregatequantity_ = from._impl_.aggregatequantity_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.price_ = from._impl_.price_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.numberoforders_ = from._impl_.numberoforders_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.side_ = from._impl_.side_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.pricelevel_ = from._impl_.pricelevel_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.updateaction_ = from._impl_.updateaction_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NoEntry::CopyFrom(const NoEntry& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:data.NoEntry)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NoEntry::IsInitialized() const {
  return true;
}

void NoEntry::InternalSwap(NoEntry* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(NoEntry, _impl_.updateaction_)
      + sizeof(NoEntry::_impl_.updateaction_)
      - PROTOBUF_FIELD_OFFSET(NoEntry, _impl_.aggregatequantity_)>(
          reinterpret_cast<char*>(&_impl_.aggregatequantity_),
          reinterpret_cast<char*>(&other->_impl_.aggregatequantity_));
}

::PROTOBUF_NAMESPACE_ID::Metadata NoEntry::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_data_2eproto_getter, &descriptor_table_data_2eproto_once,
      file_level_metadata_data_2eproto[44]);
}

// ===================================================================

class NoLiquidityProvider::_Internal {
 public:
  using HasBits = decltype(std::declval<NoLiquidityProvider>()._impl_._has_bits_);
  static void set_has_lpbrokernumber(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

NoLiquidityProvider::NoLiquidityProvider(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:data.NoLiquidityProvider)
}
NoLiquidityProvider::NoLiquidityProvider(const NoLiquidityProvider& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  NoLiquidityProvider* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.lpbrokernumber_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.lpbrokernumber_ = from._impl_.lpbrokernumber_;
  // @@protoc_insertion_point(copy_constructor:data.NoLiquidityProvider)
}

inline void NoLiquidityProvider::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.lpbrokernumber_){0}
  };
}

NoLiquidityProvider::~NoLiquidityProvider() {
  // @@protoc_insertion_point(destructor:data.NoLiquidityProvider)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void NoLiquidityProvider::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void NoLiquidityProvider::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void NoLiquidityProvider::Clear() {
// @@protoc_insertion_point(message_clear_start:data.NoLiquidityProvider)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.lpbrokernumber_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NoLiquidityProvider::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 lPBrokerNumber = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_lpbrokernumber(&has_bits);
          _impl_.lpbrokernumber_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NoLiquidityProvider::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:data.NoLiquidityProvider)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional int32 lPBrokerNumber = 1;
  if (_internal_has_lpbrokernumber()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_lpbrokernumber(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:data.NoLiquidityProvider)
  return target;
}

size_t NoLiquidityProvider::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:data.NoLiquidityProvider)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional int32 lPBrokerNumber = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_lpbrokernumber());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NoLiquidityProvider::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    NoLiquidityProvider::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NoLiquidityProvider::GetClassData() const { return &_class_data_; }


void NoLiquidityProvider::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<NoLiquidityProvider*>(&to_msg);
  auto& from = static_cast<const NoLiquidityProvider&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:data.NoLiquidityProvider)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_lpbrokernumber()) {
    _this->_internal_set_lpbrokernumber(from._internal_lpbrokernumber());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NoLiquidityProvider::CopyFrom(const NoLiquidityProvider& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:data.NoLiquidityProvider)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NoLiquidityProvider::IsInitialized() const {
  return true;
}

void NoLiquidityProvider::InternalSwap(NoLiquidityProvider* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.lpbrokernumber_, other->_impl_.lpbrokernumber_);
}

::PROTOBUF_NAMESPACE_ID::Metadata NoLiquidityProvider::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_data_2eproto_getter, &descriptor_table_data_2eproto_once,
      file_level_metadata_data_2eproto[45]);
}

// ===================================================================

class NoMarketCode::_Internal {
 public:
  using HasBits = decltype(std::declval<NoMarketCode>()._impl_._has_bits_);
  static void set_has_marketcode(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

NoMarketCode::NoMarketCode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:data.NoMarketCode)
}
NoMarketCode::NoMarketCode(const NoMarketCode& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  NoMarketCode* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.marketcode_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.marketcode_ = from._impl_.marketcode_;
  // @@protoc_insertion_point(copy_constructor:data.NoMarketCode)
}

inline void NoMarketCode::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.marketcode_){0}
  };
}

NoMarketCode::~NoMarketCode() {
  // @@protoc_insertion_point(destructor:data.NoMarketCode)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void NoMarketCode::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void NoMarketCode::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void NoMarketCode::Clear() {
// @@protoc_insertion_point(message_clear_start:data.NoMarketCode)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.marketcode_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NoMarketCode::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .data.MarketCode marketCode = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_marketcode(static_cast<::data::MarketCode>(val));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NoMarketCode::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:data.NoMarketCode)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional .data.MarketCode marketCode = 1;
  if (_internal_has_marketcode()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_marketcode(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:data.NoMarketCode)
  return target;
}

size_t NoMarketCode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:data.NoMarketCode)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .data.MarketCode marketCode = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_marketcode());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NoMarketCode::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    NoMarketCode::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NoMarketCode::GetClassData() const { return &_class_data_; }


void NoMarketCode::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<NoMarketCode*>(&to_msg);
  auto& from = static_cast<const NoMarketCode&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:data.NoMarketCode)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_marketcode()) {
    _this->_internal_set_marketcode(from._internal_marketcode());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NoMarketCode::CopyFrom(const NoMarketCode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:data.NoMarketCode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NoMarketCode::IsInitialized() const {
  return true;
}

void NoMarketCode::InternalSwap(NoMarketCode* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.marketcode_, other->_impl_.marketcode_);
}

::PROTOBUF_NAMESPACE_ID::Metadata NoMarketCode::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_data_2eproto_getter, &descriptor_table_data_2eproto_once,
      file_level_metadata_data_2eproto[46]);
}

// ===================================================================

class NoNewsLine::_Internal {
 public:
  using HasBits = decltype(std::declval<NoNewsLine>()._impl_._has_bits_);
  static void set_has_newsline(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

NoNewsLine::NoNewsLine(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:data.NoNewsLine)
}
NoNewsLine::NoNewsLine(const NoNewsLine& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  NoNewsLine* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.newsline_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.newsline_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.newsline_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_newsline()) {
    _this->_impl_.newsline_.Set(from._internal_newsline(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:data.NoNewsLine)
}

inline void NoNewsLine::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.newsline_){}
  };
  _impl_.newsline_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.newsline_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

NoNewsLine::~NoNewsLine() {
  // @@protoc_insertion_point(destructor:data.NoNewsLine)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void NoNewsLine::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.newsline_.Destroy();
}

void NoNewsLine::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void NoNewsLine::Clear() {
// @@protoc_insertion_point(message_clear_start:data.NoNewsLine)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.newsline_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NoNewsLine::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string newsLine = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_newsline();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "data.NoNewsLine.newsLine"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NoNewsLine::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:data.NoNewsLine)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional string newsLine = 1;
  if (_internal_has_newsline()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_newsline().data(), static_cast<int>(this->_internal_newsline().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "data.NoNewsLine.newsLine");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_newsline(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:data.NoNewsLine)
  return target;
}

size_t NoNewsLine::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:data.NoNewsLine)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string newsLine = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_newsline());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NoNewsLine::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    NoNewsLine::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NoNewsLine::GetClassData() const { return &_class_data_; }


void NoNewsLine::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<NoNewsLine*>(&to_msg);
  auto& from = static_cast<const NoNewsLine&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:data.NoNewsLine)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_newsline()) {
    _this->_internal_set_newsline(from._internal_newsline());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NoNewsLine::CopyFrom(const NoNewsLine& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:data.NoNewsLine)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NoNewsLine::IsInitialized() const {
  return true;
}

void NoNewsLine::InternalSwap(NoNewsLine* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.newsline_, lhs_arena,
      &other->_impl_.newsline_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata NoNewsLine::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_data_2eproto_getter, &descriptor_table_data_2eproto_once,
      file_level_metadata_data_2eproto[47]);
}

// ===================================================================

class NoSecurityCode::_Internal {
 public:
  using HasBits = decltype(std::declval<NoSecurityCode>()._impl_._has_bits_);
  static void set_has_securitycode(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

NoSecurityCode::NoSecurityCode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:data.NoSecurityCode)
}
NoSecurityCode::NoSecurityCode(const NoSecurityCode& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  NoSecurityCode* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.securitycode_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.securitycode_ = from._impl_.securitycode_;
  // @@protoc_insertion_point(copy_constructor:data.NoSecurityCode)
}

inline void NoSecurityCode::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.securitycode_){int64_t{0}}
  };
}

NoSecurityCode::~NoSecurityCode() {
  // @@protoc_insertion_point(destructor:data.NoSecurityCode)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void NoSecurityCode::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void NoSecurityCode::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void NoSecurityCode::Clear() {
// @@protoc_insertion_point(message_clear_start:data.NoSecurityCode)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.securitycode_ = int64_t{0};
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NoSecurityCode::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int64 securityCode = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_securitycode(&has_bits);
          _impl_.securitycode_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NoSecurityCode::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:data.NoSecurityCode)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional int64 securityCode = 1;
  if (_internal_has_securitycode()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_securitycode(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:data.NoSecurityCode)
  return target;
}

size_t NoSecurityCode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:data.NoSecurityCode)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional int64 securityCode = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_securitycode());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NoSecurityCode::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    NoSecurityCode::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NoSecurityCode::GetClassData() const { return &_class_data_; }


void NoSecurityCode::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<NoSecurityCode*>(&to_msg);
  auto& from = static_cast<const NoSecurityCode&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:data.NoSecurityCode)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_securitycode()) {
    _this->_internal_set_securitycode(from._internal_securitycode());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NoSecurityCode::CopyFrom(const NoSecurityCode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:data.NoSecurityCode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NoSecurityCode::IsInitialized() const {
  return true;
}

void NoSecurityCode::InternalSwap(NoSecurityCode* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.securitycode_, other->_impl_.securitycode_);
}

::PROTOBUF_NAMESPACE_ID::Metadata NoSecurityCode::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_data_2eproto_getter, &descriptor_table_data_2eproto_once,
      file_level_metadata_data_2eproto[48]);
}

// ===================================================================

class NoUnderlyingSecurity::_Internal {
 public:
  using HasBits = decltype(std::declval<NoUnderlyingSecurity>()._impl_._has_bits_);
  static void set_has_underlyingsecuritycode(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

NoUnderlyingSecurity::NoUnderlyingSecurity(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:data.NoUnderlyingSecurity)
}
NoUnderlyingSecurity::NoUnderlyingSecurity(const NoUnderlyingSecurity& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  NoUnderlyingSecurity* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.underlyingsecuritycode_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.underlyingsecuritycode_ = from._impl_.underlyingsecuritycode_;
  // @@protoc_insertion_point(copy_constructor:data.NoUnderlyingSecurity)
}

inline void NoUnderlyingSecurity::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.underlyingsecuritycode_){int64_t{0}}
  };
}

NoUnderlyingSecurity::~NoUnderlyingSecurity() {
  // @@protoc_insertion_point(destructor:data.NoUnderlyingSecurity)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void NoUnderlyingSecurity::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void NoUnderlyingSecurity::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void NoUnderlyingSecurity::Clear() {
// @@protoc_insertion_point(message_clear_start:data.NoUnderlyingSecurity)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.underlyingsecuritycode_ = int64_t{0};
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NoUnderlyingSecurity::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int64 underlyingSecurityCode = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_underlyingsecuritycode(&has_bits);
          _impl_.underlyingsecuritycode_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NoUnderlyingSecurity::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:data.NoUnderlyingSecurity)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional int64 underlyingSecurityCode = 1;
  if (_internal_has_underlyingsecuritycode()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_underlyingsecuritycode(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:data.NoUnderlyingSecurity)
  return target;
}

size_t NoUnderlyingSecurity::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:data.NoUnderlyingSecurity)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional int64 underlyingSecurityCode = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_underlyingsecuritycode());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NoUnderlyingSecurity::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    NoUnderlyingSecurity::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NoUnderlyingSecurity::GetClassData() const { return &_class_data_; }


void NoUnderlyingSecurity::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<NoUnderlyingSecurity*>(&to_msg);
  auto& from = static_cast<const NoUnderlyingSecurity&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:data.NoUnderlyingSecurity)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_underlyingsecuritycode()) {
    _this->_internal_set_underlyingsecuritycode(from._internal_underlyingsecuritycode());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NoUnderlyingSecurity::CopyFrom(const NoUnderlyingSecurity& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:data.NoUnderlyingSecurity)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NoUnderlyingSecurity::IsInitialized() const {
  return true;
}

void NoUnderlyingSecurity::InternalSwap(NoUnderlyingSecurity* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.underlyingsecuritycode_, other->_impl_.underlyingsecuritycode_);
}

::PROTOBUF_NAMESPACE_ID::Metadata NoUnderlyingSecurity::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_data_2eproto_getter, &descriptor_table_data_2eproto_once,
      file_level_metadata_data_2eproto[49]);
}

// ===================================================================

class NominalPrice::_Internal {
 public:
  using HasBits = decltype(std::declval<NominalPrice>()._impl_._has_bits_);
  static void set_has_securitycode(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_nominalprice(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

NominalPrice::NominalPrice(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:data.NominalPrice)
}
NominalPrice::NominalPrice(const NominalPrice& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  NominalPrice* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.securitycode_){}
    , decltype(_impl_.nominalprice_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.securitycode_, &from._impl_.securitycode_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.nominalprice_) -
    reinterpret_cast<char*>(&_impl_.securitycode_)) + sizeof(_impl_.nominalprice_));
  // @@protoc_insertion_point(copy_constructor:data.NominalPrice)
}

inline void NominalPrice::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.securitycode_){int64_t{0}}
    , decltype(_impl_.nominalprice_){0}
  };
}

NominalPrice::~NominalPrice() {
  // @@protoc_insertion_point(destructor:data.NominalPrice)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void NominalPrice::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void NominalPrice::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void NominalPrice::Clear() {
// @@protoc_insertion_point(message_clear_start:data.NominalPrice)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.securitycode_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.nominalprice_) -
        reinterpret_cast<char*>(&_impl_.securitycode_)) + sizeof(_impl_.nominalprice_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NominalPrice::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int64 securityCode = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_securitycode(&has_bits);
          _impl_.securitycode_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional double nominalPrice = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _Internal::set_has_nominalprice(&has_bits);
          _impl_.nominalprice_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NominalPrice::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:data.NominalPrice)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional int64 securityCode = 1;
  if (_internal_has_securitycode()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_securitycode(), target);
  }

  // optional double nominalPrice = 2;
  if (_internal_has_nominalprice()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(2, this->_internal_nominalprice(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:data.NominalPrice)
  return target;
}

size_t NominalPrice::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:data.NominalPrice)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional int64 securityCode = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_securitycode());
    }

    // optional double nominalPrice = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 8;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NominalPrice::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    NominalPrice::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NominalPrice::GetClassData() const { return &_class_data_; }


void NominalPrice::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<NominalPrice*>(&to_msg);
  auto& from = static_cast<const NominalPrice&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:data.NominalPrice)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.securitycode_ = from._impl_.securitycode_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.nominalprice_ = from._impl_.nominalprice_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NominalPrice::CopyFrom(const NominalPrice& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:data.NominalPrice)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NominalPrice::IsInitialized() const {
  return true;
}

void NominalPrice::InternalSwap(NominalPrice* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(NominalPrice, _impl_.nominalprice_)
      + sizeof(NominalPrice::_impl_.nominalprice_)
      - PROTOBUF_FIELD_OFFSET(NominalPrice, _impl_.securitycode_)>(
          reinterpret_cast<char*>(&_impl_.securitycode_),
          reinterpret_cast<char*>(&other->_impl_.securitycode_));
}

::PROTOBUF_NAMESPACE_ID::Metadata NominalPrice::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_data_2eproto_getter, &descriptor_table_data_2eproto_once,
      file_level_metadata_data_2eproto[50]);
}

// ===================================================================

class OrderImbalance::_Internal {
 public:
  using HasBits = decltype(std::declval<OrderImbalance>()._impl_._has_bits_);
  static void set_has_securitycode(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_orderimbalancedirection(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_orderimbalancequantity(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

OrderImbalance::OrderImbalance(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:data.OrderImbalance)
}
OrderImbalance::OrderImbalance(const OrderImbalance& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  OrderImbalance* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.securitycode_){}
    , decltype(_impl_.orderimbalancequantity_){}
    , decltype(_impl_.orderimbalancedirection_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.securitycode_, &from._impl_.securitycode_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.orderimbalancedirection_) -
    reinterpret_cast<char*>(&_impl_.securitycode_)) + sizeof(_impl_.orderimbalancedirection_));
  // @@protoc_insertion_point(copy_constructor:data.OrderImbalance)
}

inline void OrderImbalance::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.securitycode_){int64_t{0}}
    , decltype(_impl_.orderimbalancequantity_){int64_t{0}}
    , decltype(_impl_.orderimbalancedirection_){0}
  };
}

OrderImbalance::~OrderImbalance() {
  // @@protoc_insertion_point(destructor:data.OrderImbalance)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void OrderImbalance::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void OrderImbalance::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void OrderImbalance::Clear() {
// @@protoc_insertion_point(message_clear_start:data.OrderImbalance)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.securitycode_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.orderimbalancedirection_) -
        reinterpret_cast<char*>(&_impl_.securitycode_)) + sizeof(_impl_.orderimbalancedirection_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* OrderImbalance::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int64 securityCode = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_securitycode(&has_bits);
          _impl_.securitycode_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .data.OrderImbalanceDirection orderImbalanceDirection = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_orderimbalancedirection(static_cast<::data::OrderImbalanceDirection>(val));
        } else
          goto handle_unusual;
        continue;
      // optional int64 orderImbalanceQuantity = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_orderimbalancequantity(&has_bits);
          _impl_.orderimbalancequantity_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* OrderImbalance::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:data.OrderImbalance)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional int64 securityCode = 1;
  if (_internal_has_securitycode()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_securitycode(), target);
  }

  // optional .data.OrderImbalanceDirection orderImbalanceDirection = 2;
  if (_internal_has_orderimbalancedirection()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_orderimbalancedirection(), target);
  }

  // optional int64 orderImbalanceQuantity = 3;
  if (_internal_has_orderimbalancequantity()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(3, this->_internal_orderimbalancequantity(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:data.OrderImbalance)
  return target;
}

size_t OrderImbalance::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:data.OrderImbalance)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional int64 securityCode = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_securitycode());
    }

    // optional int64 orderImbalanceQuantity = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_orderimbalancequantity());
    }

    // optional .data.OrderImbalanceDirection orderImbalanceDirection = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_orderimbalancedirection());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData OrderImbalance::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    OrderImbalance::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*OrderImbalance::GetClassData() const { return &_class_data_; }


void OrderImbalance::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<OrderImbalance*>(&to_msg);
  auto& from = static_cast<const OrderImbalance&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:data.OrderImbalance)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.securitycode_ = from._impl_.securitycode_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.orderimbalancequantity_ = from._impl_.orderimbalancequantity_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.orderimbalancedirection_ = from._impl_.orderimbalancedirection_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void OrderImbalance::CopyFrom(const OrderImbalance& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:data.OrderImbalance)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OrderImbalance::IsInitialized() const {
  return true;
}

void OrderImbalance::InternalSwap(OrderImbalance* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(OrderImbalance, _impl_.orderimbalancedirection_)
      + sizeof(OrderImbalance::_impl_.orderimbalancedirection_)
      - PROTOBUF_FIELD_OFFSET(OrderImbalance, _impl_.securitycode_)>(
          reinterpret_cast<char*>(&_impl_.securitycode_),
          reinterpret_cast<char*>(&other->_impl_.securitycode_));
}

::PROTOBUF_NAMESPACE_ID::Metadata OrderImbalance::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_data_2eproto_getter, &descriptor_table_data_2eproto_once,
      file_level_metadata_data_2eproto[51]);
}

// ===================================================================

class PacketHeader::_Internal {
 public:
  using HasBits = decltype(std::declval<PacketHeader>()._impl_._has_bits_);
  static void set_has_pktsize(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_msgcount(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_filler(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_seqnum(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_sendtime(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

PacketHeader::PacketHeader(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:data.PacketHeader)
}
PacketHeader::PacketHeader(const PacketHeader& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PacketHeader* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.filler_){}
    , decltype(_impl_.pktsize_){}
    , decltype(_impl_.msgcount_){}
    , decltype(_impl_.seqnum_){}
    , decltype(_impl_.sendtime_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.filler_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.filler_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_filler()) {
    _this->_impl_.filler_.Set(from._internal_filler(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.pktsize_, &from._impl_.pktsize_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.sendtime_) -
    reinterpret_cast<char*>(&_impl_.pktsize_)) + sizeof(_impl_.sendtime_));
  // @@protoc_insertion_point(copy_constructor:data.PacketHeader)
}

inline void PacketHeader::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.filler_){}
    , decltype(_impl_.pktsize_){0}
    , decltype(_impl_.msgcount_){0}
    , decltype(_impl_.seqnum_){int64_t{0}}
    , decltype(_impl_.sendtime_){int64_t{0}}
  };
  _impl_.filler_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.filler_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

PacketHeader::~PacketHeader() {
  // @@protoc_insertion_point(destructor:data.PacketHeader)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PacketHeader::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.filler_.Destroy();
}

void PacketHeader::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PacketHeader::Clear() {
// @@protoc_insertion_point(message_clear_start:data.PacketHeader)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.filler_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000001eu) {
    ::memset(&_impl_.pktsize_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.sendtime_) -
        reinterpret_cast<char*>(&_impl_.pktsize_)) + sizeof(_impl_.sendtime_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PacketHeader::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 pktSize = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_pktsize(&has_bits);
          _impl_.pktsize_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 msgCount = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_msgcount(&has_bits);
          _impl_.msgcount_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string filler = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_filler();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "data.PacketHeader.filler"));
        } else
          goto handle_unusual;
        continue;
      // optional int64 seqNum = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_seqnum(&has_bits);
          _impl_.seqnum_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 sendTime = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_sendtime(&has_bits);
          _impl_.sendtime_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PacketHeader::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:data.PacketHeader)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional int32 pktSize = 1;
  if (_internal_has_pktsize()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_pktsize(), target);
  }

  // optional int32 msgCount = 2;
  if (_internal_has_msgcount()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_msgcount(), target);
  }

  // optional string filler = 3;
  if (_internal_has_filler()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_filler().data(), static_cast<int>(this->_internal_filler().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "data.PacketHeader.filler");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_filler(), target);
  }

  // optional int64 seqNum = 4;
  if (_internal_has_seqnum()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(4, this->_internal_seqnum(), target);
  }

  // optional int64 sendTime = 5;
  if (_internal_has_sendtime()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(5, this->_internal_sendtime(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:data.PacketHeader)
  return target;
}

size_t PacketHeader::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:data.PacketHeader)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional string filler = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_filler());
    }

    // optional int32 pktSize = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_pktsize());
    }

    // optional int32 msgCount = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_msgcount());
    }

    // optional int64 seqNum = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_seqnum());
    }

    // optional int64 sendTime = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_sendtime());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PacketHeader::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PacketHeader::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PacketHeader::GetClassData() const { return &_class_data_; }


void PacketHeader::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PacketHeader*>(&to_msg);
  auto& from = static_cast<const PacketHeader&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:data.PacketHeader)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_filler(from._internal_filler());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.pktsize_ = from._impl_.pktsize_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.msgcount_ = from._impl_.msgcount_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.seqnum_ = from._impl_.seqnum_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.sendtime_ = from._impl_.sendtime_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PacketHeader::CopyFrom(const PacketHeader& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:data.PacketHeader)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PacketHeader::IsInitialized() const {
  return true;
}

void PacketHeader::InternalSwap(PacketHeader* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.filler_, lhs_arena,
      &other->_impl_.filler_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PacketHeader, _impl_.sendtime_)
      + sizeof(PacketHeader::_impl_.sendtime_)
      - PROTOBUF_FIELD_OFFSET(PacketHeader, _impl_.pktsize_)>(
          reinterpret_cast<char*>(&_impl_.pktsize_),
          reinterpret_cast<char*>(&other->_impl_.pktsize_));
}

::PROTOBUF_NAMESPACE_ID::Metadata PacketHeader::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_data_2eproto_getter, &descriptor_table_data_2eproto_once,
      file_level_metadata_data_2eproto[52]);
}

// ===================================================================

class LongAdjustedClosingPrice::_Internal {
 public:
  using HasBits = decltype(std::declval<LongAdjustedClosingPrice>()._impl_._has_bits_);
  static void set_has_issuesymbol(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_securityclass(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_adjustedclosingprice(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

LongAdjustedClosingPrice::LongAdjustedClosingPrice(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:data.LongAdjustedClosingPrice)
}
LongAdjustedClosingPrice::LongAdjustedClosingPrice(const LongAdjustedClosingPrice& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  LongAdjustedClosingPrice* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.issuesymbol_){}
    , decltype(_impl_.adjustedclosingprice_){}
    , decltype(_impl_.securityclass_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.issuesymbol_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.issuesymbol_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_issuesymbol()) {
    _this->_impl_.issuesymbol_.Set(from._internal_issuesymbol(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.adjustedclosingprice_, &from._impl_.adjustedclosingprice_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.securityclass_) -
    reinterpret_cast<char*>(&_impl_.adjustedclosingprice_)) + sizeof(_impl_.securityclass_));
  // @@protoc_insertion_point(copy_constructor:data.LongAdjustedClosingPrice)
}

inline void LongAdjustedClosingPrice::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.issuesymbol_){}
    , decltype(_impl_.adjustedclosingprice_){0}
    , decltype(_impl_.securityclass_){0}
  };
  _impl_.issuesymbol_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.issuesymbol_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

LongAdjustedClosingPrice::~LongAdjustedClosingPrice() {
  // @@protoc_insertion_point(destructor:data.LongAdjustedClosingPrice)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LongAdjustedClosingPrice::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.issuesymbol_.Destroy();
}

void LongAdjustedClosingPrice::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LongAdjustedClosingPrice::Clear() {
// @@protoc_insertion_point(message_clear_start:data.LongAdjustedClosingPrice)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.issuesymbol_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&_impl_.adjustedclosingprice_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.securityclass_) -
        reinterpret_cast<char*>(&_impl_.adjustedclosingprice_)) + sizeof(_impl_.securityclass_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LongAdjustedClosingPrice::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string issueSymbol = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_issuesymbol();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "data.LongAdjustedClosingPrice.issueSymbol"));
        } else
          goto handle_unusual;
        continue;
      // optional .data.SecurityClass securityClass = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_securityclass(static_cast<::data::SecurityClass>(val));
        } else
          goto handle_unusual;
        continue;
      // optional double adjustedClosingPrice = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          _Internal::set_has_adjustedclosingprice(&has_bits);
          _impl_.adjustedclosingprice_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LongAdjustedClosingPrice::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:data.LongAdjustedClosingPrice)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional string issueSymbol = 1;
  if (_internal_has_issuesymbol()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_issuesymbol().data(), static_cast<int>(this->_internal_issuesymbol().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "data.LongAdjustedClosingPrice.issueSymbol");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_issuesymbol(), target);
  }

  // optional .data.SecurityClass securityClass = 2;
  if (_internal_has_securityclass()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_securityclass(), target);
  }

  // optional double adjustedClosingPrice = 3;
  if (_internal_has_adjustedclosingprice()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(3, this->_internal_adjustedclosingprice(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:data.LongAdjustedClosingPrice)
  return target;
}

size_t LongAdjustedClosingPrice::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:data.LongAdjustedClosingPrice)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string issueSymbol = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_issuesymbol());
    }

    // optional double adjustedClosingPrice = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 8;
    }

    // optional .data.SecurityClass securityClass = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_securityclass());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LongAdjustedClosingPrice::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    LongAdjustedClosingPrice::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LongAdjustedClosingPrice::GetClassData() const { return &_class_data_; }


void LongAdjustedClosingPrice::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<LongAdjustedClosingPrice*>(&to_msg);
  auto& from = static_cast<const LongAdjustedClosingPrice&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:data.LongAdjustedClosingPrice)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_issuesymbol(from._internal_issuesymbol());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.adjustedclosingprice_ = from._impl_.adjustedclosingprice_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.securityclass_ = from._impl_.securityclass_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LongAdjustedClosingPrice::CopyFrom(const LongAdjustedClosingPrice& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:data.LongAdjustedClosingPrice)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LongAdjustedClosingPrice::IsInitialized() const {
  return true;
}

void LongAdjustedClosingPrice::InternalSwap(LongAdjustedClosingPrice* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.issuesymbol_, lhs_arena,
      &other->_impl_.issuesymbol_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(LongAdjustedClosingPrice, _impl_.securityclass_)
      + sizeof(LongAdjustedClosingPrice::_impl_.securityclass_)
      - PROTOBUF_FIELD_OFFSET(LongAdjustedClosingPrice, _impl_.adjustedclosingprice_)>(
          reinterpret_cast<char*>(&_impl_.adjustedclosingprice_),
          reinterpret_cast<char*>(&other->_impl_.adjustedclosingprice_));
}

::PROTOBUF_NAMESPACE_ID::Metadata LongAdjustedClosingPrice::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_data_2eproto_getter, &descriptor_table_data_2eproto_once,
      file_level_metadata_data_2eproto[53]);
}

// ===================================================================

class LongDayTradeSummary::_Internal {
 public:
  using HasBits = decltype(std::declval<LongDayTradeSummary>()._impl_._has_bits_);
  static void set_has_issuesymbol(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_marketcategory(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_nasdaqhighprice(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_nasdaqlowprice(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_nasdaqclosingprice(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_consolidatedvolume(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_consolidatedopenprice(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

LongDayTradeSummary::LongDayTradeSummary(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:data.LongDayTradeSummary)
}
LongDayTradeSummary::LongDayTradeSummary(const LongDayTradeSummary& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  LongDayTradeSummary* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.issuesymbol_){}
    , decltype(_impl_.nasdaqhighprice_){}
    , decltype(_impl_.nasdaqlowprice_){}
    , decltype(_impl_.nasdaqclosingprice_){}
    , decltype(_impl_.consolidatedvolume_){}
    , decltype(_impl_.consolidatedopenprice_){}
    , decltype(_impl_.marketcategory_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.issuesymbol_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.issuesymbol_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_issuesymbol()) {
    _this->_impl_.issuesymbol_.Set(from._internal_issuesymbol(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.nasdaqhighprice_, &from._impl_.nasdaqhighprice_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.marketcategory_) -
    reinterpret_cast<char*>(&_impl_.nasdaqhighprice_)) + sizeof(_impl_.marketcategory_));
  // @@protoc_insertion_point(copy_constructor:data.LongDayTradeSummary)
}

inline void LongDayTradeSummary::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.issuesymbol_){}
    , decltype(_impl_.nasdaqhighprice_){0}
    , decltype(_impl_.nasdaqlowprice_){0}
    , decltype(_impl_.nasdaqclosingprice_){0}
    , decltype(_impl_.consolidatedvolume_){int64_t{0}}
    , decltype(_impl_.consolidatedopenprice_){0}
    , decltype(_impl_.marketcategory_){0}
  };
  _impl_.issuesymbol_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.issuesymbol_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

LongDayTradeSummary::~LongDayTradeSummary() {
  // @@protoc_insertion_point(destructor:data.LongDayTradeSummary)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LongDayTradeSummary::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.issuesymbol_.Destroy();
}

void LongDayTradeSummary::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LongDayTradeSummary::Clear() {
// @@protoc_insertion_point(message_clear_start:data.LongDayTradeSummary)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.issuesymbol_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000007eu) {
    ::memset(&_impl_.nasdaqhighprice_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.marketcategory_) -
        reinterpret_cast<char*>(&_impl_.nasdaqhighprice_)) + sizeof(_impl_.marketcategory_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LongDayTradeSummary::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string issueSymbol = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_issuesymbol();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "data.LongDayTradeSummary.issueSymbol"));
        } else
          goto handle_unusual;
        continue;
      // optional .data.MarketCategory marketCategory = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_marketcategory(static_cast<::data::MarketCategory>(val));
        } else
          goto handle_unusual;
        continue;
      // optional double nasdaqHighPrice = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          _Internal::set_has_nasdaqhighprice(&has_bits);
          _impl_.nasdaqhighprice_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double nasdaqLowPrice = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 33)) {
          _Internal::set_has_nasdaqlowprice(&has_bits);
          _impl_.nasdaqlowprice_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double nasdaqClosingPrice = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 41)) {
          _Internal::set_has_nasdaqclosingprice(&has_bits);
          _impl_.nasdaqclosingprice_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional int64 consolidatedVolume = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_consolidatedvolume(&has_bits);
          _impl_.consolidatedvolume_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional double consolidatedOpenPrice = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 57)) {
          _Internal::set_has_consolidatedopenprice(&has_bits);
          _impl_.consolidatedopenprice_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LongDayTradeSummary::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:data.LongDayTradeSummary)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional string issueSymbol = 1;
  if (_internal_has_issuesymbol()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_issuesymbol().data(), static_cast<int>(this->_internal_issuesymbol().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "data.LongDayTradeSummary.issueSymbol");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_issuesymbol(), target);
  }

  // optional .data.MarketCategory marketCategory = 2;
  if (_internal_has_marketcategory()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_marketcategory(), target);
  }

  // optional double nasdaqHighPrice = 3;
  if (_internal_has_nasdaqhighprice()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(3, this->_internal_nasdaqhighprice(), target);
  }

  // optional double nasdaqLowPrice = 4;
  if (_internal_has_nasdaqlowprice()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(4, this->_internal_nasdaqlowprice(), target);
  }

  // optional double nasdaqClosingPrice = 5;
  if (_internal_has_nasdaqclosingprice()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(5, this->_internal_nasdaqclosingprice(), target);
  }

  // optional int64 consolidatedVolume = 6;
  if (_internal_has_consolidatedvolume()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(6, this->_internal_consolidatedvolume(), target);
  }

  // optional double consolidatedOpenPrice = 7;
  if (_internal_has_consolidatedopenprice()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(7, this->_internal_consolidatedopenprice(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:data.LongDayTradeSummary)
  return target;
}

size_t LongDayTradeSummary::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:data.LongDayTradeSummary)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    // optional string issueSymbol = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_issuesymbol());
    }

    // optional double nasdaqHighPrice = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 8;
    }

    // optional double nasdaqLowPrice = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 8;
    }

    // optional double nasdaqClosingPrice = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 8;
    }

    // optional int64 consolidatedVolume = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_consolidatedvolume());
    }

    // optional double consolidatedOpenPrice = 7;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 8;
    }

    // optional .data.MarketCategory marketCategory = 2;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_marketcategory());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LongDayTradeSummary::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    LongDayTradeSummary::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LongDayTradeSummary::GetClassData() const { return &_class_data_; }


void LongDayTradeSummary::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<LongDayTradeSummary*>(&to_msg);
  auto& from = static_cast<const LongDayTradeSummary&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:data.LongDayTradeSummary)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_issuesymbol(from._internal_issuesymbol());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.nasdaqhighprice_ = from._impl_.nasdaqhighprice_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.nasdaqlowprice_ = from._impl_.nasdaqlowprice_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.nasdaqclosingprice_ = from._impl_.nasdaqclosingprice_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.consolidatedvolume_ = from._impl_.consolidatedvolume_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.consolidatedopenprice_ = from._impl_.consolidatedopenprice_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.marketcategory_ = from._impl_.marketcategory_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LongDayTradeSummary::CopyFrom(const LongDayTradeSummary& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:data.LongDayTradeSummary)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LongDayTradeSummary::IsInitialized() const {
  return true;
}

void LongDayTradeSummary::InternalSwap(LongDayTradeSummary* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.issuesymbol_, lhs_arena,
      &other->_impl_.issuesymbol_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(LongDayTradeSummary, _impl_.marketcategory_)
      + sizeof(LongDayTradeSummary::_impl_.marketcategory_)
      - PROTOBUF_FIELD_OFFSET(LongDayTradeSummary, _impl_.nasdaqhighprice_)>(
          reinterpret_cast<char*>(&_impl_.nasdaqhighprice_),
          reinterpret_cast<char*>(&other->_impl_.nasdaqhighprice_));
}

::PROTOBUF_NAMESPACE_ID::Metadata LongDayTradeSummary::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_data_2eproto_getter, &descriptor_table_data_2eproto_once,
      file_level_metadata_data_2eproto[54]);
}

// ===================================================================

class LongTradeCancelForNonNextSharesTrades::_Internal {
 public:
  using HasBits = decltype(std::declval<LongTradeCancelForNonNextSharesTrades>()._impl_._has_bits_);
  static void set_has_marketcenteridentifier(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_issuesymbol(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_securityclass(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_originalcontrolnumber(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_originaltradeprice(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_originaltradesize(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static const ::data::SaleConditionModifier& originalsaleconditionmodifier(const LongTradeCancelForNonNextSharesTrades* msg);
  static void set_has_originalsaleconditionmodifier(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_consolidatedvolume(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
};

const ::data::SaleConditionModifier&
LongTradeCancelForNonNextSharesTrades::_Internal::originalsaleconditionmodifier(const LongTradeCancelForNonNextSharesTrades* msg) {
  return *msg->_impl_.originalsaleconditionmodifier_;
}
LongTradeCancelForNonNextSharesTrades::LongTradeCancelForNonNextSharesTrades(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:data.LongTradeCancelForNonNextSharesTrades)
}
LongTradeCancelForNonNextSharesTrades::LongTradeCancelForNonNextSharesTrades(const LongTradeCancelForNonNextSharesTrades& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  LongTradeCancelForNonNextSharesTrades* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.issuesymbol_){}
    , decltype(_impl_.originalcontrolnumber_){}
    , decltype(_impl_.originalsaleconditionmodifier_){nullptr}
    , decltype(_impl_.marketcenteridentifier_){}
    , decltype(_impl_.securityclass_){}
    , decltype(_impl_.originaltradeprice_){}
    , decltype(_impl_.originaltradesize_){}
    , decltype(_impl_.consolidatedvolume_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.issuesymbol_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.issuesymbol_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_issuesymbol()) {
    _this->_impl_.issuesymbol_.Set(from._internal_issuesymbol(), 
      _this->GetArenaForAllocation());
  }
  _impl_.originalcontrolnumber_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.originalcontrolnumber_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_originalcontrolnumber()) {
    _this->_impl_.originalcontrolnumber_.Set(from._internal_originalcontrolnumber(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_originalsaleconditionmodifier()) {
    _this->_impl_.originalsaleconditionmodifier_ = new ::data::SaleConditionModifier(*from._impl_.originalsaleconditionmodifier_);
  }
  ::memcpy(&_impl_.marketcenteridentifier_, &from._impl_.marketcenteridentifier_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.consolidatedvolume_) -
    reinterpret_cast<char*>(&_impl_.marketcenteridentifier_)) + sizeof(_impl_.consolidatedvolume_));
  // @@protoc_insertion_point(copy_constructor:data.LongTradeCancelForNonNextSharesTrades)
}

inline void LongTradeCancelForNonNextSharesTrades::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.issuesymbol_){}
    , decltype(_impl_.originalcontrolnumber_){}
    , decltype(_impl_.originalsaleconditionmodifier_){nullptr}
    , decltype(_impl_.marketcenteridentifier_){0}
    , decltype(_impl_.securityclass_){0}
    , decltype(_impl_.originaltradeprice_){0}
    , decltype(_impl_.originaltradesize_){int64_t{0}}
    , decltype(_impl_.consolidatedvolume_){int64_t{0}}
  };
  _impl_.issuesymbol_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.issuesymbol_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.originalcontrolnumber_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.originalcontrolnumber_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

LongTradeCancelForNonNextSharesTrades::~LongTradeCancelForNonNextSharesTrades() {
  // @@protoc_insertion_point(destructor:data.LongTradeCancelForNonNextSharesTrades)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LongTradeCancelForNonNextSharesTrades::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.issuesymbol_.Destroy();
  _impl_.originalcontrolnumber_.Destroy();
  if (this != internal_default_instance()) delete _impl_.originalsaleconditionmodifier_;
}

void LongTradeCancelForNonNextSharesTrades::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LongTradeCancelForNonNextSharesTrades::Clear() {
// @@protoc_insertion_point(message_clear_start:data.LongTradeCancelForNonNextSharesTrades)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.issuesymbol_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.originalcontrolnumber_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.originalsaleconditionmodifier_ != nullptr);
      _impl_.originalsaleconditionmodifier_->Clear();
    }
  }
  if (cached_has_bits & 0x000000f8u) {
    ::memset(&_impl_.marketcenteridentifier_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.consolidatedvolume_) -
        reinterpret_cast<char*>(&_impl_.marketcenteridentifier_)) + sizeof(_impl_.consolidatedvolume_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LongTradeCancelForNonNextSharesTrades::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .data.OriginatingMarketCenterIdentifier marketCenterIdentifier = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_marketcenteridentifier(static_cast<::data::OriginatingMarketCenterIdentifier>(val));
        } else
          goto handle_unusual;
        continue;
      // optional string issueSymbol = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_issuesymbol();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "data.LongTradeCancelForNonNextSharesTrades.issueSymbol"));
        } else
          goto handle_unusual;
        continue;
      // optional .data.SecurityClass securityClass = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_securityclass(static_cast<::data::SecurityClass>(val));
        } else
          goto handle_unusual;
        continue;
      // optional string originalControlNumber = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_originalcontrolnumber();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "data.LongTradeCancelForNonNextSharesTrades.originalControlNumber"));
        } else
          goto handle_unusual;
        continue;
      // optional double originalTradePrice = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 41)) {
          _Internal::set_has_originaltradeprice(&has_bits);
          _impl_.originaltradeprice_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional int64 originalTradeSize = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_originaltradesize(&has_bits);
          _impl_.originaltradesize_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .data.SaleConditionModifier originalSaleConditionModifier = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_originalsaleconditionmodifier(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 consolidatedVolume = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_consolidatedvolume(&has_bits);
          _impl_.consolidatedvolume_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LongTradeCancelForNonNextSharesTrades::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:data.LongTradeCancelForNonNextSharesTrades)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional .data.OriginatingMarketCenterIdentifier marketCenterIdentifier = 1;
  if (_internal_has_marketcenteridentifier()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_marketcenteridentifier(), target);
  }

  // optional string issueSymbol = 2;
  if (_internal_has_issuesymbol()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_issuesymbol().data(), static_cast<int>(this->_internal_issuesymbol().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "data.LongTradeCancelForNonNextSharesTrades.issueSymbol");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_issuesymbol(), target);
  }

  // optional .data.SecurityClass securityClass = 3;
  if (_internal_has_securityclass()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      3, this->_internal_securityclass(), target);
  }

  // optional string originalControlNumber = 4;
  if (_internal_has_originalcontrolnumber()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_originalcontrolnumber().data(), static_cast<int>(this->_internal_originalcontrolnumber().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "data.LongTradeCancelForNonNextSharesTrades.originalControlNumber");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_originalcontrolnumber(), target);
  }

  // optional double originalTradePrice = 5;
  if (_internal_has_originaltradeprice()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(5, this->_internal_originaltradeprice(), target);
  }

  // optional int64 originalTradeSize = 6;
  if (_internal_has_originaltradesize()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(6, this->_internal_originaltradesize(), target);
  }

  // optional .data.SaleConditionModifier originalSaleConditionModifier = 7;
  if (_internal_has_originalsaleconditionmodifier()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::originalsaleconditionmodifier(this),
        _Internal::originalsaleconditionmodifier(this).GetCachedSize(), target, stream);
  }

  // optional int64 consolidatedVolume = 8;
  if (_internal_has_consolidatedvolume()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(8, this->_internal_consolidatedvolume(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:data.LongTradeCancelForNonNextSharesTrades)
  return target;
}

size_t LongTradeCancelForNonNextSharesTrades::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:data.LongTradeCancelForNonNextSharesTrades)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string issueSymbol = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_issuesymbol());
    }

    // optional string originalControlNumber = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_originalcontrolnumber());
    }

    // optional .data.SaleConditionModifier originalSaleConditionModifier = 7;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.originalsaleconditionmodifier_);
    }

    // optional .data.OriginatingMarketCenterIdentifier marketCenterIdentifier = 1;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_marketcenteridentifier());
    }

    // optional .data.SecurityClass securityClass = 3;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_securityclass());
    }

    // optional double originalTradePrice = 5;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 8;
    }

    // optional int64 originalTradeSize = 6;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_originaltradesize());
    }

    // optional int64 consolidatedVolume = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_consolidatedvolume());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LongTradeCancelForNonNextSharesTrades::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    LongTradeCancelForNonNextSharesTrades::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LongTradeCancelForNonNextSharesTrades::GetClassData() const { return &_class_data_; }


void LongTradeCancelForNonNextSharesTrades::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<LongTradeCancelForNonNextSharesTrades*>(&to_msg);
  auto& from = static_cast<const LongTradeCancelForNonNextSharesTrades&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:data.LongTradeCancelForNonNextSharesTrades)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_issuesymbol(from._internal_issuesymbol());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_originalcontrolnumber(from._internal_originalcontrolnumber());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_originalsaleconditionmodifier()->::data::SaleConditionModifier::MergeFrom(
          from._internal_originalsaleconditionmodifier());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.marketcenteridentifier_ = from._impl_.marketcenteridentifier_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.securityclass_ = from._impl_.securityclass_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.originaltradeprice_ = from._impl_.originaltradeprice_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.originaltradesize_ = from._impl_.originaltradesize_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.consolidatedvolume_ = from._impl_.consolidatedvolume_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LongTradeCancelForNonNextSharesTrades::CopyFrom(const LongTradeCancelForNonNextSharesTrades& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:data.LongTradeCancelForNonNextSharesTrades)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LongTradeCancelForNonNextSharesTrades::IsInitialized() const {
  return true;
}

void LongTradeCancelForNonNextSharesTrades::InternalSwap(LongTradeCancelForNonNextSharesTrades* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.issuesymbol_, lhs_arena,
      &other->_impl_.issuesymbol_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.originalcontrolnumber_, lhs_arena,
      &other->_impl_.originalcontrolnumber_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(LongTradeCancelForNonNextSharesTrades, _impl_.consolidatedvolume_)
      + sizeof(LongTradeCancelForNonNextSharesTrades::_impl_.consolidatedvolume_)
      - PROTOBUF_FIELD_OFFSET(LongTradeCancelForNonNextSharesTrades, _impl_.originalsaleconditionmodifier_)>(
          reinterpret_cast<char*>(&_impl_.originalsaleconditionmodifier_),
          reinterpret_cast<char*>(&other->_impl_.originalsaleconditionmodifier_));
}

::PROTOBUF_NAMESPACE_ID::Metadata LongTradeCancelForNonNextSharesTrades::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_data_2eproto_getter, &descriptor_table_data_2eproto_once,
      file_level_metadata_data_2eproto[55]);
}

// ===================================================================

class LongTradeCorrectionForNonNextsharesTrades::_Internal {
 public:
  using HasBits = decltype(std::declval<LongTradeCorrectionForNonNextsharesTrades>()._impl_._has_bits_);
  static void set_has_marketcenteridentifier(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_issuesymbol(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_securityclass(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_originalcontrolnumber(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_originaltradeprice(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_originaltradesize(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_originalconditionmodifier(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_correctedtradecontrolnumber(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_correctedtradeprice(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_correctedtradesize(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_correctedsaleconditionmodifier(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_consolidatedvolume(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
};

LongTradeCorrectionForNonNextsharesTrades::LongTradeCorrectionForNonNextsharesTrades(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:data.LongTradeCorrectionForNonNextsharesTrades)
}
LongTradeCorrectionForNonNextsharesTrades::LongTradeCorrectionForNonNextsharesTrades(const LongTradeCorrectionForNonNextsharesTrades& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  LongTradeCorrectionForNonNextsharesTrades* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.issuesymbol_){}
    , decltype(_impl_.originalcontrolnumber_){}
    , decltype(_impl_.originalconditionmodifier_){}
    , decltype(_impl_.correctedtradecontrolnumber_){}
    , decltype(_impl_.correctedsaleconditionmodifier_){}
    , decltype(_impl_.marketcenteridentifier_){}
    , decltype(_impl_.securityclass_){}
    , decltype(_impl_.originaltradeprice_){}
    , decltype(_impl_.originaltradesize_){}
    , decltype(_impl_.correctedtradeprice_){}
    , decltype(_impl_.correctedtradesize_){}
    , decltype(_impl_.consolidatedvolume_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.issuesymbol_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.issuesymbol_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_issuesymbol()) {
    _this->_impl_.issuesymbol_.Set(from._internal_issuesymbol(), 
      _this->GetArenaForAllocation());
  }
  _impl_.originalcontrolnumber_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.originalcontrolnumber_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_originalcontrolnumber()) {
    _this->_impl_.originalcontrolnumber_.Set(from._internal_originalcontrolnumber(), 
      _this->GetArenaForAllocation());
  }
  _impl_.originalconditionmodifier_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.originalconditionmodifier_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_originalconditionmodifier()) {
    _this->_impl_.originalconditionmodifier_.Set(from._internal_originalconditionmodifier(), 
      _this->GetArenaForAllocation());
  }
  _impl_.correctedtradecontrolnumber_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.correctedtradecontrolnumber_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_correctedtradecontrolnumber()) {
    _this->_impl_.correctedtradecontrolnumber_.Set(from._internal_correctedtradecontrolnumber(), 
      _this->GetArenaForAllocation());
  }
  _impl_.correctedsaleconditionmodifier_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.correctedsaleconditionmodifier_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_correctedsaleconditionmodifier()) {
    _this->_impl_.correctedsaleconditionmodifier_.Set(from._internal_correctedsaleconditionmodifier(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.marketcenteridentifier_, &from._impl_.marketcenteridentifier_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.consolidatedvolume_) -
    reinterpret_cast<char*>(&_impl_.marketcenteridentifier_)) + sizeof(_impl_.consolidatedvolume_));
  // @@protoc_insertion_point(copy_constructor:data.LongTradeCorrectionForNonNextsharesTrades)
}

inline void LongTradeCorrectionForNonNextsharesTrades::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.issuesymbol_){}
    , decltype(_impl_.originalcontrolnumber_){}
    , decltype(_impl_.originalconditionmodifier_){}
    , decltype(_impl_.correctedtradecontrolnumber_){}
    , decltype(_impl_.correctedsaleconditionmodifier_){}
    , decltype(_impl_.marketcenteridentifier_){0}
    , decltype(_impl_.securityclass_){0}
    , decltype(_impl_.originaltradeprice_){0}
    , decltype(_impl_.originaltradesize_){int64_t{0}}
    , decltype(_impl_.correctedtradeprice_){0}
    , decltype(_impl_.correctedtradesize_){int64_t{0}}
    , decltype(_impl_.consolidatedvolume_){int64_t{0}}
  };
  _impl_.issuesymbol_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.issuesymbol_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.originalcontrolnumber_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.originalcontrolnumber_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.originalconditionmodifier_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.originalconditionmodifier_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.correctedtradecontrolnumber_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.correctedtradecontrolnumber_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.correctedsaleconditionmodifier_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.correctedsaleconditionmodifier_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

LongTradeCorrectionForNonNextsharesTrades::~LongTradeCorrectionForNonNextsharesTrades() {
  // @@protoc_insertion_point(destructor:data.LongTradeCorrectionForNonNextsharesTrades)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LongTradeCorrectionForNonNextsharesTrades::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.issuesymbol_.Destroy();
  _impl_.originalcontrolnumber_.Destroy();
  _impl_.originalconditionmodifier_.Destroy();
  _impl_.correctedtradecontrolnumber_.Destroy();
  _impl_.correctedsaleconditionmodifier_.Destroy();
}

void LongTradeCorrectionForNonNextsharesTrades::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LongTradeCorrectionForNonNextsharesTrades::Clear() {
// @@protoc_insertion_point(message_clear_start:data.LongTradeCorrectionForNonNextsharesTrades)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.issuesymbol_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.originalcontrolnumber_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.originalconditionmodifier_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.correctedtradecontrolnumber_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      _impl_.correctedsaleconditionmodifier_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x000000e0u) {
    ::memset(&_impl_.marketcenteridentifier_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.originaltradeprice_) -
        reinterpret_cast<char*>(&_impl_.marketcenteridentifier_)) + sizeof(_impl_.originaltradeprice_));
  }
  if (cached_has_bits & 0x00000f00u) {
    ::memset(&_impl_.originaltradesize_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.consolidatedvolume_) -
        reinterpret_cast<char*>(&_impl_.originaltradesize_)) + sizeof(_impl_.consolidatedvolume_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LongTradeCorrectionForNonNextsharesTrades::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .data.OriginatingMarketCenterIdentifier marketCenterIdentifier = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_marketcenteridentifier(static_cast<::data::OriginatingMarketCenterIdentifier>(val));
        } else
          goto handle_unusual;
        continue;
      // optional string issueSymbol = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_issuesymbol();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "data.LongTradeCorrectionForNonNextsharesTrades.issueSymbol"));
        } else
          goto handle_unusual;
        continue;
      // optional .data.SecurityClass securityClass = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_securityclass(static_cast<::data::SecurityClass>(val));
        } else
          goto handle_unusual;
        continue;
      // optional string originalControlNumber = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_originalcontrolnumber();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "data.LongTradeCorrectionForNonNextsharesTrades.originalControlNumber"));
        } else
          goto handle_unusual;
        continue;
      // optional double originalTradePrice = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 41)) {
          _Internal::set_has_originaltradeprice(&has_bits);
          _impl_.originaltradeprice_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional int64 originalTradeSize = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_originaltradesize(&has_bits);
          _impl_.originaltradesize_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string originalConditionModifier = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_originalconditionmodifier();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "data.LongTradeCorrectionForNonNextsharesTrades.originalConditionModifier"));
        } else
          goto handle_unusual;
        continue;
      // optional string correctedTradeControlNumber = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          auto str = _internal_mutable_correctedtradecontrolnumber();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "data.LongTradeCorrectionForNonNextsharesTrades.correctedTradeControlNumber"));
        } else
          goto handle_unusual;
        continue;
      // optional double correctedTradePrice = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 73)) {
          _Internal::set_has_correctedtradeprice(&has_bits);
          _impl_.correctedtradeprice_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional int64 CorrectedTradeSize = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_correctedtradesize(&has_bits);
          _impl_.correctedtradesize_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string CorrectedSaleConditionModifier = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          auto str = _internal_mutable_correctedsaleconditionmodifier();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "data.LongTradeCorrectionForNonNextsharesTrades.CorrectedSaleConditionModifier"));
        } else
          goto handle_unusual;
        continue;
      // optional int64 consolidatedVolume = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _Internal::set_has_consolidatedvolume(&has_bits);
          _impl_.consolidatedvolume_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LongTradeCorrectionForNonNextsharesTrades::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:data.LongTradeCorrectionForNonNextsharesTrades)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional .data.OriginatingMarketCenterIdentifier marketCenterIdentifier = 1;
  if (_internal_has_marketcenteridentifier()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_marketcenteridentifier(), target);
  }

  // optional string issueSymbol = 2;
  if (_internal_has_issuesymbol()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_issuesymbol().data(), static_cast<int>(this->_internal_issuesymbol().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "data.LongTradeCorrectionForNonNextsharesTrades.issueSymbol");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_issuesymbol(), target);
  }

  // optional .data.SecurityClass securityClass = 3;
  if (_internal_has_securityclass()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      3, this->_internal_securityclass(), target);
  }

  // optional string originalControlNumber = 4;
  if (_internal_has_originalcontrolnumber()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_originalcontrolnumber().data(), static_cast<int>(this->_internal_originalcontrolnumber().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "data.LongTradeCorrectionForNonNextsharesTrades.originalControlNumber");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_originalcontrolnumber(), target);
  }

  // optional double originalTradePrice = 5;
  if (_internal_has_originaltradeprice()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(5, this->_internal_originaltradeprice(), target);
  }

  // optional int64 originalTradeSize = 6;
  if (_internal_has_originaltradesize()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(6, this->_internal_originaltradesize(), target);
  }

  // optional string originalConditionModifier = 7;
  if (_internal_has_originalconditionmodifier()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_originalconditionmodifier().data(), static_cast<int>(this->_internal_originalconditionmodifier().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "data.LongTradeCorrectionForNonNextsharesTrades.originalConditionModifier");
    target = stream->WriteStringMaybeAliased(
        7, this->_internal_originalconditionmodifier(), target);
  }

  // optional string correctedTradeControlNumber = 8;
  if (_internal_has_correctedtradecontrolnumber()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_correctedtradecontrolnumber().data(), static_cast<int>(this->_internal_correctedtradecontrolnumber().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "data.LongTradeCorrectionForNonNextsharesTrades.correctedTradeControlNumber");
    target = stream->WriteStringMaybeAliased(
        8, this->_internal_correctedtradecontrolnumber(), target);
  }

  // optional double correctedTradePrice = 9;
  if (_internal_has_correctedtradeprice()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(9, this->_internal_correctedtradeprice(), target);
  }

  // optional int64 CorrectedTradeSize = 10;
  if (_internal_has_correctedtradesize()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(10, this->_internal_correctedtradesize(), target);
  }

  // optional string CorrectedSaleConditionModifier = 11;
  if (_internal_has_correctedsaleconditionmodifier()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_correctedsaleconditionmodifier().data(), static_cast<int>(this->_internal_correctedsaleconditionmodifier().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "data.LongTradeCorrectionForNonNextsharesTrades.CorrectedSaleConditionModifier");
    target = stream->WriteStringMaybeAliased(
        11, this->_internal_correctedsaleconditionmodifier(), target);
  }

  // optional int64 consolidatedVolume = 12;
  if (_internal_has_consolidatedvolume()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(12, this->_internal_consolidatedvolume(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:data.LongTradeCorrectionForNonNextsharesTrades)
  return target;
}

size_t LongTradeCorrectionForNonNextsharesTrades::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:data.LongTradeCorrectionForNonNextsharesTrades)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string issueSymbol = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_issuesymbol());
    }

    // optional string originalControlNumber = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_originalcontrolnumber());
    }

    // optional string originalConditionModifier = 7;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_originalconditionmodifier());
    }

    // optional string correctedTradeControlNumber = 8;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_correctedtradecontrolnumber());
    }

    // optional string CorrectedSaleConditionModifier = 11;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_correctedsaleconditionmodifier());
    }

    // optional .data.OriginatingMarketCenterIdentifier marketCenterIdentifier = 1;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_marketcenteridentifier());
    }

    // optional .data.SecurityClass securityClass = 3;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_securityclass());
    }

    // optional double originalTradePrice = 5;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 8;
    }

  }
  if (cached_has_bits & 0x00000f00u) {
    // optional int64 originalTradeSize = 6;
    if (cached_has_bits & 0x00000100u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_originaltradesize());
    }

    // optional double correctedTradePrice = 9;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 + 8;
    }

    // optional int64 CorrectedTradeSize = 10;
    if (cached_has_bits & 0x00000400u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_correctedtradesize());
    }

    // optional int64 consolidatedVolume = 12;
    if (cached_has_bits & 0x00000800u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_consolidatedvolume());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LongTradeCorrectionForNonNextsharesTrades::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    LongTradeCorrectionForNonNextsharesTrades::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LongTradeCorrectionForNonNextsharesTrades::GetClassData() const { return &_class_data_; }


void LongTradeCorrectionForNonNextsharesTrades::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<LongTradeCorrectionForNonNextsharesTrades*>(&to_msg);
  auto& from = static_cast<const LongTradeCorrectionForNonNextsharesTrades&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:data.LongTradeCorrectionForNonNextsharesTrades)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_issuesymbol(from._internal_issuesymbol());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_originalcontrolnumber(from._internal_originalcontrolnumber());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_originalconditionmodifier(from._internal_originalconditionmodifier());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_set_correctedtradecontrolnumber(from._internal_correctedtradecontrolnumber());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_set_correctedsaleconditionmodifier(from._internal_correctedsaleconditionmodifier());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.marketcenteridentifier_ = from._impl_.marketcenteridentifier_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.securityclass_ = from._impl_.securityclass_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.originaltradeprice_ = from._impl_.originaltradeprice_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000f00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.originaltradesize_ = from._impl_.originaltradesize_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.correctedtradeprice_ = from._impl_.correctedtradeprice_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.correctedtradesize_ = from._impl_.correctedtradesize_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.consolidatedvolume_ = from._impl_.consolidatedvolume_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LongTradeCorrectionForNonNextsharesTrades::CopyFrom(const LongTradeCorrectionForNonNextsharesTrades& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:data.LongTradeCorrectionForNonNextsharesTrades)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LongTradeCorrectionForNonNextsharesTrades::IsInitialized() const {
  return true;
}

void LongTradeCorrectionForNonNextsharesTrades::InternalSwap(LongTradeCorrectionForNonNextsharesTrades* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.issuesymbol_, lhs_arena,
      &other->_impl_.issuesymbol_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.originalcontrolnumber_, lhs_arena,
      &other->_impl_.originalcontrolnumber_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.originalconditionmodifier_, lhs_arena,
      &other->_impl_.originalconditionmodifier_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.correctedtradecontrolnumber_, lhs_arena,
      &other->_impl_.correctedtradecontrolnumber_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.correctedsaleconditionmodifier_, lhs_arena,
      &other->_impl_.correctedsaleconditionmodifier_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(LongTradeCorrectionForNonNextsharesTrades, _impl_.consolidatedvolume_)
      + sizeof(LongTradeCorrectionForNonNextsharesTrades::_impl_.consolidatedvolume_)
      - PROTOBUF_FIELD_OFFSET(LongTradeCorrectionForNonNextsharesTrades, _impl_.marketcenteridentifier_)>(
          reinterpret_cast<char*>(&_impl_.marketcenteridentifier_),
          reinterpret_cast<char*>(&other->_impl_.marketcenteridentifier_));
}

::PROTOBUF_NAMESPACE_ID::Metadata LongTradeCorrectionForNonNextsharesTrades::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_data_2eproto_getter, &descriptor_table_data_2eproto_once,
      file_level_metadata_data_2eproto[56]);
}

// ===================================================================

class LongTradeReportForNonNextshares::_Internal {
 public:
  using HasBits = decltype(std::declval<LongTradeReportForNonNextshares>()._impl_._has_bits_);
  static void set_has_consolidatedvolume(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

LongTradeReportForNonNextshares::LongTradeReportForNonNextshares(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:data.LongTradeReportForNonNextshares)
}
LongTradeReportForNonNextshares::LongTradeReportForNonNextshares(const LongTradeReportForNonNextshares& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  LongTradeReportForNonNextshares* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.consolidatedvolume_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.consolidatedvolume_ = from._impl_.consolidatedvolume_;
  // @@protoc_insertion_point(copy_constructor:data.LongTradeReportForNonNextshares)
}

inline void LongTradeReportForNonNextshares::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.consolidatedvolume_){int64_t{0}}
  };
}

LongTradeReportForNonNextshares::~LongTradeReportForNonNextshares() {
  // @@protoc_insertion_point(destructor:data.LongTradeReportForNonNextshares)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LongTradeReportForNonNextshares::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void LongTradeReportForNonNextshares::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LongTradeReportForNonNextshares::Clear() {
// @@protoc_insertion_point(message_clear_start:data.LongTradeReportForNonNextshares)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.consolidatedvolume_ = int64_t{0};
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LongTradeReportForNonNextshares::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int64 consolidatedVolume = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_consolidatedvolume(&has_bits);
          _impl_.consolidatedvolume_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LongTradeReportForNonNextshares::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:data.LongTradeReportForNonNextshares)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional int64 consolidatedVolume = 1;
  if (_internal_has_consolidatedvolume()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_consolidatedvolume(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:data.LongTradeReportForNonNextshares)
  return target;
}

size_t LongTradeReportForNonNextshares::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:data.LongTradeReportForNonNextshares)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional int64 consolidatedVolume = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_consolidatedvolume());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LongTradeReportForNonNextshares::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    LongTradeReportForNonNextshares::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LongTradeReportForNonNextshares::GetClassData() const { return &_class_data_; }


void LongTradeReportForNonNextshares::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<LongTradeReportForNonNextshares*>(&to_msg);
  auto& from = static_cast<const LongTradeReportForNonNextshares&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:data.LongTradeReportForNonNextshares)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_consolidatedvolume()) {
    _this->_internal_set_consolidatedvolume(from._internal_consolidatedvolume());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LongTradeReportForNonNextshares::CopyFrom(const LongTradeReportForNonNextshares& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:data.LongTradeReportForNonNextshares)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LongTradeReportForNonNextshares::IsInitialized() const {
  return true;
}

void LongTradeReportForNonNextshares::InternalSwap(LongTradeReportForNonNextshares* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.consolidatedvolume_, other->_impl_.consolidatedvolume_);
}

::PROTOBUF_NAMESPACE_ID::Metadata LongTradeReportForNonNextshares::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_data_2eproto_getter, &descriptor_table_data_2eproto_once,
      file_level_metadata_data_2eproto[57]);
}

// ===================================================================

class ReferencePrice::_Internal {
 public:
  using HasBits = decltype(std::declval<ReferencePrice>()._impl_._has_bits_);
  static void set_has_securitycode(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_referenceprice(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_lowerprice(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_upperprice(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

ReferencePrice::ReferencePrice(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:data.ReferencePrice)
}
ReferencePrice::ReferencePrice(const ReferencePrice& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ReferencePrice* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.securitycode_){}
    , decltype(_impl_.referenceprice_){}
    , decltype(_impl_.lowerprice_){}
    , decltype(_impl_.upperprice_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.securitycode_, &from._impl_.securitycode_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.upperprice_) -
    reinterpret_cast<char*>(&_impl_.securitycode_)) + sizeof(_impl_.upperprice_));
  // @@protoc_insertion_point(copy_constructor:data.ReferencePrice)
}

inline void ReferencePrice::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.securitycode_){int64_t{0}}
    , decltype(_impl_.referenceprice_){0}
    , decltype(_impl_.lowerprice_){0}
    , decltype(_impl_.upperprice_){0}
  };
}

ReferencePrice::~ReferencePrice() {
  // @@protoc_insertion_point(destructor:data.ReferencePrice)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ReferencePrice::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ReferencePrice::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ReferencePrice::Clear() {
// @@protoc_insertion_point(message_clear_start:data.ReferencePrice)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&_impl_.securitycode_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.upperprice_) -
        reinterpret_cast<char*>(&_impl_.securitycode_)) + sizeof(_impl_.upperprice_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ReferencePrice::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int64 securityCode = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_securitycode(&has_bits);
          _impl_.securitycode_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional double referencePrice = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _Internal::set_has_referenceprice(&has_bits);
          _impl_.referenceprice_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double lowerPrice = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          _Internal::set_has_lowerprice(&has_bits);
          _impl_.lowerprice_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double upperPrice = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 33)) {
          _Internal::set_has_upperprice(&has_bits);
          _impl_.upperprice_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ReferencePrice::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:data.ReferencePrice)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional int64 securityCode = 1;
  if (_internal_has_securitycode()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_securitycode(), target);
  }

  // optional double referencePrice = 2;
  if (_internal_has_referenceprice()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(2, this->_internal_referenceprice(), target);
  }

  // optional double lowerPrice = 3;
  if (_internal_has_lowerprice()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(3, this->_internal_lowerprice(), target);
  }

  // optional double upperPrice = 4;
  if (_internal_has_upperprice()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(4, this->_internal_upperprice(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:data.ReferencePrice)
  return target;
}

size_t ReferencePrice::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:data.ReferencePrice)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional int64 securityCode = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_securitycode());
    }

    // optional double referencePrice = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 8;
    }

    // optional double lowerPrice = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 8;
    }

    // optional double upperPrice = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 8;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ReferencePrice::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ReferencePrice::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ReferencePrice::GetClassData() const { return &_class_data_; }


void ReferencePrice::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ReferencePrice*>(&to_msg);
  auto& from = static_cast<const ReferencePrice&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:data.ReferencePrice)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.securitycode_ = from._impl_.securitycode_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.referenceprice_ = from._impl_.referenceprice_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.lowerprice_ = from._impl_.lowerprice_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.upperprice_ = from._impl_.upperprice_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ReferencePrice::CopyFrom(const ReferencePrice& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:data.ReferencePrice)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReferencePrice::IsInitialized() const {
  return true;
}

void ReferencePrice::InternalSwap(ReferencePrice* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ReferencePrice, _impl_.upperprice_)
      + sizeof(ReferencePrice::_impl_.upperprice_)
      - PROTOBUF_FIELD_OFFSET(ReferencePrice, _impl_.securitycode_)>(
          reinterpret_cast<char*>(&_impl_.securitycode_),
          reinterpret_cast<char*>(&other->_impl_.securitycode_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ReferencePrice::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_data_2eproto_getter, &descriptor_table_data_2eproto_once,
      file_level_metadata_data_2eproto[58]);
}

// ===================================================================

class QBBOIPOQuotingPeriodUpdate::_Internal {
 public:
  using HasBits = decltype(std::declval<QBBOIPOQuotingPeriodUpdate>()._impl_._has_bits_);
  static void set_has_stock(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ipoquotationreleasetime(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_quotationreleasequalifier(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_ipoprice(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

QBBOIPOQuotingPeriodUpdate::QBBOIPOQuotingPeriodUpdate(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:data.QBBOIPOQuotingPeriodUpdate)
}
QBBOIPOQuotingPeriodUpdate::QBBOIPOQuotingPeriodUpdate(const QBBOIPOQuotingPeriodUpdate& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  QBBOIPOQuotingPeriodUpdate* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.stock_){}
    , decltype(_impl_.ipoquotationreleasetime_){}
    , decltype(_impl_.ipoprice_){}
    , decltype(_impl_.quotationreleasequalifier_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.stock_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.stock_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_stock()) {
    _this->_impl_.stock_.Set(from._internal_stock(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.ipoquotationreleasetime_, &from._impl_.ipoquotationreleasetime_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.quotationreleasequalifier_) -
    reinterpret_cast<char*>(&_impl_.ipoquotationreleasetime_)) + sizeof(_impl_.quotationreleasequalifier_));
  // @@protoc_insertion_point(copy_constructor:data.QBBOIPOQuotingPeriodUpdate)
}

inline void QBBOIPOQuotingPeriodUpdate::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.stock_){}
    , decltype(_impl_.ipoquotationreleasetime_){int64_t{0}}
    , decltype(_impl_.ipoprice_){0}
    , decltype(_impl_.quotationreleasequalifier_){0}
  };
  _impl_.stock_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.stock_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

QBBOIPOQuotingPeriodUpdate::~QBBOIPOQuotingPeriodUpdate() {
  // @@protoc_insertion_point(destructor:data.QBBOIPOQuotingPeriodUpdate)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void QBBOIPOQuotingPeriodUpdate::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.stock_.Destroy();
}

void QBBOIPOQuotingPeriodUpdate::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void QBBOIPOQuotingPeriodUpdate::Clear() {
// @@protoc_insertion_point(message_clear_start:data.QBBOIPOQuotingPeriodUpdate)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.stock_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(&_impl_.ipoquotationreleasetime_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.quotationreleasequalifier_) -
        reinterpret_cast<char*>(&_impl_.ipoquotationreleasetime_)) + sizeof(_impl_.quotationreleasequalifier_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* QBBOIPOQuotingPeriodUpdate::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string stock = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_stock();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "data.QBBOIPOQuotingPeriodUpdate.stock"));
        } else
          goto handle_unusual;
        continue;
      // optional int64 iPOQuotationReleaseTime = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_ipoquotationreleasetime(&has_bits);
          _impl_.ipoquotationreleasetime_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .data.IPOQuotationReleaseQualifier quotationReleaseQualifier = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_quotationreleasequalifier(static_cast<::data::IPOQuotationReleaseQualifier>(val));
        } else
          goto handle_unusual;
        continue;
      // optional double iPOPrice = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 33)) {
          _Internal::set_has_ipoprice(&has_bits);
          _impl_.ipoprice_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* QBBOIPOQuotingPeriodUpdate::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:data.QBBOIPOQuotingPeriodUpdate)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional string stock = 1;
  if (_internal_has_stock()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_stock().data(), static_cast<int>(this->_internal_stock().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "data.QBBOIPOQuotingPeriodUpdate.stock");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_stock(), target);
  }

  // optional int64 iPOQuotationReleaseTime = 2;
  if (_internal_has_ipoquotationreleasetime()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(2, this->_internal_ipoquotationreleasetime(), target);
  }

  // optional .data.IPOQuotationReleaseQualifier quotationReleaseQualifier = 3;
  if (_internal_has_quotationreleasequalifier()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      3, this->_internal_quotationreleasequalifier(), target);
  }

  // optional double iPOPrice = 4;
  if (_internal_has_ipoprice()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(4, this->_internal_ipoprice(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:data.QBBOIPOQuotingPeriodUpdate)
  return target;
}

size_t QBBOIPOQuotingPeriodUpdate::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:data.QBBOIPOQuotingPeriodUpdate)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string stock = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_stock());
    }

    // optional int64 iPOQuotationReleaseTime = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_ipoquotationreleasetime());
    }

    // optional double iPOPrice = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 8;
    }

    // optional .data.IPOQuotationReleaseQualifier quotationReleaseQualifier = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_quotationreleasequalifier());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData QBBOIPOQuotingPeriodUpdate::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    QBBOIPOQuotingPeriodUpdate::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*QBBOIPOQuotingPeriodUpdate::GetClassData() const { return &_class_data_; }


void QBBOIPOQuotingPeriodUpdate::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<QBBOIPOQuotingPeriodUpdate*>(&to_msg);
  auto& from = static_cast<const QBBOIPOQuotingPeriodUpdate&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:data.QBBOIPOQuotingPeriodUpdate)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_stock(from._internal_stock());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.ipoquotationreleasetime_ = from._impl_.ipoquotationreleasetime_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.ipoprice_ = from._impl_.ipoprice_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.quotationreleasequalifier_ = from._impl_.quotationreleasequalifier_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void QBBOIPOQuotingPeriodUpdate::CopyFrom(const QBBOIPOQuotingPeriodUpdate& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:data.QBBOIPOQuotingPeriodUpdate)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool QBBOIPOQuotingPeriodUpdate::IsInitialized() const {
  return true;
}

void QBBOIPOQuotingPeriodUpdate::InternalSwap(QBBOIPOQuotingPeriodUpdate* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.stock_, lhs_arena,
      &other->_impl_.stock_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(QBBOIPOQuotingPeriodUpdate, _impl_.quotationreleasequalifier_)
      + sizeof(QBBOIPOQuotingPeriodUpdate::_impl_.quotationreleasequalifier_)
      - PROTOBUF_FIELD_OFFSET(QBBOIPOQuotingPeriodUpdate, _impl_.ipoquotationreleasetime_)>(
          reinterpret_cast<char*>(&_impl_.ipoquotationreleasetime_),
          reinterpret_cast<char*>(&other->_impl_.ipoquotationreleasetime_));
}

::PROTOBUF_NAMESPACE_ID::Metadata QBBOIPOQuotingPeriodUpdate::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_data_2eproto_getter, &descriptor_table_data_2eproto_once,
      file_level_metadata_data_2eproto[59]);
}

// ===================================================================

class SecurityDefinition::_Internal {
 public:
  using HasBits = decltype(std::declval<SecurityDefinition>()._impl_._has_bits_);
  static void set_has_securitycode(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_marketcode(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_isincode(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_instrumenttype(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_producttype(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_spreadtablecode(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_securityshortname(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_currencycode(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static void set_has_securitynamegccs(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_securitynamegb(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_lotsize(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_previousclosingprice(HasBits* has_bits) {
    (*has_bits)[0] |= 65536u;
  }
  static void set_has_vcmflag(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_shortsellflag(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
  static void set_has_casflag(HasBits* has_bits) {
    (*has_bits)[0] |= 131072u;
  }
  static void set_has_ccassflag(HasBits* has_bits) {
    (*has_bits)[0] |= 262144u;
  }
  static void set_has_dummysecurityflag(HasBits* has_bits) {
    (*has_bits)[0] |= 524288u;
  }
  static void set_has_stampdutyflag(HasBits* has_bits) {
    (*has_bits)[0] |= 1048576u;
  }
  static void set_has_listingdate(HasBits* has_bits) {
    (*has_bits)[0] |= 2097152u;
  }
  static void set_has_delistingdate(HasBits* has_bits) {
    (*has_bits)[0] |= 4194304u;
  }
  static void set_has_freetext(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_posflag(HasBits* has_bits) {
    (*has_bits)[0] |= 8388608u;
  }
  static void set_has_posupperlimit(HasBits* has_bits) {
    (*has_bits)[0] |= 16777216u;
  }
  static void set_has_poslowerlimit(HasBits* has_bits) {
    (*has_bits)[0] |= 33554432u;
  }
  static void set_has_efnflag(HasBits* has_bits) {
    (*has_bits)[0] |= 67108864u;
  }
  static void set_has_accruedinterest(HasBits* has_bits) {
    (*has_bits)[0] |= 134217728u;
  }
  static void set_has_couponrate(HasBits* has_bits) {
    (*has_bits)[0] |= 268435456u;
  }
  static void set_has_facevalue(HasBits* has_bits) {
    (*has_bits)[0] |= 536870912u;
  }
  static void set_has_decimalsinfacevalue(HasBits* has_bits) {
    (*has_bits)[0] |= 1073741824u;
  }
  static void set_has_facevaluecurrency(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_bondmaturitydate(HasBits* has_bits) {
    (*has_bits)[1] |= 1u;
  }
  static void set_has_investortype(HasBits* has_bits) {
    (*has_bits)[0] |= 2147483648u;
  }
  static void set_has_conversionratio(HasBits* has_bits) {
    (*has_bits)[1] |= 2u;
  }
  static void set_has_strikeprice1(HasBits* has_bits) {
    (*has_bits)[1] |= 4u;
  }
  static void set_has_strikeprice2(HasBits* has_bits) {
    (*has_bits)[1] |= 8u;
  }
  static void set_has_warrantmaturitydate(HasBits* has_bits) {
    (*has_bits)[1] |= 16u;
  }
  static void set_has_callputflag(HasBits* has_bits) {
    (*has_bits)[1] |= 32u;
  }
  static void set_has_style(HasBits* has_bits) {
    (*has_bits)[1] |= 64u;
  }
  static void set_has_warranttype(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_callprice(HasBits* has_bits) {
    (*has_bits)[1] |= 128u;
  }
  static void set_has_decimalsincallprice(HasBits* has_bits) {
    (*has_bits)[1] |= 256u;
  }
  static void set_has_entitlement(HasBits* has_bits) {
    (*has_bits)[1] |= 512u;
  }
  static void set_has_decimalsinentitlement(HasBits* has_bits) {
    (*has_bits)[1] |= 1024u;
  }
  static void set_has_nowarrantsperentitlement(HasBits* has_bits) {
    (*has_bits)[1] |= 2048u;
  }
};

SecurityDefinition::SecurityDefinition(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:data.SecurityDefinition)
}
SecurityDefinition::SecurityDefinition(const SecurityDefinition& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SecurityDefinition* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.nounderlyingsecurities_){from._impl_.nounderlyingsecurities_}
    , decltype(_impl_.isincode_){}
    , decltype(_impl_.securityshortname_){}
    , decltype(_impl_.securitynamegccs_){}
    , decltype(_impl_.securitynamegb_){}
    , decltype(_impl_.vcmflag_){}
    , decltype(_impl_.freetext_){}
    , decltype(_impl_.facevaluecurrency_){}
    , decltype(_impl_.warranttype_){}
    , decltype(_impl_.securitycode_){}
    , decltype(_impl_.marketcode_){}
    , decltype(_impl_.instrumenttype_){}
    , decltype(_impl_.producttype_){}
    , decltype(_impl_.spreadtablecode_){}
    , decltype(_impl_.lotsize_){}
    , decltype(_impl_.currencycode_){}
    , decltype(_impl_.shortsellflag_){}
    , decltype(_impl_.previousclosingprice_){}
    , decltype(_impl_.casflag_){}
    , decltype(_impl_.ccassflag_){}
    , decltype(_impl_.dummysecurityflag_){}
    , decltype(_impl_.stampdutyflag_){}
    , decltype(_impl_.listingdate_){}
    , decltype(_impl_.delistingdate_){}
    , decltype(_impl_.posflag_){}
    , decltype(_impl_.posupperlimit_){}
    , decltype(_impl_.poslowerlimit_){}
    , decltype(_impl_.efnflag_){}
    , decltype(_impl_.accruedinterest_){}
    , decltype(_impl_.couponrate_){}
    , decltype(_impl_.facevalue_){}
    , decltype(_impl_.decimalsinfacevalue_){}
    , decltype(_impl_.investortype_){}
    , decltype(_impl_.bondmaturitydate_){}
    , decltype(_impl_.conversionratio_){}
    , decltype(_impl_.strikeprice1_){}
    , decltype(_impl_.strikeprice2_){}
    , decltype(_impl_.warrantmaturitydate_){}
    , decltype(_impl_.callputflag_){}
    , decltype(_impl_.style_){}
    , decltype(_impl_.callprice_){}
    , decltype(_impl_.decimalsincallprice_){}
    , decltype(_impl_.entitlement_){}
    , decltype(_impl_.decimalsinentitlement_){}
    , decltype(_impl_.nowarrantsperentitlement_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.isincode_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.isincode_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_isincode()) {
    _this->_impl_.isincode_.Set(from._internal_isincode(), 
      _this->GetArenaForAllocation());
  }
  _impl_.securityshortname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.securityshortname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_securityshortname()) {
    _this->_impl_.securityshortname_.Set(from._internal_securityshortname(), 
      _this->GetArenaForAllocation());
  }
  _impl_.securitynamegccs_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.securitynamegccs_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_securitynamegccs()) {
    _this->_impl_.securitynamegccs_.Set(from._internal_securitynamegccs(), 
      _this->GetArenaForAllocation());
  }
  _impl_.securitynamegb_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.securitynamegb_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_securitynamegb()) {
    _this->_impl_.securitynamegb_.Set(from._internal_securitynamegb(), 
      _this->GetArenaForAllocation());
  }
  _impl_.vcmflag_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.vcmflag_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_vcmflag()) {
    _this->_impl_.vcmflag_.Set(from._internal_vcmflag(), 
      _this->GetArenaForAllocation());
  }
  _impl_.freetext_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.freetext_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_freetext()) {
    _this->_impl_.freetext_.Set(from._internal_freetext(), 
      _this->GetArenaForAllocation());
  }
  _impl_.facevaluecurrency_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.facevaluecurrency_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_facevaluecurrency()) {
    _this->_impl_.facevaluecurrency_.Set(from._internal_facevaluecurrency(), 
      _this->GetArenaForAllocation());
  }
  _impl_.warranttype_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.warranttype_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_warranttype()) {
    _this->_impl_.warranttype_.Set(from._internal_warranttype(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.securitycode_, &from._impl_.securitycode_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.nowarrantsperentitlement_) -
    reinterpret_cast<char*>(&_impl_.securitycode_)) + sizeof(_impl_.nowarrantsperentitlement_));
  // @@protoc_insertion_point(copy_constructor:data.SecurityDefinition)
}

inline void SecurityDefinition::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.nounderlyingsecurities_){arena}
    , decltype(_impl_.isincode_){}
    , decltype(_impl_.securityshortname_){}
    , decltype(_impl_.securitynamegccs_){}
    , decltype(_impl_.securitynamegb_){}
    , decltype(_impl_.vcmflag_){}
    , decltype(_impl_.freetext_){}
    , decltype(_impl_.facevaluecurrency_){}
    , decltype(_impl_.warranttype_){}
    , decltype(_impl_.securitycode_){int64_t{0}}
    , decltype(_impl_.marketcode_){0}
    , decltype(_impl_.instrumenttype_){0}
    , decltype(_impl_.producttype_){0}
    , decltype(_impl_.spreadtablecode_){0}
    , decltype(_impl_.lotsize_){int64_t{0}}
    , decltype(_impl_.currencycode_){0}
    , decltype(_impl_.shortsellflag_){0}
    , decltype(_impl_.previousclosingprice_){0}
    , decltype(_impl_.casflag_){0}
    , decltype(_impl_.ccassflag_){0}
    , decltype(_impl_.dummysecurityflag_){0}
    , decltype(_impl_.stampdutyflag_){0}
    , decltype(_impl_.listingdate_){int64_t{0}}
    , decltype(_impl_.delistingdate_){int64_t{0}}
    , decltype(_impl_.posflag_){0}
    , decltype(_impl_.posupperlimit_){0}
    , decltype(_impl_.poslowerlimit_){0}
    , decltype(_impl_.efnflag_){0}
    , decltype(_impl_.accruedinterest_){0}
    , decltype(_impl_.couponrate_){0}
    , decltype(_impl_.facevalue_){int64_t{0}}
    , decltype(_impl_.decimalsinfacevalue_){0}
    , decltype(_impl_.investortype_){0}
    , decltype(_impl_.bondmaturitydate_){int64_t{0}}
    , decltype(_impl_.conversionratio_){0}
    , decltype(_impl_.strikeprice1_){0}
    , decltype(_impl_.strikeprice2_){0}
    , decltype(_impl_.warrantmaturitydate_){int64_t{0}}
    , decltype(_impl_.callputflag_){0}
    , decltype(_impl_.style_){0}
    , decltype(_impl_.callprice_){0}
    , decltype(_impl_.decimalsincallprice_){0}
    , decltype(_impl_.entitlement_){0}
    , decltype(_impl_.decimalsinentitlement_){0}
    , decltype(_impl_.nowarrantsperentitlement_){int64_t{0}}
  };
  _impl_.isincode_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.isincode_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.securityshortname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.securityshortname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.securitynamegccs_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.securitynamegccs_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.securitynamegb_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.securitynamegb_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.vcmflag_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.vcmflag_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.freetext_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.freetext_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.facevaluecurrency_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.facevaluecurrency_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.warranttype_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.warranttype_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

SecurityDefinition::~SecurityDefinition() {
  // @@protoc_insertion_point(destructor:data.SecurityDefinition)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SecurityDefinition::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.nounderlyingsecurities_.~RepeatedPtrField();
  _impl_.isincode_.Destroy();
  _impl_.securityshortname_.Destroy();
  _impl_.securitynamegccs_.Destroy();
  _impl_.securitynamegb_.Destroy();
  _impl_.vcmflag_.Destroy();
  _impl_.freetext_.Destroy();
  _impl_.facevaluecurrency_.Destroy();
  _impl_.warranttype_.Destroy();
}

void SecurityDefinition::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SecurityDefinition::Clear() {
// @@protoc_insertion_point(message_clear_start:data.SecurityDefinition)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.nounderlyingsecurities_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.isincode_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.securityshortname_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.securitynamegccs_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.securitynamegb_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      _impl_.vcmflag_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000020u) {
      _impl_.freetext_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000040u) {
      _impl_.facevaluecurrency_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000080u) {
      _impl_.warranttype_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x0000ff00u) {
    ::memset(&_impl_.securitycode_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.shortsellflag_) -
        reinterpret_cast<char*>(&_impl_.securitycode_)) + sizeof(_impl_.shortsellflag_));
  }
  if (cached_has_bits & 0x00ff0000u) {
    ::memset(&_impl_.previousclosingprice_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.posflag_) -
        reinterpret_cast<char*>(&_impl_.previousclosingprice_)) + sizeof(_impl_.posflag_));
  }
  if (cached_has_bits & 0xff000000u) {
    ::memset(&_impl_.posupperlimit_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.investortype_) -
        reinterpret_cast<char*>(&_impl_.posupperlimit_)) + sizeof(_impl_.investortype_));
  }
  cached_has_bits = _impl_._has_bits_[1];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&_impl_.bondmaturitydate_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.callprice_) -
        reinterpret_cast<char*>(&_impl_.bondmaturitydate_)) + sizeof(_impl_.callprice_));
  }
  if (cached_has_bits & 0x00000f00u) {
    ::memset(&_impl_.decimalsincallprice_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.nowarrantsperentitlement_) -
        reinterpret_cast<char*>(&_impl_.decimalsincallprice_)) + sizeof(_impl_.nowarrantsperentitlement_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SecurityDefinition::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int64 securityCode = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_securitycode(&_impl_._has_bits_);
          _impl_.securitycode_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .data.MarketCode marketCode = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_marketcode(static_cast<::data::MarketCode>(val));
        } else
          goto handle_unusual;
        continue;
      // optional string isinCode = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_isincode();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "data.SecurityDefinition.isinCode"));
        } else
          goto handle_unusual;
        continue;
      // optional .data.InstrumentType instrumentType = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_instrumenttype(static_cast<::data::InstrumentType>(val));
        } else
          goto handle_unusual;
        continue;
      // optional .data.ProductType productType = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_producttype(static_cast<::data::ProductType>(val));
        } else
          goto handle_unusual;
        continue;
      // optional .data.SpreadTableCode spreadTableCode = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_spreadtablecode(static_cast<::data::SpreadTableCode>(val));
        } else
          goto handle_unusual;
        continue;
      // optional string securityShortName = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_securityshortname();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "data.SecurityDefinition.securityShortName"));
        } else
          goto handle_unusual;
        continue;
      // optional .data.CurrencyType currencyCode = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_currencycode(static_cast<::data::CurrencyType>(val));
        } else
          goto handle_unusual;
        continue;
      // optional string securityNameGCCS = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          auto str = _internal_mutable_securitynamegccs();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "data.SecurityDefinition.securityNameGCCS"));
        } else
          goto handle_unusual;
        continue;
      // optional string securityNameGB = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          auto str = _internal_mutable_securitynamegb();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "data.SecurityDefinition.securityNameGB"));
        } else
          goto handle_unusual;
        continue;
      // optional int64 lotSize = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _Internal::set_has_lotsize(&_impl_._has_bits_);
          _impl_.lotsize_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional double previousClosingPrice = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 97)) {
          _Internal::set_has_previousclosingprice(&_impl_._has_bits_);
          _impl_.previousclosingprice_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional string VCMFlag = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
          auto str = _internal_mutable_vcmflag();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "data.SecurityDefinition.VCMFlag"));
        } else
          goto handle_unusual;
        continue;
      // optional .data.IndicatesWhether shortSellFlag = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_shortsellflag(static_cast<::data::IndicatesWhether>(val));
        } else
          goto handle_unusual;
        continue;
      // optional .data.IndicatesWhether casFlag = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 120)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_casflag(static_cast<::data::IndicatesWhether>(val));
        } else
          goto handle_unusual;
        continue;
      // optional .data.IndicatesWhether CCASSFlag = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 128)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_ccassflag(static_cast<::data::IndicatesWhether>(val));
        } else
          goto handle_unusual;
        continue;
      // optional .data.IndicatesWhether dummySecurityFlag = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 136)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_dummysecurityflag(static_cast<::data::IndicatesWhether>(val));
        } else
          goto handle_unusual;
        continue;
      // optional .data.IndicatesWhether stampDutyFlag = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 144)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_stampdutyflag(static_cast<::data::IndicatesWhether>(val));
        } else
          goto handle_unusual;
        continue;
      // optional int64 listingDate = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 152)) {
          _Internal::set_has_listingdate(&_impl_._has_bits_);
          _impl_.listingdate_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 delistingDate = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 160)) {
          _Internal::set_has_delistingdate(&_impl_._has_bits_);
          _impl_.delistingdate_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string freeText = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 170)) {
          auto str = _internal_mutable_freetext();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "data.SecurityDefinition.freeText"));
        } else
          goto handle_unusual;
        continue;
      // optional .data.IndicatesWhether posFlag = 22;
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 176)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_posflag(static_cast<::data::IndicatesWhether>(val));
        } else
          goto handle_unusual;
        continue;
      // optional int32 posUpperLimit = 23;
      case 23:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 184)) {
          _Internal::set_has_posupperlimit(&_impl_._has_bits_);
          _impl_.posupperlimit_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 posLowerLimit = 24;
      case 24:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 192)) {
          _Internal::set_has_poslowerlimit(&_impl_._has_bits_);
          _impl_.poslowerlimit_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .data.IndicatesWhether EFNFlag = 25;
      case 25:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 200)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_efnflag(static_cast<::data::IndicatesWhether>(val));
        } else
          goto handle_unusual;
        continue;
      // optional double accruedInterest = 26;
      case 26:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 209)) {
          _Internal::set_has_accruedinterest(&_impl_._has_bits_);
          _impl_.accruedinterest_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double couponRate = 27;
      case 27:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 217)) {
          _Internal::set_has_couponrate(&_impl_._has_bits_);
          _impl_.couponrate_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional int64 faceValue = 28;
      case 28:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 224)) {
          _Internal::set_has_facevalue(&_impl_._has_bits_);
          _impl_.facevalue_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 decimalsInFaceValue = 29;
      case 29:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 232)) {
          _Internal::set_has_decimalsinfacevalue(&_impl_._has_bits_);
          _impl_.decimalsinfacevalue_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string faceValueCurrency = 30;
      case 30:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 242)) {
          auto str = _internal_mutable_facevaluecurrency();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "data.SecurityDefinition.faceValueCurrency"));
        } else
          goto handle_unusual;
        continue;
      // optional int64 bondMaturityDate = 31;
      case 31:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 248)) {
          _Internal::set_has_bondmaturitydate(&_impl_._has_bits_);
          _impl_.bondmaturitydate_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .data.InvestorType investorType = 32;
      case 32:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 0)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_investortype(static_cast<::data::InvestorType>(val));
        } else
          goto handle_unusual;
        continue;
      // optional double conversionRatio = 33;
      case 33:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _Internal::set_has_conversionratio(&_impl_._has_bits_);
          _impl_.conversionratio_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double strikePrice1 = 34;
      case 34:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _Internal::set_has_strikeprice1(&_impl_._has_bits_);
          _impl_.strikeprice1_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double strikePrice2 = 35;
      case 35:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          _Internal::set_has_strikeprice2(&_impl_._has_bits_);
          _impl_.strikeprice2_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional int64 warrantMaturityDate = 36;
      case 36:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_warrantmaturitydate(&_impl_._has_bits_);
          _impl_.warrantmaturitydate_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .data.CallPutFlag callPutFlag = 37;
      case 37:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_callputflag(static_cast<::data::CallPutFlag>(val));
        } else
          goto handle_unusual;
        continue;
      // optional .data.Style style = 38;
      case 38:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_style(static_cast<::data::Style>(val));
        } else
          goto handle_unusual;
        continue;
      // optional string warrantType = 39;
      case 39:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_warranttype();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "data.SecurityDefinition.warrantType"));
        } else
          goto handle_unusual;
        continue;
      // optional int32 callPrice = 40;
      case 40:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_callprice(&_impl_._has_bits_);
          _impl_.callprice_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 DecimalsInCallPrice = 41;
      case 41:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_decimalsincallprice(&_impl_._has_bits_);
          _impl_.decimalsincallprice_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 entitlement = 42;
      case 42:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_entitlement(&_impl_._has_bits_);
          _impl_.entitlement_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 decimalsInEntitlement = 43;
      case 43:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _Internal::set_has_decimalsinentitlement(&_impl_._has_bits_);
          _impl_.decimalsinentitlement_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 noWarrantsPerEntitlement = 44;
      case 44:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _Internal::set_has_nowarrantsperentitlement(&_impl_._has_bits_);
          _impl_.nowarrantsperentitlement_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .data.NoUnderlyingSecurity noUnderlyingSecurities = 45;
      case 45:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_nounderlyingsecurities(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<362>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SecurityDefinition::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:data.SecurityDefinition)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional int64 securityCode = 1;
  if (_internal_has_securitycode()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_securitycode(), target);
  }

  // optional .data.MarketCode marketCode = 2;
  if (_internal_has_marketcode()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_marketcode(), target);
  }

  // optional string isinCode = 3;
  if (_internal_has_isincode()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_isincode().data(), static_cast<int>(this->_internal_isincode().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "data.SecurityDefinition.isinCode");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_isincode(), target);
  }

  // optional .data.InstrumentType instrumentType = 4;
  if (_internal_has_instrumenttype()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      4, this->_internal_instrumenttype(), target);
  }

  // optional .data.ProductType productType = 5;
  if (_internal_has_producttype()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      5, this->_internal_producttype(), target);
  }

  // optional .data.SpreadTableCode spreadTableCode = 6;
  if (_internal_has_spreadtablecode()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      6, this->_internal_spreadtablecode(), target);
  }

  // optional string securityShortName = 7;
  if (_internal_has_securityshortname()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_securityshortname().data(), static_cast<int>(this->_internal_securityshortname().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "data.SecurityDefinition.securityShortName");
    target = stream->WriteStringMaybeAliased(
        7, this->_internal_securityshortname(), target);
  }

  // optional .data.CurrencyType currencyCode = 8;
  if (_internal_has_currencycode()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      8, this->_internal_currencycode(), target);
  }

  // optional string securityNameGCCS = 9;
  if (_internal_has_securitynamegccs()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_securitynamegccs().data(), static_cast<int>(this->_internal_securitynamegccs().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "data.SecurityDefinition.securityNameGCCS");
    target = stream->WriteStringMaybeAliased(
        9, this->_internal_securitynamegccs(), target);
  }

  // optional string securityNameGB = 10;
  if (_internal_has_securitynamegb()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_securitynamegb().data(), static_cast<int>(this->_internal_securitynamegb().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "data.SecurityDefinition.securityNameGB");
    target = stream->WriteStringMaybeAliased(
        10, this->_internal_securitynamegb(), target);
  }

  // optional int64 lotSize = 11;
  if (_internal_has_lotsize()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(11, this->_internal_lotsize(), target);
  }

  // optional double previousClosingPrice = 12;
  if (_internal_has_previousclosingprice()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(12, this->_internal_previousclosingprice(), target);
  }

  // optional string VCMFlag = 13;
  if (_internal_has_vcmflag()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_vcmflag().data(), static_cast<int>(this->_internal_vcmflag().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "data.SecurityDefinition.VCMFlag");
    target = stream->WriteStringMaybeAliased(
        13, this->_internal_vcmflag(), target);
  }

  // optional .data.IndicatesWhether shortSellFlag = 14;
  if (_internal_has_shortsellflag()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      14, this->_internal_shortsellflag(), target);
  }

  // optional .data.IndicatesWhether casFlag = 15;
  if (_internal_has_casflag()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      15, this->_internal_casflag(), target);
  }

  // optional .data.IndicatesWhether CCASSFlag = 16;
  if (_internal_has_ccassflag()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      16, this->_internal_ccassflag(), target);
  }

  // optional .data.IndicatesWhether dummySecurityFlag = 17;
  if (_internal_has_dummysecurityflag()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      17, this->_internal_dummysecurityflag(), target);
  }

  // optional .data.IndicatesWhether stampDutyFlag = 18;
  if (_internal_has_stampdutyflag()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      18, this->_internal_stampdutyflag(), target);
  }

  // optional int64 listingDate = 19;
  if (_internal_has_listingdate()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(19, this->_internal_listingdate(), target);
  }

  // optional int64 delistingDate = 20;
  if (_internal_has_delistingdate()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(20, this->_internal_delistingdate(), target);
  }

  // optional string freeText = 21;
  if (_internal_has_freetext()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_freetext().data(), static_cast<int>(this->_internal_freetext().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "data.SecurityDefinition.freeText");
    target = stream->WriteStringMaybeAliased(
        21, this->_internal_freetext(), target);
  }

  // optional .data.IndicatesWhether posFlag = 22;
  if (_internal_has_posflag()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      22, this->_internal_posflag(), target);
  }

  // optional int32 posUpperLimit = 23;
  if (_internal_has_posupperlimit()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(23, this->_internal_posupperlimit(), target);
  }

  // optional int32 posLowerLimit = 24;
  if (_internal_has_poslowerlimit()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(24, this->_internal_poslowerlimit(), target);
  }

  // optional .data.IndicatesWhether EFNFlag = 25;
  if (_internal_has_efnflag()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      25, this->_internal_efnflag(), target);
  }

  // optional double accruedInterest = 26;
  if (_internal_has_accruedinterest()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(26, this->_internal_accruedinterest(), target);
  }

  // optional double couponRate = 27;
  if (_internal_has_couponrate()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(27, this->_internal_couponrate(), target);
  }

  // optional int64 faceValue = 28;
  if (_internal_has_facevalue()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(28, this->_internal_facevalue(), target);
  }

  // optional int32 decimalsInFaceValue = 29;
  if (_internal_has_decimalsinfacevalue()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(29, this->_internal_decimalsinfacevalue(), target);
  }

  // optional string faceValueCurrency = 30;
  if (_internal_has_facevaluecurrency()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_facevaluecurrency().data(), static_cast<int>(this->_internal_facevaluecurrency().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "data.SecurityDefinition.faceValueCurrency");
    target = stream->WriteStringMaybeAliased(
        30, this->_internal_facevaluecurrency(), target);
  }

  // optional int64 bondMaturityDate = 31;
  if (_internal_has_bondmaturitydate()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(31, this->_internal_bondmaturitydate(), target);
  }

  // optional .data.InvestorType investorType = 32;
  if (_internal_has_investortype()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      32, this->_internal_investortype(), target);
  }

  // optional double conversionRatio = 33;
  if (_internal_has_conversionratio()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(33, this->_internal_conversionratio(), target);
  }

  // optional double strikePrice1 = 34;
  if (_internal_has_strikeprice1()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(34, this->_internal_strikeprice1(), target);
  }

  // optional double strikePrice2 = 35;
  if (_internal_has_strikeprice2()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(35, this->_internal_strikeprice2(), target);
  }

  // optional int64 warrantMaturityDate = 36;
  if (_internal_has_warrantmaturitydate()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(36, this->_internal_warrantmaturitydate(), target);
  }

  // optional .data.CallPutFlag callPutFlag = 37;
  if (_internal_has_callputflag()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      37, this->_internal_callputflag(), target);
  }

  // optional .data.Style style = 38;
  if (_internal_has_style()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      38, this->_internal_style(), target);
  }

  // optional string warrantType = 39;
  if (_internal_has_warranttype()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_warranttype().data(), static_cast<int>(this->_internal_warranttype().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "data.SecurityDefinition.warrantType");
    target = stream->WriteStringMaybeAliased(
        39, this->_internal_warranttype(), target);
  }

  // optional int32 callPrice = 40;
  if (_internal_has_callprice()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(40, this->_internal_callprice(), target);
  }

  // optional int32 DecimalsInCallPrice = 41;
  if (_internal_has_decimalsincallprice()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(41, this->_internal_decimalsincallprice(), target);
  }

  // optional int32 entitlement = 42;
  if (_internal_has_entitlement()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(42, this->_internal_entitlement(), target);
  }

  // optional int32 decimalsInEntitlement = 43;
  if (_internal_has_decimalsinentitlement()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(43, this->_internal_decimalsinentitlement(), target);
  }

  // optional int64 noWarrantsPerEntitlement = 44;
  if (_internal_has_nowarrantsperentitlement()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(44, this->_internal_nowarrantsperentitlement(), target);
  }

  // repeated .data.NoUnderlyingSecurity noUnderlyingSecurities = 45;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_nounderlyingsecurities_size()); i < n; i++) {
    const auto& repfield = this->_internal_nounderlyingsecurities(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(45, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:data.SecurityDefinition)
  return target;
}

size_t SecurityDefinition::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:data.SecurityDefinition)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .data.NoUnderlyingSecurity noUnderlyingSecurities = 45;
  total_size += 2UL * this->_internal_nounderlyingsecurities_size();
  for (const auto& msg : this->_impl_.nounderlyingsecurities_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string isinCode = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_isincode());
    }

    // optional string securityShortName = 7;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_securityshortname());
    }

    // optional string securityNameGCCS = 9;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_securitynamegccs());
    }

    // optional string securityNameGB = 10;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_securitynamegb());
    }

    // optional string VCMFlag = 13;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_vcmflag());
    }

    // optional string freeText = 21;
    if (cached_has_bits & 0x00000020u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_freetext());
    }

    // optional string faceValueCurrency = 30;
    if (cached_has_bits & 0x00000040u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_facevaluecurrency());
    }

    // optional string warrantType = 39;
    if (cached_has_bits & 0x00000080u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_warranttype());
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional int64 securityCode = 1;
    if (cached_has_bits & 0x00000100u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_securitycode());
    }

    // optional .data.MarketCode marketCode = 2;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_marketcode());
    }

    // optional .data.InstrumentType instrumentType = 4;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_instrumenttype());
    }

    // optional .data.ProductType productType = 5;
    if (cached_has_bits & 0x00000800u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_producttype());
    }

    // optional .data.SpreadTableCode spreadTableCode = 6;
    if (cached_has_bits & 0x00001000u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_spreadtablecode());
    }

    // optional int64 lotSize = 11;
    if (cached_has_bits & 0x00002000u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_lotsize());
    }

    // optional .data.CurrencyType currencyCode = 8;
    if (cached_has_bits & 0x00004000u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_currencycode());
    }

    // optional .data.IndicatesWhether shortSellFlag = 14;
    if (cached_has_bits & 0x00008000u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_shortsellflag());
    }

  }
  if (cached_has_bits & 0x00ff0000u) {
    // optional double previousClosingPrice = 12;
    if (cached_has_bits & 0x00010000u) {
      total_size += 1 + 8;
    }

    // optional .data.IndicatesWhether casFlag = 15;
    if (cached_has_bits & 0x00020000u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_casflag());
    }

    // optional .data.IndicatesWhether CCASSFlag = 16;
    if (cached_has_bits & 0x00040000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_ccassflag());
    }

    // optional .data.IndicatesWhether dummySecurityFlag = 17;
    if (cached_has_bits & 0x00080000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_dummysecurityflag());
    }

    // optional .data.IndicatesWhether stampDutyFlag = 18;
    if (cached_has_bits & 0x00100000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_stampdutyflag());
    }

    // optional int64 listingDate = 19;
    if (cached_has_bits & 0x00200000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int64Size(
          this->_internal_listingdate());
    }

    // optional int64 delistingDate = 20;
    if (cached_has_bits & 0x00400000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int64Size(
          this->_internal_delistingdate());
    }

    // optional .data.IndicatesWhether posFlag = 22;
    if (cached_has_bits & 0x00800000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_posflag());
    }

  }
  if (cached_has_bits & 0xff000000u) {
    // optional int32 posUpperLimit = 23;
    if (cached_has_bits & 0x01000000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int32Size(
          this->_internal_posupperlimit());
    }

    // optional int32 posLowerLimit = 24;
    if (cached_has_bits & 0x02000000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int32Size(
          this->_internal_poslowerlimit());
    }

    // optional .data.IndicatesWhether EFNFlag = 25;
    if (cached_has_bits & 0x04000000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_efnflag());
    }

    // optional double accruedInterest = 26;
    if (cached_has_bits & 0x08000000u) {
      total_size += 2 + 8;
    }

    // optional double couponRate = 27;
    if (cached_has_bits & 0x10000000u) {
      total_size += 2 + 8;
    }

    // optional int64 faceValue = 28;
    if (cached_has_bits & 0x20000000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int64Size(
          this->_internal_facevalue());
    }

    // optional int32 decimalsInFaceValue = 29;
    if (cached_has_bits & 0x40000000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int32Size(
          this->_internal_decimalsinfacevalue());
    }

    // optional .data.InvestorType investorType = 32;
    if (cached_has_bits & 0x80000000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_investortype());
    }

  }
  cached_has_bits = _impl_._has_bits_[1];
  if (cached_has_bits & 0x000000ffu) {
    // optional int64 bondMaturityDate = 31;
    if (cached_has_bits & 0x00000001u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int64Size(
          this->_internal_bondmaturitydate());
    }

    // optional double conversionRatio = 33;
    if (cached_has_bits & 0x00000002u) {
      total_size += 2 + 8;
    }

    // optional double strikePrice1 = 34;
    if (cached_has_bits & 0x00000004u) {
      total_size += 2 + 8;
    }

    // optional double strikePrice2 = 35;
    if (cached_has_bits & 0x00000008u) {
      total_size += 2 + 8;
    }

    // optional int64 warrantMaturityDate = 36;
    if (cached_has_bits & 0x00000010u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int64Size(
          this->_internal_warrantmaturitydate());
    }

    // optional .data.CallPutFlag callPutFlag = 37;
    if (cached_has_bits & 0x00000020u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_callputflag());
    }

    // optional .data.Style style = 38;
    if (cached_has_bits & 0x00000040u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_style());
    }

    // optional int32 callPrice = 40;
    if (cached_has_bits & 0x00000080u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int32Size(
          this->_internal_callprice());
    }

  }
  if (cached_has_bits & 0x00000f00u) {
    // optional int32 DecimalsInCallPrice = 41;
    if (cached_has_bits & 0x00000100u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int32Size(
          this->_internal_decimalsincallprice());
    }

    // optional int32 entitlement = 42;
    if (cached_has_bits & 0x00000200u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int32Size(
          this->_internal_entitlement());
    }

    // optional int32 decimalsInEntitlement = 43;
    if (cached_has_bits & 0x00000400u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int32Size(
          this->_internal_decimalsinentitlement());
    }

    // optional int64 noWarrantsPerEntitlement = 44;
    if (cached_has_bits & 0x00000800u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int64Size(
          this->_internal_nowarrantsperentitlement());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SecurityDefinition::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SecurityDefinition::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SecurityDefinition::GetClassData() const { return &_class_data_; }


void SecurityDefinition::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SecurityDefinition*>(&to_msg);
  auto& from = static_cast<const SecurityDefinition&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:data.SecurityDefinition)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.nounderlyingsecurities_.MergeFrom(from._impl_.nounderlyingsecurities_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_isincode(from._internal_isincode());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_securityshortname(from._internal_securityshortname());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_securitynamegccs(from._internal_securitynamegccs());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_set_securitynamegb(from._internal_securitynamegb());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_set_vcmflag(from._internal_vcmflag());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_internal_set_freetext(from._internal_freetext());
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_internal_set_facevaluecurrency(from._internal_facevaluecurrency());
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_internal_set_warranttype(from._internal_warranttype());
    }
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.securitycode_ = from._impl_.securitycode_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.marketcode_ = from._impl_.marketcode_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.instrumenttype_ = from._impl_.instrumenttype_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.producttype_ = from._impl_.producttype_;
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_impl_.spreadtablecode_ = from._impl_.spreadtablecode_;
    }
    if (cached_has_bits & 0x00002000u) {
      _this->_impl_.lotsize_ = from._impl_.lotsize_;
    }
    if (cached_has_bits & 0x00004000u) {
      _this->_impl_.currencycode_ = from._impl_.currencycode_;
    }
    if (cached_has_bits & 0x00008000u) {
      _this->_impl_.shortsellflag_ = from._impl_.shortsellflag_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00ff0000u) {
    if (cached_has_bits & 0x00010000u) {
      _this->_impl_.previousclosingprice_ = from._impl_.previousclosingprice_;
    }
    if (cached_has_bits & 0x00020000u) {
      _this->_impl_.casflag_ = from._impl_.casflag_;
    }
    if (cached_has_bits & 0x00040000u) {
      _this->_impl_.ccassflag_ = from._impl_.ccassflag_;
    }
    if (cached_has_bits & 0x00080000u) {
      _this->_impl_.dummysecurityflag_ = from._impl_.dummysecurityflag_;
    }
    if (cached_has_bits & 0x00100000u) {
      _this->_impl_.stampdutyflag_ = from._impl_.stampdutyflag_;
    }
    if (cached_has_bits & 0x00200000u) {
      _this->_impl_.listingdate_ = from._impl_.listingdate_;
    }
    if (cached_has_bits & 0x00400000u) {
      _this->_impl_.delistingdate_ = from._impl_.delistingdate_;
    }
    if (cached_has_bits & 0x00800000u) {
      _this->_impl_.posflag_ = from._impl_.posflag_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0xff000000u) {
    if (cached_has_bits & 0x01000000u) {
      _this->_impl_.posupperlimit_ = from._impl_.posupperlimit_;
    }
    if (cached_has_bits & 0x02000000u) {
      _this->_impl_.poslowerlimit_ = from._impl_.poslowerlimit_;
    }
    if (cached_has_bits & 0x04000000u) {
      _this->_impl_.efnflag_ = from._impl_.efnflag_;
    }
    if (cached_has_bits & 0x08000000u) {
      _this->_impl_.accruedinterest_ = from._impl_.accruedinterest_;
    }
    if (cached_has_bits & 0x10000000u) {
      _this->_impl_.couponrate_ = from._impl_.couponrate_;
    }
    if (cached_has_bits & 0x20000000u) {
      _this->_impl_.facevalue_ = from._impl_.facevalue_;
    }
    if (cached_has_bits & 0x40000000u) {
      _this->_impl_.decimalsinfacevalue_ = from._impl_.decimalsinfacevalue_;
    }
    if (cached_has_bits & 0x80000000u) {
      _this->_impl_.investortype_ = from._impl_.investortype_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  cached_has_bits = from._impl_._has_bits_[1];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.bondmaturitydate_ = from._impl_.bondmaturitydate_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.conversionratio_ = from._impl_.conversionratio_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.strikeprice1_ = from._impl_.strikeprice1_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.strikeprice2_ = from._impl_.strikeprice2_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.warrantmaturitydate_ = from._impl_.warrantmaturitydate_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.callputflag_ = from._impl_.callputflag_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.style_ = from._impl_.style_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.callprice_ = from._impl_.callprice_;
    }
    _this->_impl_._has_bits_[1] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000f00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.decimalsincallprice_ = from._impl_.decimalsincallprice_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.entitlement_ = from._impl_.entitlement_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.decimalsinentitlement_ = from._impl_.decimalsinentitlement_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.nowarrantsperentitlement_ = from._impl_.nowarrantsperentitlement_;
    }
    _this->_impl_._has_bits_[1] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SecurityDefinition::CopyFrom(const SecurityDefinition& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:data.SecurityDefinition)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SecurityDefinition::IsInitialized() const {
  return true;
}

void SecurityDefinition::InternalSwap(SecurityDefinition* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_._has_bits_[1], other->_impl_._has_bits_[1]);
  _impl_.nounderlyingsecurities_.InternalSwap(&other->_impl_.nounderlyingsecurities_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.isincode_, lhs_arena,
      &other->_impl_.isincode_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.securityshortname_, lhs_arena,
      &other->_impl_.securityshortname_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.securitynamegccs_, lhs_arena,
      &other->_impl_.securitynamegccs_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.securitynamegb_, lhs_arena,
      &other->_impl_.securitynamegb_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.vcmflag_, lhs_arena,
      &other->_impl_.vcmflag_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.freetext_, lhs_arena,
      &other->_impl_.freetext_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.facevaluecurrency_, lhs_arena,
      &other->_impl_.facevaluecurrency_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.warranttype_, lhs_arena,
      &other->_impl_.warranttype_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SecurityDefinition, _impl_.nowarrantsperentitlement_)
      + sizeof(SecurityDefinition::_impl_.nowarrantsperentitlement_)
      - PROTOBUF_FIELD_OFFSET(SecurityDefinition, _impl_.securitycode_)>(
          reinterpret_cast<char*>(&_impl_.securitycode_),
          reinterpret_cast<char*>(&other->_impl_.securitycode_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SecurityDefinition::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_data_2eproto_getter, &descriptor_table_data_2eproto_once,
      file_level_metadata_data_2eproto[60]);
}

// ===================================================================

class SecurityStatus::_Internal {
 public:
  using HasBits = decltype(std::declval<SecurityStatus>()._impl_._has_bits_);
  static void set_has_securitycode(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_suspensionindicator(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

SecurityStatus::SecurityStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:data.SecurityStatus)
}
SecurityStatus::SecurityStatus(const SecurityStatus& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SecurityStatus* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.securitycode_){}
    , decltype(_impl_.suspensionindicator_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.securitycode_, &from._impl_.securitycode_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.suspensionindicator_) -
    reinterpret_cast<char*>(&_impl_.securitycode_)) + sizeof(_impl_.suspensionindicator_));
  // @@protoc_insertion_point(copy_constructor:data.SecurityStatus)
}

inline void SecurityStatus::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.securitycode_){int64_t{0}}
    , decltype(_impl_.suspensionindicator_){0}
  };
}

SecurityStatus::~SecurityStatus() {
  // @@protoc_insertion_point(destructor:data.SecurityStatus)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SecurityStatus::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void SecurityStatus::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SecurityStatus::Clear() {
// @@protoc_insertion_point(message_clear_start:data.SecurityStatus)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.securitycode_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.suspensionindicator_) -
        reinterpret_cast<char*>(&_impl_.securitycode_)) + sizeof(_impl_.suspensionindicator_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SecurityStatus::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int64 securityCode = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_securitycode(&has_bits);
          _impl_.securitycode_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .data.SuspensionIndicator suspensionIndicator = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_suspensionindicator(static_cast<::data::SuspensionIndicator>(val));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SecurityStatus::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:data.SecurityStatus)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional int64 securityCode = 1;
  if (_internal_has_securitycode()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_securitycode(), target);
  }

  // optional .data.SuspensionIndicator suspensionIndicator = 2;
  if (_internal_has_suspensionindicator()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_suspensionindicator(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:data.SecurityStatus)
  return target;
}

size_t SecurityStatus::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:data.SecurityStatus)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional int64 securityCode = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_securitycode());
    }

    // optional .data.SuspensionIndicator suspensionIndicator = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_suspensionindicator());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SecurityStatus::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SecurityStatus::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SecurityStatus::GetClassData() const { return &_class_data_; }


void SecurityStatus::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SecurityStatus*>(&to_msg);
  auto& from = static_cast<const SecurityStatus&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:data.SecurityStatus)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.securitycode_ = from._impl_.securitycode_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.suspensionindicator_ = from._impl_.suspensionindicator_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SecurityStatus::CopyFrom(const SecurityStatus& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:data.SecurityStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SecurityStatus::IsInitialized() const {
  return true;
}

void SecurityStatus::InternalSwap(SecurityStatus* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SecurityStatus, _impl_.suspensionindicator_)
      + sizeof(SecurityStatus::_impl_.suspensionindicator_)
      - PROTOBUF_FIELD_OFFSET(SecurityStatus, _impl_.securitycode_)>(
          reinterpret_cast<char*>(&_impl_.securitycode_),
          reinterpret_cast<char*>(&other->_impl_.securitycode_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SecurityStatus::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_data_2eproto_getter, &descriptor_table_data_2eproto_once,
      file_level_metadata_data_2eproto[61]);
}

// ===================================================================

class Statistics::_Internal {
 public:
  using HasBits = decltype(std::declval<Statistics>()._impl_._has_bits_);
  static void set_has_securitycode(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_sharestraded(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_vcmreferenceprice(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_highprice(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_lowprice(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_lastprice(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_vwap(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_shortsellsharestraded(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_shortsellturnover(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
};

Statistics::Statistics(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:data.Statistics)
}
Statistics::Statistics(const Statistics& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Statistics* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.securitycode_){}
    , decltype(_impl_.sharestraded_){}
    , decltype(_impl_.vcmreferenceprice_){}
    , decltype(_impl_.highprice_){}
    , decltype(_impl_.lowprice_){}
    , decltype(_impl_.lastprice_){}
    , decltype(_impl_.vwap_){}
    , decltype(_impl_.shortsellsharestraded_){}
    , decltype(_impl_.shortsellturnover_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.securitycode_, &from._impl_.securitycode_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.shortsellturnover_) -
    reinterpret_cast<char*>(&_impl_.securitycode_)) + sizeof(_impl_.shortsellturnover_));
  // @@protoc_insertion_point(copy_constructor:data.Statistics)
}

inline void Statistics::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.securitycode_){int64_t{0}}
    , decltype(_impl_.sharestraded_){int64_t{0}}
    , decltype(_impl_.vcmreferenceprice_){0}
    , decltype(_impl_.highprice_){0}
    , decltype(_impl_.lowprice_){0}
    , decltype(_impl_.lastprice_){0}
    , decltype(_impl_.vwap_){0}
    , decltype(_impl_.shortsellsharestraded_){int64_t{0}}
    , decltype(_impl_.shortsellturnover_){0}
  };
}

Statistics::~Statistics() {
  // @@protoc_insertion_point(destructor:data.Statistics)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Statistics::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Statistics::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Statistics::Clear() {
// @@protoc_insertion_point(message_clear_start:data.Statistics)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&_impl_.securitycode_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.shortsellsharestraded_) -
        reinterpret_cast<char*>(&_impl_.securitycode_)) + sizeof(_impl_.shortsellsharestraded_));
  }
  _impl_.shortsellturnover_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Statistics::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int64 securityCode = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_securitycode(&has_bits);
          _impl_.securitycode_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 sharesTraded = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_sharestraded(&has_bits);
          _impl_.sharestraded_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional double vCMReferencePrice = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          _Internal::set_has_vcmreferenceprice(&has_bits);
          _impl_.vcmreferenceprice_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double highPrice = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 33)) {
          _Internal::set_has_highprice(&has_bits);
          _impl_.highprice_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double lowPrice = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 41)) {
          _Internal::set_has_lowprice(&has_bits);
          _impl_.lowprice_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double lastPrice = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 49)) {
          _Internal::set_has_lastprice(&has_bits);
          _impl_.lastprice_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double vwap = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 57)) {
          _Internal::set_has_vwap(&has_bits);
          _impl_.vwap_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional int64 shortSellSharesTraded = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_shortsellsharestraded(&has_bits);
          _impl_.shortsellsharestraded_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional double shortSellTurnover = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 73)) {
          _Internal::set_has_shortsellturnover(&has_bits);
          _impl_.shortsellturnover_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Statistics::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:data.Statistics)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional int64 securityCode = 1;
  if (_internal_has_securitycode()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_securitycode(), target);
  }

  // optional int64 sharesTraded = 2;
  if (_internal_has_sharestraded()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(2, this->_internal_sharestraded(), target);
  }

  // optional double vCMReferencePrice = 3;
  if (_internal_has_vcmreferenceprice()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(3, this->_internal_vcmreferenceprice(), target);
  }

  // optional double highPrice = 4;
  if (_internal_has_highprice()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(4, this->_internal_highprice(), target);
  }

  // optional double lowPrice = 5;
  if (_internal_has_lowprice()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(5, this->_internal_lowprice(), target);
  }

  // optional double lastPrice = 6;
  if (_internal_has_lastprice()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(6, this->_internal_lastprice(), target);
  }

  // optional double vwap = 7;
  if (_internal_has_vwap()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(7, this->_internal_vwap(), target);
  }

  // optional int64 shortSellSharesTraded = 8;
  if (_internal_has_shortsellsharestraded()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(8, this->_internal_shortsellsharestraded(), target);
  }

  // optional double shortSellTurnover = 9;
  if (_internal_has_shortsellturnover()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(9, this->_internal_shortsellturnover(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:data.Statistics)
  return target;
}

size_t Statistics::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:data.Statistics)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional int64 securityCode = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_securitycode());
    }

    // optional int64 sharesTraded = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_sharestraded());
    }

    // optional double vCMReferencePrice = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 8;
    }

    // optional double highPrice = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 8;
    }

    // optional double lowPrice = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 8;
    }

    // optional double lastPrice = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 8;
    }

    // optional double vwap = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 8;
    }

    // optional int64 shortSellSharesTraded = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_shortsellsharestraded());
    }

  }
  // optional double shortSellTurnover = 9;
  if (cached_has_bits & 0x00000100u) {
    total_size += 1 + 8;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Statistics::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Statistics::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Statistics::GetClassData() const { return &_class_data_; }


void Statistics::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Statistics*>(&to_msg);
  auto& from = static_cast<const Statistics&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:data.Statistics)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.securitycode_ = from._impl_.securitycode_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.sharestraded_ = from._impl_.sharestraded_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.vcmreferenceprice_ = from._impl_.vcmreferenceprice_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.highprice_ = from._impl_.highprice_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.lowprice_ = from._impl_.lowprice_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.lastprice_ = from._impl_.lastprice_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.vwap_ = from._impl_.vwap_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.shortsellsharestraded_ = from._impl_.shortsellsharestraded_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000100u) {
    _this->_internal_set_shortsellturnover(from._internal_shortsellturnover());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Statistics::CopyFrom(const Statistics& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:data.Statistics)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Statistics::IsInitialized() const {
  return true;
}

void Statistics::InternalSwap(Statistics* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Statistics, _impl_.shortsellturnover_)
      + sizeof(Statistics::_impl_.shortsellturnover_)
      - PROTOBUF_FIELD_OFFSET(Statistics, _impl_.securitycode_)>(
          reinterpret_cast<char*>(&_impl_.securitycode_),
          reinterpret_cast<char*>(&other->_impl_.securitycode_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Statistics::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_data_2eproto_getter, &descriptor_table_data_2eproto_once,
      file_level_metadata_data_2eproto[62]);
}

// ===================================================================

class StockConnectDailyQuotaBalance::_Internal {
 public:
  using HasBits = decltype(std::declval<StockConnectDailyQuotaBalance>()._impl_._has_bits_);
  static void set_has_stockconnectmarket(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_tradingdirection(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_dailyquotabalance(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_dailyquotabalancetime(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

StockConnectDailyQuotaBalance::StockConnectDailyQuotaBalance(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:data.StockConnectDailyQuotaBalance)
}
StockConnectDailyQuotaBalance::StockConnectDailyQuotaBalance(const StockConnectDailyQuotaBalance& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  StockConnectDailyQuotaBalance* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.stockconnectmarket_){}
    , decltype(_impl_.tradingdirection_){}
    , decltype(_impl_.dailyquotabalance_){}
    , decltype(_impl_.dailyquotabalancetime_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.stockconnectmarket_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.stockconnectmarket_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_stockconnectmarket()) {
    _this->_impl_.stockconnectmarket_.Set(from._internal_stockconnectmarket(), 
      _this->GetArenaForAllocation());
  }
  _impl_.tradingdirection_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.tradingdirection_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_tradingdirection()) {
    _this->_impl_.tradingdirection_.Set(from._internal_tradingdirection(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.dailyquotabalance_, &from._impl_.dailyquotabalance_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.dailyquotabalancetime_) -
    reinterpret_cast<char*>(&_impl_.dailyquotabalance_)) + sizeof(_impl_.dailyquotabalancetime_));
  // @@protoc_insertion_point(copy_constructor:data.StockConnectDailyQuotaBalance)
}

inline void StockConnectDailyQuotaBalance::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.stockconnectmarket_){}
    , decltype(_impl_.tradingdirection_){}
    , decltype(_impl_.dailyquotabalance_){int64_t{0}}
    , decltype(_impl_.dailyquotabalancetime_){int64_t{0}}
  };
  _impl_.stockconnectmarket_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.stockconnectmarket_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.tradingdirection_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.tradingdirection_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

StockConnectDailyQuotaBalance::~StockConnectDailyQuotaBalance() {
  // @@protoc_insertion_point(destructor:data.StockConnectDailyQuotaBalance)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void StockConnectDailyQuotaBalance::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.stockconnectmarket_.Destroy();
  _impl_.tradingdirection_.Destroy();
}

void StockConnectDailyQuotaBalance::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void StockConnectDailyQuotaBalance::Clear() {
// @@protoc_insertion_point(message_clear_start:data.StockConnectDailyQuotaBalance)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.stockconnectmarket_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.tradingdirection_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x0000000cu) {
    ::memset(&_impl_.dailyquotabalance_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.dailyquotabalancetime_) -
        reinterpret_cast<char*>(&_impl_.dailyquotabalance_)) + sizeof(_impl_.dailyquotabalancetime_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StockConnectDailyQuotaBalance::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string stockConnectMarket = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_stockconnectmarket();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "data.StockConnectDailyQuotaBalance.stockConnectMarket"));
        } else
          goto handle_unusual;
        continue;
      // optional string tradingDirection = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_tradingdirection();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "data.StockConnectDailyQuotaBalance.tradingDirection"));
        } else
          goto handle_unusual;
        continue;
      // optional int64 dailyQuotaBalance = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_dailyquotabalance(&has_bits);
          _impl_.dailyquotabalance_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 dailyQuotaBalanceTime = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_dailyquotabalancetime(&has_bits);
          _impl_.dailyquotabalancetime_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* StockConnectDailyQuotaBalance::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:data.StockConnectDailyQuotaBalance)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional string stockConnectMarket = 1;
  if (_internal_has_stockconnectmarket()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_stockconnectmarket().data(), static_cast<int>(this->_internal_stockconnectmarket().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "data.StockConnectDailyQuotaBalance.stockConnectMarket");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_stockconnectmarket(), target);
  }

  // optional string tradingDirection = 2;
  if (_internal_has_tradingdirection()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_tradingdirection().data(), static_cast<int>(this->_internal_tradingdirection().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "data.StockConnectDailyQuotaBalance.tradingDirection");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_tradingdirection(), target);
  }

  // optional int64 dailyQuotaBalance = 3;
  if (_internal_has_dailyquotabalance()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(3, this->_internal_dailyquotabalance(), target);
  }

  // optional int64 dailyQuotaBalanceTime = 4;
  if (_internal_has_dailyquotabalancetime()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(4, this->_internal_dailyquotabalancetime(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:data.StockConnectDailyQuotaBalance)
  return target;
}

size_t StockConnectDailyQuotaBalance::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:data.StockConnectDailyQuotaBalance)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string stockConnectMarket = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_stockconnectmarket());
    }

    // optional string tradingDirection = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_tradingdirection());
    }

    // optional int64 dailyQuotaBalance = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_dailyquotabalance());
    }

    // optional int64 dailyQuotaBalanceTime = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_dailyquotabalancetime());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StockConnectDailyQuotaBalance::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    StockConnectDailyQuotaBalance::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StockConnectDailyQuotaBalance::GetClassData() const { return &_class_data_; }


void StockConnectDailyQuotaBalance::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<StockConnectDailyQuotaBalance*>(&to_msg);
  auto& from = static_cast<const StockConnectDailyQuotaBalance&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:data.StockConnectDailyQuotaBalance)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_stockconnectmarket(from._internal_stockconnectmarket());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_tradingdirection(from._internal_tradingdirection());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.dailyquotabalance_ = from._impl_.dailyquotabalance_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.dailyquotabalancetime_ = from._impl_.dailyquotabalancetime_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StockConnectDailyQuotaBalance::CopyFrom(const StockConnectDailyQuotaBalance& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:data.StockConnectDailyQuotaBalance)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StockConnectDailyQuotaBalance::IsInitialized() const {
  return true;
}

void StockConnectDailyQuotaBalance::InternalSwap(StockConnectDailyQuotaBalance* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.stockconnectmarket_, lhs_arena,
      &other->_impl_.stockconnectmarket_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.tradingdirection_, lhs_arena,
      &other->_impl_.tradingdirection_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(StockConnectDailyQuotaBalance, _impl_.dailyquotabalancetime_)
      + sizeof(StockConnectDailyQuotaBalance::_impl_.dailyquotabalancetime_)
      - PROTOBUF_FIELD_OFFSET(StockConnectDailyQuotaBalance, _impl_.dailyquotabalance_)>(
          reinterpret_cast<char*>(&_impl_.dailyquotabalance_),
          reinterpret_cast<char*>(&other->_impl_.dailyquotabalance_));
}

::PROTOBUF_NAMESPACE_ID::Metadata StockConnectDailyQuotaBalance::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_data_2eproto_getter, &descriptor_table_data_2eproto_once,
      file_level_metadata_data_2eproto[63]);
}

// ===================================================================

class StockConnectMarketTurnover::_Internal {
 public:
  using HasBits = decltype(std::declval<StockConnectMarketTurnover>()._impl_._has_bits_);
  static void set_has_stockconnectmarket(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_tradingdirection(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_buyturnover(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_sellturnover(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_buysellturnover(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

StockConnectMarketTurnover::StockConnectMarketTurnover(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:data.StockConnectMarketTurnover)
}
StockConnectMarketTurnover::StockConnectMarketTurnover(const StockConnectMarketTurnover& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  StockConnectMarketTurnover* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.stockconnectmarket_){}
    , decltype(_impl_.tradingdirection_){}
    , decltype(_impl_.buyturnover_){}
    , decltype(_impl_.sellturnover_){}
    , decltype(_impl_.buysellturnover_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.stockconnectmarket_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.stockconnectmarket_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_stockconnectmarket()) {
    _this->_impl_.stockconnectmarket_.Set(from._internal_stockconnectmarket(), 
      _this->GetArenaForAllocation());
  }
  _impl_.tradingdirection_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.tradingdirection_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_tradingdirection()) {
    _this->_impl_.tradingdirection_.Set(from._internal_tradingdirection(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.buyturnover_, &from._impl_.buyturnover_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.buysellturnover_) -
    reinterpret_cast<char*>(&_impl_.buyturnover_)) + sizeof(_impl_.buysellturnover_));
  // @@protoc_insertion_point(copy_constructor:data.StockConnectMarketTurnover)
}

inline void StockConnectMarketTurnover::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.stockconnectmarket_){}
    , decltype(_impl_.tradingdirection_){}
    , decltype(_impl_.buyturnover_){int64_t{0}}
    , decltype(_impl_.sellturnover_){int64_t{0}}
    , decltype(_impl_.buysellturnover_){int64_t{0}}
  };
  _impl_.stockconnectmarket_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.stockconnectmarket_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.tradingdirection_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.tradingdirection_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

StockConnectMarketTurnover::~StockConnectMarketTurnover() {
  // @@protoc_insertion_point(destructor:data.StockConnectMarketTurnover)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void StockConnectMarketTurnover::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.stockconnectmarket_.Destroy();
  _impl_.tradingdirection_.Destroy();
}

void StockConnectMarketTurnover::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void StockConnectMarketTurnover::Clear() {
// @@protoc_insertion_point(message_clear_start:data.StockConnectMarketTurnover)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.stockconnectmarket_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.tradingdirection_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x0000001cu) {
    ::memset(&_impl_.buyturnover_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.buysellturnover_) -
        reinterpret_cast<char*>(&_impl_.buyturnover_)) + sizeof(_impl_.buysellturnover_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StockConnectMarketTurnover::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string stockConnectMarket = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_stockconnectmarket();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "data.StockConnectMarketTurnover.stockConnectMarket"));
        } else
          goto handle_unusual;
        continue;
      // optional string tradingDirection = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_tradingdirection();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "data.StockConnectMarketTurnover.tradingDirection"));
        } else
          goto handle_unusual;
        continue;
      // optional int64 buyTurnover = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_buyturnover(&has_bits);
          _impl_.buyturnover_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 sellTurnover = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_sellturnover(&has_bits);
          _impl_.sellturnover_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 buySellTurnover = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_buysellturnover(&has_bits);
          _impl_.buysellturnover_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* StockConnectMarketTurnover::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:data.StockConnectMarketTurnover)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional string stockConnectMarket = 1;
  if (_internal_has_stockconnectmarket()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_stockconnectmarket().data(), static_cast<int>(this->_internal_stockconnectmarket().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "data.StockConnectMarketTurnover.stockConnectMarket");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_stockconnectmarket(), target);
  }

  // optional string tradingDirection = 2;
  if (_internal_has_tradingdirection()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_tradingdirection().data(), static_cast<int>(this->_internal_tradingdirection().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "data.StockConnectMarketTurnover.tradingDirection");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_tradingdirection(), target);
  }

  // optional int64 buyTurnover = 3;
  if (_internal_has_buyturnover()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(3, this->_internal_buyturnover(), target);
  }

  // optional int64 sellTurnover = 4;
  if (_internal_has_sellturnover()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(4, this->_internal_sellturnover(), target);
  }

  // optional int64 buySellTurnover = 5;
  if (_internal_has_buysellturnover()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(5, this->_internal_buysellturnover(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:data.StockConnectMarketTurnover)
  return target;
}

size_t StockConnectMarketTurnover::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:data.StockConnectMarketTurnover)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional string stockConnectMarket = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_stockconnectmarket());
    }

    // optional string tradingDirection = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_tradingdirection());
    }

    // optional int64 buyTurnover = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_buyturnover());
    }

    // optional int64 sellTurnover = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_sellturnover());
    }

    // optional int64 buySellTurnover = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_buysellturnover());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StockConnectMarketTurnover::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    StockConnectMarketTurnover::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StockConnectMarketTurnover::GetClassData() const { return &_class_data_; }


void StockConnectMarketTurnover::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<StockConnectMarketTurnover*>(&to_msg);
  auto& from = static_cast<const StockConnectMarketTurnover&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:data.StockConnectMarketTurnover)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_stockconnectmarket(from._internal_stockconnectmarket());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_tradingdirection(from._internal_tradingdirection());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.buyturnover_ = from._impl_.buyturnover_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.sellturnover_ = from._impl_.sellturnover_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.buysellturnover_ = from._impl_.buysellturnover_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StockConnectMarketTurnover::CopyFrom(const StockConnectMarketTurnover& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:data.StockConnectMarketTurnover)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StockConnectMarketTurnover::IsInitialized() const {
  return true;
}

void StockConnectMarketTurnover::InternalSwap(StockConnectMarketTurnover* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.stockconnectmarket_, lhs_arena,
      &other->_impl_.stockconnectmarket_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.tradingdirection_, lhs_arena,
      &other->_impl_.tradingdirection_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(StockConnectMarketTurnover, _impl_.buysellturnover_)
      + sizeof(StockConnectMarketTurnover::_impl_.buysellturnover_)
      - PROTOBUF_FIELD_OFFSET(StockConnectMarketTurnover, _impl_.buyturnover_)>(
          reinterpret_cast<char*>(&_impl_.buyturnover_),
          reinterpret_cast<char*>(&other->_impl_.buyturnover_));
}

::PROTOBUF_NAMESPACE_ID::Metadata StockConnectMarketTurnover::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_data_2eproto_getter, &descriptor_table_data_2eproto_once,
      file_level_metadata_data_2eproto[64]);
}

// ===================================================================

class Trade::_Internal {
 public:
  using HasBits = decltype(std::declval<Trade>()._impl_._has_bits_);
  static void set_has_securitycode(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_tradeid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_price(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_quantity(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_trdtype(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_tradetime(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

Trade::Trade(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:data.Trade)
}
Trade::Trade(const Trade& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Trade* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.securitycode_){}
    , decltype(_impl_.tradeid_){}
    , decltype(_impl_.price_){}
    , decltype(_impl_.quantity_){}
    , decltype(_impl_.tradetime_){}
    , decltype(_impl_.trdtype_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.securitycode_, &from._impl_.securitycode_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.trdtype_) -
    reinterpret_cast<char*>(&_impl_.securitycode_)) + sizeof(_impl_.trdtype_));
  // @@protoc_insertion_point(copy_constructor:data.Trade)
}

inline void Trade::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.securitycode_){int64_t{0}}
    , decltype(_impl_.tradeid_){int64_t{0}}
    , decltype(_impl_.price_){0}
    , decltype(_impl_.quantity_){int64_t{0}}
    , decltype(_impl_.tradetime_){int64_t{0}}
    , decltype(_impl_.trdtype_){0}
  };
}

Trade::~Trade() {
  // @@protoc_insertion_point(destructor:data.Trade)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Trade::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Trade::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Trade::Clear() {
// @@protoc_insertion_point(message_clear_start:data.Trade)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    ::memset(&_impl_.securitycode_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.trdtype_) -
        reinterpret_cast<char*>(&_impl_.securitycode_)) + sizeof(_impl_.trdtype_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Trade::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int64 securityCode = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_securitycode(&has_bits);
          _impl_.securitycode_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 tradeId = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_tradeid(&has_bits);
          _impl_.tradeid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional double price = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          _Internal::set_has_price(&has_bits);
          _impl_.price_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional int64 quantity = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_quantity(&has_bits);
          _impl_.quantity_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .data.TrdType trdType = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_trdtype(static_cast<::data::TrdType>(val));
        } else
          goto handle_unusual;
        continue;
      // optional int64 TradeTime = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_tradetime(&has_bits);
          _impl_.tradetime_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Trade::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:data.Trade)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional int64 securityCode = 1;
  if (_internal_has_securitycode()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_securitycode(), target);
  }

  // optional int64 tradeId = 2;
  if (_internal_has_tradeid()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(2, this->_internal_tradeid(), target);
  }

  // optional double price = 3;
  if (_internal_has_price()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(3, this->_internal_price(), target);
  }

  // optional int64 quantity = 4;
  if (_internal_has_quantity()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(4, this->_internal_quantity(), target);
  }

  // optional .data.TrdType trdType = 5;
  if (_internal_has_trdtype()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      5, this->_internal_trdtype(), target);
  }

  // optional int64 TradeTime = 6;
  if (_internal_has_tradetime()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(6, this->_internal_tradetime(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:data.Trade)
  return target;
}

size_t Trade::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:data.Trade)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional int64 securityCode = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_securitycode());
    }

    // optional int64 tradeId = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_tradeid());
    }

    // optional double price = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 8;
    }

    // optional int64 quantity = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_quantity());
    }

    // optional int64 TradeTime = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_tradetime());
    }

    // optional .data.TrdType trdType = 5;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_trdtype());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Trade::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Trade::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Trade::GetClassData() const { return &_class_data_; }


void Trade::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Trade*>(&to_msg);
  auto& from = static_cast<const Trade&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:data.Trade)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.securitycode_ = from._impl_.securitycode_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.tradeid_ = from._impl_.tradeid_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.price_ = from._impl_.price_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.quantity_ = from._impl_.quantity_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.tradetime_ = from._impl_.tradetime_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.trdtype_ = from._impl_.trdtype_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Trade::CopyFrom(const Trade& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:data.Trade)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Trade::IsInitialized() const {
  return true;
}

void Trade::InternalSwap(Trade* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Trade, _impl_.trdtype_)
      + sizeof(Trade::_impl_.trdtype_)
      - PROTOBUF_FIELD_OFFSET(Trade, _impl_.securitycode_)>(
          reinterpret_cast<char*>(&_impl_.securitycode_),
          reinterpret_cast<char*>(&other->_impl_.securitycode_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Trade::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_data_2eproto_getter, &descriptor_table_data_2eproto_once,
      file_level_metadata_data_2eproto[65]);
}

// ===================================================================

class TradeCancel::_Internal {
 public:
  using HasBits = decltype(std::declval<TradeCancel>()._impl_._has_bits_);
  static void set_has_securitycode(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_tradeid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

TradeCancel::TradeCancel(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:data.TradeCancel)
}
TradeCancel::TradeCancel(const TradeCancel& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TradeCancel* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.securitycode_){}
    , decltype(_impl_.tradeid_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.securitycode_, &from._impl_.securitycode_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.tradeid_) -
    reinterpret_cast<char*>(&_impl_.securitycode_)) + sizeof(_impl_.tradeid_));
  // @@protoc_insertion_point(copy_constructor:data.TradeCancel)
}

inline void TradeCancel::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.securitycode_){int64_t{0}}
    , decltype(_impl_.tradeid_){int64_t{0}}
  };
}

TradeCancel::~TradeCancel() {
  // @@protoc_insertion_point(destructor:data.TradeCancel)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TradeCancel::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void TradeCancel::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TradeCancel::Clear() {
// @@protoc_insertion_point(message_clear_start:data.TradeCancel)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.securitycode_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.tradeid_) -
        reinterpret_cast<char*>(&_impl_.securitycode_)) + sizeof(_impl_.tradeid_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TradeCancel::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int64 securityCode = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_securitycode(&has_bits);
          _impl_.securitycode_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 tradeId = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_tradeid(&has_bits);
          _impl_.tradeid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TradeCancel::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:data.TradeCancel)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional int64 securityCode = 1;
  if (_internal_has_securitycode()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_securitycode(), target);
  }

  // optional int64 tradeId = 2;
  if (_internal_has_tradeid()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(2, this->_internal_tradeid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:data.TradeCancel)
  return target;
}

size_t TradeCancel::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:data.TradeCancel)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional int64 securityCode = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_securitycode());
    }

    // optional int64 tradeId = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_tradeid());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TradeCancel::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TradeCancel::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TradeCancel::GetClassData() const { return &_class_data_; }


void TradeCancel::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TradeCancel*>(&to_msg);
  auto& from = static_cast<const TradeCancel&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:data.TradeCancel)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.securitycode_ = from._impl_.securitycode_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.tradeid_ = from._impl_.tradeid_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TradeCancel::CopyFrom(const TradeCancel& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:data.TradeCancel)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TradeCancel::IsInitialized() const {
  return true;
}

void TradeCancel::InternalSwap(TradeCancel* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TradeCancel, _impl_.tradeid_)
      + sizeof(TradeCancel::_impl_.tradeid_)
      - PROTOBUF_FIELD_OFFSET(TradeCancel, _impl_.securitycode_)>(
          reinterpret_cast<char*>(&_impl_.securitycode_),
          reinterpret_cast<char*>(&other->_impl_.securitycode_));
}

::PROTOBUF_NAMESPACE_ID::Metadata TradeCancel::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_data_2eproto_getter, &descriptor_table_data_2eproto_once,
      file_level_metadata_data_2eproto[66]);
}

// ===================================================================

class TradingSessionStatus::_Internal {
 public:
  using HasBits = decltype(std::declval<TradingSessionStatus>()._impl_._has_bits_);
  static void set_has_marketcode(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_tradingsessionsubid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_tradingsesstatus(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_tradingsescontrolflag(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_startdatetime(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_enddatetime(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

TradingSessionStatus::TradingSessionStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:data.TradingSessionStatus)
}
TradingSessionStatus::TradingSessionStatus(const TradingSessionStatus& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TradingSessionStatus* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.marketcode_){}
    , decltype(_impl_.tradingsessionsubid_){}
    , decltype(_impl_.tradingsesstatus_){}
    , decltype(_impl_.tradingsescontrolflag_){}
    , decltype(_impl_.startdatetime_){}
    , decltype(_impl_.enddatetime_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.marketcode_, &from._impl_.marketcode_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.enddatetime_) -
    reinterpret_cast<char*>(&_impl_.marketcode_)) + sizeof(_impl_.enddatetime_));
  // @@protoc_insertion_point(copy_constructor:data.TradingSessionStatus)
}

inline void TradingSessionStatus::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.marketcode_){0}
    , decltype(_impl_.tradingsessionsubid_){0}
    , decltype(_impl_.tradingsesstatus_){0}
    , decltype(_impl_.tradingsescontrolflag_){0}
    , decltype(_impl_.startdatetime_){int64_t{0}}
    , decltype(_impl_.enddatetime_){int64_t{0}}
  };
}

TradingSessionStatus::~TradingSessionStatus() {
  // @@protoc_insertion_point(destructor:data.TradingSessionStatus)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TradingSessionStatus::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void TradingSessionStatus::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TradingSessionStatus::Clear() {
// @@protoc_insertion_point(message_clear_start:data.TradingSessionStatus)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    ::memset(&_impl_.marketcode_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.enddatetime_) -
        reinterpret_cast<char*>(&_impl_.marketcode_)) + sizeof(_impl_.enddatetime_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TradingSessionStatus::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .data.MarketCode marketCode = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_marketcode(static_cast<::data::MarketCode>(val));
        } else
          goto handle_unusual;
        continue;
      // optional .data.TradingSessionSubID tradingSessionSubID = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_tradingsessionsubid(static_cast<::data::TradingSessionSubID>(val));
        } else
          goto handle_unusual;
        continue;
      // optional .data.TradingSesStatus tradingSesStatus = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_tradingsesstatus(static_cast<::data::TradingSesStatus>(val));
        } else
          goto handle_unusual;
        continue;
      // optional .data.TradingSesControlType TradingSesControlFlag = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_tradingsescontrolflag(static_cast<::data::TradingSesControlType>(val));
        } else
          goto handle_unusual;
        continue;
      // optional int64 startDateTime = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_startdatetime(&has_bits);
          _impl_.startdatetime_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 endDateTime = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_enddatetime(&has_bits);
          _impl_.enddatetime_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TradingSessionStatus::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:data.TradingSessionStatus)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional .data.MarketCode marketCode = 1;
  if (_internal_has_marketcode()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_marketcode(), target);
  }

  // optional .data.TradingSessionSubID tradingSessionSubID = 2;
  if (_internal_has_tradingsessionsubid()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_tradingsessionsubid(), target);
  }

  // optional .data.TradingSesStatus tradingSesStatus = 3;
  if (_internal_has_tradingsesstatus()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      3, this->_internal_tradingsesstatus(), target);
  }

  // optional .data.TradingSesControlType TradingSesControlFlag = 4;
  if (_internal_has_tradingsescontrolflag()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      4, this->_internal_tradingsescontrolflag(), target);
  }

  // optional int64 startDateTime = 5;
  if (_internal_has_startdatetime()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(5, this->_internal_startdatetime(), target);
  }

  // optional int64 endDateTime = 6;
  if (_internal_has_enddatetime()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(6, this->_internal_enddatetime(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:data.TradingSessionStatus)
  return target;
}

size_t TradingSessionStatus::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:data.TradingSessionStatus)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional .data.MarketCode marketCode = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_marketcode());
    }

    // optional .data.TradingSessionSubID tradingSessionSubID = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_tradingsessionsubid());
    }

    // optional .data.TradingSesStatus tradingSesStatus = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_tradingsesstatus());
    }

    // optional .data.TradingSesControlType TradingSesControlFlag = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_tradingsescontrolflag());
    }

    // optional int64 startDateTime = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_startdatetime());
    }

    // optional int64 endDateTime = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_enddatetime());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TradingSessionStatus::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TradingSessionStatus::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TradingSessionStatus::GetClassData() const { return &_class_data_; }


void TradingSessionStatus::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TradingSessionStatus*>(&to_msg);
  auto& from = static_cast<const TradingSessionStatus&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:data.TradingSessionStatus)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.marketcode_ = from._impl_.marketcode_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.tradingsessionsubid_ = from._impl_.tradingsessionsubid_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.tradingsesstatus_ = from._impl_.tradingsesstatus_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.tradingsescontrolflag_ = from._impl_.tradingsescontrolflag_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.startdatetime_ = from._impl_.startdatetime_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.enddatetime_ = from._impl_.enddatetime_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TradingSessionStatus::CopyFrom(const TradingSessionStatus& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:data.TradingSessionStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TradingSessionStatus::IsInitialized() const {
  return true;
}

void TradingSessionStatus::InternalSwap(TradingSessionStatus* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TradingSessionStatus, _impl_.enddatetime_)
      + sizeof(TradingSessionStatus::_impl_.enddatetime_)
      - PROTOBUF_FIELD_OFFSET(TradingSessionStatus, _impl_.marketcode_)>(
          reinterpret_cast<char*>(&_impl_.marketcode_),
          reinterpret_cast<char*>(&other->_impl_.marketcode_));
}

::PROTOBUF_NAMESPACE_ID::Metadata TradingSessionStatus::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_data_2eproto_getter, &descriptor_table_data_2eproto_once,
      file_level_metadata_data_2eproto[67]);
}

// ===================================================================

class VCMTrigger::_Internal {
 public:
  using HasBits = decltype(std::declval<VCMTrigger>()._impl_._has_bits_);
  static void set_has_securitycode(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_coolingoffstarttime(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_coolingoffendtime(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_vcmreferenceprice(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_vcmlowerprice(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_vcmupperprice(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

VCMTrigger::VCMTrigger(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:data.VCMTrigger)
}
VCMTrigger::VCMTrigger(const VCMTrigger& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  VCMTrigger* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.securitycode_){}
    , decltype(_impl_.coolingoffstarttime_){}
    , decltype(_impl_.coolingoffendtime_){}
    , decltype(_impl_.vcmreferenceprice_){}
    , decltype(_impl_.vcmlowerprice_){}
    , decltype(_impl_.vcmupperprice_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.securitycode_, &from._impl_.securitycode_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.vcmupperprice_) -
    reinterpret_cast<char*>(&_impl_.securitycode_)) + sizeof(_impl_.vcmupperprice_));
  // @@protoc_insertion_point(copy_constructor:data.VCMTrigger)
}

inline void VCMTrigger::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.securitycode_){int64_t{0}}
    , decltype(_impl_.coolingoffstarttime_){int64_t{0}}
    , decltype(_impl_.coolingoffendtime_){int64_t{0}}
    , decltype(_impl_.vcmreferenceprice_){0}
    , decltype(_impl_.vcmlowerprice_){0}
    , decltype(_impl_.vcmupperprice_){0}
  };
}

VCMTrigger::~VCMTrigger() {
  // @@protoc_insertion_point(destructor:data.VCMTrigger)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void VCMTrigger::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void VCMTrigger::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void VCMTrigger::Clear() {
// @@protoc_insertion_point(message_clear_start:data.VCMTrigger)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    ::memset(&_impl_.securitycode_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.vcmupperprice_) -
        reinterpret_cast<char*>(&_impl_.securitycode_)) + sizeof(_impl_.vcmupperprice_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* VCMTrigger::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int64 securityCode = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_securitycode(&has_bits);
          _impl_.securitycode_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 coolingOffStartTime = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_coolingoffstarttime(&has_bits);
          _impl_.coolingoffstarttime_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 coolingOffEndTime = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_coolingoffendtime(&has_bits);
          _impl_.coolingoffendtime_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional double vCMReferencePrice = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 33)) {
          _Internal::set_has_vcmreferenceprice(&has_bits);
          _impl_.vcmreferenceprice_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double vCMLowerPrice = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 41)) {
          _Internal::set_has_vcmlowerprice(&has_bits);
          _impl_.vcmlowerprice_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double vCMUpperPrice = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 49)) {
          _Internal::set_has_vcmupperprice(&has_bits);
          _impl_.vcmupperprice_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* VCMTrigger::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:data.VCMTrigger)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional int64 securityCode = 1;
  if (_internal_has_securitycode()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_securitycode(), target);
  }

  // optional int64 coolingOffStartTime = 2;
  if (_internal_has_coolingoffstarttime()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(2, this->_internal_coolingoffstarttime(), target);
  }

  // optional int64 coolingOffEndTime = 3;
  if (_internal_has_coolingoffendtime()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(3, this->_internal_coolingoffendtime(), target);
  }

  // optional double vCMReferencePrice = 4;
  if (_internal_has_vcmreferenceprice()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(4, this->_internal_vcmreferenceprice(), target);
  }

  // optional double vCMLowerPrice = 5;
  if (_internal_has_vcmlowerprice()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(5, this->_internal_vcmlowerprice(), target);
  }

  // optional double vCMUpperPrice = 6;
  if (_internal_has_vcmupperprice()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(6, this->_internal_vcmupperprice(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:data.VCMTrigger)
  return target;
}

size_t VCMTrigger::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:data.VCMTrigger)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional int64 securityCode = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_securitycode());
    }

    // optional int64 coolingOffStartTime = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_coolingoffstarttime());
    }

    // optional int64 coolingOffEndTime = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_coolingoffendtime());
    }

    // optional double vCMReferencePrice = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 8;
    }

    // optional double vCMLowerPrice = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 8;
    }

    // optional double vCMUpperPrice = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 8;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData VCMTrigger::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    VCMTrigger::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*VCMTrigger::GetClassData() const { return &_class_data_; }


void VCMTrigger::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<VCMTrigger*>(&to_msg);
  auto& from = static_cast<const VCMTrigger&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:data.VCMTrigger)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.securitycode_ = from._impl_.securitycode_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.coolingoffstarttime_ = from._impl_.coolingoffstarttime_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.coolingoffendtime_ = from._impl_.coolingoffendtime_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.vcmreferenceprice_ = from._impl_.vcmreferenceprice_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.vcmlowerprice_ = from._impl_.vcmlowerprice_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.vcmupperprice_ = from._impl_.vcmupperprice_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void VCMTrigger::CopyFrom(const VCMTrigger& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:data.VCMTrigger)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VCMTrigger::IsInitialized() const {
  return true;
}

void VCMTrigger::InternalSwap(VCMTrigger* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(VCMTrigger, _impl_.vcmupperprice_)
      + sizeof(VCMTrigger::_impl_.vcmupperprice_)
      - PROTOBUF_FIELD_OFFSET(VCMTrigger, _impl_.securitycode_)>(
          reinterpret_cast<char*>(&_impl_.securitycode_),
          reinterpret_cast<char*>(&other->_impl_.securitycode_));
}

::PROTOBUF_NAMESPACE_ID::Metadata VCMTrigger::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_data_2eproto_getter, &descriptor_table_data_2eproto_once,
      file_level_metadata_data_2eproto[68]);
}

// ===================================================================

class Yield::_Internal {
 public:
  using HasBits = decltype(std::declval<Yield>()._impl_._has_bits_);
  static void set_has_securitycode(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_yield(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

Yield::Yield(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:data.Yield)
}
Yield::Yield(const Yield& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Yield* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.securitycode_){}
    , decltype(_impl_.yield_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.securitycode_, &from._impl_.securitycode_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.yield_) -
    reinterpret_cast<char*>(&_impl_.securitycode_)) + sizeof(_impl_.yield_));
  // @@protoc_insertion_point(copy_constructor:data.Yield)
}

inline void Yield::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.securitycode_){int64_t{0}}
    , decltype(_impl_.yield_){0}
  };
}

Yield::~Yield() {
  // @@protoc_insertion_point(destructor:data.Yield)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Yield::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Yield::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Yield::Clear() {
// @@protoc_insertion_point(message_clear_start:data.Yield)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.securitycode_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.yield_) -
        reinterpret_cast<char*>(&_impl_.securitycode_)) + sizeof(_impl_.yield_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Yield::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int64 securityCode = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_securitycode(&has_bits);
          _impl_.securitycode_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 yield = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_yield(&has_bits);
          _impl_.yield_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Yield::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:data.Yield)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional int64 securityCode = 1;
  if (_internal_has_securitycode()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_securitycode(), target);
  }

  // optional int32 yield = 2;
  if (_internal_has_yield()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_yield(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:data.Yield)
  return target;
}

size_t Yield::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:data.Yield)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional int64 securityCode = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_securitycode());
    }

    // optional int32 yield = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_yield());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Yield::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Yield::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Yield::GetClassData() const { return &_class_data_; }


void Yield::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Yield*>(&to_msg);
  auto& from = static_cast<const Yield&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:data.Yield)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.securitycode_ = from._impl_.securitycode_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.yield_ = from._impl_.yield_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Yield::CopyFrom(const Yield& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:data.Yield)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Yield::IsInitialized() const {
  return true;
}

void Yield::InternalSwap(Yield* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Yield, _impl_.yield_)
      + sizeof(Yield::_impl_.yield_)
      - PROTOBUF_FIELD_OFFSET(Yield, _impl_.securitycode_)>(
          reinterpret_cast<char*>(&_impl_.securitycode_),
          reinterpret_cast<char*>(&other->_impl_.securitycode_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Yield::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_data_2eproto_getter, &descriptor_table_data_2eproto_once,
      file_level_metadata_data_2eproto[69]);
}

// ===================================================================

class CNMarketDefinition::_Internal {
 public:
  using HasBits = decltype(std::declval<CNMarketDefinition>()._impl_._has_bits_);
  static void set_has_marketcode(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_marketname(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_currencycode(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_numberofsecurities(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

CNMarketDefinition::CNMarketDefinition(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:data.CNMarketDefinition)
}
CNMarketDefinition::CNMarketDefinition(const CNMarketDefinition& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CNMarketDefinition* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.marketname_){}
    , decltype(_impl_.marketcode_){}
    , decltype(_impl_.currencycode_){}
    , decltype(_impl_.numberofsecurities_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.marketname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.marketname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_marketname()) {
    _this->_impl_.marketname_.Set(from._internal_marketname(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.marketcode_, &from._impl_.marketcode_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.numberofsecurities_) -
    reinterpret_cast<char*>(&_impl_.marketcode_)) + sizeof(_impl_.numberofsecurities_));
  // @@protoc_insertion_point(copy_constructor:data.CNMarketDefinition)
}

inline void CNMarketDefinition::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.marketname_){}
    , decltype(_impl_.marketcode_){0}
    , decltype(_impl_.currencycode_){0}
    , decltype(_impl_.numberofsecurities_){int64_t{0}}
  };
  _impl_.marketname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.marketname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CNMarketDefinition::~CNMarketDefinition() {
  // @@protoc_insertion_point(destructor:data.CNMarketDefinition)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CNMarketDefinition::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.marketname_.Destroy();
}

void CNMarketDefinition::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CNMarketDefinition::Clear() {
// @@protoc_insertion_point(message_clear_start:data.CNMarketDefinition)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.marketname_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(&_impl_.marketcode_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.numberofsecurities_) -
        reinterpret_cast<char*>(&_impl_.marketcode_)) + sizeof(_impl_.numberofsecurities_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CNMarketDefinition::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .data.CnMarketCode marketCode = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_marketcode(static_cast<::data::CnMarketCode>(val));
        } else
          goto handle_unusual;
        continue;
      // optional string marketName = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_marketname();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "data.CNMarketDefinition.marketName"));
        } else
          goto handle_unusual;
        continue;
      // optional .data.CurrencyType currencyCode = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_currencycode(static_cast<::data::CurrencyType>(val));
        } else
          goto handle_unusual;
        continue;
      // optional int64 numberOfSecurities = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_numberofsecurities(&has_bits);
          _impl_.numberofsecurities_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CNMarketDefinition::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:data.CNMarketDefinition)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional .data.CnMarketCode marketCode = 1;
  if (_internal_has_marketcode()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_marketcode(), target);
  }

  // optional string marketName = 2;
  if (_internal_has_marketname()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_marketname().data(), static_cast<int>(this->_internal_marketname().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "data.CNMarketDefinition.marketName");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_marketname(), target);
  }

  // optional .data.CurrencyType currencyCode = 3;
  if (_internal_has_currencycode()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      3, this->_internal_currencycode(), target);
  }

  // optional int64 numberOfSecurities = 4;
  if (_internal_has_numberofsecurities()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(4, this->_internal_numberofsecurities(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:data.CNMarketDefinition)
  return target;
}

size_t CNMarketDefinition::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:data.CNMarketDefinition)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string marketName = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_marketname());
    }

    // optional .data.CnMarketCode marketCode = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_marketcode());
    }

    // optional .data.CurrencyType currencyCode = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_currencycode());
    }

    // optional int64 numberOfSecurities = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_numberofsecurities());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CNMarketDefinition::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CNMarketDefinition::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CNMarketDefinition::GetClassData() const { return &_class_data_; }


void CNMarketDefinition::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CNMarketDefinition*>(&to_msg);
  auto& from = static_cast<const CNMarketDefinition&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:data.CNMarketDefinition)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_marketname(from._internal_marketname());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.marketcode_ = from._impl_.marketcode_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.currencycode_ = from._impl_.currencycode_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.numberofsecurities_ = from._impl_.numberofsecurities_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CNMarketDefinition::CopyFrom(const CNMarketDefinition& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:data.CNMarketDefinition)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CNMarketDefinition::IsInitialized() const {
  return true;
}

void CNMarketDefinition::InternalSwap(CNMarketDefinition* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.marketname_, lhs_arena,
      &other->_impl_.marketname_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CNMarketDefinition, _impl_.numberofsecurities_)
      + sizeof(CNMarketDefinition::_impl_.numberofsecurities_)
      - PROTOBUF_FIELD_OFFSET(CNMarketDefinition, _impl_.marketcode_)>(
          reinterpret_cast<char*>(&_impl_.marketcode_),
          reinterpret_cast<char*>(&other->_impl_.marketcode_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CNMarketDefinition::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_data_2eproto_getter, &descriptor_table_data_2eproto_once,
      file_level_metadata_data_2eproto[70]);
}

// ===================================================================

class CNSecurityDefinition::_Internal {
 public:
  using HasBits = decltype(std::declval<CNSecurityDefinition>()._impl_._has_bits_);
  static void set_has_securitycode(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_marketcode(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_isincode(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_instrumenttype(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_securityshortname(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_currencycode(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_securitynamegb(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_lotsize(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_previousclosingprice(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_shortsellflag(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_listingdate(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
};

CNSecurityDefinition::CNSecurityDefinition(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:data.CNSecurityDefinition)
}
CNSecurityDefinition::CNSecurityDefinition(const CNSecurityDefinition& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CNSecurityDefinition* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.isincode_){}
    , decltype(_impl_.securityshortname_){}
    , decltype(_impl_.securitynamegb_){}
    , decltype(_impl_.securitycode_){}
    , decltype(_impl_.marketcode_){}
    , decltype(_impl_.instrumenttype_){}
    , decltype(_impl_.lotsize_){}
    , decltype(_impl_.currencycode_){}
    , decltype(_impl_.shortsellflag_){}
    , decltype(_impl_.previousclosingprice_){}
    , decltype(_impl_.listingdate_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.isincode_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.isincode_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_isincode()) {
    _this->_impl_.isincode_.Set(from._internal_isincode(), 
      _this->GetArenaForAllocation());
  }
  _impl_.securityshortname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.securityshortname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_securityshortname()) {
    _this->_impl_.securityshortname_.Set(from._internal_securityshortname(), 
      _this->GetArenaForAllocation());
  }
  _impl_.securitynamegb_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.securitynamegb_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_securitynamegb()) {
    _this->_impl_.securitynamegb_.Set(from._internal_securitynamegb(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.securitycode_, &from._impl_.securitycode_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.listingdate_) -
    reinterpret_cast<char*>(&_impl_.securitycode_)) + sizeof(_impl_.listingdate_));
  // @@protoc_insertion_point(copy_constructor:data.CNSecurityDefinition)
}

inline void CNSecurityDefinition::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.isincode_){}
    , decltype(_impl_.securityshortname_){}
    , decltype(_impl_.securitynamegb_){}
    , decltype(_impl_.securitycode_){int64_t{0}}
    , decltype(_impl_.marketcode_){0}
    , decltype(_impl_.instrumenttype_){0}
    , decltype(_impl_.lotsize_){int64_t{0}}
    , decltype(_impl_.currencycode_){0}
    , decltype(_impl_.shortsellflag_){0}
    , decltype(_impl_.previousclosingprice_){0}
    , decltype(_impl_.listingdate_){int64_t{0}}
  };
  _impl_.isincode_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.isincode_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.securityshortname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.securityshortname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.securitynamegb_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.securitynamegb_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CNSecurityDefinition::~CNSecurityDefinition() {
  // @@protoc_insertion_point(destructor:data.CNSecurityDefinition)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CNSecurityDefinition::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.isincode_.Destroy();
  _impl_.securityshortname_.Destroy();
  _impl_.securitynamegb_.Destroy();
}

void CNSecurityDefinition::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CNSecurityDefinition::Clear() {
// @@protoc_insertion_point(message_clear_start:data.CNSecurityDefinition)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.isincode_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.securityshortname_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.securitynamegb_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x000000f8u) {
    ::memset(&_impl_.securitycode_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.currencycode_) -
        reinterpret_cast<char*>(&_impl_.securitycode_)) + sizeof(_impl_.currencycode_));
  }
  if (cached_has_bits & 0x00000700u) {
    ::memset(&_impl_.shortsellflag_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.listingdate_) -
        reinterpret_cast<char*>(&_impl_.shortsellflag_)) + sizeof(_impl_.listingdate_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CNSecurityDefinition::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int64 securityCode = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_securitycode(&has_bits);
          _impl_.securitycode_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .data.CnMarketCode marketCode = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_marketcode(static_cast<::data::CnMarketCode>(val));
        } else
          goto handle_unusual;
        continue;
      // optional string isinCode = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_isincode();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "data.CNSecurityDefinition.isinCode"));
        } else
          goto handle_unusual;
        continue;
      // optional .data.InstrumentType instrumentType = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_instrumenttype(static_cast<::data::InstrumentType>(val));
        } else
          goto handle_unusual;
        continue;
      // optional string securityShortName = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_securityshortname();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "data.CNSecurityDefinition.securityShortName"));
        } else
          goto handle_unusual;
        continue;
      // optional .data.CurrencyType currencyCode = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_currencycode(static_cast<::data::CurrencyType>(val));
        } else
          goto handle_unusual;
        continue;
      // optional string securityNameGB = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_securitynamegb();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "data.CNSecurityDefinition.securityNameGB"));
        } else
          goto handle_unusual;
        continue;
      // optional int64 lotSize = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_lotsize(&has_bits);
          _impl_.lotsize_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional double previousClosingPrice = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 73)) {
          _Internal::set_has_previousclosingprice(&has_bits);
          _impl_.previousclosingprice_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional .data.IndicatesWhether shortSellFlag = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_shortsellflag(static_cast<::data::IndicatesWhether>(val));
        } else
          goto handle_unusual;
        continue;
      // optional int64 listingDate = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _Internal::set_has_listingdate(&has_bits);
          _impl_.listingdate_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CNSecurityDefinition::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:data.CNSecurityDefinition)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional int64 securityCode = 1;
  if (_internal_has_securitycode()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_securitycode(), target);
  }

  // optional .data.CnMarketCode marketCode = 2;
  if (_internal_has_marketcode()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_marketcode(), target);
  }

  // optional string isinCode = 3;
  if (_internal_has_isincode()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_isincode().data(), static_cast<int>(this->_internal_isincode().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "data.CNSecurityDefinition.isinCode");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_isincode(), target);
  }

  // optional .data.InstrumentType instrumentType = 4;
  if (_internal_has_instrumenttype()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      4, this->_internal_instrumenttype(), target);
  }

  // optional string securityShortName = 5;
  if (_internal_has_securityshortname()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_securityshortname().data(), static_cast<int>(this->_internal_securityshortname().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "data.CNSecurityDefinition.securityShortName");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_securityshortname(), target);
  }

  // optional .data.CurrencyType currencyCode = 6;
  if (_internal_has_currencycode()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      6, this->_internal_currencycode(), target);
  }

  // optional string securityNameGB = 7;
  if (_internal_has_securitynamegb()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_securitynamegb().data(), static_cast<int>(this->_internal_securitynamegb().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "data.CNSecurityDefinition.securityNameGB");
    target = stream->WriteStringMaybeAliased(
        7, this->_internal_securitynamegb(), target);
  }

  // optional int64 lotSize = 8;
  if (_internal_has_lotsize()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(8, this->_internal_lotsize(), target);
  }

  // optional double previousClosingPrice = 9;
  if (_internal_has_previousclosingprice()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(9, this->_internal_previousclosingprice(), target);
  }

  // optional .data.IndicatesWhether shortSellFlag = 10;
  if (_internal_has_shortsellflag()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      10, this->_internal_shortsellflag(), target);
  }

  // optional int64 listingDate = 11;
  if (_internal_has_listingdate()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(11, this->_internal_listingdate(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:data.CNSecurityDefinition)
  return target;
}

size_t CNSecurityDefinition::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:data.CNSecurityDefinition)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string isinCode = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_isincode());
    }

    // optional string securityShortName = 5;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_securityshortname());
    }

    // optional string securityNameGB = 7;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_securitynamegb());
    }

    // optional int64 securityCode = 1;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_securitycode());
    }

    // optional .data.CnMarketCode marketCode = 2;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_marketcode());
    }

    // optional .data.InstrumentType instrumentType = 4;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_instrumenttype());
    }

    // optional int64 lotSize = 8;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_lotsize());
    }

    // optional .data.CurrencyType currencyCode = 6;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_currencycode());
    }

  }
  if (cached_has_bits & 0x00000700u) {
    // optional .data.IndicatesWhether shortSellFlag = 10;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_shortsellflag());
    }

    // optional double previousClosingPrice = 9;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 + 8;
    }

    // optional int64 listingDate = 11;
    if (cached_has_bits & 0x00000400u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_listingdate());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CNSecurityDefinition::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CNSecurityDefinition::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CNSecurityDefinition::GetClassData() const { return &_class_data_; }


void CNSecurityDefinition::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CNSecurityDefinition*>(&to_msg);
  auto& from = static_cast<const CNSecurityDefinition&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:data.CNSecurityDefinition)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_isincode(from._internal_isincode());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_securityshortname(from._internal_securityshortname());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_securitynamegb(from._internal_securitynamegb());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.securitycode_ = from._impl_.securitycode_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.marketcode_ = from._impl_.marketcode_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.instrumenttype_ = from._impl_.instrumenttype_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.lotsize_ = from._impl_.lotsize_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.currencycode_ = from._impl_.currencycode_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000700u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.shortsellflag_ = from._impl_.shortsellflag_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.previousclosingprice_ = from._impl_.previousclosingprice_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.listingdate_ = from._impl_.listingdate_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CNSecurityDefinition::CopyFrom(const CNSecurityDefinition& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:data.CNSecurityDefinition)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CNSecurityDefinition::IsInitialized() const {
  return true;
}

void CNSecurityDefinition::InternalSwap(CNSecurityDefinition* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.isincode_, lhs_arena,
      &other->_impl_.isincode_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.securityshortname_, lhs_arena,
      &other->_impl_.securityshortname_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.securitynamegb_, lhs_arena,
      &other->_impl_.securitynamegb_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CNSecurityDefinition, _impl_.listingdate_)
      + sizeof(CNSecurityDefinition::_impl_.listingdate_)
      - PROTOBUF_FIELD_OFFSET(CNSecurityDefinition, _impl_.securitycode_)>(
          reinterpret_cast<char*>(&_impl_.securitycode_),
          reinterpret_cast<char*>(&other->_impl_.securitycode_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CNSecurityDefinition::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_data_2eproto_getter, &descriptor_table_data_2eproto_once,
      file_level_metadata_data_2eproto[71]);
}

// ===================================================================

class CNSecurityStatus::_Internal {
 public:
  using HasBits = decltype(std::declval<CNSecurityStatus>()._impl_._has_bits_);
  static void set_has_securitycode(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_securitytradingstatus(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_tradingphasecode(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CNSecurityStatus::CNSecurityStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:data.CNSecurityStatus)
}
CNSecurityStatus::CNSecurityStatus(const CNSecurityStatus& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CNSecurityStatus* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.tradingphasecode_){}
    , decltype(_impl_.securitycode_){}
    , decltype(_impl_.securitytradingstatus_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.tradingphasecode_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.tradingphasecode_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_tradingphasecode()) {
    _this->_impl_.tradingphasecode_.Set(from._internal_tradingphasecode(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.securitycode_, &from._impl_.securitycode_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.securitytradingstatus_) -
    reinterpret_cast<char*>(&_impl_.securitycode_)) + sizeof(_impl_.securitytradingstatus_));
  // @@protoc_insertion_point(copy_constructor:data.CNSecurityStatus)
}

inline void CNSecurityStatus::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.tradingphasecode_){}
    , decltype(_impl_.securitycode_){int64_t{0}}
    , decltype(_impl_.securitytradingstatus_){0}
  };
  _impl_.tradingphasecode_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.tradingphasecode_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CNSecurityStatus::~CNSecurityStatus() {
  // @@protoc_insertion_point(destructor:data.CNSecurityStatus)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CNSecurityStatus::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.tradingphasecode_.Destroy();
}

void CNSecurityStatus::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CNSecurityStatus::Clear() {
// @@protoc_insertion_point(message_clear_start:data.CNSecurityStatus)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.tradingphasecode_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&_impl_.securitycode_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.securitytradingstatus_) -
        reinterpret_cast<char*>(&_impl_.securitycode_)) + sizeof(_impl_.securitytradingstatus_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CNSecurityStatus::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int64 securityCode = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_securitycode(&has_bits);
          _impl_.securitycode_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .data.SecurityTradingStatus securityTradingStatus = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_securitytradingstatus(static_cast<::data::SecurityTradingStatus>(val));
        } else
          goto handle_unusual;
        continue;
      // optional string tradingPhaseCode = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_tradingphasecode();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "data.CNSecurityStatus.tradingPhaseCode"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CNSecurityStatus::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:data.CNSecurityStatus)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional int64 securityCode = 1;
  if (_internal_has_securitycode()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_securitycode(), target);
  }

  // optional .data.SecurityTradingStatus securityTradingStatus = 2;
  if (_internal_has_securitytradingstatus()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_securitytradingstatus(), target);
  }

  // optional string tradingPhaseCode = 3;
  if (_internal_has_tradingphasecode()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_tradingphasecode().data(), static_cast<int>(this->_internal_tradingphasecode().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "data.CNSecurityStatus.tradingPhaseCode");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_tradingphasecode(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:data.CNSecurityStatus)
  return target;
}

size_t CNSecurityStatus::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:data.CNSecurityStatus)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string tradingPhaseCode = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_tradingphasecode());
    }

    // optional int64 securityCode = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_securitycode());
    }

    // optional .data.SecurityTradingStatus securityTradingStatus = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_securitytradingstatus());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CNSecurityStatus::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CNSecurityStatus::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CNSecurityStatus::GetClassData() const { return &_class_data_; }


void CNSecurityStatus::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CNSecurityStatus*>(&to_msg);
  auto& from = static_cast<const CNSecurityStatus&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:data.CNSecurityStatus)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_tradingphasecode(from._internal_tradingphasecode());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.securitycode_ = from._impl_.securitycode_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.securitytradingstatus_ = from._impl_.securitytradingstatus_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CNSecurityStatus::CopyFrom(const CNSecurityStatus& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:data.CNSecurityStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CNSecurityStatus::IsInitialized() const {
  return true;
}

void CNSecurityStatus::InternalSwap(CNSecurityStatus* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.tradingphasecode_, lhs_arena,
      &other->_impl_.tradingphasecode_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CNSecurityStatus, _impl_.securitytradingstatus_)
      + sizeof(CNSecurityStatus::_impl_.securitytradingstatus_)
      - PROTOBUF_FIELD_OFFSET(CNSecurityStatus, _impl_.securitycode_)>(
          reinterpret_cast<char*>(&_impl_.securitycode_),
          reinterpret_cast<char*>(&other->_impl_.securitycode_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CNSecurityStatus::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_data_2eproto_getter, &descriptor_table_data_2eproto_once,
      file_level_metadata_data_2eproto[72]);
}

// ===================================================================

class CNStatistics::_Internal {
 public:
  using HasBits = decltype(std::declval<CNStatistics>()._impl_._has_bits_);
  static void set_has_securitycode(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_sharestraded(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_turnover(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_highprice(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_lowprice(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_lastprice(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_openingprice(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
};

CNStatistics::CNStatistics(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:data.CNStatistics)
}
CNStatistics::CNStatistics(const CNStatistics& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CNStatistics* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.securitycode_){}
    , decltype(_impl_.sharestraded_){}
    , decltype(_impl_.turnover_){}
    , decltype(_impl_.highprice_){}
    , decltype(_impl_.lowprice_){}
    , decltype(_impl_.lastprice_){}
    , decltype(_impl_.openingprice_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.securitycode_, &from._impl_.securitycode_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.openingprice_) -
    reinterpret_cast<char*>(&_impl_.securitycode_)) + sizeof(_impl_.openingprice_));
  // @@protoc_insertion_point(copy_constructor:data.CNStatistics)
}

inline void CNStatistics::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.securitycode_){int64_t{0}}
    , decltype(_impl_.sharestraded_){int64_t{0}}
    , decltype(_impl_.turnover_){0}
    , decltype(_impl_.highprice_){0}
    , decltype(_impl_.lowprice_){0}
    , decltype(_impl_.lastprice_){0}
    , decltype(_impl_.openingprice_){0}
  };
}

CNStatistics::~CNStatistics() {
  // @@protoc_insertion_point(destructor:data.CNStatistics)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CNStatistics::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CNStatistics::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CNStatistics::Clear() {
// @@protoc_insertion_point(message_clear_start:data.CNStatistics)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    ::memset(&_impl_.securitycode_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.openingprice_) -
        reinterpret_cast<char*>(&_impl_.securitycode_)) + sizeof(_impl_.openingprice_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CNStatistics::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int64 securityCode = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_securitycode(&has_bits);
          _impl_.securitycode_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 sharesTraded = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_sharestraded(&has_bits);
          _impl_.sharestraded_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional double turnover = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          _Internal::set_has_turnover(&has_bits);
          _impl_.turnover_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double highPrice = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 33)) {
          _Internal::set_has_highprice(&has_bits);
          _impl_.highprice_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double lowPrice = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 41)) {
          _Internal::set_has_lowprice(&has_bits);
          _impl_.lowprice_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double lastPrice = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 49)) {
          _Internal::set_has_lastprice(&has_bits);
          _impl_.lastprice_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double openingPrice = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 57)) {
          _Internal::set_has_openingprice(&has_bits);
          _impl_.openingprice_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CNStatistics::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:data.CNStatistics)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional int64 securityCode = 1;
  if (_internal_has_securitycode()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_securitycode(), target);
  }

  // optional int64 sharesTraded = 2;
  if (_internal_has_sharestraded()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(2, this->_internal_sharestraded(), target);
  }

  // optional double turnover = 3;
  if (_internal_has_turnover()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(3, this->_internal_turnover(), target);
  }

  // optional double highPrice = 4;
  if (_internal_has_highprice()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(4, this->_internal_highprice(), target);
  }

  // optional double lowPrice = 5;
  if (_internal_has_lowprice()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(5, this->_internal_lowprice(), target);
  }

  // optional double lastPrice = 6;
  if (_internal_has_lastprice()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(6, this->_internal_lastprice(), target);
  }

  // optional double openingPrice = 7;
  if (_internal_has_openingprice()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(7, this->_internal_openingprice(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:data.CNStatistics)
  return target;
}

size_t CNStatistics::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:data.CNStatistics)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    // optional int64 securityCode = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_securitycode());
    }

    // optional int64 sharesTraded = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_sharestraded());
    }

    // optional double turnover = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 8;
    }

    // optional double highPrice = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 8;
    }

    // optional double lowPrice = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 8;
    }

    // optional double lastPrice = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 8;
    }

    // optional double openingPrice = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 8;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CNStatistics::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CNStatistics::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CNStatistics::GetClassData() const { return &_class_data_; }


void CNStatistics::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CNStatistics*>(&to_msg);
  auto& from = static_cast<const CNStatistics&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:data.CNStatistics)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.securitycode_ = from._impl_.securitycode_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.sharestraded_ = from._impl_.sharestraded_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.turnover_ = from._impl_.turnover_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.highprice_ = from._impl_.highprice_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.lowprice_ = from._impl_.lowprice_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.lastprice_ = from._impl_.lastprice_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.openingprice_ = from._impl_.openingprice_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CNStatistics::CopyFrom(const CNStatistics& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:data.CNStatistics)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CNStatistics::IsInitialized() const {
  return true;
}

void CNStatistics::InternalSwap(CNStatistics* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CNStatistics, _impl_.openingprice_)
      + sizeof(CNStatistics::_impl_.openingprice_)
      - PROTOBUF_FIELD_OFFSET(CNStatistics, _impl_.securitycode_)>(
          reinterpret_cast<char*>(&_impl_.securitycode_),
          reinterpret_cast<char*>(&other->_impl_.securitycode_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CNStatistics::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_data_2eproto_getter, &descriptor_table_data_2eproto_once,
      file_level_metadata_data_2eproto[73]);
}

// ===================================================================

class CNTopBook::_Internal {
 public:
  using HasBits = decltype(std::declval<CNTopBook>()._impl_._has_bits_);
  static void set_has_securitycode(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_aggregatebidquantity(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_aggregateaskquantity(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_bidprice(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_askprice(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

CNTopBook::CNTopBook(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:data.CNTopBook)
}
CNTopBook::CNTopBook(const CNTopBook& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CNTopBook* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.securitycode_){}
    , decltype(_impl_.aggregatebidquantity_){}
    , decltype(_impl_.aggregateaskquantity_){}
    , decltype(_impl_.bidprice_){}
    , decltype(_impl_.askprice_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.securitycode_, &from._impl_.securitycode_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.askprice_) -
    reinterpret_cast<char*>(&_impl_.securitycode_)) + sizeof(_impl_.askprice_));
  // @@protoc_insertion_point(copy_constructor:data.CNTopBook)
}

inline void CNTopBook::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.securitycode_){int64_t{0}}
    , decltype(_impl_.aggregatebidquantity_){int64_t{0}}
    , decltype(_impl_.aggregateaskquantity_){int64_t{0}}
    , decltype(_impl_.bidprice_){0}
    , decltype(_impl_.askprice_){0}
  };
}

CNTopBook::~CNTopBook() {
  // @@protoc_insertion_point(destructor:data.CNTopBook)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CNTopBook::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CNTopBook::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CNTopBook::Clear() {
// @@protoc_insertion_point(message_clear_start:data.CNTopBook)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&_impl_.securitycode_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.askprice_) -
        reinterpret_cast<char*>(&_impl_.securitycode_)) + sizeof(_impl_.askprice_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CNTopBook::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int64 securityCode = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_securitycode(&has_bits);
          _impl_.securitycode_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 aggregateBidQuantity = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_aggregatebidquantity(&has_bits);
          _impl_.aggregatebidquantity_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 aggregateAskQuantity = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_aggregateaskquantity(&has_bits);
          _impl_.aggregateaskquantity_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional double bidPrice = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 33)) {
          _Internal::set_has_bidprice(&has_bits);
          _impl_.bidprice_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double askPrice = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 41)) {
          _Internal::set_has_askprice(&has_bits);
          _impl_.askprice_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CNTopBook::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:data.CNTopBook)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional int64 securityCode = 1;
  if (_internal_has_securitycode()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_securitycode(), target);
  }

  // optional int64 aggregateBidQuantity = 2;
  if (_internal_has_aggregatebidquantity()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(2, this->_internal_aggregatebidquantity(), target);
  }

  // optional int64 aggregateAskQuantity = 3;
  if (_internal_has_aggregateaskquantity()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(3, this->_internal_aggregateaskquantity(), target);
  }

  // optional double bidPrice = 4;
  if (_internal_has_bidprice()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(4, this->_internal_bidprice(), target);
  }

  // optional double askPrice = 5;
  if (_internal_has_askprice()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(5, this->_internal_askprice(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:data.CNTopBook)
  return target;
}

size_t CNTopBook::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:data.CNTopBook)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional int64 securityCode = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_securitycode());
    }

    // optional int64 aggregateBidQuantity = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_aggregatebidquantity());
    }

    // optional int64 aggregateAskQuantity = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_aggregateaskquantity());
    }

    // optional double bidPrice = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 8;
    }

    // optional double askPrice = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 8;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CNTopBook::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CNTopBook::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CNTopBook::GetClassData() const { return &_class_data_; }


void CNTopBook::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CNTopBook*>(&to_msg);
  auto& from = static_cast<const CNTopBook&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:data.CNTopBook)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.securitycode_ = from._impl_.securitycode_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.aggregatebidquantity_ = from._impl_.aggregatebidquantity_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.aggregateaskquantity_ = from._impl_.aggregateaskquantity_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.bidprice_ = from._impl_.bidprice_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.askprice_ = from._impl_.askprice_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CNTopBook::CopyFrom(const CNTopBook& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:data.CNTopBook)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CNTopBook::IsInitialized() const {
  return true;
}

void CNTopBook::InternalSwap(CNTopBook* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CNTopBook, _impl_.askprice_)
      + sizeof(CNTopBook::_impl_.askprice_)
      - PROTOBUF_FIELD_OFFSET(CNTopBook, _impl_.securitycode_)>(
          reinterpret_cast<char*>(&_impl_.securitycode_),
          reinterpret_cast<char*>(&other->_impl_.securitycode_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CNTopBook::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_data_2eproto_getter, &descriptor_table_data_2eproto_once,
      file_level_metadata_data_2eproto[74]);
}

// ===================================================================

class CertificationMsg::_Internal {
 public:
  using HasBits = decltype(std::declval<CertificationMsg>()._impl_._has_bits_);
  static void set_has_actiontype(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_auth(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::data::Resp& response(const CertificationMsg* msg);
  static void set_has_response(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::data::Resp&
CertificationMsg::_Internal::response(const CertificationMsg* msg) {
  return *msg->_impl_.response_;
}
CertificationMsg::CertificationMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:data.CertificationMsg)
}
CertificationMsg::CertificationMsg(const CertificationMsg& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CertificationMsg* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.auth_){}
    , decltype(_impl_.response_){nullptr}
    , decltype(_impl_.actiontype_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.auth_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.auth_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_auth()) {
    _this->_impl_.auth_.Set(from._internal_auth(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_response()) {
    _this->_impl_.response_ = new ::data::Resp(*from._impl_.response_);
  }
  _this->_impl_.actiontype_ = from._impl_.actiontype_;
  // @@protoc_insertion_point(copy_constructor:data.CertificationMsg)
}

inline void CertificationMsg::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.auth_){}
    , decltype(_impl_.response_){nullptr}
    , decltype(_impl_.actiontype_){0}
  };
  _impl_.auth_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.auth_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CertificationMsg::~CertificationMsg() {
  // @@protoc_insertion_point(destructor:data.CertificationMsg)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CertificationMsg::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.auth_.Destroy();
  if (this != internal_default_instance()) delete _impl_.response_;
}

void CertificationMsg::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CertificationMsg::Clear() {
// @@protoc_insertion_point(message_clear_start:data.CertificationMsg)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.auth_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.response_ != nullptr);
      _impl_.response_->Clear();
    }
  }
  _impl_.actiontype_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CertificationMsg::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .data.ActionType actionType = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_actiontype(static_cast<::data::ActionType>(val));
        } else
          goto handle_unusual;
        continue;
      // optional string auth = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_auth();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "data.CertificationMsg.auth"));
        } else
          goto handle_unusual;
        continue;
      // optional .data.Resp response = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_response(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CertificationMsg::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:data.CertificationMsg)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional .data.ActionType actionType = 1;
  if (_internal_has_actiontype()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_actiontype(), target);
  }

  // optional string auth = 2;
  if (_internal_has_auth()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_auth().data(), static_cast<int>(this->_internal_auth().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "data.CertificationMsg.auth");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_auth(), target);
  }

  // optional .data.Resp response = 3;
  if (_internal_has_response()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::response(this),
        _Internal::response(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:data.CertificationMsg)
  return target;
}

size_t CertificationMsg::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:data.CertificationMsg)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string auth = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_auth());
    }

    // optional .data.Resp response = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.response_);
    }

    // optional .data.ActionType actionType = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_actiontype());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CertificationMsg::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CertificationMsg::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CertificationMsg::GetClassData() const { return &_class_data_; }


void CertificationMsg::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CertificationMsg*>(&to_msg);
  auto& from = static_cast<const CertificationMsg&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:data.CertificationMsg)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_auth(from._internal_auth());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_response()->::data::Resp::MergeFrom(
          from._internal_response());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.actiontype_ = from._impl_.actiontype_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CertificationMsg::CopyFrom(const CertificationMsg& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:data.CertificationMsg)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CertificationMsg::IsInitialized() const {
  return true;
}

void CertificationMsg::InternalSwap(CertificationMsg* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.auth_, lhs_arena,
      &other->_impl_.auth_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CertificationMsg, _impl_.actiontype_)
      + sizeof(CertificationMsg::_impl_.actiontype_)
      - PROTOBUF_FIELD_OFFSET(CertificationMsg, _impl_.response_)>(
          reinterpret_cast<char*>(&_impl_.response_),
          reinterpret_cast<char*>(&other->_impl_.response_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CertificationMsg::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_data_2eproto_getter, &descriptor_table_data_2eproto_once,
      file_level_metadata_data_2eproto[75]);
}

// ===================================================================

class Resp::_Internal {
 public:
  using HasBits = decltype(std::declval<Resp>()._impl_._has_bits_);
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_errormsg(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

Resp::Resp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:data.Resp)
}
Resp::Resp(const Resp& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Resp* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.errormsg_){}
    , decltype(_impl_.type_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.errormsg_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.errormsg_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_errormsg()) {
    _this->_impl_.errormsg_.Set(from._internal_errormsg(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.type_ = from._impl_.type_;
  // @@protoc_insertion_point(copy_constructor:data.Resp)
}

inline void Resp::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.errormsg_){}
    , decltype(_impl_.type_){0}
  };
  _impl_.errormsg_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.errormsg_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Resp::~Resp() {
  // @@protoc_insertion_point(destructor:data.Resp)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Resp::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.errormsg_.Destroy();
}

void Resp::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Resp::Clear() {
// @@protoc_insertion_point(message_clear_start:data.Resp)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.errormsg_.ClearNonDefaultToEmpty();
  }
  _impl_.type_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Resp::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .data.ResponseType type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_type(static_cast<::data::ResponseType>(val));
        } else
          goto handle_unusual;
        continue;
      // optional string errorMsg = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_errormsg();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "data.Resp.errorMsg"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Resp::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:data.Resp)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional .data.ResponseType type = 1;
  if (_internal_has_type()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_type(), target);
  }

  // optional string errorMsg = 2;
  if (_internal_has_errormsg()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_errormsg().data(), static_cast<int>(this->_internal_errormsg().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "data.Resp.errorMsg");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_errormsg(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:data.Resp)
  return target;
}

size_t Resp::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:data.Resp)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string errorMsg = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_errormsg());
    }

    // optional .data.ResponseType type = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Resp::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Resp::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Resp::GetClassData() const { return &_class_data_; }


void Resp::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Resp*>(&to_msg);
  auto& from = static_cast<const Resp&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:data.Resp)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_errormsg(from._internal_errormsg());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.type_ = from._impl_.type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Resp::CopyFrom(const Resp& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:data.Resp)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Resp::IsInitialized() const {
  return true;
}

void Resp::InternalSwap(Resp* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.errormsg_, lhs_arena,
      &other->_impl_.errormsg_, rhs_arena
  );
  swap(_impl_.type_, other->_impl_.type_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Resp::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_data_2eproto_getter, &descriptor_table_data_2eproto_once,
      file_level_metadata_data_2eproto[76]);
}

// ===================================================================

class Message::_Internal {
 public:
  using HasBits = decltype(std::declval<Message>()._impl_._has_bits_);
  static void set_has_data_type(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::data::AddOddLotOrder& addoddlotorder(const Message* msg);
  static const ::data::AggregateOrderBookUpdate& aggregateorderbookupdate(const Message* msg);
  static const ::data::BrokerQueue& brokerqueue(const Message* msg);
  static const ::data::ClosingPrice& closingprice(const Message* msg);
  static const ::data::CurrencyRate& currencyrate(const Message* msg);
  static const ::data::DeleteOddLotOrder& deleteoddlotorder(const Message* msg);
  static const ::data::IndexData& indexdata(const Message* msg);
  static const ::data::IndexDefinition& indexdefinition(const Message* msg);
  static const ::data::IndicativeEquilibriumPrice& indicativeequilibriumprice(const Message* msg);
  static const ::data::LiquidityProvider& liquidityprovider(const Message* msg);
  static const ::data::MarketDefinition& marketdefinition(const Message* msg);
  static const ::data::MarketTurnover& marketturnover(const Message* msg);
  static const ::data::News& news(const Message* msg);
  static const ::data::NominalPrice& nominalprice(const Message* msg);
  static const ::data::OrderImbalance& orderimbalance(const Message* msg);
  static const ::data::ReferencePrice& referenceprice(const Message* msg);
  static const ::data::SecurityDefinition& securitydefinition(const Message* msg);
  static const ::data::SecurityStatus& securitystatus(const Message* msg);
  static const ::data::Statistics& statistics(const Message* msg);
  static const ::data::StockConnectDailyQuotaBalance& stockconnectdailyquotabalance(const Message* msg);
  static const ::data::StockConnectMarketTurnover& stockconnectmarketturnover(const Message* msg);
  static const ::data::Trade& trade(const Message* msg);
  static const ::data::TradeCancel& tradecancel(const Message* msg);
  static const ::data::TradingSessionStatus& tradingsessionstatus(const Message* msg);
  static const ::data::VCMTrigger& vcmtrigger(const Message* msg);
  static const ::data::Yield& yield(const Message* msg);
  static const ::data::AdjustedClosingPrice& adjustedclosingprice(const Message* msg);
  static const ::data::DayTradeSummary& daytradesummary(const Message* msg);
  static const ::data::DayTradeSummaryNextShares& daytradesummarynextshares(const Message* msg);
  static const ::data::IPOInformation& ipoinformation(const Message* msg);
  static const ::data::IPOQuotingPeriodUpdate& ipoquotingperiodupdate(const Message* msg);
  static const ::data::LongAdjustedClosingPrice& longadjustedclosingprice(const Message* msg);
  static const ::data::LongDayTradeSummary& longdaytradesummary(const Message* msg);
  static const ::data::LongTradeCancelForNonNextSharesTrades& longtradecancelfornonnextsharestrades(const Message* msg);
  static const ::data::LongTradeCorrectionForNonNextsharesTrades& longtradecorrectionfornonnextsharestrades(const Message* msg);
  static const ::data::LongTradeReportForNonNextshares& longtradereportfornonnextshares(const Message* msg);
  static const ::data::MWCBStatusMessage& mwcbstatusmessage(const Message* msg);
  static const ::data::MarketWideCircuitBreaker& marketwidecircuitbreaker(const Message* msg);
  static const ::data::OperationalHalt& operationalhalt(const Message* msg);
  static const ::data::SaleConditionModifier& saleconditionmodifier(const Message* msg);
  static const ::data::ShortSaleRestrictionIndicatorMessage& shortsalerestrictionindicatormessage(const Message* msg);
  static const ::data::StockDirectory& stockdirectory(const Message* msg);
  static const ::data::StockTradingAction& stocktradingaction(const Message* msg);
  static const ::data::SystemEventMessage& systemeventmessage(const Message* msg);
  static const ::data::TradeCancelForNextsharesTrades& tradecancelfornextsharestrades(const Message* msg);
  static const ::data::TradeCancelForNonNextSharesTrades& tradecancelfornonnextsharestrades(const Message* msg);
  static const ::data::TradeCorrectionForNextsharesTrades& tradecorrectionfornextsharestrades(const Message* msg);
  static const ::data::TradeCorrectionForNonNextsharesTrades& tradecorrectionfornonnextsharestrades(const Message* msg);
  static const ::data::TradeReportForNextshares& tradereportfornextshares(const Message* msg);
  static const ::data::TradeReportForNonNextshares& tradereportfornonnextshares(const Message* msg);
  static const ::data::QBBOMWCBBreachMessage& qbbomwcbbreachmessage(const Message* msg);
  static const ::data::QBBOMWCBDeclineLevelMessage& qbbomwcbdeclinelevelmessage(const Message* msg);
  static const ::data::QBBONextSharesQuotationMessage& qbbonextsharesquotationmessage(const Message* msg);
  static const ::data::QBBOOperationalHalt& qbbooperationalhalt(const Message* msg);
  static const ::data::QBBOQuotationMessage& qbboquotationmessage(const Message* msg);
  static const ::data::QBBORegShoRestriction& qbboregshorestriction(const Message* msg);
  static const ::data::QBBOStockDirectory& qbbostockdirectory(const Message* msg);
  static const ::data::QBBOStockTradingAction& qbbostocktradingaction(const Message* msg);
  static const ::data::QBBOSystemEventMessage& qbbosystemeventmessage(const Message* msg);
  static const ::data::QBBOIPOQuotingPeriodUpdate& qbboipoquotingperiodupdate(const Message* msg);
  static const ::data::CertificationMsg& certificationmsg(const Message* msg);
  static const ::data::CNMarketDefinition& cnmarketdefinition(const Message* msg);
  static const ::data::CNSecurityDefinition& cnsecuritydefinition(const Message* msg);
  static const ::data::CNSecurityStatus& cnsecuritystatus(const Message* msg);
  static const ::data::CNStatistics& cnstatistics(const Message* msg);
  static const ::data::CNTopBook& cntopbook(const Message* msg);
  static void set_has_timestamp(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::data::AddOddLotOrder&
Message::_Internal::addoddlotorder(const Message* msg) {
  return *msg->_impl_.dataBody_.addoddlotorder_;
}
const ::data::AggregateOrderBookUpdate&
Message::_Internal::aggregateorderbookupdate(const Message* msg) {
  return *msg->_impl_.dataBody_.aggregateorderbookupdate_;
}
const ::data::BrokerQueue&
Message::_Internal::brokerqueue(const Message* msg) {
  return *msg->_impl_.dataBody_.brokerqueue_;
}
const ::data::ClosingPrice&
Message::_Internal::closingprice(const Message* msg) {
  return *msg->_impl_.dataBody_.closingprice_;
}
const ::data::CurrencyRate&
Message::_Internal::currencyrate(const Message* msg) {
  return *msg->_impl_.dataBody_.currencyrate_;
}
const ::data::DeleteOddLotOrder&
Message::_Internal::deleteoddlotorder(const Message* msg) {
  return *msg->_impl_.dataBody_.deleteoddlotorder_;
}
const ::data::IndexData&
Message::_Internal::indexdata(const Message* msg) {
  return *msg->_impl_.dataBody_.indexdata_;
}
const ::data::IndexDefinition&
Message::_Internal::indexdefinition(const Message* msg) {
  return *msg->_impl_.dataBody_.indexdefinition_;
}
const ::data::IndicativeEquilibriumPrice&
Message::_Internal::indicativeequilibriumprice(const Message* msg) {
  return *msg->_impl_.dataBody_.indicativeequilibriumprice_;
}
const ::data::LiquidityProvider&
Message::_Internal::liquidityprovider(const Message* msg) {
  return *msg->_impl_.dataBody_.liquidityprovider_;
}
const ::data::MarketDefinition&
Message::_Internal::marketdefinition(const Message* msg) {
  return *msg->_impl_.dataBody_.marketdefinition_;
}
const ::data::MarketTurnover&
Message::_Internal::marketturnover(const Message* msg) {
  return *msg->_impl_.dataBody_.marketturnover_;
}
const ::data::News&
Message::_Internal::news(const Message* msg) {
  return *msg->_impl_.dataBody_.news_;
}
const ::data::NominalPrice&
Message::_Internal::nominalprice(const Message* msg) {
  return *msg->_impl_.dataBody_.nominalprice_;
}
const ::data::OrderImbalance&
Message::_Internal::orderimbalance(const Message* msg) {
  return *msg->_impl_.dataBody_.orderimbalance_;
}
const ::data::ReferencePrice&
Message::_Internal::referenceprice(const Message* msg) {
  return *msg->_impl_.dataBody_.referenceprice_;
}
const ::data::SecurityDefinition&
Message::_Internal::securitydefinition(const Message* msg) {
  return *msg->_impl_.dataBody_.securitydefinition_;
}
const ::data::SecurityStatus&
Message::_Internal::securitystatus(const Message* msg) {
  return *msg->_impl_.dataBody_.securitystatus_;
}
const ::data::Statistics&
Message::_Internal::statistics(const Message* msg) {
  return *msg->_impl_.dataBody_.statistics_;
}
const ::data::StockConnectDailyQuotaBalance&
Message::_Internal::stockconnectdailyquotabalance(const Message* msg) {
  return *msg->_impl_.dataBody_.stockconnectdailyquotabalance_;
}
const ::data::StockConnectMarketTurnover&
Message::_Internal::stockconnectmarketturnover(const Message* msg) {
  return *msg->_impl_.dataBody_.stockconnectmarketturnover_;
}
const ::data::Trade&
Message::_Internal::trade(const Message* msg) {
  return *msg->_impl_.dataBody_.trade_;
}
const ::data::TradeCancel&
Message::_Internal::tradecancel(const Message* msg) {
  return *msg->_impl_.dataBody_.tradecancel_;
}
const ::data::TradingSessionStatus&
Message::_Internal::tradingsessionstatus(const Message* msg) {
  return *msg->_impl_.dataBody_.tradingsessionstatus_;
}
const ::data::VCMTrigger&
Message::_Internal::vcmtrigger(const Message* msg) {
  return *msg->_impl_.dataBody_.vcmtrigger_;
}
const ::data::Yield&
Message::_Internal::yield(const Message* msg) {
  return *msg->_impl_.dataBody_.yield_;
}
const ::data::AdjustedClosingPrice&
Message::_Internal::adjustedclosingprice(const Message* msg) {
  return *msg->_impl_.dataBody_.adjustedclosingprice_;
}
const ::data::DayTradeSummary&
Message::_Internal::daytradesummary(const Message* msg) {
  return *msg->_impl_.dataBody_.daytradesummary_;
}
const ::data::DayTradeSummaryNextShares&
Message::_Internal::daytradesummarynextshares(const Message* msg) {
  return *msg->_impl_.dataBody_.daytradesummarynextshares_;
}
const ::data::IPOInformation&
Message::_Internal::ipoinformation(const Message* msg) {
  return *msg->_impl_.dataBody_.ipoinformation_;
}
const ::data::IPOQuotingPeriodUpdate&
Message::_Internal::ipoquotingperiodupdate(const Message* msg) {
  return *msg->_impl_.dataBody_.ipoquotingperiodupdate_;
}
const ::data::LongAdjustedClosingPrice&
Message::_Internal::longadjustedclosingprice(const Message* msg) {
  return *msg->_impl_.dataBody_.longadjustedclosingprice_;
}
const ::data::LongDayTradeSummary&
Message::_Internal::longdaytradesummary(const Message* msg) {
  return *msg->_impl_.dataBody_.longdaytradesummary_;
}
const ::data::LongTradeCancelForNonNextSharesTrades&
Message::_Internal::longtradecancelfornonnextsharestrades(const Message* msg) {
  return *msg->_impl_.dataBody_.longtradecancelfornonnextsharestrades_;
}
const ::data::LongTradeCorrectionForNonNextsharesTrades&
Message::_Internal::longtradecorrectionfornonnextsharestrades(const Message* msg) {
  return *msg->_impl_.dataBody_.longtradecorrectionfornonnextsharestrades_;
}
const ::data::LongTradeReportForNonNextshares&
Message::_Internal::longtradereportfornonnextshares(const Message* msg) {
  return *msg->_impl_.dataBody_.longtradereportfornonnextshares_;
}
const ::data::MWCBStatusMessage&
Message::_Internal::mwcbstatusmessage(const Message* msg) {
  return *msg->_impl_.dataBody_.mwcbstatusmessage_;
}
const ::data::MarketWideCircuitBreaker&
Message::_Internal::marketwidecircuitbreaker(const Message* msg) {
  return *msg->_impl_.dataBody_.marketwidecircuitbreaker_;
}
const ::data::OperationalHalt&
Message::_Internal::operationalhalt(const Message* msg) {
  return *msg->_impl_.dataBody_.operationalhalt_;
}
const ::data::SaleConditionModifier&
Message::_Internal::saleconditionmodifier(const Message* msg) {
  return *msg->_impl_.dataBody_.saleconditionmodifier_;
}
const ::data::ShortSaleRestrictionIndicatorMessage&
Message::_Internal::shortsalerestrictionindicatormessage(const Message* msg) {
  return *msg->_impl_.dataBody_.shortsalerestrictionindicatormessage_;
}
const ::data::StockDirectory&
Message::_Internal::stockdirectory(const Message* msg) {
  return *msg->_impl_.dataBody_.stockdirectory_;
}
const ::data::StockTradingAction&
Message::_Internal::stocktradingaction(const Message* msg) {
  return *msg->_impl_.dataBody_.stocktradingaction_;
}
const ::data::SystemEventMessage&
Message::_Internal::systemeventmessage(const Message* msg) {
  return *msg->_impl_.dataBody_.systemeventmessage_;
}
const ::data::TradeCancelForNextsharesTrades&
Message::_Internal::tradecancelfornextsharestrades(const Message* msg) {
  return *msg->_impl_.dataBody_.tradecancelfornextsharestrades_;
}
const ::data::TradeCancelForNonNextSharesTrades&
Message::_Internal::tradecancelfornonnextsharestrades(const Message* msg) {
  return *msg->_impl_.dataBody_.tradecancelfornonnextsharestrades_;
}
const ::data::TradeCorrectionForNextsharesTrades&
Message::_Internal::tradecorrectionfornextsharestrades(const Message* msg) {
  return *msg->_impl_.dataBody_.tradecorrectionfornextsharestrades_;
}
const ::data::TradeCorrectionForNonNextsharesTrades&
Message::_Internal::tradecorrectionfornonnextsharestrades(const Message* msg) {
  return *msg->_impl_.dataBody_.tradecorrectionfornonnextsharestrades_;
}
const ::data::TradeReportForNextshares&
Message::_Internal::tradereportfornextshares(const Message* msg) {
  return *msg->_impl_.dataBody_.tradereportfornextshares_;
}
const ::data::TradeReportForNonNextshares&
Message::_Internal::tradereportfornonnextshares(const Message* msg) {
  return *msg->_impl_.dataBody_.tradereportfornonnextshares_;
}
const ::data::QBBOMWCBBreachMessage&
Message::_Internal::qbbomwcbbreachmessage(const Message* msg) {
  return *msg->_impl_.dataBody_.qbbomwcbbreachmessage_;
}
const ::data::QBBOMWCBDeclineLevelMessage&
Message::_Internal::qbbomwcbdeclinelevelmessage(const Message* msg) {
  return *msg->_impl_.dataBody_.qbbomwcbdeclinelevelmessage_;
}
const ::data::QBBONextSharesQuotationMessage&
Message::_Internal::qbbonextsharesquotationmessage(const Message* msg) {
  return *msg->_impl_.dataBody_.qbbonextsharesquotationmessage_;
}
const ::data::QBBOOperationalHalt&
Message::_Internal::qbbooperationalhalt(const Message* msg) {
  return *msg->_impl_.dataBody_.qbbooperationalhalt_;
}
const ::data::QBBOQuotationMessage&
Message::_Internal::qbboquotationmessage(const Message* msg) {
  return *msg->_impl_.dataBody_.qbboquotationmessage_;
}
const ::data::QBBORegShoRestriction&
Message::_Internal::qbboregshorestriction(const Message* msg) {
  return *msg->_impl_.dataBody_.qbboregshorestriction_;
}
const ::data::QBBOStockDirectory&
Message::_Internal::qbbostockdirectory(const Message* msg) {
  return *msg->_impl_.dataBody_.qbbostockdirectory_;
}
const ::data::QBBOStockTradingAction&
Message::_Internal::qbbostocktradingaction(const Message* msg) {
  return *msg->_impl_.dataBody_.qbbostocktradingaction_;
}
const ::data::QBBOSystemEventMessage&
Message::_Internal::qbbosystemeventmessage(const Message* msg) {
  return *msg->_impl_.dataBody_.qbbosystemeventmessage_;
}
const ::data::QBBOIPOQuotingPeriodUpdate&
Message::_Internal::qbboipoquotingperiodupdate(const Message* msg) {
  return *msg->_impl_.dataBody_.qbboipoquotingperiodupdate_;
}
const ::data::CertificationMsg&
Message::_Internal::certificationmsg(const Message* msg) {
  return *msg->_impl_.dataBody_.certificationmsg_;
}
const ::data::CNMarketDefinition&
Message::_Internal::cnmarketdefinition(const Message* msg) {
  return *msg->_impl_.dataBody_.cnmarketdefinition_;
}
const ::data::CNSecurityDefinition&
Message::_Internal::cnsecuritydefinition(const Message* msg) {
  return *msg->_impl_.dataBody_.cnsecuritydefinition_;
}
const ::data::CNSecurityStatus&
Message::_Internal::cnsecuritystatus(const Message* msg) {
  return *msg->_impl_.dataBody_.cnsecuritystatus_;
}
const ::data::CNStatistics&
Message::_Internal::cnstatistics(const Message* msg) {
  return *msg->_impl_.dataBody_.cnstatistics_;
}
const ::data::CNTopBook&
Message::_Internal::cntopbook(const Message* msg) {
  return *msg->_impl_.dataBody_.cntopbook_;
}
void Message::set_allocated_addoddlotorder(::data::AddOddLotOrder* addoddlotorder) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_dataBody();
  if (addoddlotorder) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(addoddlotorder);
    if (message_arena != submessage_arena) {
      addoddlotorder = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, addoddlotorder, submessage_arena);
    }
    set_has_addoddlotorder();
    _impl_.dataBody_.addoddlotorder_ = addoddlotorder;
  }
  // @@protoc_insertion_point(field_set_allocated:data.Message.addOddLotOrder)
}
void Message::set_allocated_aggregateorderbookupdate(::data::AggregateOrderBookUpdate* aggregateorderbookupdate) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_dataBody();
  if (aggregateorderbookupdate) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(aggregateorderbookupdate);
    if (message_arena != submessage_arena) {
      aggregateorderbookupdate = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, aggregateorderbookupdate, submessage_arena);
    }
    set_has_aggregateorderbookupdate();
    _impl_.dataBody_.aggregateorderbookupdate_ = aggregateorderbookupdate;
  }
  // @@protoc_insertion_point(field_set_allocated:data.Message.aggregateOrderBookUpdate)
}
void Message::set_allocated_brokerqueue(::data::BrokerQueue* brokerqueue) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_dataBody();
  if (brokerqueue) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(brokerqueue);
    if (message_arena != submessage_arena) {
      brokerqueue = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, brokerqueue, submessage_arena);
    }
    set_has_brokerqueue();
    _impl_.dataBody_.brokerqueue_ = brokerqueue;
  }
  // @@protoc_insertion_point(field_set_allocated:data.Message.brokerQueue)
}
void Message::set_allocated_closingprice(::data::ClosingPrice* closingprice) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_dataBody();
  if (closingprice) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(closingprice);
    if (message_arena != submessage_arena) {
      closingprice = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, closingprice, submessage_arena);
    }
    set_has_closingprice();
    _impl_.dataBody_.closingprice_ = closingprice;
  }
  // @@protoc_insertion_point(field_set_allocated:data.Message.closingPrice)
}
void Message::set_allocated_currencyrate(::data::CurrencyRate* currencyrate) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_dataBody();
  if (currencyrate) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(currencyrate);
    if (message_arena != submessage_arena) {
      currencyrate = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, currencyrate, submessage_arena);
    }
    set_has_currencyrate();
    _impl_.dataBody_.currencyrate_ = currencyrate;
  }
  // @@protoc_insertion_point(field_set_allocated:data.Message.currencyRate)
}
void Message::set_allocated_deleteoddlotorder(::data::DeleteOddLotOrder* deleteoddlotorder) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_dataBody();
  if (deleteoddlotorder) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(deleteoddlotorder);
    if (message_arena != submessage_arena) {
      deleteoddlotorder = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, deleteoddlotorder, submessage_arena);
    }
    set_has_deleteoddlotorder();
    _impl_.dataBody_.deleteoddlotorder_ = deleteoddlotorder;
  }
  // @@protoc_insertion_point(field_set_allocated:data.Message.deleteOddLotOrder)
}
void Message::set_allocated_indexdata(::data::IndexData* indexdata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_dataBody();
  if (indexdata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(indexdata);
    if (message_arena != submessage_arena) {
      indexdata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, indexdata, submessage_arena);
    }
    set_has_indexdata();
    _impl_.dataBody_.indexdata_ = indexdata;
  }
  // @@protoc_insertion_point(field_set_allocated:data.Message.indexData)
}
void Message::set_allocated_indexdefinition(::data::IndexDefinition* indexdefinition) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_dataBody();
  if (indexdefinition) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(indexdefinition);
    if (message_arena != submessage_arena) {
      indexdefinition = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, indexdefinition, submessage_arena);
    }
    set_has_indexdefinition();
    _impl_.dataBody_.indexdefinition_ = indexdefinition;
  }
  // @@protoc_insertion_point(field_set_allocated:data.Message.indexDefinition)
}
void Message::set_allocated_indicativeequilibriumprice(::data::IndicativeEquilibriumPrice* indicativeequilibriumprice) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_dataBody();
  if (indicativeequilibriumprice) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(indicativeequilibriumprice);
    if (message_arena != submessage_arena) {
      indicativeequilibriumprice = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, indicativeequilibriumprice, submessage_arena);
    }
    set_has_indicativeequilibriumprice();
    _impl_.dataBody_.indicativeequilibriumprice_ = indicativeequilibriumprice;
  }
  // @@protoc_insertion_point(field_set_allocated:data.Message.indicativeEquilibriumPrice)
}
void Message::set_allocated_liquidityprovider(::data::LiquidityProvider* liquidityprovider) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_dataBody();
  if (liquidityprovider) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(liquidityprovider);
    if (message_arena != submessage_arena) {
      liquidityprovider = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, liquidityprovider, submessage_arena);
    }
    set_has_liquidityprovider();
    _impl_.dataBody_.liquidityprovider_ = liquidityprovider;
  }
  // @@protoc_insertion_point(field_set_allocated:data.Message.liquidityProvider)
}
void Message::set_allocated_marketdefinition(::data::MarketDefinition* marketdefinition) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_dataBody();
  if (marketdefinition) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(marketdefinition);
    if (message_arena != submessage_arena) {
      marketdefinition = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, marketdefinition, submessage_arena);
    }
    set_has_marketdefinition();
    _impl_.dataBody_.marketdefinition_ = marketdefinition;
  }
  // @@protoc_insertion_point(field_set_allocated:data.Message.marketDefinition)
}
void Message::set_allocated_marketturnover(::data::MarketTurnover* marketturnover) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_dataBody();
  if (marketturnover) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(marketturnover);
    if (message_arena != submessage_arena) {
      marketturnover = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, marketturnover, submessage_arena);
    }
    set_has_marketturnover();
    _impl_.dataBody_.marketturnover_ = marketturnover;
  }
  // @@protoc_insertion_point(field_set_allocated:data.Message.marketTurnover)
}
void Message::set_allocated_news(::data::News* news) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_dataBody();
  if (news) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(news);
    if (message_arena != submessage_arena) {
      news = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, news, submessage_arena);
    }
    set_has_news();
    _impl_.dataBody_.news_ = news;
  }
  // @@protoc_insertion_point(field_set_allocated:data.Message.news)
}
void Message::set_allocated_nominalprice(::data::NominalPrice* nominalprice) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_dataBody();
  if (nominalprice) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(nominalprice);
    if (message_arena != submessage_arena) {
      nominalprice = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, nominalprice, submessage_arena);
    }
    set_has_nominalprice();
    _impl_.dataBody_.nominalprice_ = nominalprice;
  }
  // @@protoc_insertion_point(field_set_allocated:data.Message.nominalPrice)
}
void Message::set_allocated_orderimbalance(::data::OrderImbalance* orderimbalance) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_dataBody();
  if (orderimbalance) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(orderimbalance);
    if (message_arena != submessage_arena) {
      orderimbalance = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, orderimbalance, submessage_arena);
    }
    set_has_orderimbalance();
    _impl_.dataBody_.orderimbalance_ = orderimbalance;
  }
  // @@protoc_insertion_point(field_set_allocated:data.Message.orderImbalance)
}
void Message::set_allocated_referenceprice(::data::ReferencePrice* referenceprice) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_dataBody();
  if (referenceprice) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(referenceprice);
    if (message_arena != submessage_arena) {
      referenceprice = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, referenceprice, submessage_arena);
    }
    set_has_referenceprice();
    _impl_.dataBody_.referenceprice_ = referenceprice;
  }
  // @@protoc_insertion_point(field_set_allocated:data.Message.referencePrice)
}
void Message::set_allocated_securitydefinition(::data::SecurityDefinition* securitydefinition) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_dataBody();
  if (securitydefinition) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(securitydefinition);
    if (message_arena != submessage_arena) {
      securitydefinition = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, securitydefinition, submessage_arena);
    }
    set_has_securitydefinition();
    _impl_.dataBody_.securitydefinition_ = securitydefinition;
  }
  // @@protoc_insertion_point(field_set_allocated:data.Message.securityDefinition)
}
void Message::set_allocated_securitystatus(::data::SecurityStatus* securitystatus) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_dataBody();
  if (securitystatus) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(securitystatus);
    if (message_arena != submessage_arena) {
      securitystatus = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, securitystatus, submessage_arena);
    }
    set_has_securitystatus();
    _impl_.dataBody_.securitystatus_ = securitystatus;
  }
  // @@protoc_insertion_point(field_set_allocated:data.Message.securityStatus)
}
void Message::set_allocated_statistics(::data::Statistics* statistics) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_dataBody();
  if (statistics) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(statistics);
    if (message_arena != submessage_arena) {
      statistics = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, statistics, submessage_arena);
    }
    set_has_statistics();
    _impl_.dataBody_.statistics_ = statistics;
  }
  // @@protoc_insertion_point(field_set_allocated:data.Message.statistics)
}
void Message::set_allocated_stockconnectdailyquotabalance(::data::StockConnectDailyQuotaBalance* stockconnectdailyquotabalance) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_dataBody();
  if (stockconnectdailyquotabalance) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(stockconnectdailyquotabalance);
    if (message_arena != submessage_arena) {
      stockconnectdailyquotabalance = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stockconnectdailyquotabalance, submessage_arena);
    }
    set_has_stockconnectdailyquotabalance();
    _impl_.dataBody_.stockconnectdailyquotabalance_ = stockconnectdailyquotabalance;
  }
  // @@protoc_insertion_point(field_set_allocated:data.Message.stockConnectDailyQuotaBalance)
}
void Message::set_allocated_stockconnectmarketturnover(::data::StockConnectMarketTurnover* stockconnectmarketturnover) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_dataBody();
  if (stockconnectmarketturnover) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(stockconnectmarketturnover);
    if (message_arena != submessage_arena) {
      stockconnectmarketturnover = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stockconnectmarketturnover, submessage_arena);
    }
    set_has_stockconnectmarketturnover();
    _impl_.dataBody_.stockconnectmarketturnover_ = stockconnectmarketturnover;
  }
  // @@protoc_insertion_point(field_set_allocated:data.Message.stockConnectMarketTurnover)
}
void Message::set_allocated_trade(::data::Trade* trade) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_dataBody();
  if (trade) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(trade);
    if (message_arena != submessage_arena) {
      trade = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, trade, submessage_arena);
    }
    set_has_trade();
    _impl_.dataBody_.trade_ = trade;
  }
  // @@protoc_insertion_point(field_set_allocated:data.Message.trade)
}
void Message::set_allocated_tradecancel(::data::TradeCancel* tradecancel) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_dataBody();
  if (tradecancel) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(tradecancel);
    if (message_arena != submessage_arena) {
      tradecancel = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tradecancel, submessage_arena);
    }
    set_has_tradecancel();
    _impl_.dataBody_.tradecancel_ = tradecancel;
  }
  // @@protoc_insertion_point(field_set_allocated:data.Message.tradeCancel)
}
void Message::set_allocated_tradingsessionstatus(::data::TradingSessionStatus* tradingsessionstatus) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_dataBody();
  if (tradingsessionstatus) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(tradingsessionstatus);
    if (message_arena != submessage_arena) {
      tradingsessionstatus = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tradingsessionstatus, submessage_arena);
    }
    set_has_tradingsessionstatus();
    _impl_.dataBody_.tradingsessionstatus_ = tradingsessionstatus;
  }
  // @@protoc_insertion_point(field_set_allocated:data.Message.tradingSessionStatus)
}
void Message::set_allocated_vcmtrigger(::data::VCMTrigger* vcmtrigger) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_dataBody();
  if (vcmtrigger) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(vcmtrigger);
    if (message_arena != submessage_arena) {
      vcmtrigger = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, vcmtrigger, submessage_arena);
    }
    set_has_vcmtrigger();
    _impl_.dataBody_.vcmtrigger_ = vcmtrigger;
  }
  // @@protoc_insertion_point(field_set_allocated:data.Message.vCMTrigger)
}
void Message::set_allocated_yield(::data::Yield* yield) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_dataBody();
  if (yield) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(yield);
    if (message_arena != submessage_arena) {
      yield = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, yield, submessage_arena);
    }
    set_has_yield();
    _impl_.dataBody_.yield_ = yield;
  }
  // @@protoc_insertion_point(field_set_allocated:data.Message.yield)
}
void Message::set_allocated_adjustedclosingprice(::data::AdjustedClosingPrice* adjustedclosingprice) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_dataBody();
  if (adjustedclosingprice) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(adjustedclosingprice);
    if (message_arena != submessage_arena) {
      adjustedclosingprice = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, adjustedclosingprice, submessage_arena);
    }
    set_has_adjustedclosingprice();
    _impl_.dataBody_.adjustedclosingprice_ = adjustedclosingprice;
  }
  // @@protoc_insertion_point(field_set_allocated:data.Message.adjustedClosingPrice)
}
void Message::set_allocated_daytradesummary(::data::DayTradeSummary* daytradesummary) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_dataBody();
  if (daytradesummary) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(daytradesummary);
    if (message_arena != submessage_arena) {
      daytradesummary = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, daytradesummary, submessage_arena);
    }
    set_has_daytradesummary();
    _impl_.dataBody_.daytradesummary_ = daytradesummary;
  }
  // @@protoc_insertion_point(field_set_allocated:data.Message.dayTradeSummary)
}
void Message::set_allocated_daytradesummarynextshares(::data::DayTradeSummaryNextShares* daytradesummarynextshares) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_dataBody();
  if (daytradesummarynextshares) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(daytradesummarynextshares);
    if (message_arena != submessage_arena) {
      daytradesummarynextshares = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, daytradesummarynextshares, submessage_arena);
    }
    set_has_daytradesummarynextshares();
    _impl_.dataBody_.daytradesummarynextshares_ = daytradesummarynextshares;
  }
  // @@protoc_insertion_point(field_set_allocated:data.Message.dayTradeSummaryNextShares)
}
void Message::set_allocated_ipoinformation(::data::IPOInformation* ipoinformation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_dataBody();
  if (ipoinformation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(ipoinformation);
    if (message_arena != submessage_arena) {
      ipoinformation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ipoinformation, submessage_arena);
    }
    set_has_ipoinformation();
    _impl_.dataBody_.ipoinformation_ = ipoinformation;
  }
  // @@protoc_insertion_point(field_set_allocated:data.Message.iPOInformation)
}
void Message::set_allocated_ipoquotingperiodupdate(::data::IPOQuotingPeriodUpdate* ipoquotingperiodupdate) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_dataBody();
  if (ipoquotingperiodupdate) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(ipoquotingperiodupdate);
    if (message_arena != submessage_arena) {
      ipoquotingperiodupdate = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ipoquotingperiodupdate, submessage_arena);
    }
    set_has_ipoquotingperiodupdate();
    _impl_.dataBody_.ipoquotingperiodupdate_ = ipoquotingperiodupdate;
  }
  // @@protoc_insertion_point(field_set_allocated:data.Message.iPOQuotingPeriodUpdate)
}
void Message::set_allocated_longadjustedclosingprice(::data::LongAdjustedClosingPrice* longadjustedclosingprice) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_dataBody();
  if (longadjustedclosingprice) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(longadjustedclosingprice);
    if (message_arena != submessage_arena) {
      longadjustedclosingprice = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, longadjustedclosingprice, submessage_arena);
    }
    set_has_longadjustedclosingprice();
    _impl_.dataBody_.longadjustedclosingprice_ = longadjustedclosingprice;
  }
  // @@protoc_insertion_point(field_set_allocated:data.Message.longAdjustedClosingPrice)
}
void Message::set_allocated_longdaytradesummary(::data::LongDayTradeSummary* longdaytradesummary) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_dataBody();
  if (longdaytradesummary) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(longdaytradesummary);
    if (message_arena != submessage_arena) {
      longdaytradesummary = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, longdaytradesummary, submessage_arena);
    }
    set_has_longdaytradesummary();
    _impl_.dataBody_.longdaytradesummary_ = longdaytradesummary;
  }
  // @@protoc_insertion_point(field_set_allocated:data.Message.longDayTradeSummary)
}
void Message::set_allocated_longtradecancelfornonnextsharestrades(::data::LongTradeCancelForNonNextSharesTrades* longtradecancelfornonnextsharestrades) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_dataBody();
  if (longtradecancelfornonnextsharestrades) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(longtradecancelfornonnextsharestrades);
    if (message_arena != submessage_arena) {
      longtradecancelfornonnextsharestrades = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, longtradecancelfornonnextsharestrades, submessage_arena);
    }
    set_has_longtradecancelfornonnextsharestrades();
    _impl_.dataBody_.longtradecancelfornonnextsharestrades_ = longtradecancelfornonnextsharestrades;
  }
  // @@protoc_insertion_point(field_set_allocated:data.Message.longTradeCancelForNonNextSharesTrades)
}
void Message::set_allocated_longtradecorrectionfornonnextsharestrades(::data::LongTradeCorrectionForNonNextsharesTrades* longtradecorrectionfornonnextsharestrades) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_dataBody();
  if (longtradecorrectionfornonnextsharestrades) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(longtradecorrectionfornonnextsharestrades);
    if (message_arena != submessage_arena) {
      longtradecorrectionfornonnextsharestrades = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, longtradecorrectionfornonnextsharestrades, submessage_arena);
    }
    set_has_longtradecorrectionfornonnextsharestrades();
    _impl_.dataBody_.longtradecorrectionfornonnextsharestrades_ = longtradecorrectionfornonnextsharestrades;
  }
  // @@protoc_insertion_point(field_set_allocated:data.Message.longTradeCorrectionForNonNextsharesTrades)
}
void Message::set_allocated_longtradereportfornonnextshares(::data::LongTradeReportForNonNextshares* longtradereportfornonnextshares) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_dataBody();
  if (longtradereportfornonnextshares) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(longtradereportfornonnextshares);
    if (message_arena != submessage_arena) {
      longtradereportfornonnextshares = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, longtradereportfornonnextshares, submessage_arena);
    }
    set_has_longtradereportfornonnextshares();
    _impl_.dataBody_.longtradereportfornonnextshares_ = longtradereportfornonnextshares;
  }
  // @@protoc_insertion_point(field_set_allocated:data.Message.longTradeReportForNonNextshares)
}
void Message::set_allocated_mwcbstatusmessage(::data::MWCBStatusMessage* mwcbstatusmessage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_dataBody();
  if (mwcbstatusmessage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(mwcbstatusmessage);
    if (message_arena != submessage_arena) {
      mwcbstatusmessage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, mwcbstatusmessage, submessage_arena);
    }
    set_has_mwcbstatusmessage();
    _impl_.dataBody_.mwcbstatusmessage_ = mwcbstatusmessage;
  }
  // @@protoc_insertion_point(field_set_allocated:data.Message.mWCBStatusMessage)
}
void Message::set_allocated_marketwidecircuitbreaker(::data::MarketWideCircuitBreaker* marketwidecircuitbreaker) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_dataBody();
  if (marketwidecircuitbreaker) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(marketwidecircuitbreaker);
    if (message_arena != submessage_arena) {
      marketwidecircuitbreaker = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, marketwidecircuitbreaker, submessage_arena);
    }
    set_has_marketwidecircuitbreaker();
    _impl_.dataBody_.marketwidecircuitbreaker_ = marketwidecircuitbreaker;
  }
  // @@protoc_insertion_point(field_set_allocated:data.Message.marketWideCircuitBreaker)
}
void Message::set_allocated_operationalhalt(::data::OperationalHalt* operationalhalt) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_dataBody();
  if (operationalhalt) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(operationalhalt);
    if (message_arena != submessage_arena) {
      operationalhalt = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, operationalhalt, submessage_arena);
    }
    set_has_operationalhalt();
    _impl_.dataBody_.operationalhalt_ = operationalhalt;
  }
  // @@protoc_insertion_point(field_set_allocated:data.Message.operationalHalt)
}
void Message::set_allocated_saleconditionmodifier(::data::SaleConditionModifier* saleconditionmodifier) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_dataBody();
  if (saleconditionmodifier) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(saleconditionmodifier);
    if (message_arena != submessage_arena) {
      saleconditionmodifier = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, saleconditionmodifier, submessage_arena);
    }
    set_has_saleconditionmodifier();
    _impl_.dataBody_.saleconditionmodifier_ = saleconditionmodifier;
  }
  // @@protoc_insertion_point(field_set_allocated:data.Message.saleConditionModifier)
}
void Message::set_allocated_shortsalerestrictionindicatormessage(::data::ShortSaleRestrictionIndicatorMessage* shortsalerestrictionindicatormessage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_dataBody();
  if (shortsalerestrictionindicatormessage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(shortsalerestrictionindicatormessage);
    if (message_arena != submessage_arena) {
      shortsalerestrictionindicatormessage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, shortsalerestrictionindicatormessage, submessage_arena);
    }
    set_has_shortsalerestrictionindicatormessage();
    _impl_.dataBody_.shortsalerestrictionindicatormessage_ = shortsalerestrictionindicatormessage;
  }
  // @@protoc_insertion_point(field_set_allocated:data.Message.shortSaleRestrictionIndicatorMessage)
}
void Message::set_allocated_stockdirectory(::data::StockDirectory* stockdirectory) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_dataBody();
  if (stockdirectory) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(stockdirectory);
    if (message_arena != submessage_arena) {
      stockdirectory = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stockdirectory, submessage_arena);
    }
    set_has_stockdirectory();
    _impl_.dataBody_.stockdirectory_ = stockdirectory;
  }
  // @@protoc_insertion_point(field_set_allocated:data.Message.stockDirectory)
}
void Message::set_allocated_stocktradingaction(::data::StockTradingAction* stocktradingaction) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_dataBody();
  if (stocktradingaction) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(stocktradingaction);
    if (message_arena != submessage_arena) {
      stocktradingaction = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stocktradingaction, submessage_arena);
    }
    set_has_stocktradingaction();
    _impl_.dataBody_.stocktradingaction_ = stocktradingaction;
  }
  // @@protoc_insertion_point(field_set_allocated:data.Message.stockTradingAction)
}
void Message::set_allocated_systemeventmessage(::data::SystemEventMessage* systemeventmessage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_dataBody();
  if (systemeventmessage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(systemeventmessage);
    if (message_arena != submessage_arena) {
      systemeventmessage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, systemeventmessage, submessage_arena);
    }
    set_has_systemeventmessage();
    _impl_.dataBody_.systemeventmessage_ = systemeventmessage;
  }
  // @@protoc_insertion_point(field_set_allocated:data.Message.systemEventMessage)
}
void Message::set_allocated_tradecancelfornextsharestrades(::data::TradeCancelForNextsharesTrades* tradecancelfornextsharestrades) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_dataBody();
  if (tradecancelfornextsharestrades) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(tradecancelfornextsharestrades);
    if (message_arena != submessage_arena) {
      tradecancelfornextsharestrades = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tradecancelfornextsharestrades, submessage_arena);
    }
    set_has_tradecancelfornextsharestrades();
    _impl_.dataBody_.tradecancelfornextsharestrades_ = tradecancelfornextsharestrades;
  }
  // @@protoc_insertion_point(field_set_allocated:data.Message.tradeCancelForNextsharesTrades)
}
void Message::set_allocated_tradecancelfornonnextsharestrades(::data::TradeCancelForNonNextSharesTrades* tradecancelfornonnextsharestrades) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_dataBody();
  if (tradecancelfornonnextsharestrades) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(tradecancelfornonnextsharestrades);
    if (message_arena != submessage_arena) {
      tradecancelfornonnextsharestrades = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tradecancelfornonnextsharestrades, submessage_arena);
    }
    set_has_tradecancelfornonnextsharestrades();
    _impl_.dataBody_.tradecancelfornonnextsharestrades_ = tradecancelfornonnextsharestrades;
  }
  // @@protoc_insertion_point(field_set_allocated:data.Message.tradeCancelForNonNextSharesTrades)
}
void Message::set_allocated_tradecorrectionfornextsharestrades(::data::TradeCorrectionForNextsharesTrades* tradecorrectionfornextsharestrades) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_dataBody();
  if (tradecorrectionfornextsharestrades) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(tradecorrectionfornextsharestrades);
    if (message_arena != submessage_arena) {
      tradecorrectionfornextsharestrades = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tradecorrectionfornextsharestrades, submessage_arena);
    }
    set_has_tradecorrectionfornextsharestrades();
    _impl_.dataBody_.tradecorrectionfornextsharestrades_ = tradecorrectionfornextsharestrades;
  }
  // @@protoc_insertion_point(field_set_allocated:data.Message.tradeCorrectionForNextsharesTrades)
}
void Message::set_allocated_tradecorrectionfornonnextsharestrades(::data::TradeCorrectionForNonNextsharesTrades* tradecorrectionfornonnextsharestrades) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_dataBody();
  if (tradecorrectionfornonnextsharestrades) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(tradecorrectionfornonnextsharestrades);
    if (message_arena != submessage_arena) {
      tradecorrectionfornonnextsharestrades = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tradecorrectionfornonnextsharestrades, submessage_arena);
    }
    set_has_tradecorrectionfornonnextsharestrades();
    _impl_.dataBody_.tradecorrectionfornonnextsharestrades_ = tradecorrectionfornonnextsharestrades;
  }
  // @@protoc_insertion_point(field_set_allocated:data.Message.tradeCorrectionForNonNextsharesTrades)
}
void Message::set_allocated_tradereportfornextshares(::data::TradeReportForNextshares* tradereportfornextshares) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_dataBody();
  if (tradereportfornextshares) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(tradereportfornextshares);
    if (message_arena != submessage_arena) {
      tradereportfornextshares = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tradereportfornextshares, submessage_arena);
    }
    set_has_tradereportfornextshares();
    _impl_.dataBody_.tradereportfornextshares_ = tradereportfornextshares;
  }
  // @@protoc_insertion_point(field_set_allocated:data.Message.tradeReportForNextshares)
}
void Message::set_allocated_tradereportfornonnextshares(::data::TradeReportForNonNextshares* tradereportfornonnextshares) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_dataBody();
  if (tradereportfornonnextshares) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(tradereportfornonnextshares);
    if (message_arena != submessage_arena) {
      tradereportfornonnextshares = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tradereportfornonnextshares, submessage_arena);
    }
    set_has_tradereportfornonnextshares();
    _impl_.dataBody_.tradereportfornonnextshares_ = tradereportfornonnextshares;
  }
  // @@protoc_insertion_point(field_set_allocated:data.Message.tradeReportForNonNextshares)
}
void Message::set_allocated_qbbomwcbbreachmessage(::data::QBBOMWCBBreachMessage* qbbomwcbbreachmessage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_dataBody();
  if (qbbomwcbbreachmessage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(qbbomwcbbreachmessage);
    if (message_arena != submessage_arena) {
      qbbomwcbbreachmessage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, qbbomwcbbreachmessage, submessage_arena);
    }
    set_has_qbbomwcbbreachmessage();
    _impl_.dataBody_.qbbomwcbbreachmessage_ = qbbomwcbbreachmessage;
  }
  // @@protoc_insertion_point(field_set_allocated:data.Message.qBBOMWCBBreachMessage)
}
void Message::set_allocated_qbbomwcbdeclinelevelmessage(::data::QBBOMWCBDeclineLevelMessage* qbbomwcbdeclinelevelmessage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_dataBody();
  if (qbbomwcbdeclinelevelmessage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(qbbomwcbdeclinelevelmessage);
    if (message_arena != submessage_arena) {
      qbbomwcbdeclinelevelmessage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, qbbomwcbdeclinelevelmessage, submessage_arena);
    }
    set_has_qbbomwcbdeclinelevelmessage();
    _impl_.dataBody_.qbbomwcbdeclinelevelmessage_ = qbbomwcbdeclinelevelmessage;
  }
  // @@protoc_insertion_point(field_set_allocated:data.Message.qBBOMWCBDeclineLevelMessage)
}
void Message::set_allocated_qbbonextsharesquotationmessage(::data::QBBONextSharesQuotationMessage* qbbonextsharesquotationmessage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_dataBody();
  if (qbbonextsharesquotationmessage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(qbbonextsharesquotationmessage);
    if (message_arena != submessage_arena) {
      qbbonextsharesquotationmessage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, qbbonextsharesquotationmessage, submessage_arena);
    }
    set_has_qbbonextsharesquotationmessage();
    _impl_.dataBody_.qbbonextsharesquotationmessage_ = qbbonextsharesquotationmessage;
  }
  // @@protoc_insertion_point(field_set_allocated:data.Message.qBBONextSharesQuotationMessage)
}
void Message::set_allocated_qbbooperationalhalt(::data::QBBOOperationalHalt* qbbooperationalhalt) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_dataBody();
  if (qbbooperationalhalt) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(qbbooperationalhalt);
    if (message_arena != submessage_arena) {
      qbbooperationalhalt = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, qbbooperationalhalt, submessage_arena);
    }
    set_has_qbbooperationalhalt();
    _impl_.dataBody_.qbbooperationalhalt_ = qbbooperationalhalt;
  }
  // @@protoc_insertion_point(field_set_allocated:data.Message.qBBOOperationalHalt)
}
void Message::set_allocated_qbboquotationmessage(::data::QBBOQuotationMessage* qbboquotationmessage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_dataBody();
  if (qbboquotationmessage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(qbboquotationmessage);
    if (message_arena != submessage_arena) {
      qbboquotationmessage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, qbboquotationmessage, submessage_arena);
    }
    set_has_qbboquotationmessage();
    _impl_.dataBody_.qbboquotationmessage_ = qbboquotationmessage;
  }
  // @@protoc_insertion_point(field_set_allocated:data.Message.qBBOQuotationMessage)
}
void Message::set_allocated_qbboregshorestriction(::data::QBBORegShoRestriction* qbboregshorestriction) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_dataBody();
  if (qbboregshorestriction) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(qbboregshorestriction);
    if (message_arena != submessage_arena) {
      qbboregshorestriction = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, qbboregshorestriction, submessage_arena);
    }
    set_has_qbboregshorestriction();
    _impl_.dataBody_.qbboregshorestriction_ = qbboregshorestriction;
  }
  // @@protoc_insertion_point(field_set_allocated:data.Message.qBBORegShoRestriction)
}
void Message::set_allocated_qbbostockdirectory(::data::QBBOStockDirectory* qbbostockdirectory) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_dataBody();
  if (qbbostockdirectory) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(qbbostockdirectory);
    if (message_arena != submessage_arena) {
      qbbostockdirectory = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, qbbostockdirectory, submessage_arena);
    }
    set_has_qbbostockdirectory();
    _impl_.dataBody_.qbbostockdirectory_ = qbbostockdirectory;
  }
  // @@protoc_insertion_point(field_set_allocated:data.Message.qBBOStockDirectory)
}
void Message::set_allocated_qbbostocktradingaction(::data::QBBOStockTradingAction* qbbostocktradingaction) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_dataBody();
  if (qbbostocktradingaction) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(qbbostocktradingaction);
    if (message_arena != submessage_arena) {
      qbbostocktradingaction = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, qbbostocktradingaction, submessage_arena);
    }
    set_has_qbbostocktradingaction();
    _impl_.dataBody_.qbbostocktradingaction_ = qbbostocktradingaction;
  }
  // @@protoc_insertion_point(field_set_allocated:data.Message.qBBOStockTradingAction)
}
void Message::set_allocated_qbbosystemeventmessage(::data::QBBOSystemEventMessage* qbbosystemeventmessage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_dataBody();
  if (qbbosystemeventmessage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(qbbosystemeventmessage);
    if (message_arena != submessage_arena) {
      qbbosystemeventmessage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, qbbosystemeventmessage, submessage_arena);
    }
    set_has_qbbosystemeventmessage();
    _impl_.dataBody_.qbbosystemeventmessage_ = qbbosystemeventmessage;
  }
  // @@protoc_insertion_point(field_set_allocated:data.Message.qBBOSystemEventMessage)
}
void Message::set_allocated_qbboipoquotingperiodupdate(::data::QBBOIPOQuotingPeriodUpdate* qbboipoquotingperiodupdate) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_dataBody();
  if (qbboipoquotingperiodupdate) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(qbboipoquotingperiodupdate);
    if (message_arena != submessage_arena) {
      qbboipoquotingperiodupdate = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, qbboipoquotingperiodupdate, submessage_arena);
    }
    set_has_qbboipoquotingperiodupdate();
    _impl_.dataBody_.qbboipoquotingperiodupdate_ = qbboipoquotingperiodupdate;
  }
  // @@protoc_insertion_point(field_set_allocated:data.Message.qBBOIPOQuotingPeriodUpdate)
}
void Message::set_allocated_certificationmsg(::data::CertificationMsg* certificationmsg) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_dataBody();
  if (certificationmsg) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(certificationmsg);
    if (message_arena != submessage_arena) {
      certificationmsg = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, certificationmsg, submessage_arena);
    }
    set_has_certificationmsg();
    _impl_.dataBody_.certificationmsg_ = certificationmsg;
  }
  // @@protoc_insertion_point(field_set_allocated:data.Message.certificationMsg)
}
void Message::set_allocated_cnmarketdefinition(::data::CNMarketDefinition* cnmarketdefinition) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_dataBody();
  if (cnmarketdefinition) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(cnmarketdefinition);
    if (message_arena != submessage_arena) {
      cnmarketdefinition = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cnmarketdefinition, submessage_arena);
    }
    set_has_cnmarketdefinition();
    _impl_.dataBody_.cnmarketdefinition_ = cnmarketdefinition;
  }
  // @@protoc_insertion_point(field_set_allocated:data.Message.cNMarketDefinition)
}
void Message::set_allocated_cnsecuritydefinition(::data::CNSecurityDefinition* cnsecuritydefinition) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_dataBody();
  if (cnsecuritydefinition) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(cnsecuritydefinition);
    if (message_arena != submessage_arena) {
      cnsecuritydefinition = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cnsecuritydefinition, submessage_arena);
    }
    set_has_cnsecuritydefinition();
    _impl_.dataBody_.cnsecuritydefinition_ = cnsecuritydefinition;
  }
  // @@protoc_insertion_point(field_set_allocated:data.Message.cNSecurityDefinition)
}
void Message::set_allocated_cnsecuritystatus(::data::CNSecurityStatus* cnsecuritystatus) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_dataBody();
  if (cnsecuritystatus) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(cnsecuritystatus);
    if (message_arena != submessage_arena) {
      cnsecuritystatus = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cnsecuritystatus, submessage_arena);
    }
    set_has_cnsecuritystatus();
    _impl_.dataBody_.cnsecuritystatus_ = cnsecuritystatus;
  }
  // @@protoc_insertion_point(field_set_allocated:data.Message.cNSecurityStatus)
}
void Message::set_allocated_cnstatistics(::data::CNStatistics* cnstatistics) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_dataBody();
  if (cnstatistics) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(cnstatistics);
    if (message_arena != submessage_arena) {
      cnstatistics = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cnstatistics, submessage_arena);
    }
    set_has_cnstatistics();
    _impl_.dataBody_.cnstatistics_ = cnstatistics;
  }
  // @@protoc_insertion_point(field_set_allocated:data.Message.cNStatistics)
}
void Message::set_allocated_cntopbook(::data::CNTopBook* cntopbook) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_dataBody();
  if (cntopbook) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(cntopbook);
    if (message_arena != submessage_arena) {
      cntopbook = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cntopbook, submessage_arena);
    }
    set_has_cntopbook();
    _impl_.dataBody_.cntopbook_ = cntopbook;
  }
  // @@protoc_insertion_point(field_set_allocated:data.Message.cNTopBook)
}
Message::Message(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:data.Message)
}
Message::Message(const Message& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Message* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.timestamp_){}
    , decltype(_impl_.data_type_){}
    , decltype(_impl_.dataBody_){}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.timestamp_, &from._impl_.timestamp_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.data_type_) -
    reinterpret_cast<char*>(&_impl_.timestamp_)) + sizeof(_impl_.data_type_));
  clear_has_dataBody();
  switch (from.dataBody_case()) {
    case kAddOddLotOrder: {
      _this->_internal_mutable_addoddlotorder()->::data::AddOddLotOrder::MergeFrom(
          from._internal_addoddlotorder());
      break;
    }
    case kAggregateOrderBookUpdate: {
      _this->_internal_mutable_aggregateorderbookupdate()->::data::AggregateOrderBookUpdate::MergeFrom(
          from._internal_aggregateorderbookupdate());
      break;
    }
    case kBrokerQueue: {
      _this->_internal_mutable_brokerqueue()->::data::BrokerQueue::MergeFrom(
          from._internal_brokerqueue());
      break;
    }
    case kClosingPrice: {
      _this->_internal_mutable_closingprice()->::data::ClosingPrice::MergeFrom(
          from._internal_closingprice());
      break;
    }
    case kCurrencyRate: {
      _this->_internal_mutable_currencyrate()->::data::CurrencyRate::MergeFrom(
          from._internal_currencyrate());
      break;
    }
    case kDeleteOddLotOrder: {
      _this->_internal_mutable_deleteoddlotorder()->::data::DeleteOddLotOrder::MergeFrom(
          from._internal_deleteoddlotorder());
      break;
    }
    case kIndexData: {
      _this->_internal_mutable_indexdata()->::data::IndexData::MergeFrom(
          from._internal_indexdata());
      break;
    }
    case kIndexDefinition: {
      _this->_internal_mutable_indexdefinition()->::data::IndexDefinition::MergeFrom(
          from._internal_indexdefinition());
      break;
    }
    case kIndicativeEquilibriumPrice: {
      _this->_internal_mutable_indicativeequilibriumprice()->::data::IndicativeEquilibriumPrice::MergeFrom(
          from._internal_indicativeequilibriumprice());
      break;
    }
    case kLiquidityProvider: {
      _this->_internal_mutable_liquidityprovider()->::data::LiquidityProvider::MergeFrom(
          from._internal_liquidityprovider());
      break;
    }
    case kMarketDefinition: {
      _this->_internal_mutable_marketdefinition()->::data::MarketDefinition::MergeFrom(
          from._internal_marketdefinition());
      break;
    }
    case kMarketTurnover: {
      _this->_internal_mutable_marketturnover()->::data::MarketTurnover::MergeFrom(
          from._internal_marketturnover());
      break;
    }
    case kNews: {
      _this->_internal_mutable_news()->::data::News::MergeFrom(
          from._internal_news());
      break;
    }
    case kNominalPrice: {
      _this->_internal_mutable_nominalprice()->::data::NominalPrice::MergeFrom(
          from._internal_nominalprice());
      break;
    }
    case kOrderImbalance: {
      _this->_internal_mutable_orderimbalance()->::data::OrderImbalance::MergeFrom(
          from._internal_orderimbalance());
      break;
    }
    case kReferencePrice: {
      _this->_internal_mutable_referenceprice()->::data::ReferencePrice::MergeFrom(
          from._internal_referenceprice());
      break;
    }
    case kSecurityDefinition: {
      _this->_internal_mutable_securitydefinition()->::data::SecurityDefinition::MergeFrom(
          from._internal_securitydefinition());
      break;
    }
    case kSecurityStatus: {
      _this->_internal_mutable_securitystatus()->::data::SecurityStatus::MergeFrom(
          from._internal_securitystatus());
      break;
    }
    case kStatistics: {
      _this->_internal_mutable_statistics()->::data::Statistics::MergeFrom(
          from._internal_statistics());
      break;
    }
    case kStockConnectDailyQuotaBalance: {
      _this->_internal_mutable_stockconnectdailyquotabalance()->::data::StockConnectDailyQuotaBalance::MergeFrom(
          from._internal_stockconnectdailyquotabalance());
      break;
    }
    case kStockConnectMarketTurnover: {
      _this->_internal_mutable_stockconnectmarketturnover()->::data::StockConnectMarketTurnover::MergeFrom(
          from._internal_stockconnectmarketturnover());
      break;
    }
    case kTrade: {
      _this->_internal_mutable_trade()->::data::Trade::MergeFrom(
          from._internal_trade());
      break;
    }
    case kTradeCancel: {
      _this->_internal_mutable_tradecancel()->::data::TradeCancel::MergeFrom(
          from._internal_tradecancel());
      break;
    }
    case kTradingSessionStatus: {
      _this->_internal_mutable_tradingsessionstatus()->::data::TradingSessionStatus::MergeFrom(
          from._internal_tradingsessionstatus());
      break;
    }
    case kVCMTrigger: {
      _this->_internal_mutable_vcmtrigger()->::data::VCMTrigger::MergeFrom(
          from._internal_vcmtrigger());
      break;
    }
    case kYield: {
      _this->_internal_mutable_yield()->::data::Yield::MergeFrom(
          from._internal_yield());
      break;
    }
    case kAdjustedClosingPrice: {
      _this->_internal_mutable_adjustedclosingprice()->::data::AdjustedClosingPrice::MergeFrom(
          from._internal_adjustedclosingprice());
      break;
    }
    case kDayTradeSummary: {
      _this->_internal_mutable_daytradesummary()->::data::DayTradeSummary::MergeFrom(
          from._internal_daytradesummary());
      break;
    }
    case kDayTradeSummaryNextShares: {
      _this->_internal_mutable_daytradesummarynextshares()->::data::DayTradeSummaryNextShares::MergeFrom(
          from._internal_daytradesummarynextshares());
      break;
    }
    case kIPOInformation: {
      _this->_internal_mutable_ipoinformation()->::data::IPOInformation::MergeFrom(
          from._internal_ipoinformation());
      break;
    }
    case kIPOQuotingPeriodUpdate: {
      _this->_internal_mutable_ipoquotingperiodupdate()->::data::IPOQuotingPeriodUpdate::MergeFrom(
          from._internal_ipoquotingperiodupdate());
      break;
    }
    case kLongAdjustedClosingPrice: {
      _this->_internal_mutable_longadjustedclosingprice()->::data::LongAdjustedClosingPrice::MergeFrom(
          from._internal_longadjustedclosingprice());
      break;
    }
    case kLongDayTradeSummary: {
      _this->_internal_mutable_longdaytradesummary()->::data::LongDayTradeSummary::MergeFrom(
          from._internal_longdaytradesummary());
      break;
    }
    case kLongTradeCancelForNonNextSharesTrades: {
      _this->_internal_mutable_longtradecancelfornonnextsharestrades()->::data::LongTradeCancelForNonNextSharesTrades::MergeFrom(
          from._internal_longtradecancelfornonnextsharestrades());
      break;
    }
    case kLongTradeCorrectionForNonNextsharesTrades: {
      _this->_internal_mutable_longtradecorrectionfornonnextsharestrades()->::data::LongTradeCorrectionForNonNextsharesTrades::MergeFrom(
          from._internal_longtradecorrectionfornonnextsharestrades());
      break;
    }
    case kLongTradeReportForNonNextshares: {
      _this->_internal_mutable_longtradereportfornonnextshares()->::data::LongTradeReportForNonNextshares::MergeFrom(
          from._internal_longtradereportfornonnextshares());
      break;
    }
    case kMWCBStatusMessage: {
      _this->_internal_mutable_mwcbstatusmessage()->::data::MWCBStatusMessage::MergeFrom(
          from._internal_mwcbstatusmessage());
      break;
    }
    case kMarketWideCircuitBreaker: {
      _this->_internal_mutable_marketwidecircuitbreaker()->::data::MarketWideCircuitBreaker::MergeFrom(
          from._internal_marketwidecircuitbreaker());
      break;
    }
    case kOperationalHalt: {
      _this->_internal_mutable_operationalhalt()->::data::OperationalHalt::MergeFrom(
          from._internal_operationalhalt());
      break;
    }
    case kSaleConditionModifier: {
      _this->_internal_mutable_saleconditionmodifier()->::data::SaleConditionModifier::MergeFrom(
          from._internal_saleconditionmodifier());
      break;
    }
    case kShortSaleRestrictionIndicatorMessage: {
      _this->_internal_mutable_shortsalerestrictionindicatormessage()->::data::ShortSaleRestrictionIndicatorMessage::MergeFrom(
          from._internal_shortsalerestrictionindicatormessage());
      break;
    }
    case kStockDirectory: {
      _this->_internal_mutable_stockdirectory()->::data::StockDirectory::MergeFrom(
          from._internal_stockdirectory());
      break;
    }
    case kStockTradingAction: {
      _this->_internal_mutable_stocktradingaction()->::data::StockTradingAction::MergeFrom(
          from._internal_stocktradingaction());
      break;
    }
    case kSystemEventMessage: {
      _this->_internal_mutable_systemeventmessage()->::data::SystemEventMessage::MergeFrom(
          from._internal_systemeventmessage());
      break;
    }
    case kTradeCancelForNextsharesTrades: {
      _this->_internal_mutable_tradecancelfornextsharestrades()->::data::TradeCancelForNextsharesTrades::MergeFrom(
          from._internal_tradecancelfornextsharestrades());
      break;
    }
    case kTradeCancelForNonNextSharesTrades: {
      _this->_internal_mutable_tradecancelfornonnextsharestrades()->::data::TradeCancelForNonNextSharesTrades::MergeFrom(
          from._internal_tradecancelfornonnextsharestrades());
      break;
    }
    case kTradeCorrectionForNextsharesTrades: {
      _this->_internal_mutable_tradecorrectionfornextsharestrades()->::data::TradeCorrectionForNextsharesTrades::MergeFrom(
          from._internal_tradecorrectionfornextsharestrades());
      break;
    }
    case kTradeCorrectionForNonNextsharesTrades: {
      _this->_internal_mutable_tradecorrectionfornonnextsharestrades()->::data::TradeCorrectionForNonNextsharesTrades::MergeFrom(
          from._internal_tradecorrectionfornonnextsharestrades());
      break;
    }
    case kTradeReportForNextshares: {
      _this->_internal_mutable_tradereportfornextshares()->::data::TradeReportForNextshares::MergeFrom(
          from._internal_tradereportfornextshares());
      break;
    }
    case kTradeReportForNonNextshares: {
      _this->_internal_mutable_tradereportfornonnextshares()->::data::TradeReportForNonNextshares::MergeFrom(
          from._internal_tradereportfornonnextshares());
      break;
    }
    case kQBBOMWCBBreachMessage: {
      _this->_internal_mutable_qbbomwcbbreachmessage()->::data::QBBOMWCBBreachMessage::MergeFrom(
          from._internal_qbbomwcbbreachmessage());
      break;
    }
    case kQBBOMWCBDeclineLevelMessage: {
      _this->_internal_mutable_qbbomwcbdeclinelevelmessage()->::data::QBBOMWCBDeclineLevelMessage::MergeFrom(
          from._internal_qbbomwcbdeclinelevelmessage());
      break;
    }
    case kQBBONextSharesQuotationMessage: {
      _this->_internal_mutable_qbbonextsharesquotationmessage()->::data::QBBONextSharesQuotationMessage::MergeFrom(
          from._internal_qbbonextsharesquotationmessage());
      break;
    }
    case kQBBOOperationalHalt: {
      _this->_internal_mutable_qbbooperationalhalt()->::data::QBBOOperationalHalt::MergeFrom(
          from._internal_qbbooperationalhalt());
      break;
    }
    case kQBBOQuotationMessage: {
      _this->_internal_mutable_qbboquotationmessage()->::data::QBBOQuotationMessage::MergeFrom(
          from._internal_qbboquotationmessage());
      break;
    }
    case kQBBORegShoRestriction: {
      _this->_internal_mutable_qbboregshorestriction()->::data::QBBORegShoRestriction::MergeFrom(
          from._internal_qbboregshorestriction());
      break;
    }
    case kQBBOStockDirectory: {
      _this->_internal_mutable_qbbostockdirectory()->::data::QBBOStockDirectory::MergeFrom(
          from._internal_qbbostockdirectory());
      break;
    }
    case kQBBOStockTradingAction: {
      _this->_internal_mutable_qbbostocktradingaction()->::data::QBBOStockTradingAction::MergeFrom(
          from._internal_qbbostocktradingaction());
      break;
    }
    case kQBBOSystemEventMessage: {
      _this->_internal_mutable_qbbosystemeventmessage()->::data::QBBOSystemEventMessage::MergeFrom(
          from._internal_qbbosystemeventmessage());
      break;
    }
    case kQBBOIPOQuotingPeriodUpdate: {
      _this->_internal_mutable_qbboipoquotingperiodupdate()->::data::QBBOIPOQuotingPeriodUpdate::MergeFrom(
          from._internal_qbboipoquotingperiodupdate());
      break;
    }
    case kCertificationMsg: {
      _this->_internal_mutable_certificationmsg()->::data::CertificationMsg::MergeFrom(
          from._internal_certificationmsg());
      break;
    }
    case kCNMarketDefinition: {
      _this->_internal_mutable_cnmarketdefinition()->::data::CNMarketDefinition::MergeFrom(
          from._internal_cnmarketdefinition());
      break;
    }
    case kCNSecurityDefinition: {
      _this->_internal_mutable_cnsecuritydefinition()->::data::CNSecurityDefinition::MergeFrom(
          from._internal_cnsecuritydefinition());
      break;
    }
    case kCNSecurityStatus: {
      _this->_internal_mutable_cnsecuritystatus()->::data::CNSecurityStatus::MergeFrom(
          from._internal_cnsecuritystatus());
      break;
    }
    case kCNStatistics: {
      _this->_internal_mutable_cnstatistics()->::data::CNStatistics::MergeFrom(
          from._internal_cnstatistics());
      break;
    }
    case kCNTopBook: {
      _this->_internal_mutable_cntopbook()->::data::CNTopBook::MergeFrom(
          from._internal_cntopbook());
      break;
    }
    case DATABODY_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:data.Message)
}

inline void Message::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.timestamp_){int64_t{0}}
    , decltype(_impl_.data_type_){0}
    , decltype(_impl_.dataBody_){}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_dataBody();
}

Message::~Message() {
  // @@protoc_insertion_point(destructor:data.Message)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Message::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_dataBody()) {
    clear_dataBody();
  }
}

void Message::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Message::clear_dataBody() {
// @@protoc_insertion_point(one_of_clear_start:data.Message)
  switch (dataBody_case()) {
    case kAddOddLotOrder: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.dataBody_.addoddlotorder_;
      }
      break;
    }
    case kAggregateOrderBookUpdate: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.dataBody_.aggregateorderbookupdate_;
      }
      break;
    }
    case kBrokerQueue: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.dataBody_.brokerqueue_;
      }
      break;
    }
    case kClosingPrice: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.dataBody_.closingprice_;
      }
      break;
    }
    case kCurrencyRate: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.dataBody_.currencyrate_;
      }
      break;
    }
    case kDeleteOddLotOrder: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.dataBody_.deleteoddlotorder_;
      }
      break;
    }
    case kIndexData: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.dataBody_.indexdata_;
      }
      break;
    }
    case kIndexDefinition: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.dataBody_.indexdefinition_;
      }
      break;
    }
    case kIndicativeEquilibriumPrice: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.dataBody_.indicativeequilibriumprice_;
      }
      break;
    }
    case kLiquidityProvider: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.dataBody_.liquidityprovider_;
      }
      break;
    }
    case kMarketDefinition: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.dataBody_.marketdefinition_;
      }
      break;
    }
    case kMarketTurnover: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.dataBody_.marketturnover_;
      }
      break;
    }
    case kNews: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.dataBody_.news_;
      }
      break;
    }
    case kNominalPrice: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.dataBody_.nominalprice_;
      }
      break;
    }
    case kOrderImbalance: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.dataBody_.orderimbalance_;
      }
      break;
    }
    case kReferencePrice: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.dataBody_.referenceprice_;
      }
      break;
    }
    case kSecurityDefinition: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.dataBody_.securitydefinition_;
      }
      break;
    }
    case kSecurityStatus: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.dataBody_.securitystatus_;
      }
      break;
    }
    case kStatistics: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.dataBody_.statistics_;
      }
      break;
    }
    case kStockConnectDailyQuotaBalance: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.dataBody_.stockconnectdailyquotabalance_;
      }
      break;
    }
    case kStockConnectMarketTurnover: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.dataBody_.stockconnectmarketturnover_;
      }
      break;
    }
    case kTrade: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.dataBody_.trade_;
      }
      break;
    }
    case kTradeCancel: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.dataBody_.tradecancel_;
      }
      break;
    }
    case kTradingSessionStatus: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.dataBody_.tradingsessionstatus_;
      }
      break;
    }
    case kVCMTrigger: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.dataBody_.vcmtrigger_;
      }
      break;
    }
    case kYield: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.dataBody_.yield_;
      }
      break;
    }
    case kAdjustedClosingPrice: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.dataBody_.adjustedclosingprice_;
      }
      break;
    }
    case kDayTradeSummary: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.dataBody_.daytradesummary_;
      }
      break;
    }
    case kDayTradeSummaryNextShares: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.dataBody_.daytradesummarynextshares_;
      }
      break;
    }
    case kIPOInformation: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.dataBody_.ipoinformation_;
      }
      break;
    }
    case kIPOQuotingPeriodUpdate: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.dataBody_.ipoquotingperiodupdate_;
      }
      break;
    }
    case kLongAdjustedClosingPrice: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.dataBody_.longadjustedclosingprice_;
      }
      break;
    }
    case kLongDayTradeSummary: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.dataBody_.longdaytradesummary_;
      }
      break;
    }
    case kLongTradeCancelForNonNextSharesTrades: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.dataBody_.longtradecancelfornonnextsharestrades_;
      }
      break;
    }
    case kLongTradeCorrectionForNonNextsharesTrades: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.dataBody_.longtradecorrectionfornonnextsharestrades_;
      }
      break;
    }
    case kLongTradeReportForNonNextshares: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.dataBody_.longtradereportfornonnextshares_;
      }
      break;
    }
    case kMWCBStatusMessage: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.dataBody_.mwcbstatusmessage_;
      }
      break;
    }
    case kMarketWideCircuitBreaker: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.dataBody_.marketwidecircuitbreaker_;
      }
      break;
    }
    case kOperationalHalt: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.dataBody_.operationalhalt_;
      }
      break;
    }
    case kSaleConditionModifier: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.dataBody_.saleconditionmodifier_;
      }
      break;
    }
    case kShortSaleRestrictionIndicatorMessage: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.dataBody_.shortsalerestrictionindicatormessage_;
      }
      break;
    }
    case kStockDirectory: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.dataBody_.stockdirectory_;
      }
      break;
    }
    case kStockTradingAction: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.dataBody_.stocktradingaction_;
      }
      break;
    }
    case kSystemEventMessage: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.dataBody_.systemeventmessage_;
      }
      break;
    }
    case kTradeCancelForNextsharesTrades: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.dataBody_.tradecancelfornextsharestrades_;
      }
      break;
    }
    case kTradeCancelForNonNextSharesTrades: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.dataBody_.tradecancelfornonnextsharestrades_;
      }
      break;
    }
    case kTradeCorrectionForNextsharesTrades: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.dataBody_.tradecorrectionfornextsharestrades_;
      }
      break;
    }
    case kTradeCorrectionForNonNextsharesTrades: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.dataBody_.tradecorrectionfornonnextsharestrades_;
      }
      break;
    }
    case kTradeReportForNextshares: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.dataBody_.tradereportfornextshares_;
      }
      break;
    }
    case kTradeReportForNonNextshares: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.dataBody_.tradereportfornonnextshares_;
      }
      break;
    }
    case kQBBOMWCBBreachMessage: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.dataBody_.qbbomwcbbreachmessage_;
      }
      break;
    }
    case kQBBOMWCBDeclineLevelMessage: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.dataBody_.qbbomwcbdeclinelevelmessage_;
      }
      break;
    }
    case kQBBONextSharesQuotationMessage: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.dataBody_.qbbonextsharesquotationmessage_;
      }
      break;
    }
    case kQBBOOperationalHalt: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.dataBody_.qbbooperationalhalt_;
      }
      break;
    }
    case kQBBOQuotationMessage: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.dataBody_.qbboquotationmessage_;
      }
      break;
    }
    case kQBBORegShoRestriction: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.dataBody_.qbboregshorestriction_;
      }
      break;
    }
    case kQBBOStockDirectory: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.dataBody_.qbbostockdirectory_;
      }
      break;
    }
    case kQBBOStockTradingAction: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.dataBody_.qbbostocktradingaction_;
      }
      break;
    }
    case kQBBOSystemEventMessage: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.dataBody_.qbbosystemeventmessage_;
      }
      break;
    }
    case kQBBOIPOQuotingPeriodUpdate: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.dataBody_.qbboipoquotingperiodupdate_;
      }
      break;
    }
    case kCertificationMsg: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.dataBody_.certificationmsg_;
      }
      break;
    }
    case kCNMarketDefinition: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.dataBody_.cnmarketdefinition_;
      }
      break;
    }
    case kCNSecurityDefinition: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.dataBody_.cnsecuritydefinition_;
      }
      break;
    }
    case kCNSecurityStatus: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.dataBody_.cnsecuritystatus_;
      }
      break;
    }
    case kCNStatistics: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.dataBody_.cnstatistics_;
      }
      break;
    }
    case kCNTopBook: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.dataBody_.cntopbook_;
      }
      break;
    }
    case DATABODY_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = DATABODY_NOT_SET;
}


void Message::Clear() {
// @@protoc_insertion_point(message_clear_start:data.Message)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.timestamp_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.data_type_) -
        reinterpret_cast<char*>(&_impl_.timestamp_)) + sizeof(_impl_.data_type_));
  }
  clear_dataBody();
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Message::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .data.Message.DataType data_type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_data_type(static_cast<::data::Message_DataType>(val));
        } else
          goto handle_unusual;
        continue;
      // .data.AddOddLotOrder addOddLotOrder = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_addoddlotorder(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .data.AggregateOrderBookUpdate aggregateOrderBookUpdate = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_aggregateorderbookupdate(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .data.BrokerQueue brokerQueue = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_brokerqueue(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .data.ClosingPrice closingPrice = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_closingprice(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .data.CurrencyRate currencyRate = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_currencyrate(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .data.DeleteOddLotOrder deleteOddLotOrder = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_deleteoddlotorder(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .data.IndexData indexData = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_indexdata(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .data.IndexDefinition indexDefinition = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_indexdefinition(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .data.IndicativeEquilibriumPrice indicativeEquilibriumPrice = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_indicativeequilibriumprice(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .data.LiquidityProvider liquidityProvider = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_liquidityprovider(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .data.MarketDefinition marketDefinition = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          ptr = ctx->ParseMessage(_internal_mutable_marketdefinition(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .data.MarketTurnover marketTurnover = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
          ptr = ctx->ParseMessage(_internal_mutable_marketturnover(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .data.News news = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 114)) {
          ptr = ctx->ParseMessage(_internal_mutable_news(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .data.NominalPrice nominalPrice = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 122)) {
          ptr = ctx->ParseMessage(_internal_mutable_nominalprice(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .data.OrderImbalance orderImbalance = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 130)) {
          ptr = ctx->ParseMessage(_internal_mutable_orderimbalance(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .data.ReferencePrice referencePrice = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 138)) {
          ptr = ctx->ParseMessage(_internal_mutable_referenceprice(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .data.SecurityDefinition securityDefinition = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 146)) {
          ptr = ctx->ParseMessage(_internal_mutable_securitydefinition(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .data.SecurityStatus securityStatus = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 154)) {
          ptr = ctx->ParseMessage(_internal_mutable_securitystatus(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .data.Statistics statistics = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 162)) {
          ptr = ctx->ParseMessage(_internal_mutable_statistics(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .data.StockConnectDailyQuotaBalance stockConnectDailyQuotaBalance = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 170)) {
          ptr = ctx->ParseMessage(_internal_mutable_stockconnectdailyquotabalance(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .data.StockConnectMarketTurnover stockConnectMarketTurnover = 22;
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 178)) {
          ptr = ctx->ParseMessage(_internal_mutable_stockconnectmarketturnover(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .data.Trade trade = 23;
      case 23:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 186)) {
          ptr = ctx->ParseMessage(_internal_mutable_trade(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .data.TradeCancel tradeCancel = 24;
      case 24:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 194)) {
          ptr = ctx->ParseMessage(_internal_mutable_tradecancel(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .data.TradingSessionStatus tradingSessionStatus = 25;
      case 25:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 202)) {
          ptr = ctx->ParseMessage(_internal_mutable_tradingsessionstatus(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .data.VCMTrigger vCMTrigger = 26;
      case 26:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 210)) {
          ptr = ctx->ParseMessage(_internal_mutable_vcmtrigger(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .data.Yield yield = 27;
      case 27:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 218)) {
          ptr = ctx->ParseMessage(_internal_mutable_yield(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .data.AdjustedClosingPrice adjustedClosingPrice = 28;
      case 28:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 226)) {
          ptr = ctx->ParseMessage(_internal_mutable_adjustedclosingprice(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .data.DayTradeSummary dayTradeSummary = 29;
      case 29:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 234)) {
          ptr = ctx->ParseMessage(_internal_mutable_daytradesummary(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .data.DayTradeSummaryNextShares dayTradeSummaryNextShares = 30;
      case 30:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 242)) {
          ptr = ctx->ParseMessage(_internal_mutable_daytradesummarynextshares(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .data.IPOInformation iPOInformation = 31;
      case 31:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 250)) {
          ptr = ctx->ParseMessage(_internal_mutable_ipoinformation(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .data.IPOQuotingPeriodUpdate iPOQuotingPeriodUpdate = 32;
      case 32:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 2)) {
          ptr = ctx->ParseMessage(_internal_mutable_ipoquotingperiodupdate(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .data.LongAdjustedClosingPrice longAdjustedClosingPrice = 33;
      case 33:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_longadjustedclosingprice(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .data.LongDayTradeSummary longDayTradeSummary = 34;
      case 34:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_longdaytradesummary(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .data.LongTradeCancelForNonNextSharesTrades longTradeCancelForNonNextSharesTrades = 35;
      case 35:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_longtradecancelfornonnextsharestrades(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .data.LongTradeCorrectionForNonNextsharesTrades longTradeCorrectionForNonNextsharesTrades = 36;
      case 36:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_longtradecorrectionfornonnextsharestrades(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .data.LongTradeReportForNonNextshares longTradeReportForNonNextshares = 37;
      case 37:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_longtradereportfornonnextshares(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .data.MWCBStatusMessage mWCBStatusMessage = 38;
      case 38:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_mwcbstatusmessage(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .data.MarketWideCircuitBreaker marketWideCircuitBreaker = 39;
      case 39:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_marketwidecircuitbreaker(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .data.OperationalHalt operationalHalt = 40;
      case 40:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_operationalhalt(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .data.SaleConditionModifier saleConditionModifier = 41;
      case 41:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_saleconditionmodifier(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .data.ShortSaleRestrictionIndicatorMessage shortSaleRestrictionIndicatorMessage = 42;
      case 42:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_shortsalerestrictionindicatormessage(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .data.StockDirectory stockDirectory = 43;
      case 43:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_stockdirectory(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .data.StockTradingAction stockTradingAction = 44;
      case 44:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          ptr = ctx->ParseMessage(_internal_mutable_stocktradingaction(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .data.SystemEventMessage systemEventMessage = 45;
      case 45:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
          ptr = ctx->ParseMessage(_internal_mutable_systemeventmessage(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .data.TradeCancelForNextsharesTrades tradeCancelForNextsharesTrades = 46;
      case 46:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 114)) {
          ptr = ctx->ParseMessage(_internal_mutable_tradecancelfornextsharestrades(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .data.TradeCancelForNonNextSharesTrades tradeCancelForNonNextSharesTrades = 47;
      case 47:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 122)) {
          ptr = ctx->ParseMessage(_internal_mutable_tradecancelfornonnextsharestrades(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .data.TradeCorrectionForNextsharesTrades tradeCorrectionForNextsharesTrades = 48;
      case 48:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 130)) {
          ptr = ctx->ParseMessage(_internal_mutable_tradecorrectionfornextsharestrades(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .data.TradeCorrectionForNonNextsharesTrades tradeCorrectionForNonNextsharesTrades = 49;
      case 49:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 138)) {
          ptr = ctx->ParseMessage(_internal_mutable_tradecorrectionfornonnextsharestrades(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .data.TradeReportForNextshares tradeReportForNextshares = 50;
      case 50:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 146)) {
          ptr = ctx->ParseMessage(_internal_mutable_tradereportfornextshares(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .data.TradeReportForNonNextshares tradeReportForNonNextshares = 51;
      case 51:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 154)) {
          ptr = ctx->ParseMessage(_internal_mutable_tradereportfornonnextshares(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .data.QBBOMWCBBreachMessage qBBOMWCBBreachMessage = 52;
      case 52:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 162)) {
          ptr = ctx->ParseMessage(_internal_mutable_qbbomwcbbreachmessage(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .data.QBBOMWCBDeclineLevelMessage qBBOMWCBDeclineLevelMessage = 53;
      case 53:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 170)) {
          ptr = ctx->ParseMessage(_internal_mutable_qbbomwcbdeclinelevelmessage(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .data.QBBONextSharesQuotationMessage qBBONextSharesQuotationMessage = 54;
      case 54:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 178)) {
          ptr = ctx->ParseMessage(_internal_mutable_qbbonextsharesquotationmessage(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .data.QBBOOperationalHalt qBBOOperationalHalt = 55;
      case 55:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 186)) {
          ptr = ctx->ParseMessage(_internal_mutable_qbbooperationalhalt(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .data.QBBOQuotationMessage qBBOQuotationMessage = 56;
      case 56:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 194)) {
          ptr = ctx->ParseMessage(_internal_mutable_qbboquotationmessage(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .data.QBBORegShoRestriction qBBORegShoRestriction = 57;
      case 57:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 202)) {
          ptr = ctx->ParseMessage(_internal_mutable_qbboregshorestriction(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .data.QBBOStockDirectory qBBOStockDirectory = 58;
      case 58:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 210)) {
          ptr = ctx->ParseMessage(_internal_mutable_qbbostockdirectory(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .data.QBBOStockTradingAction qBBOStockTradingAction = 59;
      case 59:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 218)) {
          ptr = ctx->ParseMessage(_internal_mutable_qbbostocktradingaction(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .data.QBBOSystemEventMessage qBBOSystemEventMessage = 60;
      case 60:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 226)) {
          ptr = ctx->ParseMessage(_internal_mutable_qbbosystemeventmessage(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .data.QBBOIPOQuotingPeriodUpdate qBBOIPOQuotingPeriodUpdate = 61;
      case 61:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 234)) {
          ptr = ctx->ParseMessage(_internal_mutable_qbboipoquotingperiodupdate(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .data.CertificationMsg certificationMsg = 62;
      case 62:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 242)) {
          ptr = ctx->ParseMessage(_internal_mutable_certificationmsg(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .data.CNMarketDefinition cNMarketDefinition = 63;
      case 63:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 250)) {
          ptr = ctx->ParseMessage(_internal_mutable_cnmarketdefinition(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .data.CNSecurityDefinition cNSecurityDefinition = 64;
      case 64:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 2)) {
          ptr = ctx->ParseMessage(_internal_mutable_cnsecuritydefinition(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .data.CNSecurityStatus cNSecurityStatus = 65;
      case 65:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_cnsecuritystatus(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .data.CNStatistics cNStatistics = 66;
      case 66:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_cnstatistics(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .data.CNTopBook cNTopBook = 67;
      case 67:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_cntopbook(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 timestamp = 68;
      case 68:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_timestamp(&has_bits);
          _impl_.timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Message::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:data.Message)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional .data.Message.DataType data_type = 1;
  if (_internal_has_data_type()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_data_type(), target);
  }

  // .data.AddOddLotOrder addOddLotOrder = 2;
  if (_internal_has_addoddlotorder()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::addoddlotorder(this),
        _Internal::addoddlotorder(this).GetCachedSize(), target, stream);
  }

  // .data.AggregateOrderBookUpdate aggregateOrderBookUpdate = 3;
  if (_internal_has_aggregateorderbookupdate()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::aggregateorderbookupdate(this),
        _Internal::aggregateorderbookupdate(this).GetCachedSize(), target, stream);
  }

  // .data.BrokerQueue brokerQueue = 4;
  if (_internal_has_brokerqueue()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::brokerqueue(this),
        _Internal::brokerqueue(this).GetCachedSize(), target, stream);
  }

  // .data.ClosingPrice closingPrice = 5;
  if (_internal_has_closingprice()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::closingprice(this),
        _Internal::closingprice(this).GetCachedSize(), target, stream);
  }

  // .data.CurrencyRate currencyRate = 6;
  if (_internal_has_currencyrate()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::currencyrate(this),
        _Internal::currencyrate(this).GetCachedSize(), target, stream);
  }

  // .data.DeleteOddLotOrder deleteOddLotOrder = 7;
  if (_internal_has_deleteoddlotorder()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::deleteoddlotorder(this),
        _Internal::deleteoddlotorder(this).GetCachedSize(), target, stream);
  }

  // .data.IndexData indexData = 8;
  if (_internal_has_indexdata()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(8, _Internal::indexdata(this),
        _Internal::indexdata(this).GetCachedSize(), target, stream);
  }

  // .data.IndexDefinition indexDefinition = 9;
  if (_internal_has_indexdefinition()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(9, _Internal::indexdefinition(this),
        _Internal::indexdefinition(this).GetCachedSize(), target, stream);
  }

  // .data.IndicativeEquilibriumPrice indicativeEquilibriumPrice = 10;
  if (_internal_has_indicativeequilibriumprice()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(10, _Internal::indicativeequilibriumprice(this),
        _Internal::indicativeequilibriumprice(this).GetCachedSize(), target, stream);
  }

  // .data.LiquidityProvider liquidityProvider = 11;
  if (_internal_has_liquidityprovider()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(11, _Internal::liquidityprovider(this),
        _Internal::liquidityprovider(this).GetCachedSize(), target, stream);
  }

  // .data.MarketDefinition marketDefinition = 12;
  if (_internal_has_marketdefinition()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(12, _Internal::marketdefinition(this),
        _Internal::marketdefinition(this).GetCachedSize(), target, stream);
  }

  // .data.MarketTurnover marketTurnover = 13;
  if (_internal_has_marketturnover()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(13, _Internal::marketturnover(this),
        _Internal::marketturnover(this).GetCachedSize(), target, stream);
  }

  // .data.News news = 14;
  if (_internal_has_news()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(14, _Internal::news(this),
        _Internal::news(this).GetCachedSize(), target, stream);
  }

  // .data.NominalPrice nominalPrice = 15;
  if (_internal_has_nominalprice()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(15, _Internal::nominalprice(this),
        _Internal::nominalprice(this).GetCachedSize(), target, stream);
  }

  // .data.OrderImbalance orderImbalance = 16;
  if (_internal_has_orderimbalance()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(16, _Internal::orderimbalance(this),
        _Internal::orderimbalance(this).GetCachedSize(), target, stream);
  }

  // .data.ReferencePrice referencePrice = 17;
  if (_internal_has_referenceprice()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(17, _Internal::referenceprice(this),
        _Internal::referenceprice(this).GetCachedSize(), target, stream);
  }

  // .data.SecurityDefinition securityDefinition = 18;
  if (_internal_has_securitydefinition()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(18, _Internal::securitydefinition(this),
        _Internal::securitydefinition(this).GetCachedSize(), target, stream);
  }

  // .data.SecurityStatus securityStatus = 19;
  if (_internal_has_securitystatus()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(19, _Internal::securitystatus(this),
        _Internal::securitystatus(this).GetCachedSize(), target, stream);
  }

  // .data.Statistics statistics = 20;
  if (_internal_has_statistics()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(20, _Internal::statistics(this),
        _Internal::statistics(this).GetCachedSize(), target, stream);
  }

  // .data.StockConnectDailyQuotaBalance stockConnectDailyQuotaBalance = 21;
  if (_internal_has_stockconnectdailyquotabalance()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(21, _Internal::stockconnectdailyquotabalance(this),
        _Internal::stockconnectdailyquotabalance(this).GetCachedSize(), target, stream);
  }

  // .data.StockConnectMarketTurnover stockConnectMarketTurnover = 22;
  if (_internal_has_stockconnectmarketturnover()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(22, _Internal::stockconnectmarketturnover(this),
        _Internal::stockconnectmarketturnover(this).GetCachedSize(), target, stream);
  }

  // .data.Trade trade = 23;
  if (_internal_has_trade()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(23, _Internal::trade(this),
        _Internal::trade(this).GetCachedSize(), target, stream);
  }

  // .data.TradeCancel tradeCancel = 24;
  if (_internal_has_tradecancel()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(24, _Internal::tradecancel(this),
        _Internal::tradecancel(this).GetCachedSize(), target, stream);
  }

  // .data.TradingSessionStatus tradingSessionStatus = 25;
  if (_internal_has_tradingsessionstatus()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(25, _Internal::tradingsessionstatus(this),
        _Internal::tradingsessionstatus(this).GetCachedSize(), target, stream);
  }

  // .data.VCMTrigger vCMTrigger = 26;
  if (_internal_has_vcmtrigger()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(26, _Internal::vcmtrigger(this),
        _Internal::vcmtrigger(this).GetCachedSize(), target, stream);
  }

  // .data.Yield yield = 27;
  if (_internal_has_yield()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(27, _Internal::yield(this),
        _Internal::yield(this).GetCachedSize(), target, stream);
  }

  // .data.AdjustedClosingPrice adjustedClosingPrice = 28;
  if (_internal_has_adjustedclosingprice()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(28, _Internal::adjustedclosingprice(this),
        _Internal::adjustedclosingprice(this).GetCachedSize(), target, stream);
  }

  // .data.DayTradeSummary dayTradeSummary = 29;
  if (_internal_has_daytradesummary()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(29, _Internal::daytradesummary(this),
        _Internal::daytradesummary(this).GetCachedSize(), target, stream);
  }

  // .data.DayTradeSummaryNextShares dayTradeSummaryNextShares = 30;
  if (_internal_has_daytradesummarynextshares()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(30, _Internal::daytradesummarynextshares(this),
        _Internal::daytradesummarynextshares(this).GetCachedSize(), target, stream);
  }

  // .data.IPOInformation iPOInformation = 31;
  if (_internal_has_ipoinformation()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(31, _Internal::ipoinformation(this),
        _Internal::ipoinformation(this).GetCachedSize(), target, stream);
  }

  // .data.IPOQuotingPeriodUpdate iPOQuotingPeriodUpdate = 32;
  if (_internal_has_ipoquotingperiodupdate()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(32, _Internal::ipoquotingperiodupdate(this),
        _Internal::ipoquotingperiodupdate(this).GetCachedSize(), target, stream);
  }

  // .data.LongAdjustedClosingPrice longAdjustedClosingPrice = 33;
  if (_internal_has_longadjustedclosingprice()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(33, _Internal::longadjustedclosingprice(this),
        _Internal::longadjustedclosingprice(this).GetCachedSize(), target, stream);
  }

  // .data.LongDayTradeSummary longDayTradeSummary = 34;
  if (_internal_has_longdaytradesummary()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(34, _Internal::longdaytradesummary(this),
        _Internal::longdaytradesummary(this).GetCachedSize(), target, stream);
  }

  // .data.LongTradeCancelForNonNextSharesTrades longTradeCancelForNonNextSharesTrades = 35;
  if (_internal_has_longtradecancelfornonnextsharestrades()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(35, _Internal::longtradecancelfornonnextsharestrades(this),
        _Internal::longtradecancelfornonnextsharestrades(this).GetCachedSize(), target, stream);
  }

  // .data.LongTradeCorrectionForNonNextsharesTrades longTradeCorrectionForNonNextsharesTrades = 36;
  if (_internal_has_longtradecorrectionfornonnextsharestrades()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(36, _Internal::longtradecorrectionfornonnextsharestrades(this),
        _Internal::longtradecorrectionfornonnextsharestrades(this).GetCachedSize(), target, stream);
  }

  // .data.LongTradeReportForNonNextshares longTradeReportForNonNextshares = 37;
  if (_internal_has_longtradereportfornonnextshares()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(37, _Internal::longtradereportfornonnextshares(this),
        _Internal::longtradereportfornonnextshares(this).GetCachedSize(), target, stream);
  }

  // .data.MWCBStatusMessage mWCBStatusMessage = 38;
  if (_internal_has_mwcbstatusmessage()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(38, _Internal::mwcbstatusmessage(this),
        _Internal::mwcbstatusmessage(this).GetCachedSize(), target, stream);
  }

  // .data.MarketWideCircuitBreaker marketWideCircuitBreaker = 39;
  if (_internal_has_marketwidecircuitbreaker()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(39, _Internal::marketwidecircuitbreaker(this),
        _Internal::marketwidecircuitbreaker(this).GetCachedSize(), target, stream);
  }

  // .data.OperationalHalt operationalHalt = 40;
  if (_internal_has_operationalhalt()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(40, _Internal::operationalhalt(this),
        _Internal::operationalhalt(this).GetCachedSize(), target, stream);
  }

  // .data.SaleConditionModifier saleConditionModifier = 41;
  if (_internal_has_saleconditionmodifier()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(41, _Internal::saleconditionmodifier(this),
        _Internal::saleconditionmodifier(this).GetCachedSize(), target, stream);
  }

  // .data.ShortSaleRestrictionIndicatorMessage shortSaleRestrictionIndicatorMessage = 42;
  if (_internal_has_shortsalerestrictionindicatormessage()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(42, _Internal::shortsalerestrictionindicatormessage(this),
        _Internal::shortsalerestrictionindicatormessage(this).GetCachedSize(), target, stream);
  }

  // .data.StockDirectory stockDirectory = 43;
  if (_internal_has_stockdirectory()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(43, _Internal::stockdirectory(this),
        _Internal::stockdirectory(this).GetCachedSize(), target, stream);
  }

  // .data.StockTradingAction stockTradingAction = 44;
  if (_internal_has_stocktradingaction()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(44, _Internal::stocktradingaction(this),
        _Internal::stocktradingaction(this).GetCachedSize(), target, stream);
  }

  // .data.SystemEventMessage systemEventMessage = 45;
  if (_internal_has_systemeventmessage()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(45, _Internal::systemeventmessage(this),
        _Internal::systemeventmessage(this).GetCachedSize(), target, stream);
  }

  // .data.TradeCancelForNextsharesTrades tradeCancelForNextsharesTrades = 46;
  if (_internal_has_tradecancelfornextsharestrades()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(46, _Internal::tradecancelfornextsharestrades(this),
        _Internal::tradecancelfornextsharestrades(this).GetCachedSize(), target, stream);
  }

  // .data.TradeCancelForNonNextSharesTrades tradeCancelForNonNextSharesTrades = 47;
  if (_internal_has_tradecancelfornonnextsharestrades()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(47, _Internal::tradecancelfornonnextsharestrades(this),
        _Internal::tradecancelfornonnextsharestrades(this).GetCachedSize(), target, stream);
  }

  // .data.TradeCorrectionForNextsharesTrades tradeCorrectionForNextsharesTrades = 48;
  if (_internal_has_tradecorrectionfornextsharestrades()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(48, _Internal::tradecorrectionfornextsharestrades(this),
        _Internal::tradecorrectionfornextsharestrades(this).GetCachedSize(), target, stream);
  }

  // .data.TradeCorrectionForNonNextsharesTrades tradeCorrectionForNonNextsharesTrades = 49;
  if (_internal_has_tradecorrectionfornonnextsharestrades()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(49, _Internal::tradecorrectionfornonnextsharestrades(this),
        _Internal::tradecorrectionfornonnextsharestrades(this).GetCachedSize(), target, stream);
  }

  // .data.TradeReportForNextshares tradeReportForNextshares = 50;
  if (_internal_has_tradereportfornextshares()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(50, _Internal::tradereportfornextshares(this),
        _Internal::tradereportfornextshares(this).GetCachedSize(), target, stream);
  }

  // .data.TradeReportForNonNextshares tradeReportForNonNextshares = 51;
  if (_internal_has_tradereportfornonnextshares()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(51, _Internal::tradereportfornonnextshares(this),
        _Internal::tradereportfornonnextshares(this).GetCachedSize(), target, stream);
  }

  // .data.QBBOMWCBBreachMessage qBBOMWCBBreachMessage = 52;
  if (_internal_has_qbbomwcbbreachmessage()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(52, _Internal::qbbomwcbbreachmessage(this),
        _Internal::qbbomwcbbreachmessage(this).GetCachedSize(), target, stream);
  }

  // .data.QBBOMWCBDeclineLevelMessage qBBOMWCBDeclineLevelMessage = 53;
  if (_internal_has_qbbomwcbdeclinelevelmessage()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(53, _Internal::qbbomwcbdeclinelevelmessage(this),
        _Internal::qbbomwcbdeclinelevelmessage(this).GetCachedSize(), target, stream);
  }

  // .data.QBBONextSharesQuotationMessage qBBONextSharesQuotationMessage = 54;
  if (_internal_has_qbbonextsharesquotationmessage()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(54, _Internal::qbbonextsharesquotationmessage(this),
        _Internal::qbbonextsharesquotationmessage(this).GetCachedSize(), target, stream);
  }

  // .data.QBBOOperationalHalt qBBOOperationalHalt = 55;
  if (_internal_has_qbbooperationalhalt()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(55, _Internal::qbbooperationalhalt(this),
        _Internal::qbbooperationalhalt(this).GetCachedSize(), target, stream);
  }

  // .data.QBBOQuotationMessage qBBOQuotationMessage = 56;
  if (_internal_has_qbboquotationmessage()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(56, _Internal::qbboquotationmessage(this),
        _Internal::qbboquotationmessage(this).GetCachedSize(), target, stream);
  }

  // .data.QBBORegShoRestriction qBBORegShoRestriction = 57;
  if (_internal_has_qbboregshorestriction()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(57, _Internal::qbboregshorestriction(this),
        _Internal::qbboregshorestriction(this).GetCachedSize(), target, stream);
  }

  // .data.QBBOStockDirectory qBBOStockDirectory = 58;
  if (_internal_has_qbbostockdirectory()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(58, _Internal::qbbostockdirectory(this),
        _Internal::qbbostockdirectory(this).GetCachedSize(), target, stream);
  }

  // .data.QBBOStockTradingAction qBBOStockTradingAction = 59;
  if (_internal_has_qbbostocktradingaction()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(59, _Internal::qbbostocktradingaction(this),
        _Internal::qbbostocktradingaction(this).GetCachedSize(), target, stream);
  }

  // .data.QBBOSystemEventMessage qBBOSystemEventMessage = 60;
  if (_internal_has_qbbosystemeventmessage()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(60, _Internal::qbbosystemeventmessage(this),
        _Internal::qbbosystemeventmessage(this).GetCachedSize(), target, stream);
  }

  // .data.QBBOIPOQuotingPeriodUpdate qBBOIPOQuotingPeriodUpdate = 61;
  if (_internal_has_qbboipoquotingperiodupdate()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(61, _Internal::qbboipoquotingperiodupdate(this),
        _Internal::qbboipoquotingperiodupdate(this).GetCachedSize(), target, stream);
  }

  // .data.CertificationMsg certificationMsg = 62;
  if (_internal_has_certificationmsg()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(62, _Internal::certificationmsg(this),
        _Internal::certificationmsg(this).GetCachedSize(), target, stream);
  }

  // .data.CNMarketDefinition cNMarketDefinition = 63;
  if (_internal_has_cnmarketdefinition()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(63, _Internal::cnmarketdefinition(this),
        _Internal::cnmarketdefinition(this).GetCachedSize(), target, stream);
  }

  // .data.CNSecurityDefinition cNSecurityDefinition = 64;
  if (_internal_has_cnsecuritydefinition()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(64, _Internal::cnsecuritydefinition(this),
        _Internal::cnsecuritydefinition(this).GetCachedSize(), target, stream);
  }

  // .data.CNSecurityStatus cNSecurityStatus = 65;
  if (_internal_has_cnsecuritystatus()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(65, _Internal::cnsecuritystatus(this),
        _Internal::cnsecuritystatus(this).GetCachedSize(), target, stream);
  }

  // .data.CNStatistics cNStatistics = 66;
  if (_internal_has_cnstatistics()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(66, _Internal::cnstatistics(this),
        _Internal::cnstatistics(this).GetCachedSize(), target, stream);
  }

  // .data.CNTopBook cNTopBook = 67;
  if (_internal_has_cntopbook()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(67, _Internal::cntopbook(this),
        _Internal::cntopbook(this).GetCachedSize(), target, stream);
  }

  // optional int64 timestamp = 68;
  if (_internal_has_timestamp()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(68, this->_internal_timestamp(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:data.Message)
  return target;
}

size_t Message::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:data.Message)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional int64 timestamp = 68;
    if (cached_has_bits & 0x00000001u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int64Size(
          this->_internal_timestamp());
    }

    // optional .data.Message.DataType data_type = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_data_type());
    }

  }
  switch (dataBody_case()) {
    // .data.AddOddLotOrder addOddLotOrder = 2;
    case kAddOddLotOrder: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.dataBody_.addoddlotorder_);
      break;
    }
    // .data.AggregateOrderBookUpdate aggregateOrderBookUpdate = 3;
    case kAggregateOrderBookUpdate: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.dataBody_.aggregateorderbookupdate_);
      break;
    }
    // .data.BrokerQueue brokerQueue = 4;
    case kBrokerQueue: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.dataBody_.brokerqueue_);
      break;
    }
    // .data.ClosingPrice closingPrice = 5;
    case kClosingPrice: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.dataBody_.closingprice_);
      break;
    }
    // .data.CurrencyRate currencyRate = 6;
    case kCurrencyRate: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.dataBody_.currencyrate_);
      break;
    }
    // .data.DeleteOddLotOrder deleteOddLotOrder = 7;
    case kDeleteOddLotOrder: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.dataBody_.deleteoddlotorder_);
      break;
    }
    // .data.IndexData indexData = 8;
    case kIndexData: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.dataBody_.indexdata_);
      break;
    }
    // .data.IndexDefinition indexDefinition = 9;
    case kIndexDefinition: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.dataBody_.indexdefinition_);
      break;
    }
    // .data.IndicativeEquilibriumPrice indicativeEquilibriumPrice = 10;
    case kIndicativeEquilibriumPrice: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.dataBody_.indicativeequilibriumprice_);
      break;
    }
    // .data.LiquidityProvider liquidityProvider = 11;
    case kLiquidityProvider: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.dataBody_.liquidityprovider_);
      break;
    }
    // .data.MarketDefinition marketDefinition = 12;
    case kMarketDefinition: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.dataBody_.marketdefinition_);
      break;
    }
    // .data.MarketTurnover marketTurnover = 13;
    case kMarketTurnover: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.dataBody_.marketturnover_);
      break;
    }
    // .data.News news = 14;
    case kNews: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.dataBody_.news_);
      break;
    }
    // .data.NominalPrice nominalPrice = 15;
    case kNominalPrice: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.dataBody_.nominalprice_);
      break;
    }
    // .data.OrderImbalance orderImbalance = 16;
    case kOrderImbalance: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.dataBody_.orderimbalance_);
      break;
    }
    // .data.ReferencePrice referencePrice = 17;
    case kReferencePrice: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.dataBody_.referenceprice_);
      break;
    }
    // .data.SecurityDefinition securityDefinition = 18;
    case kSecurityDefinition: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.dataBody_.securitydefinition_);
      break;
    }
    // .data.SecurityStatus securityStatus = 19;
    case kSecurityStatus: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.dataBody_.securitystatus_);
      break;
    }
    // .data.Statistics statistics = 20;
    case kStatistics: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.dataBody_.statistics_);
      break;
    }
    // .data.StockConnectDailyQuotaBalance stockConnectDailyQuotaBalance = 21;
    case kStockConnectDailyQuotaBalance: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.dataBody_.stockconnectdailyquotabalance_);
      break;
    }
    // .data.StockConnectMarketTurnover stockConnectMarketTurnover = 22;
    case kStockConnectMarketTurnover: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.dataBody_.stockconnectmarketturnover_);
      break;
    }
    // .data.Trade trade = 23;
    case kTrade: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.dataBody_.trade_);
      break;
    }
    // .data.TradeCancel tradeCancel = 24;
    case kTradeCancel: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.dataBody_.tradecancel_);
      break;
    }
    // .data.TradingSessionStatus tradingSessionStatus = 25;
    case kTradingSessionStatus: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.dataBody_.tradingsessionstatus_);
      break;
    }
    // .data.VCMTrigger vCMTrigger = 26;
    case kVCMTrigger: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.dataBody_.vcmtrigger_);
      break;
    }
    // .data.Yield yield = 27;
    case kYield: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.dataBody_.yield_);
      break;
    }
    // .data.AdjustedClosingPrice adjustedClosingPrice = 28;
    case kAdjustedClosingPrice: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.dataBody_.adjustedclosingprice_);
      break;
    }
    // .data.DayTradeSummary dayTradeSummary = 29;
    case kDayTradeSummary: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.dataBody_.daytradesummary_);
      break;
    }
    // .data.DayTradeSummaryNextShares dayTradeSummaryNextShares = 30;
    case kDayTradeSummaryNextShares: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.dataBody_.daytradesummarynextshares_);
      break;
    }
    // .data.IPOInformation iPOInformation = 31;
    case kIPOInformation: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.dataBody_.ipoinformation_);
      break;
    }
    // .data.IPOQuotingPeriodUpdate iPOQuotingPeriodUpdate = 32;
    case kIPOQuotingPeriodUpdate: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.dataBody_.ipoquotingperiodupdate_);
      break;
    }
    // .data.LongAdjustedClosingPrice longAdjustedClosingPrice = 33;
    case kLongAdjustedClosingPrice: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.dataBody_.longadjustedclosingprice_);
      break;
    }
    // .data.LongDayTradeSummary longDayTradeSummary = 34;
    case kLongDayTradeSummary: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.dataBody_.longdaytradesummary_);
      break;
    }
    // .data.LongTradeCancelForNonNextSharesTrades longTradeCancelForNonNextSharesTrades = 35;
    case kLongTradeCancelForNonNextSharesTrades: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.dataBody_.longtradecancelfornonnextsharestrades_);
      break;
    }
    // .data.LongTradeCorrectionForNonNextsharesTrades longTradeCorrectionForNonNextsharesTrades = 36;
    case kLongTradeCorrectionForNonNextsharesTrades: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.dataBody_.longtradecorrectionfornonnextsharestrades_);
      break;
    }
    // .data.LongTradeReportForNonNextshares longTradeReportForNonNextshares = 37;
    case kLongTradeReportForNonNextshares: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.dataBody_.longtradereportfornonnextshares_);
      break;
    }
    // .data.MWCBStatusMessage mWCBStatusMessage = 38;
    case kMWCBStatusMessage: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.dataBody_.mwcbstatusmessage_);
      break;
    }
    // .data.MarketWideCircuitBreaker marketWideCircuitBreaker = 39;
    case kMarketWideCircuitBreaker: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.dataBody_.marketwidecircuitbreaker_);
      break;
    }
    // .data.OperationalHalt operationalHalt = 40;
    case kOperationalHalt: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.dataBody_.operationalhalt_);
      break;
    }
    // .data.SaleConditionModifier saleConditionModifier = 41;
    case kSaleConditionModifier: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.dataBody_.saleconditionmodifier_);
      break;
    }
    // .data.ShortSaleRestrictionIndicatorMessage shortSaleRestrictionIndicatorMessage = 42;
    case kShortSaleRestrictionIndicatorMessage: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.dataBody_.shortsalerestrictionindicatormessage_);
      break;
    }
    // .data.StockDirectory stockDirectory = 43;
    case kStockDirectory: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.dataBody_.stockdirectory_);
      break;
    }
    // .data.StockTradingAction stockTradingAction = 44;
    case kStockTradingAction: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.dataBody_.stocktradingaction_);
      break;
    }
    // .data.SystemEventMessage systemEventMessage = 45;
    case kSystemEventMessage: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.dataBody_.systemeventmessage_);
      break;
    }
    // .data.TradeCancelForNextsharesTrades tradeCancelForNextsharesTrades = 46;
    case kTradeCancelForNextsharesTrades: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.dataBody_.tradecancelfornextsharestrades_);
      break;
    }
    // .data.TradeCancelForNonNextSharesTrades tradeCancelForNonNextSharesTrades = 47;
    case kTradeCancelForNonNextSharesTrades: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.dataBody_.tradecancelfornonnextsharestrades_);
      break;
    }
    // .data.TradeCorrectionForNextsharesTrades tradeCorrectionForNextsharesTrades = 48;
    case kTradeCorrectionForNextsharesTrades: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.dataBody_.tradecorrectionfornextsharestrades_);
      break;
    }
    // .data.TradeCorrectionForNonNextsharesTrades tradeCorrectionForNonNextsharesTrades = 49;
    case kTradeCorrectionForNonNextsharesTrades: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.dataBody_.tradecorrectionfornonnextsharestrades_);
      break;
    }
    // .data.TradeReportForNextshares tradeReportForNextshares = 50;
    case kTradeReportForNextshares: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.dataBody_.tradereportfornextshares_);
      break;
    }
    // .data.TradeReportForNonNextshares tradeReportForNonNextshares = 51;
    case kTradeReportForNonNextshares: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.dataBody_.tradereportfornonnextshares_);
      break;
    }
    // .data.QBBOMWCBBreachMessage qBBOMWCBBreachMessage = 52;
    case kQBBOMWCBBreachMessage: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.dataBody_.qbbomwcbbreachmessage_);
      break;
    }
    // .data.QBBOMWCBDeclineLevelMessage qBBOMWCBDeclineLevelMessage = 53;
    case kQBBOMWCBDeclineLevelMessage: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.dataBody_.qbbomwcbdeclinelevelmessage_);
      break;
    }
    // .data.QBBONextSharesQuotationMessage qBBONextSharesQuotationMessage = 54;
    case kQBBONextSharesQuotationMessage: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.dataBody_.qbbonextsharesquotationmessage_);
      break;
    }
    // .data.QBBOOperationalHalt qBBOOperationalHalt = 55;
    case kQBBOOperationalHalt: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.dataBody_.qbbooperationalhalt_);
      break;
    }
    // .data.QBBOQuotationMessage qBBOQuotationMessage = 56;
    case kQBBOQuotationMessage: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.dataBody_.qbboquotationmessage_);
      break;
    }
    // .data.QBBORegShoRestriction qBBORegShoRestriction = 57;
    case kQBBORegShoRestriction: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.dataBody_.qbboregshorestriction_);
      break;
    }
    // .data.QBBOStockDirectory qBBOStockDirectory = 58;
    case kQBBOStockDirectory: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.dataBody_.qbbostockdirectory_);
      break;
    }
    // .data.QBBOStockTradingAction qBBOStockTradingAction = 59;
    case kQBBOStockTradingAction: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.dataBody_.qbbostocktradingaction_);
      break;
    }
    // .data.QBBOSystemEventMessage qBBOSystemEventMessage = 60;
    case kQBBOSystemEventMessage: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.dataBody_.qbbosystemeventmessage_);
      break;
    }
    // .data.QBBOIPOQuotingPeriodUpdate qBBOIPOQuotingPeriodUpdate = 61;
    case kQBBOIPOQuotingPeriodUpdate: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.dataBody_.qbboipoquotingperiodupdate_);
      break;
    }
    // .data.CertificationMsg certificationMsg = 62;
    case kCertificationMsg: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.dataBody_.certificationmsg_);
      break;
    }
    // .data.CNMarketDefinition cNMarketDefinition = 63;
    case kCNMarketDefinition: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.dataBody_.cnmarketdefinition_);
      break;
    }
    // .data.CNSecurityDefinition cNSecurityDefinition = 64;
    case kCNSecurityDefinition: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.dataBody_.cnsecuritydefinition_);
      break;
    }
    // .data.CNSecurityStatus cNSecurityStatus = 65;
    case kCNSecurityStatus: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.dataBody_.cnsecuritystatus_);
      break;
    }
    // .data.CNStatistics cNStatistics = 66;
    case kCNStatistics: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.dataBody_.cnstatistics_);
      break;
    }
    // .data.CNTopBook cNTopBook = 67;
    case kCNTopBook: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.dataBody_.cntopbook_);
      break;
    }
    case DATABODY_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Message::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Message::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Message::GetClassData() const { return &_class_data_; }


void Message::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Message*>(&to_msg);
  auto& from = static_cast<const Message&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:data.Message)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.timestamp_ = from._impl_.timestamp_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.data_type_ = from._impl_.data_type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  switch (from.dataBody_case()) {
    case kAddOddLotOrder: {
      _this->_internal_mutable_addoddlotorder()->::data::AddOddLotOrder::MergeFrom(
          from._internal_addoddlotorder());
      break;
    }
    case kAggregateOrderBookUpdate: {
      _this->_internal_mutable_aggregateorderbookupdate()->::data::AggregateOrderBookUpdate::MergeFrom(
          from._internal_aggregateorderbookupdate());
      break;
    }
    case kBrokerQueue: {
      _this->_internal_mutable_brokerqueue()->::data::BrokerQueue::MergeFrom(
          from._internal_brokerqueue());
      break;
    }
    case kClosingPrice: {
      _this->_internal_mutable_closingprice()->::data::ClosingPrice::MergeFrom(
          from._internal_closingprice());
      break;
    }
    case kCurrencyRate: {
      _this->_internal_mutable_currencyrate()->::data::CurrencyRate::MergeFrom(
          from._internal_currencyrate());
      break;
    }
    case kDeleteOddLotOrder: {
      _this->_internal_mutable_deleteoddlotorder()->::data::DeleteOddLotOrder::MergeFrom(
          from._internal_deleteoddlotorder());
      break;
    }
    case kIndexData: {
      _this->_internal_mutable_indexdata()->::data::IndexData::MergeFrom(
          from._internal_indexdata());
      break;
    }
    case kIndexDefinition: {
      _this->_internal_mutable_indexdefinition()->::data::IndexDefinition::MergeFrom(
          from._internal_indexdefinition());
      break;
    }
    case kIndicativeEquilibriumPrice: {
      _this->_internal_mutable_indicativeequilibriumprice()->::data::IndicativeEquilibriumPrice::MergeFrom(
          from._internal_indicativeequilibriumprice());
      break;
    }
    case kLiquidityProvider: {
      _this->_internal_mutable_liquidityprovider()->::data::LiquidityProvider::MergeFrom(
          from._internal_liquidityprovider());
      break;
    }
    case kMarketDefinition: {
      _this->_internal_mutable_marketdefinition()->::data::MarketDefinition::MergeFrom(
          from._internal_marketdefinition());
      break;
    }
    case kMarketTurnover: {
      _this->_internal_mutable_marketturnover()->::data::MarketTurnover::MergeFrom(
          from._internal_marketturnover());
      break;
    }
    case kNews: {
      _this->_internal_mutable_news()->::data::News::MergeFrom(
          from._internal_news());
      break;
    }
    case kNominalPrice: {
      _this->_internal_mutable_nominalprice()->::data::NominalPrice::MergeFrom(
          from._internal_nominalprice());
      break;
    }
    case kOrderImbalance: {
      _this->_internal_mutable_orderimbalance()->::data::OrderImbalance::MergeFrom(
          from._internal_orderimbalance());
      break;
    }
    case kReferencePrice: {
      _this->_internal_mutable_referenceprice()->::data::ReferencePrice::MergeFrom(
          from._internal_referenceprice());
      break;
    }
    case kSecurityDefinition: {
      _this->_internal_mutable_securitydefinition()->::data::SecurityDefinition::MergeFrom(
          from._internal_securitydefinition());
      break;
    }
    case kSecurityStatus: {
      _this->_internal_mutable_securitystatus()->::data::SecurityStatus::MergeFrom(
          from._internal_securitystatus());
      break;
    }
    case kStatistics: {
      _this->_internal_mutable_statistics()->::data::Statistics::MergeFrom(
          from._internal_statistics());
      break;
    }
    case kStockConnectDailyQuotaBalance: {
      _this->_internal_mutable_stockconnectdailyquotabalance()->::data::StockConnectDailyQuotaBalance::MergeFrom(
          from._internal_stockconnectdailyquotabalance());
      break;
    }
    case kStockConnectMarketTurnover: {
      _this->_internal_mutable_stockconnectmarketturnover()->::data::StockConnectMarketTurnover::MergeFrom(
          from._internal_stockconnectmarketturnover());
      break;
    }
    case kTrade: {
      _this->_internal_mutable_trade()->::data::Trade::MergeFrom(
          from._internal_trade());
      break;
    }
    case kTradeCancel: {
      _this->_internal_mutable_tradecancel()->::data::TradeCancel::MergeFrom(
          from._internal_tradecancel());
      break;
    }
    case kTradingSessionStatus: {
      _this->_internal_mutable_tradingsessionstatus()->::data::TradingSessionStatus::MergeFrom(
          from._internal_tradingsessionstatus());
      break;
    }
    case kVCMTrigger: {
      _this->_internal_mutable_vcmtrigger()->::data::VCMTrigger::MergeFrom(
          from._internal_vcmtrigger());
      break;
    }
    case kYield: {
      _this->_internal_mutable_yield()->::data::Yield::MergeFrom(
          from._internal_yield());
      break;
    }
    case kAdjustedClosingPrice: {
      _this->_internal_mutable_adjustedclosingprice()->::data::AdjustedClosingPrice::MergeFrom(
          from._internal_adjustedclosingprice());
      break;
    }
    case kDayTradeSummary: {
      _this->_internal_mutable_daytradesummary()->::data::DayTradeSummary::MergeFrom(
          from._internal_daytradesummary());
      break;
    }
    case kDayTradeSummaryNextShares: {
      _this->_internal_mutable_daytradesummarynextshares()->::data::DayTradeSummaryNextShares::MergeFrom(
          from._internal_daytradesummarynextshares());
      break;
    }
    case kIPOInformation: {
      _this->_internal_mutable_ipoinformation()->::data::IPOInformation::MergeFrom(
          from._internal_ipoinformation());
      break;
    }
    case kIPOQuotingPeriodUpdate: {
      _this->_internal_mutable_ipoquotingperiodupdate()->::data::IPOQuotingPeriodUpdate::MergeFrom(
          from._internal_ipoquotingperiodupdate());
      break;
    }
    case kLongAdjustedClosingPrice: {
      _this->_internal_mutable_longadjustedclosingprice()->::data::LongAdjustedClosingPrice::MergeFrom(
          from._internal_longadjustedclosingprice());
      break;
    }
    case kLongDayTradeSummary: {
      _this->_internal_mutable_longdaytradesummary()->::data::LongDayTradeSummary::MergeFrom(
          from._internal_longdaytradesummary());
      break;
    }
    case kLongTradeCancelForNonNextSharesTrades: {
      _this->_internal_mutable_longtradecancelfornonnextsharestrades()->::data::LongTradeCancelForNonNextSharesTrades::MergeFrom(
          from._internal_longtradecancelfornonnextsharestrades());
      break;
    }
    case kLongTradeCorrectionForNonNextsharesTrades: {
      _this->_internal_mutable_longtradecorrectionfornonnextsharestrades()->::data::LongTradeCorrectionForNonNextsharesTrades::MergeFrom(
          from._internal_longtradecorrectionfornonnextsharestrades());
      break;
    }
    case kLongTradeReportForNonNextshares: {
      _this->_internal_mutable_longtradereportfornonnextshares()->::data::LongTradeReportForNonNextshares::MergeFrom(
          from._internal_longtradereportfornonnextshares());
      break;
    }
    case kMWCBStatusMessage: {
      _this->_internal_mutable_mwcbstatusmessage()->::data::MWCBStatusMessage::MergeFrom(
          from._internal_mwcbstatusmessage());
      break;
    }
    case kMarketWideCircuitBreaker: {
      _this->_internal_mutable_marketwidecircuitbreaker()->::data::MarketWideCircuitBreaker::MergeFrom(
          from._internal_marketwidecircuitbreaker());
      break;
    }
    case kOperationalHalt: {
      _this->_internal_mutable_operationalhalt()->::data::OperationalHalt::MergeFrom(
          from._internal_operationalhalt());
      break;
    }
    case kSaleConditionModifier: {
      _this->_internal_mutable_saleconditionmodifier()->::data::SaleConditionModifier::MergeFrom(
          from._internal_saleconditionmodifier());
      break;
    }
    case kShortSaleRestrictionIndicatorMessage: {
      _this->_internal_mutable_shortsalerestrictionindicatormessage()->::data::ShortSaleRestrictionIndicatorMessage::MergeFrom(
          from._internal_shortsalerestrictionindicatormessage());
      break;
    }
    case kStockDirectory: {
      _this->_internal_mutable_stockdirectory()->::data::StockDirectory::MergeFrom(
          from._internal_stockdirectory());
      break;
    }
    case kStockTradingAction: {
      _this->_internal_mutable_stocktradingaction()->::data::StockTradingAction::MergeFrom(
          from._internal_stocktradingaction());
      break;
    }
    case kSystemEventMessage: {
      _this->_internal_mutable_systemeventmessage()->::data::SystemEventMessage::MergeFrom(
          from._internal_systemeventmessage());
      break;
    }
    case kTradeCancelForNextsharesTrades: {
      _this->_internal_mutable_tradecancelfornextsharestrades()->::data::TradeCancelForNextsharesTrades::MergeFrom(
          from._internal_tradecancelfornextsharestrades());
      break;
    }
    case kTradeCancelForNonNextSharesTrades: {
      _this->_internal_mutable_tradecancelfornonnextsharestrades()->::data::TradeCancelForNonNextSharesTrades::MergeFrom(
          from._internal_tradecancelfornonnextsharestrades());
      break;
    }
    case kTradeCorrectionForNextsharesTrades: {
      _this->_internal_mutable_tradecorrectionfornextsharestrades()->::data::TradeCorrectionForNextsharesTrades::MergeFrom(
          from._internal_tradecorrectionfornextsharestrades());
      break;
    }
    case kTradeCorrectionForNonNextsharesTrades: {
      _this->_internal_mutable_tradecorrectionfornonnextsharestrades()->::data::TradeCorrectionForNonNextsharesTrades::MergeFrom(
          from._internal_tradecorrectionfornonnextsharestrades());
      break;
    }
    case kTradeReportForNextshares: {
      _this->_internal_mutable_tradereportfornextshares()->::data::TradeReportForNextshares::MergeFrom(
          from._internal_tradereportfornextshares());
      break;
    }
    case kTradeReportForNonNextshares: {
      _this->_internal_mutable_tradereportfornonnextshares()->::data::TradeReportForNonNextshares::MergeFrom(
          from._internal_tradereportfornonnextshares());
      break;
    }
    case kQBBOMWCBBreachMessage: {
      _this->_internal_mutable_qbbomwcbbreachmessage()->::data::QBBOMWCBBreachMessage::MergeFrom(
          from._internal_qbbomwcbbreachmessage());
      break;
    }
    case kQBBOMWCBDeclineLevelMessage: {
      _this->_internal_mutable_qbbomwcbdeclinelevelmessage()->::data::QBBOMWCBDeclineLevelMessage::MergeFrom(
          from._internal_qbbomwcbdeclinelevelmessage());
      break;
    }
    case kQBBONextSharesQuotationMessage: {
      _this->_internal_mutable_qbbonextsharesquotationmessage()->::data::QBBONextSharesQuotationMessage::MergeFrom(
          from._internal_qbbonextsharesquotationmessage());
      break;
    }
    case kQBBOOperationalHalt: {
      _this->_internal_mutable_qbbooperationalhalt()->::data::QBBOOperationalHalt::MergeFrom(
          from._internal_qbbooperationalhalt());
      break;
    }
    case kQBBOQuotationMessage: {
      _this->_internal_mutable_qbboquotationmessage()->::data::QBBOQuotationMessage::MergeFrom(
          from._internal_qbboquotationmessage());
      break;
    }
    case kQBBORegShoRestriction: {
      _this->_internal_mutable_qbboregshorestriction()->::data::QBBORegShoRestriction::MergeFrom(
          from._internal_qbboregshorestriction());
      break;
    }
    case kQBBOStockDirectory: {
      _this->_internal_mutable_qbbostockdirectory()->::data::QBBOStockDirectory::MergeFrom(
          from._internal_qbbostockdirectory());
      break;
    }
    case kQBBOStockTradingAction: {
      _this->_internal_mutable_qbbostocktradingaction()->::data::QBBOStockTradingAction::MergeFrom(
          from._internal_qbbostocktradingaction());
      break;
    }
    case kQBBOSystemEventMessage: {
      _this->_internal_mutable_qbbosystemeventmessage()->::data::QBBOSystemEventMessage::MergeFrom(
          from._internal_qbbosystemeventmessage());
      break;
    }
    case kQBBOIPOQuotingPeriodUpdate: {
      _this->_internal_mutable_qbboipoquotingperiodupdate()->::data::QBBOIPOQuotingPeriodUpdate::MergeFrom(
          from._internal_qbboipoquotingperiodupdate());
      break;
    }
    case kCertificationMsg: {
      _this->_internal_mutable_certificationmsg()->::data::CertificationMsg::MergeFrom(
          from._internal_certificationmsg());
      break;
    }
    case kCNMarketDefinition: {
      _this->_internal_mutable_cnmarketdefinition()->::data::CNMarketDefinition::MergeFrom(
          from._internal_cnmarketdefinition());
      break;
    }
    case kCNSecurityDefinition: {
      _this->_internal_mutable_cnsecuritydefinition()->::data::CNSecurityDefinition::MergeFrom(
          from._internal_cnsecuritydefinition());
      break;
    }
    case kCNSecurityStatus: {
      _this->_internal_mutable_cnsecuritystatus()->::data::CNSecurityStatus::MergeFrom(
          from._internal_cnsecuritystatus());
      break;
    }
    case kCNStatistics: {
      _this->_internal_mutable_cnstatistics()->::data::CNStatistics::MergeFrom(
          from._internal_cnstatistics());
      break;
    }
    case kCNTopBook: {
      _this->_internal_mutable_cntopbook()->::data::CNTopBook::MergeFrom(
          from._internal_cntopbook());
      break;
    }
    case DATABODY_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Message::CopyFrom(const Message& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:data.Message)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Message::IsInitialized() const {
  return true;
}

void Message::InternalSwap(Message* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Message, _impl_.data_type_)
      + sizeof(Message::_impl_.data_type_)
      - PROTOBUF_FIELD_OFFSET(Message, _impl_.timestamp_)>(
          reinterpret_cast<char*>(&_impl_.timestamp_),
          reinterpret_cast<char*>(&other->_impl_.timestamp_));
  swap(_impl_.dataBody_, other->_impl_.dataBody_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata Message::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_data_2eproto_getter, &descriptor_table_data_2eproto_once,
      file_level_metadata_data_2eproto[77]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace data
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::data::AdjustedClosingPrice*
Arena::CreateMaybeMessage< ::data::AdjustedClosingPrice >(Arena* arena) {
  return Arena::CreateMessageInternal< ::data::AdjustedClosingPrice >(arena);
}
template<> PROTOBUF_NOINLINE ::data::DayTradeSummary*
Arena::CreateMaybeMessage< ::data::DayTradeSummary >(Arena* arena) {
  return Arena::CreateMessageInternal< ::data::DayTradeSummary >(arena);
}
template<> PROTOBUF_NOINLINE ::data::DayTradeSummaryNextShares*
Arena::CreateMaybeMessage< ::data::DayTradeSummaryNextShares >(Arena* arena) {
  return Arena::CreateMessageInternal< ::data::DayTradeSummaryNextShares >(arena);
}
template<> PROTOBUF_NOINLINE ::data::IPOInformation*
Arena::CreateMaybeMessage< ::data::IPOInformation >(Arena* arena) {
  return Arena::CreateMessageInternal< ::data::IPOInformation >(arena);
}
template<> PROTOBUF_NOINLINE ::data::IPOQuotingPeriodUpdate*
Arena::CreateMaybeMessage< ::data::IPOQuotingPeriodUpdate >(Arena* arena) {
  return Arena::CreateMessageInternal< ::data::IPOQuotingPeriodUpdate >(arena);
}
template<> PROTOBUF_NOINLINE ::data::MWCBStatusMessage*
Arena::CreateMaybeMessage< ::data::MWCBStatusMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::data::MWCBStatusMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::data::MarketWideCircuitBreaker*
Arena::CreateMaybeMessage< ::data::MarketWideCircuitBreaker >(Arena* arena) {
  return Arena::CreateMessageInternal< ::data::MarketWideCircuitBreaker >(arena);
}
template<> PROTOBUF_NOINLINE ::data::MessageHeader*
Arena::CreateMaybeMessage< ::data::MessageHeader >(Arena* arena) {
  return Arena::CreateMessageInternal< ::data::MessageHeader >(arena);
}
template<> PROTOBUF_NOINLINE ::data::OperationalHalt*
Arena::CreateMaybeMessage< ::data::OperationalHalt >(Arena* arena) {
  return Arena::CreateMessageInternal< ::data::OperationalHalt >(arena);
}
template<> PROTOBUF_NOINLINE ::data::SaleConditionModifier*
Arena::CreateMaybeMessage< ::data::SaleConditionModifier >(Arena* arena) {
  return Arena::CreateMessageInternal< ::data::SaleConditionModifier >(arena);
}
template<> PROTOBUF_NOINLINE ::data::ShortSaleRestrictionIndicatorMessage*
Arena::CreateMaybeMessage< ::data::ShortSaleRestrictionIndicatorMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::data::ShortSaleRestrictionIndicatorMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::data::StockDirectory*
Arena::CreateMaybeMessage< ::data::StockDirectory >(Arena* arena) {
  return Arena::CreateMessageInternal< ::data::StockDirectory >(arena);
}
template<> PROTOBUF_NOINLINE ::data::StockTradingAction*
Arena::CreateMaybeMessage< ::data::StockTradingAction >(Arena* arena) {
  return Arena::CreateMessageInternal< ::data::StockTradingAction >(arena);
}
template<> PROTOBUF_NOINLINE ::data::SystemEventMessage*
Arena::CreateMaybeMessage< ::data::SystemEventMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::data::SystemEventMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::data::TradeCancelForNextsharesTrades*
Arena::CreateMaybeMessage< ::data::TradeCancelForNextsharesTrades >(Arena* arena) {
  return Arena::CreateMessageInternal< ::data::TradeCancelForNextsharesTrades >(arena);
}
template<> PROTOBUF_NOINLINE ::data::TradeCancelForNonNextSharesTrades*
Arena::CreateMaybeMessage< ::data::TradeCancelForNonNextSharesTrades >(Arena* arena) {
  return Arena::CreateMessageInternal< ::data::TradeCancelForNonNextSharesTrades >(arena);
}
template<> PROTOBUF_NOINLINE ::data::TradeCorrectionForNextsharesTrades*
Arena::CreateMaybeMessage< ::data::TradeCorrectionForNextsharesTrades >(Arena* arena) {
  return Arena::CreateMessageInternal< ::data::TradeCorrectionForNextsharesTrades >(arena);
}
template<> PROTOBUF_NOINLINE ::data::TradeCorrectionForNonNextsharesTrades*
Arena::CreateMaybeMessage< ::data::TradeCorrectionForNonNextsharesTrades >(Arena* arena) {
  return Arena::CreateMessageInternal< ::data::TradeCorrectionForNonNextsharesTrades >(arena);
}
template<> PROTOBUF_NOINLINE ::data::TradeReportForNextshares*
Arena::CreateMaybeMessage< ::data::TradeReportForNextshares >(Arena* arena) {
  return Arena::CreateMessageInternal< ::data::TradeReportForNextshares >(arena);
}
template<> PROTOBUF_NOINLINE ::data::TradeReportForNonNextshares*
Arena::CreateMaybeMessage< ::data::TradeReportForNonNextshares >(Arena* arena) {
  return Arena::CreateMessageInternal< ::data::TradeReportForNonNextshares >(arena);
}
template<> PROTOBUF_NOINLINE ::data::QBBOMWCBBreachMessage*
Arena::CreateMaybeMessage< ::data::QBBOMWCBBreachMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::data::QBBOMWCBBreachMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::data::QBBOMWCBDeclineLevelMessage*
Arena::CreateMaybeMessage< ::data::QBBOMWCBDeclineLevelMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::data::QBBOMWCBDeclineLevelMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::data::QBBOMessageHeader*
Arena::CreateMaybeMessage< ::data::QBBOMessageHeader >(Arena* arena) {
  return Arena::CreateMessageInternal< ::data::QBBOMessageHeader >(arena);
}
template<> PROTOBUF_NOINLINE ::data::QBBONextSharesQuotationMessage*
Arena::CreateMaybeMessage< ::data::QBBONextSharesQuotationMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::data::QBBONextSharesQuotationMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::data::QBBOOperationalHalt*
Arena::CreateMaybeMessage< ::data::QBBOOperationalHalt >(Arena* arena) {
  return Arena::CreateMessageInternal< ::data::QBBOOperationalHalt >(arena);
}
template<> PROTOBUF_NOINLINE ::data::QBBOQuotationMessage*
Arena::CreateMaybeMessage< ::data::QBBOQuotationMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::data::QBBOQuotationMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::data::QBBORegShoRestriction*
Arena::CreateMaybeMessage< ::data::QBBORegShoRestriction >(Arena* arena) {
  return Arena::CreateMessageInternal< ::data::QBBORegShoRestriction >(arena);
}
template<> PROTOBUF_NOINLINE ::data::QBBOStockDirectory*
Arena::CreateMaybeMessage< ::data::QBBOStockDirectory >(Arena* arena) {
  return Arena::CreateMessageInternal< ::data::QBBOStockDirectory >(arena);
}
template<> PROTOBUF_NOINLINE ::data::QBBOStockTradingAction*
Arena::CreateMaybeMessage< ::data::QBBOStockTradingAction >(Arena* arena) {
  return Arena::CreateMessageInternal< ::data::QBBOStockTradingAction >(arena);
}
template<> PROTOBUF_NOINLINE ::data::QBBOSystemEventMessage*
Arena::CreateMaybeMessage< ::data::QBBOSystemEventMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::data::QBBOSystemEventMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::data::AddOddLotOrder*
Arena::CreateMaybeMessage< ::data::AddOddLotOrder >(Arena* arena) {
  return Arena::CreateMessageInternal< ::data::AddOddLotOrder >(arena);
}
template<> PROTOBUF_NOINLINE ::data::AggregateOrderBookUpdate*
Arena::CreateMaybeMessage< ::data::AggregateOrderBookUpdate >(Arena* arena) {
  return Arena::CreateMessageInternal< ::data::AggregateOrderBookUpdate >(arena);
}
template<> PROTOBUF_NOINLINE ::data::BQMoreItem*
Arena::CreateMaybeMessage< ::data::BQMoreItem >(Arena* arena) {
  return Arena::CreateMessageInternal< ::data::BQMoreItem >(arena);
}
template<> PROTOBUF_NOINLINE ::data::BrokerQueue*
Arena::CreateMaybeMessage< ::data::BrokerQueue >(Arena* arena) {
  return Arena::CreateMessageInternal< ::data::BrokerQueue >(arena);
}
template<> PROTOBUF_NOINLINE ::data::ClosingPrice*
Arena::CreateMaybeMessage< ::data::ClosingPrice >(Arena* arena) {
  return Arena::CreateMessageInternal< ::data::ClosingPrice >(arena);
}
template<> PROTOBUF_NOINLINE ::data::CurrencyRate*
Arena::CreateMaybeMessage< ::data::CurrencyRate >(Arena* arena) {
  return Arena::CreateMessageInternal< ::data::CurrencyRate >(arena);
}
template<> PROTOBUF_NOINLINE ::data::DeleteOddLotOrder*
Arena::CreateMaybeMessage< ::data::DeleteOddLotOrder >(Arena* arena) {
  return Arena::CreateMessageInternal< ::data::DeleteOddLotOrder >(arena);
}
template<> PROTOBUF_NOINLINE ::data::IndexData*
Arena::CreateMaybeMessage< ::data::IndexData >(Arena* arena) {
  return Arena::CreateMessageInternal< ::data::IndexData >(arena);
}
template<> PROTOBUF_NOINLINE ::data::IndexDefinition*
Arena::CreateMaybeMessage< ::data::IndexDefinition >(Arena* arena) {
  return Arena::CreateMessageInternal< ::data::IndexDefinition >(arena);
}
template<> PROTOBUF_NOINLINE ::data::IndicativeEquilibriumPrice*
Arena::CreateMaybeMessage< ::data::IndicativeEquilibriumPrice >(Arena* arena) {
  return Arena::CreateMessageInternal< ::data::IndicativeEquilibriumPrice >(arena);
}
template<> PROTOBUF_NOINLINE ::data::LiquidityProvider*
Arena::CreateMaybeMessage< ::data::LiquidityProvider >(Arena* arena) {
  return Arena::CreateMessageInternal< ::data::LiquidityProvider >(arena);
}
template<> PROTOBUF_NOINLINE ::data::MarketDefinition*
Arena::CreateMaybeMessage< ::data::MarketDefinition >(Arena* arena) {
  return Arena::CreateMessageInternal< ::data::MarketDefinition >(arena);
}
template<> PROTOBUF_NOINLINE ::data::MarketTurnover*
Arena::CreateMaybeMessage< ::data::MarketTurnover >(Arena* arena) {
  return Arena::CreateMessageInternal< ::data::MarketTurnover >(arena);
}
template<> PROTOBUF_NOINLINE ::data::News*
Arena::CreateMaybeMessage< ::data::News >(Arena* arena) {
  return Arena::CreateMessageInternal< ::data::News >(arena);
}
template<> PROTOBUF_NOINLINE ::data::NoEntry*
Arena::CreateMaybeMessage< ::data::NoEntry >(Arena* arena) {
  return Arena::CreateMessageInternal< ::data::NoEntry >(arena);
}
template<> PROTOBUF_NOINLINE ::data::NoLiquidityProvider*
Arena::CreateMaybeMessage< ::data::NoLiquidityProvider >(Arena* arena) {
  return Arena::CreateMessageInternal< ::data::NoLiquidityProvider >(arena);
}
template<> PROTOBUF_NOINLINE ::data::NoMarketCode*
Arena::CreateMaybeMessage< ::data::NoMarketCode >(Arena* arena) {
  return Arena::CreateMessageInternal< ::data::NoMarketCode >(arena);
}
template<> PROTOBUF_NOINLINE ::data::NoNewsLine*
Arena::CreateMaybeMessage< ::data::NoNewsLine >(Arena* arena) {
  return Arena::CreateMessageInternal< ::data::NoNewsLine >(arena);
}
template<> PROTOBUF_NOINLINE ::data::NoSecurityCode*
Arena::CreateMaybeMessage< ::data::NoSecurityCode >(Arena* arena) {
  return Arena::CreateMessageInternal< ::data::NoSecurityCode >(arena);
}
template<> PROTOBUF_NOINLINE ::data::NoUnderlyingSecurity*
Arena::CreateMaybeMessage< ::data::NoUnderlyingSecurity >(Arena* arena) {
  return Arena::CreateMessageInternal< ::data::NoUnderlyingSecurity >(arena);
}
template<> PROTOBUF_NOINLINE ::data::NominalPrice*
Arena::CreateMaybeMessage< ::data::NominalPrice >(Arena* arena) {
  return Arena::CreateMessageInternal< ::data::NominalPrice >(arena);
}
template<> PROTOBUF_NOINLINE ::data::OrderImbalance*
Arena::CreateMaybeMessage< ::data::OrderImbalance >(Arena* arena) {
  return Arena::CreateMessageInternal< ::data::OrderImbalance >(arena);
}
template<> PROTOBUF_NOINLINE ::data::PacketHeader*
Arena::CreateMaybeMessage< ::data::PacketHeader >(Arena* arena) {
  return Arena::CreateMessageInternal< ::data::PacketHeader >(arena);
}
template<> PROTOBUF_NOINLINE ::data::LongAdjustedClosingPrice*
Arena::CreateMaybeMessage< ::data::LongAdjustedClosingPrice >(Arena* arena) {
  return Arena::CreateMessageInternal< ::data::LongAdjustedClosingPrice >(arena);
}
template<> PROTOBUF_NOINLINE ::data::LongDayTradeSummary*
Arena::CreateMaybeMessage< ::data::LongDayTradeSummary >(Arena* arena) {
  return Arena::CreateMessageInternal< ::data::LongDayTradeSummary >(arena);
}
template<> PROTOBUF_NOINLINE ::data::LongTradeCancelForNonNextSharesTrades*
Arena::CreateMaybeMessage< ::data::LongTradeCancelForNonNextSharesTrades >(Arena* arena) {
  return Arena::CreateMessageInternal< ::data::LongTradeCancelForNonNextSharesTrades >(arena);
}
template<> PROTOBUF_NOINLINE ::data::LongTradeCorrectionForNonNextsharesTrades*
Arena::CreateMaybeMessage< ::data::LongTradeCorrectionForNonNextsharesTrades >(Arena* arena) {
  return Arena::CreateMessageInternal< ::data::LongTradeCorrectionForNonNextsharesTrades >(arena);
}
template<> PROTOBUF_NOINLINE ::data::LongTradeReportForNonNextshares*
Arena::CreateMaybeMessage< ::data::LongTradeReportForNonNextshares >(Arena* arena) {
  return Arena::CreateMessageInternal< ::data::LongTradeReportForNonNextshares >(arena);
}
template<> PROTOBUF_NOINLINE ::data::ReferencePrice*
Arena::CreateMaybeMessage< ::data::ReferencePrice >(Arena* arena) {
  return Arena::CreateMessageInternal< ::data::ReferencePrice >(arena);
}
template<> PROTOBUF_NOINLINE ::data::QBBOIPOQuotingPeriodUpdate*
Arena::CreateMaybeMessage< ::data::QBBOIPOQuotingPeriodUpdate >(Arena* arena) {
  return Arena::CreateMessageInternal< ::data::QBBOIPOQuotingPeriodUpdate >(arena);
}
template<> PROTOBUF_NOINLINE ::data::SecurityDefinition*
Arena::CreateMaybeMessage< ::data::SecurityDefinition >(Arena* arena) {
  return Arena::CreateMessageInternal< ::data::SecurityDefinition >(arena);
}
template<> PROTOBUF_NOINLINE ::data::SecurityStatus*
Arena::CreateMaybeMessage< ::data::SecurityStatus >(Arena* arena) {
  return Arena::CreateMessageInternal< ::data::SecurityStatus >(arena);
}
template<> PROTOBUF_NOINLINE ::data::Statistics*
Arena::CreateMaybeMessage< ::data::Statistics >(Arena* arena) {
  return Arena::CreateMessageInternal< ::data::Statistics >(arena);
}
template<> PROTOBUF_NOINLINE ::data::StockConnectDailyQuotaBalance*
Arena::CreateMaybeMessage< ::data::StockConnectDailyQuotaBalance >(Arena* arena) {
  return Arena::CreateMessageInternal< ::data::StockConnectDailyQuotaBalance >(arena);
}
template<> PROTOBUF_NOINLINE ::data::StockConnectMarketTurnover*
Arena::CreateMaybeMessage< ::data::StockConnectMarketTurnover >(Arena* arena) {
  return Arena::CreateMessageInternal< ::data::StockConnectMarketTurnover >(arena);
}
template<> PROTOBUF_NOINLINE ::data::Trade*
Arena::CreateMaybeMessage< ::data::Trade >(Arena* arena) {
  return Arena::CreateMessageInternal< ::data::Trade >(arena);
}
template<> PROTOBUF_NOINLINE ::data::TradeCancel*
Arena::CreateMaybeMessage< ::data::TradeCancel >(Arena* arena) {
  return Arena::CreateMessageInternal< ::data::TradeCancel >(arena);
}
template<> PROTOBUF_NOINLINE ::data::TradingSessionStatus*
Arena::CreateMaybeMessage< ::data::TradingSessionStatus >(Arena* arena) {
  return Arena::CreateMessageInternal< ::data::TradingSessionStatus >(arena);
}
template<> PROTOBUF_NOINLINE ::data::VCMTrigger*
Arena::CreateMaybeMessage< ::data::VCMTrigger >(Arena* arena) {
  return Arena::CreateMessageInternal< ::data::VCMTrigger >(arena);
}
template<> PROTOBUF_NOINLINE ::data::Yield*
Arena::CreateMaybeMessage< ::data::Yield >(Arena* arena) {
  return Arena::CreateMessageInternal< ::data::Yield >(arena);
}
template<> PROTOBUF_NOINLINE ::data::CNMarketDefinition*
Arena::CreateMaybeMessage< ::data::CNMarketDefinition >(Arena* arena) {
  return Arena::CreateMessageInternal< ::data::CNMarketDefinition >(arena);
}
template<> PROTOBUF_NOINLINE ::data::CNSecurityDefinition*
Arena::CreateMaybeMessage< ::data::CNSecurityDefinition >(Arena* arena) {
  return Arena::CreateMessageInternal< ::data::CNSecurityDefinition >(arena);
}
template<> PROTOBUF_NOINLINE ::data::CNSecurityStatus*
Arena::CreateMaybeMessage< ::data::CNSecurityStatus >(Arena* arena) {
  return Arena::CreateMessageInternal< ::data::CNSecurityStatus >(arena);
}
template<> PROTOBUF_NOINLINE ::data::CNStatistics*
Arena::CreateMaybeMessage< ::data::CNStatistics >(Arena* arena) {
  return Arena::CreateMessageInternal< ::data::CNStatistics >(arena);
}
template<> PROTOBUF_NOINLINE ::data::CNTopBook*
Arena::CreateMaybeMessage< ::data::CNTopBook >(Arena* arena) {
  return Arena::CreateMessageInternal< ::data::CNTopBook >(arena);
}
template<> PROTOBUF_NOINLINE ::data::CertificationMsg*
Arena::CreateMaybeMessage< ::data::CertificationMsg >(Arena* arena) {
  return Arena::CreateMessageInternal< ::data::CertificationMsg >(arena);
}
template<> PROTOBUF_NOINLINE ::data::Resp*
Arena::CreateMaybeMessage< ::data::Resp >(Arena* arena) {
  return Arena::CreateMessageInternal< ::data::Resp >(arena);
}
template<> PROTOBUF_NOINLINE ::data::Message*
Arena::CreateMaybeMessage< ::data::Message >(Arena* arena) {
  return Arena::CreateMessageInternal< ::data::Message >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
