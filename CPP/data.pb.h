// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: data.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_data_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_data_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_data_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_data_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_data_2eproto;
namespace data {
class AddOddLotOrder;
struct AddOddLotOrderDefaultTypeInternal;
extern AddOddLotOrderDefaultTypeInternal _AddOddLotOrder_default_instance_;
class AdjustedClosingPrice;
struct AdjustedClosingPriceDefaultTypeInternal;
extern AdjustedClosingPriceDefaultTypeInternal _AdjustedClosingPrice_default_instance_;
class AggregateOrderBookUpdate;
struct AggregateOrderBookUpdateDefaultTypeInternal;
extern AggregateOrderBookUpdateDefaultTypeInternal _AggregateOrderBookUpdate_default_instance_;
class BQMoreItem;
struct BQMoreItemDefaultTypeInternal;
extern BQMoreItemDefaultTypeInternal _BQMoreItem_default_instance_;
class BrokerQueue;
struct BrokerQueueDefaultTypeInternal;
extern BrokerQueueDefaultTypeInternal _BrokerQueue_default_instance_;
class CNMarketDefinition;
struct CNMarketDefinitionDefaultTypeInternal;
extern CNMarketDefinitionDefaultTypeInternal _CNMarketDefinition_default_instance_;
class CNSecurityDefinition;
struct CNSecurityDefinitionDefaultTypeInternal;
extern CNSecurityDefinitionDefaultTypeInternal _CNSecurityDefinition_default_instance_;
class CNSecurityStatus;
struct CNSecurityStatusDefaultTypeInternal;
extern CNSecurityStatusDefaultTypeInternal _CNSecurityStatus_default_instance_;
class CNStatistics;
struct CNStatisticsDefaultTypeInternal;
extern CNStatisticsDefaultTypeInternal _CNStatistics_default_instance_;
class CNTopBook;
struct CNTopBookDefaultTypeInternal;
extern CNTopBookDefaultTypeInternal _CNTopBook_default_instance_;
class CertificationMsg;
struct CertificationMsgDefaultTypeInternal;
extern CertificationMsgDefaultTypeInternal _CertificationMsg_default_instance_;
class ClosingPrice;
struct ClosingPriceDefaultTypeInternal;
extern ClosingPriceDefaultTypeInternal _ClosingPrice_default_instance_;
class CurrencyRate;
struct CurrencyRateDefaultTypeInternal;
extern CurrencyRateDefaultTypeInternal _CurrencyRate_default_instance_;
class DayTradeSummary;
struct DayTradeSummaryDefaultTypeInternal;
extern DayTradeSummaryDefaultTypeInternal _DayTradeSummary_default_instance_;
class DayTradeSummaryNextShares;
struct DayTradeSummaryNextSharesDefaultTypeInternal;
extern DayTradeSummaryNextSharesDefaultTypeInternal _DayTradeSummaryNextShares_default_instance_;
class DeleteOddLotOrder;
struct DeleteOddLotOrderDefaultTypeInternal;
extern DeleteOddLotOrderDefaultTypeInternal _DeleteOddLotOrder_default_instance_;
class IPOInformation;
struct IPOInformationDefaultTypeInternal;
extern IPOInformationDefaultTypeInternal _IPOInformation_default_instance_;
class IPOQuotingPeriodUpdate;
struct IPOQuotingPeriodUpdateDefaultTypeInternal;
extern IPOQuotingPeriodUpdateDefaultTypeInternal _IPOQuotingPeriodUpdate_default_instance_;
class IndexData;
struct IndexDataDefaultTypeInternal;
extern IndexDataDefaultTypeInternal _IndexData_default_instance_;
class IndexDefinition;
struct IndexDefinitionDefaultTypeInternal;
extern IndexDefinitionDefaultTypeInternal _IndexDefinition_default_instance_;
class IndicativeEquilibriumPrice;
struct IndicativeEquilibriumPriceDefaultTypeInternal;
extern IndicativeEquilibriumPriceDefaultTypeInternal _IndicativeEquilibriumPrice_default_instance_;
class LiquidityProvider;
struct LiquidityProviderDefaultTypeInternal;
extern LiquidityProviderDefaultTypeInternal _LiquidityProvider_default_instance_;
class LongAdjustedClosingPrice;
struct LongAdjustedClosingPriceDefaultTypeInternal;
extern LongAdjustedClosingPriceDefaultTypeInternal _LongAdjustedClosingPrice_default_instance_;
class LongDayTradeSummary;
struct LongDayTradeSummaryDefaultTypeInternal;
extern LongDayTradeSummaryDefaultTypeInternal _LongDayTradeSummary_default_instance_;
class LongTradeCancelForNonNextSharesTrades;
struct LongTradeCancelForNonNextSharesTradesDefaultTypeInternal;
extern LongTradeCancelForNonNextSharesTradesDefaultTypeInternal _LongTradeCancelForNonNextSharesTrades_default_instance_;
class LongTradeCorrectionForNonNextsharesTrades;
struct LongTradeCorrectionForNonNextsharesTradesDefaultTypeInternal;
extern LongTradeCorrectionForNonNextsharesTradesDefaultTypeInternal _LongTradeCorrectionForNonNextsharesTrades_default_instance_;
class LongTradeReportForNonNextshares;
struct LongTradeReportForNonNextsharesDefaultTypeInternal;
extern LongTradeReportForNonNextsharesDefaultTypeInternal _LongTradeReportForNonNextshares_default_instance_;
class MWCBStatusMessage;
struct MWCBStatusMessageDefaultTypeInternal;
extern MWCBStatusMessageDefaultTypeInternal _MWCBStatusMessage_default_instance_;
class MarketDefinition;
struct MarketDefinitionDefaultTypeInternal;
extern MarketDefinitionDefaultTypeInternal _MarketDefinition_default_instance_;
class MarketTurnover;
struct MarketTurnoverDefaultTypeInternal;
extern MarketTurnoverDefaultTypeInternal _MarketTurnover_default_instance_;
class MarketWideCircuitBreaker;
struct MarketWideCircuitBreakerDefaultTypeInternal;
extern MarketWideCircuitBreakerDefaultTypeInternal _MarketWideCircuitBreaker_default_instance_;
class Message;
struct MessageDefaultTypeInternal;
extern MessageDefaultTypeInternal _Message_default_instance_;
class MessageHeader;
struct MessageHeaderDefaultTypeInternal;
extern MessageHeaderDefaultTypeInternal _MessageHeader_default_instance_;
class News;
struct NewsDefaultTypeInternal;
extern NewsDefaultTypeInternal _News_default_instance_;
class NoEntry;
struct NoEntryDefaultTypeInternal;
extern NoEntryDefaultTypeInternal _NoEntry_default_instance_;
class NoLiquidityProvider;
struct NoLiquidityProviderDefaultTypeInternal;
extern NoLiquidityProviderDefaultTypeInternal _NoLiquidityProvider_default_instance_;
class NoMarketCode;
struct NoMarketCodeDefaultTypeInternal;
extern NoMarketCodeDefaultTypeInternal _NoMarketCode_default_instance_;
class NoNewsLine;
struct NoNewsLineDefaultTypeInternal;
extern NoNewsLineDefaultTypeInternal _NoNewsLine_default_instance_;
class NoSecurityCode;
struct NoSecurityCodeDefaultTypeInternal;
extern NoSecurityCodeDefaultTypeInternal _NoSecurityCode_default_instance_;
class NoUnderlyingSecurity;
struct NoUnderlyingSecurityDefaultTypeInternal;
extern NoUnderlyingSecurityDefaultTypeInternal _NoUnderlyingSecurity_default_instance_;
class NominalPrice;
struct NominalPriceDefaultTypeInternal;
extern NominalPriceDefaultTypeInternal _NominalPrice_default_instance_;
class OperationalHalt;
struct OperationalHaltDefaultTypeInternal;
extern OperationalHaltDefaultTypeInternal _OperationalHalt_default_instance_;
class OrderImbalance;
struct OrderImbalanceDefaultTypeInternal;
extern OrderImbalanceDefaultTypeInternal _OrderImbalance_default_instance_;
class PacketHeader;
struct PacketHeaderDefaultTypeInternal;
extern PacketHeaderDefaultTypeInternal _PacketHeader_default_instance_;
class QBBOIPOQuotingPeriodUpdate;
struct QBBOIPOQuotingPeriodUpdateDefaultTypeInternal;
extern QBBOIPOQuotingPeriodUpdateDefaultTypeInternal _QBBOIPOQuotingPeriodUpdate_default_instance_;
class QBBOMWCBBreachMessage;
struct QBBOMWCBBreachMessageDefaultTypeInternal;
extern QBBOMWCBBreachMessageDefaultTypeInternal _QBBOMWCBBreachMessage_default_instance_;
class QBBOMWCBDeclineLevelMessage;
struct QBBOMWCBDeclineLevelMessageDefaultTypeInternal;
extern QBBOMWCBDeclineLevelMessageDefaultTypeInternal _QBBOMWCBDeclineLevelMessage_default_instance_;
class QBBOMessageHeader;
struct QBBOMessageHeaderDefaultTypeInternal;
extern QBBOMessageHeaderDefaultTypeInternal _QBBOMessageHeader_default_instance_;
class QBBONextSharesQuotationMessage;
struct QBBONextSharesQuotationMessageDefaultTypeInternal;
extern QBBONextSharesQuotationMessageDefaultTypeInternal _QBBONextSharesQuotationMessage_default_instance_;
class QBBOOperationalHalt;
struct QBBOOperationalHaltDefaultTypeInternal;
extern QBBOOperationalHaltDefaultTypeInternal _QBBOOperationalHalt_default_instance_;
class QBBOQuotationMessage;
struct QBBOQuotationMessageDefaultTypeInternal;
extern QBBOQuotationMessageDefaultTypeInternal _QBBOQuotationMessage_default_instance_;
class QBBORegShoRestriction;
struct QBBORegShoRestrictionDefaultTypeInternal;
extern QBBORegShoRestrictionDefaultTypeInternal _QBBORegShoRestriction_default_instance_;
class QBBOStockDirectory;
struct QBBOStockDirectoryDefaultTypeInternal;
extern QBBOStockDirectoryDefaultTypeInternal _QBBOStockDirectory_default_instance_;
class QBBOStockTradingAction;
struct QBBOStockTradingActionDefaultTypeInternal;
extern QBBOStockTradingActionDefaultTypeInternal _QBBOStockTradingAction_default_instance_;
class QBBOSystemEventMessage;
struct QBBOSystemEventMessageDefaultTypeInternal;
extern QBBOSystemEventMessageDefaultTypeInternal _QBBOSystemEventMessage_default_instance_;
class ReferencePrice;
struct ReferencePriceDefaultTypeInternal;
extern ReferencePriceDefaultTypeInternal _ReferencePrice_default_instance_;
class Resp;
struct RespDefaultTypeInternal;
extern RespDefaultTypeInternal _Resp_default_instance_;
class SaleConditionModifier;
struct SaleConditionModifierDefaultTypeInternal;
extern SaleConditionModifierDefaultTypeInternal _SaleConditionModifier_default_instance_;
class SecurityDefinition;
struct SecurityDefinitionDefaultTypeInternal;
extern SecurityDefinitionDefaultTypeInternal _SecurityDefinition_default_instance_;
class SecurityStatus;
struct SecurityStatusDefaultTypeInternal;
extern SecurityStatusDefaultTypeInternal _SecurityStatus_default_instance_;
class ShortSaleRestrictionIndicatorMessage;
struct ShortSaleRestrictionIndicatorMessageDefaultTypeInternal;
extern ShortSaleRestrictionIndicatorMessageDefaultTypeInternal _ShortSaleRestrictionIndicatorMessage_default_instance_;
class Statistics;
struct StatisticsDefaultTypeInternal;
extern StatisticsDefaultTypeInternal _Statistics_default_instance_;
class StockConnectDailyQuotaBalance;
struct StockConnectDailyQuotaBalanceDefaultTypeInternal;
extern StockConnectDailyQuotaBalanceDefaultTypeInternal _StockConnectDailyQuotaBalance_default_instance_;
class StockConnectMarketTurnover;
struct StockConnectMarketTurnoverDefaultTypeInternal;
extern StockConnectMarketTurnoverDefaultTypeInternal _StockConnectMarketTurnover_default_instance_;
class StockDirectory;
struct StockDirectoryDefaultTypeInternal;
extern StockDirectoryDefaultTypeInternal _StockDirectory_default_instance_;
class StockTradingAction;
struct StockTradingActionDefaultTypeInternal;
extern StockTradingActionDefaultTypeInternal _StockTradingAction_default_instance_;
class SystemEventMessage;
struct SystemEventMessageDefaultTypeInternal;
extern SystemEventMessageDefaultTypeInternal _SystemEventMessage_default_instance_;
class Trade;
struct TradeDefaultTypeInternal;
extern TradeDefaultTypeInternal _Trade_default_instance_;
class TradeCancel;
struct TradeCancelDefaultTypeInternal;
extern TradeCancelDefaultTypeInternal _TradeCancel_default_instance_;
class TradeCancelForNextsharesTrades;
struct TradeCancelForNextsharesTradesDefaultTypeInternal;
extern TradeCancelForNextsharesTradesDefaultTypeInternal _TradeCancelForNextsharesTrades_default_instance_;
class TradeCancelForNonNextSharesTrades;
struct TradeCancelForNonNextSharesTradesDefaultTypeInternal;
extern TradeCancelForNonNextSharesTradesDefaultTypeInternal _TradeCancelForNonNextSharesTrades_default_instance_;
class TradeCorrectionForNextsharesTrades;
struct TradeCorrectionForNextsharesTradesDefaultTypeInternal;
extern TradeCorrectionForNextsharesTradesDefaultTypeInternal _TradeCorrectionForNextsharesTrades_default_instance_;
class TradeCorrectionForNonNextsharesTrades;
struct TradeCorrectionForNonNextsharesTradesDefaultTypeInternal;
extern TradeCorrectionForNonNextsharesTradesDefaultTypeInternal _TradeCorrectionForNonNextsharesTrades_default_instance_;
class TradeReportForNextshares;
struct TradeReportForNextsharesDefaultTypeInternal;
extern TradeReportForNextsharesDefaultTypeInternal _TradeReportForNextshares_default_instance_;
class TradeReportForNonNextshares;
struct TradeReportForNonNextsharesDefaultTypeInternal;
extern TradeReportForNonNextsharesDefaultTypeInternal _TradeReportForNonNextshares_default_instance_;
class TradingSessionStatus;
struct TradingSessionStatusDefaultTypeInternal;
extern TradingSessionStatusDefaultTypeInternal _TradingSessionStatus_default_instance_;
class VCMTrigger;
struct VCMTriggerDefaultTypeInternal;
extern VCMTriggerDefaultTypeInternal _VCMTrigger_default_instance_;
class Yield;
struct YieldDefaultTypeInternal;
extern YieldDefaultTypeInternal _Yield_default_instance_;
}  // namespace data
PROTOBUF_NAMESPACE_OPEN
template<> ::data::AddOddLotOrder* Arena::CreateMaybeMessage<::data::AddOddLotOrder>(Arena*);
template<> ::data::AdjustedClosingPrice* Arena::CreateMaybeMessage<::data::AdjustedClosingPrice>(Arena*);
template<> ::data::AggregateOrderBookUpdate* Arena::CreateMaybeMessage<::data::AggregateOrderBookUpdate>(Arena*);
template<> ::data::BQMoreItem* Arena::CreateMaybeMessage<::data::BQMoreItem>(Arena*);
template<> ::data::BrokerQueue* Arena::CreateMaybeMessage<::data::BrokerQueue>(Arena*);
template<> ::data::CNMarketDefinition* Arena::CreateMaybeMessage<::data::CNMarketDefinition>(Arena*);
template<> ::data::CNSecurityDefinition* Arena::CreateMaybeMessage<::data::CNSecurityDefinition>(Arena*);
template<> ::data::CNSecurityStatus* Arena::CreateMaybeMessage<::data::CNSecurityStatus>(Arena*);
template<> ::data::CNStatistics* Arena::CreateMaybeMessage<::data::CNStatistics>(Arena*);
template<> ::data::CNTopBook* Arena::CreateMaybeMessage<::data::CNTopBook>(Arena*);
template<> ::data::CertificationMsg* Arena::CreateMaybeMessage<::data::CertificationMsg>(Arena*);
template<> ::data::ClosingPrice* Arena::CreateMaybeMessage<::data::ClosingPrice>(Arena*);
template<> ::data::CurrencyRate* Arena::CreateMaybeMessage<::data::CurrencyRate>(Arena*);
template<> ::data::DayTradeSummary* Arena::CreateMaybeMessage<::data::DayTradeSummary>(Arena*);
template<> ::data::DayTradeSummaryNextShares* Arena::CreateMaybeMessage<::data::DayTradeSummaryNextShares>(Arena*);
template<> ::data::DeleteOddLotOrder* Arena::CreateMaybeMessage<::data::DeleteOddLotOrder>(Arena*);
template<> ::data::IPOInformation* Arena::CreateMaybeMessage<::data::IPOInformation>(Arena*);
template<> ::data::IPOQuotingPeriodUpdate* Arena::CreateMaybeMessage<::data::IPOQuotingPeriodUpdate>(Arena*);
template<> ::data::IndexData* Arena::CreateMaybeMessage<::data::IndexData>(Arena*);
template<> ::data::IndexDefinition* Arena::CreateMaybeMessage<::data::IndexDefinition>(Arena*);
template<> ::data::IndicativeEquilibriumPrice* Arena::CreateMaybeMessage<::data::IndicativeEquilibriumPrice>(Arena*);
template<> ::data::LiquidityProvider* Arena::CreateMaybeMessage<::data::LiquidityProvider>(Arena*);
template<> ::data::LongAdjustedClosingPrice* Arena::CreateMaybeMessage<::data::LongAdjustedClosingPrice>(Arena*);
template<> ::data::LongDayTradeSummary* Arena::CreateMaybeMessage<::data::LongDayTradeSummary>(Arena*);
template<> ::data::LongTradeCancelForNonNextSharesTrades* Arena::CreateMaybeMessage<::data::LongTradeCancelForNonNextSharesTrades>(Arena*);
template<> ::data::LongTradeCorrectionForNonNextsharesTrades* Arena::CreateMaybeMessage<::data::LongTradeCorrectionForNonNextsharesTrades>(Arena*);
template<> ::data::LongTradeReportForNonNextshares* Arena::CreateMaybeMessage<::data::LongTradeReportForNonNextshares>(Arena*);
template<> ::data::MWCBStatusMessage* Arena::CreateMaybeMessage<::data::MWCBStatusMessage>(Arena*);
template<> ::data::MarketDefinition* Arena::CreateMaybeMessage<::data::MarketDefinition>(Arena*);
template<> ::data::MarketTurnover* Arena::CreateMaybeMessage<::data::MarketTurnover>(Arena*);
template<> ::data::MarketWideCircuitBreaker* Arena::CreateMaybeMessage<::data::MarketWideCircuitBreaker>(Arena*);
template<> ::data::Message* Arena::CreateMaybeMessage<::data::Message>(Arena*);
template<> ::data::MessageHeader* Arena::CreateMaybeMessage<::data::MessageHeader>(Arena*);
template<> ::data::News* Arena::CreateMaybeMessage<::data::News>(Arena*);
template<> ::data::NoEntry* Arena::CreateMaybeMessage<::data::NoEntry>(Arena*);
template<> ::data::NoLiquidityProvider* Arena::CreateMaybeMessage<::data::NoLiquidityProvider>(Arena*);
template<> ::data::NoMarketCode* Arena::CreateMaybeMessage<::data::NoMarketCode>(Arena*);
template<> ::data::NoNewsLine* Arena::CreateMaybeMessage<::data::NoNewsLine>(Arena*);
template<> ::data::NoSecurityCode* Arena::CreateMaybeMessage<::data::NoSecurityCode>(Arena*);
template<> ::data::NoUnderlyingSecurity* Arena::CreateMaybeMessage<::data::NoUnderlyingSecurity>(Arena*);
template<> ::data::NominalPrice* Arena::CreateMaybeMessage<::data::NominalPrice>(Arena*);
template<> ::data::OperationalHalt* Arena::CreateMaybeMessage<::data::OperationalHalt>(Arena*);
template<> ::data::OrderImbalance* Arena::CreateMaybeMessage<::data::OrderImbalance>(Arena*);
template<> ::data::PacketHeader* Arena::CreateMaybeMessage<::data::PacketHeader>(Arena*);
template<> ::data::QBBOIPOQuotingPeriodUpdate* Arena::CreateMaybeMessage<::data::QBBOIPOQuotingPeriodUpdate>(Arena*);
template<> ::data::QBBOMWCBBreachMessage* Arena::CreateMaybeMessage<::data::QBBOMWCBBreachMessage>(Arena*);
template<> ::data::QBBOMWCBDeclineLevelMessage* Arena::CreateMaybeMessage<::data::QBBOMWCBDeclineLevelMessage>(Arena*);
template<> ::data::QBBOMessageHeader* Arena::CreateMaybeMessage<::data::QBBOMessageHeader>(Arena*);
template<> ::data::QBBONextSharesQuotationMessage* Arena::CreateMaybeMessage<::data::QBBONextSharesQuotationMessage>(Arena*);
template<> ::data::QBBOOperationalHalt* Arena::CreateMaybeMessage<::data::QBBOOperationalHalt>(Arena*);
template<> ::data::QBBOQuotationMessage* Arena::CreateMaybeMessage<::data::QBBOQuotationMessage>(Arena*);
template<> ::data::QBBORegShoRestriction* Arena::CreateMaybeMessage<::data::QBBORegShoRestriction>(Arena*);
template<> ::data::QBBOStockDirectory* Arena::CreateMaybeMessage<::data::QBBOStockDirectory>(Arena*);
template<> ::data::QBBOStockTradingAction* Arena::CreateMaybeMessage<::data::QBBOStockTradingAction>(Arena*);
template<> ::data::QBBOSystemEventMessage* Arena::CreateMaybeMessage<::data::QBBOSystemEventMessage>(Arena*);
template<> ::data::ReferencePrice* Arena::CreateMaybeMessage<::data::ReferencePrice>(Arena*);
template<> ::data::Resp* Arena::CreateMaybeMessage<::data::Resp>(Arena*);
template<> ::data::SaleConditionModifier* Arena::CreateMaybeMessage<::data::SaleConditionModifier>(Arena*);
template<> ::data::SecurityDefinition* Arena::CreateMaybeMessage<::data::SecurityDefinition>(Arena*);
template<> ::data::SecurityStatus* Arena::CreateMaybeMessage<::data::SecurityStatus>(Arena*);
template<> ::data::ShortSaleRestrictionIndicatorMessage* Arena::CreateMaybeMessage<::data::ShortSaleRestrictionIndicatorMessage>(Arena*);
template<> ::data::Statistics* Arena::CreateMaybeMessage<::data::Statistics>(Arena*);
template<> ::data::StockConnectDailyQuotaBalance* Arena::CreateMaybeMessage<::data::StockConnectDailyQuotaBalance>(Arena*);
template<> ::data::StockConnectMarketTurnover* Arena::CreateMaybeMessage<::data::StockConnectMarketTurnover>(Arena*);
template<> ::data::StockDirectory* Arena::CreateMaybeMessage<::data::StockDirectory>(Arena*);
template<> ::data::StockTradingAction* Arena::CreateMaybeMessage<::data::StockTradingAction>(Arena*);
template<> ::data::SystemEventMessage* Arena::CreateMaybeMessage<::data::SystemEventMessage>(Arena*);
template<> ::data::Trade* Arena::CreateMaybeMessage<::data::Trade>(Arena*);
template<> ::data::TradeCancel* Arena::CreateMaybeMessage<::data::TradeCancel>(Arena*);
template<> ::data::TradeCancelForNextsharesTrades* Arena::CreateMaybeMessage<::data::TradeCancelForNextsharesTrades>(Arena*);
template<> ::data::TradeCancelForNonNextSharesTrades* Arena::CreateMaybeMessage<::data::TradeCancelForNonNextSharesTrades>(Arena*);
template<> ::data::TradeCorrectionForNextsharesTrades* Arena::CreateMaybeMessage<::data::TradeCorrectionForNextsharesTrades>(Arena*);
template<> ::data::TradeCorrectionForNonNextsharesTrades* Arena::CreateMaybeMessage<::data::TradeCorrectionForNonNextsharesTrades>(Arena*);
template<> ::data::TradeReportForNextshares* Arena::CreateMaybeMessage<::data::TradeReportForNextshares>(Arena*);
template<> ::data::TradeReportForNonNextshares* Arena::CreateMaybeMessage<::data::TradeReportForNonNextshares>(Arena*);
template<> ::data::TradingSessionStatus* Arena::CreateMaybeMessage<::data::TradingSessionStatus>(Arena*);
template<> ::data::VCMTrigger* Arena::CreateMaybeMessage<::data::VCMTrigger>(Arena*);
template<> ::data::Yield* Arena::CreateMaybeMessage<::data::Yield>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace data {

enum Message_DataType : int {
  Message_DataType_AddOddLotOrderType = 0,
  Message_DataType_AggregateOrderBookUpdateType = 1,
  Message_DataType_BrokerQueueType = 2,
  Message_DataType_ClosingPriceType = 3,
  Message_DataType_CurrencyRateType = 4,
  Message_DataType_DeleteOddLotOrderType = 5,
  Message_DataType_IndexDataType = 6,
  Message_DataType_IndexDefinitionType = 7,
  Message_DataType_IndicativeEquilibriumPriceType = 8,
  Message_DataType_LiquidityProviderType = 9,
  Message_DataType_MarketDefinitionType = 10,
  Message_DataType_MarketTurnoverType = 11,
  Message_DataType_NewsType = 12,
  Message_DataType_NominalPriceType = 13,
  Message_DataType_OrderImbalanceType = 14,
  Message_DataType_ReferencePriceType = 15,
  Message_DataType_SecurityDefinitionType = 16,
  Message_DataType_SecurityStatusType = 17,
  Message_DataType_StatisticsType = 18,
  Message_DataType_StockConnectDailyQuotaBalanceType = 19,
  Message_DataType_StockConnectMarketTurnoverType = 20,
  Message_DataType_TradeType = 21,
  Message_DataType_TradeCancelType = 22,
  Message_DataType_TradingSessionStatusType = 23,
  Message_DataType_VCMTriggerType = 24,
  Message_DataType_YieldType = 25,
  Message_DataType_AdjustedClosingPriceType = 26,
  Message_DataType_DayTradeSummaryType = 27,
  Message_DataType_DayTradeSummaryNextSharesType = 28,
  Message_DataType_IPOInformationType = 29,
  Message_DataType_IPOQuotingPeriodUpdateType = 30,
  Message_DataType_LongAdjustedClosingPriceType = 31,
  Message_DataType_LongDayTradeSummaryType = 32,
  Message_DataType_LongTradeCancelForNonNextSharesTradesType = 33,
  Message_DataType_LongTradeCorrectionForNonNextsharesTradesType = 34,
  Message_DataType_LongTradeReportForNonNextsharesType = 35,
  Message_DataType_MWCBStatusMessageType = 36,
  Message_DataType_MarketWideCircuitBreakerType = 37,
  Message_DataType_OperationalHaltType = 38,
  Message_DataType_SaleConditionModifierType = 39,
  Message_DataType_ShortSaleRestrictionIndicatorMessageType = 40,
  Message_DataType_StockDirectoryType = 41,
  Message_DataType_StockTradingActionType = 42,
  Message_DataType_SystemEventMessageType = 43,
  Message_DataType_TradeCancelForNextsharesTradesType = 44,
  Message_DataType_TradeCancelForNonNextSharesTradesType = 45,
  Message_DataType_TradeCorrectionForNextsharesTradesType = 46,
  Message_DataType_TradeCorrectionForNonNextsharesTradesType = 47,
  Message_DataType_TradeReportForNextsharesType = 48,
  Message_DataType_TradeReportForNonNextsharesType = 49,
  Message_DataType_QBBOMWCBBreachMessageType = 50,
  Message_DataType_QBBOMWCBDeclineLevelMessageType = 51,
  Message_DataType_QBBONextSharesQuotationMessageType = 52,
  Message_DataType_QBBOOperationalHaltType = 53,
  Message_DataType_QBBOQuotationMessageType = 54,
  Message_DataType_QBBORegShoRestrictionType = 55,
  Message_DataType_QBBOStockDirectoryType = 56,
  Message_DataType_QBBOStockTradingActionType = 57,
  Message_DataType_QBBOSystemEventMessageType = 58,
  Message_DataType_QBBOIPOQuotingPeriodUpdateType = 59,
  Message_DataType_CertificationMsgType = 60,
  Message_DataType_CNMarketDefinitionType = 61,
  Message_DataType_CNSecurityDefinitionType = 62,
  Message_DataType_CNSecurityStatusType = 63,
  Message_DataType_CNStatisticsType = 64,
  Message_DataType_CNTopBookType = 65,
  Message_DataType_Message_DataType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Message_DataType_Message_DataType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Message_DataType_IsValid(int value);
constexpr Message_DataType Message_DataType_DataType_MIN = Message_DataType_AddOddLotOrderType;
constexpr Message_DataType Message_DataType_DataType_MAX = Message_DataType_CNTopBookType;
constexpr int Message_DataType_DataType_ARRAYSIZE = Message_DataType_DataType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Message_DataType_descriptor();
template<typename T>
inline const std::string& Message_DataType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Message_DataType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Message_DataType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Message_DataType_descriptor(), enum_t_value);
}
inline bool Message_DataType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Message_DataType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Message_DataType>(
    Message_DataType_descriptor(), name, value);
}
enum ActionType : int {
  Login = 0,
  Logout = 1,
  Heartbeat = 2,
  ActionType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ActionType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ActionType_IsValid(int value);
constexpr ActionType ActionType_MIN = Login;
constexpr ActionType ActionType_MAX = Heartbeat;
constexpr int ActionType_ARRAYSIZE = ActionType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ActionType_descriptor();
template<typename T>
inline const std::string& ActionType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ActionType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ActionType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ActionType_descriptor(), enum_t_value);
}
inline bool ActionType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ActionType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ActionType>(
    ActionType_descriptor(), name, value);
}
enum ResponseType : int {
  Success = 0,
  Failure = 1,
  ResponseType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ResponseType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ResponseType_IsValid(int value);
constexpr ResponseType ResponseType_MIN = Success;
constexpr ResponseType ResponseType_MAX = Failure;
constexpr int ResponseType_ARRAYSIZE = ResponseType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ResponseType_descriptor();
template<typename T>
inline const std::string& ResponseType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ResponseType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ResponseType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ResponseType_descriptor(), enum_t_value);
}
inline bool ResponseType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ResponseType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ResponseType>(
    ResponseType_descriptor(), name, value);
}
enum SecurityTradingStatus : int {
  SecurityTradingStatus_Trading_Halt = 0,
  SecurityTradingStatus_Resume = 1,
  SecurityTradingStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  SecurityTradingStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool SecurityTradingStatus_IsValid(int value);
constexpr SecurityTradingStatus SecurityTradingStatus_MIN = SecurityTradingStatus_Trading_Halt;
constexpr SecurityTradingStatus SecurityTradingStatus_MAX = SecurityTradingStatus_Resume;
constexpr int SecurityTradingStatus_ARRAYSIZE = SecurityTradingStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SecurityTradingStatus_descriptor();
template<typename T>
inline const std::string& SecurityTradingStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SecurityTradingStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SecurityTradingStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SecurityTradingStatus_descriptor(), enum_t_value);
}
inline bool SecurityTradingStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SecurityTradingStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SecurityTradingStatus>(
    SecurityTradingStatus_descriptor(), name, value);
}
enum SuspensionIndicator : int {
  SuspensionIndicator_Trading_Halt_OF_Suspend = 0,
  SuspensionIndicator_Resume = 1,
  SuspensionIndicator_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  SuspensionIndicator_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool SuspensionIndicator_IsValid(int value);
constexpr SuspensionIndicator SuspensionIndicator_MIN = SuspensionIndicator_Trading_Halt_OF_Suspend;
constexpr SuspensionIndicator SuspensionIndicator_MAX = SuspensionIndicator_Resume;
constexpr int SuspensionIndicator_ARRAYSIZE = SuspensionIndicator_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SuspensionIndicator_descriptor();
template<typename T>
inline const std::string& SuspensionIndicator_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SuspensionIndicator>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SuspensionIndicator_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SuspensionIndicator_descriptor(), enum_t_value);
}
inline bool SuspensionIndicator_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SuspensionIndicator* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SuspensionIndicator>(
    SuspensionIndicator_descriptor(), name, value);
}
enum Authenticity : int {
  Authenticity_LIVE_PRODUCTION = 0,
  Authenticity_TEST = 1,
  Authenticity_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Authenticity_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Authenticity_IsValid(int value);
constexpr Authenticity Authenticity_MIN = Authenticity_LIVE_PRODUCTION;
constexpr Authenticity Authenticity_MAX = Authenticity_TEST;
constexpr int Authenticity_ARRAYSIZE = Authenticity_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Authenticity_descriptor();
template<typename T>
inline const std::string& Authenticity_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Authenticity>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Authenticity_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Authenticity_descriptor(), enum_t_value);
}
inline bool Authenticity_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Authenticity* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Authenticity>(
    Authenticity_descriptor(), name, value);
}
enum BreachedLevel : int {
  BreachedLevel_LEVEL1 = 0,
  BreachedLevel_LEVEL2 = 1,
  BreachedLevel_LEVEL3 = 2,
  BreachedLevel_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  BreachedLevel_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool BreachedLevel_IsValid(int value);
constexpr BreachedLevel BreachedLevel_MIN = BreachedLevel_LEVEL1;
constexpr BreachedLevel BreachedLevel_MAX = BreachedLevel_LEVEL3;
constexpr int BreachedLevel_ARRAYSIZE = BreachedLevel_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* BreachedLevel_descriptor();
template<typename T>
inline const std::string& BreachedLevel_Name(T enum_t_value) {
  static_assert(::std::is_same<T, BreachedLevel>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function BreachedLevel_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    BreachedLevel_descriptor(), enum_t_value);
}
inline bool BreachedLevel_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, BreachedLevel* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<BreachedLevel>(
    BreachedLevel_descriptor(), name, value);
}
enum CurrentTradingState : int {
  CurrentTradingState_HALT_IN_EFFECT = 0,
  CurrentTradingState_PAUSED_ACROSS_ALL = 1,
  CurrentTradingState_QUOTE_ONLY_PERIOD_IN_EFFECT = 2,
  CurrentTradingState_TRADING_ON_NASDAQ_MARKET = 3,
  CurrentTradingState_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  CurrentTradingState_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool CurrentTradingState_IsValid(int value);
constexpr CurrentTradingState CurrentTradingState_MIN = CurrentTradingState_HALT_IN_EFFECT;
constexpr CurrentTradingState CurrentTradingState_MAX = CurrentTradingState_TRADING_ON_NASDAQ_MARKET;
constexpr int CurrentTradingState_ARRAYSIZE = CurrentTradingState_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CurrentTradingState_descriptor();
template<typename T>
inline const std::string& CurrentTradingState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CurrentTradingState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CurrentTradingState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CurrentTradingState_descriptor(), enum_t_value);
}
inline bool CurrentTradingState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CurrentTradingState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CurrentTradingState>(
    CurrentTradingState_descriptor(), name, value);
}
enum EventCode : int {
  EventCode_START_OF_TRANSMISSIONS = 0,
  EventCode_START_OF_SYSTEM_HOURS = 1,
  EventCode_START_OF_MARKET_HOURS = 2,
  EventCode_END_OF_THE_REGULAR_US_SESSION = 3,
  EventCode_END_OF_SYSTEM_HOURS = 4,
  EventCode_END_OF_TRANSMISSIONS = 5,
  EventCode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  EventCode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool EventCode_IsValid(int value);
constexpr EventCode EventCode_MIN = EventCode_START_OF_TRANSMISSIONS;
constexpr EventCode EventCode_MAX = EventCode_END_OF_TRANSMISSIONS;
constexpr int EventCode_ARRAYSIZE = EventCode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EventCode_descriptor();
template<typename T>
inline const std::string& EventCode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EventCode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EventCode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EventCode_descriptor(), enum_t_value);
}
inline bool EventCode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EventCode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EventCode>(
    EventCode_descriptor(), name, value);
}
enum FinancialStatusIndicator : int {
  FinancialStatusIndicator_DEFICIENT = 0,
  FinancialStatusIndicator_DELINQUENT = 1,
  FinancialStatusIndicator_BANKRUPT = 2,
  FinancialStatusIndicator_SUSPENDED = 3,
  FinancialStatusIndicator_DEFICIENT_AND_BANKRUPT = 4,
  FinancialStatusIndicator_DEFICIENT_AND_DELINQUENT = 5,
  FinancialStatusIndicator_DELINQUENT_AND_BANKRUPT = 6,
  FinancialStatusIndicator_DEFICIENT_DELINQUENT_AND_BANKRUPT = 7,
  FinancialStatusIndicator_REDEMPTIONS_SUSPENDED_FOR_EXCHANGE_TRADED_PRODUCT = 8,
  FinancialStatusIndicator_ISSUER_IS_NOT_DEFICIENT = 9,
  FinancialStatusIndicator_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  FinancialStatusIndicator_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool FinancialStatusIndicator_IsValid(int value);
constexpr FinancialStatusIndicator FinancialStatusIndicator_MIN = FinancialStatusIndicator_DEFICIENT;
constexpr FinancialStatusIndicator FinancialStatusIndicator_MAX = FinancialStatusIndicator_ISSUER_IS_NOT_DEFICIENT;
constexpr int FinancialStatusIndicator_ARRAYSIZE = FinancialStatusIndicator_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* FinancialStatusIndicator_descriptor();
template<typename T>
inline const std::string& FinancialStatusIndicator_Name(T enum_t_value) {
  static_assert(::std::is_same<T, FinancialStatusIndicator>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function FinancialStatusIndicator_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    FinancialStatusIndicator_descriptor(), enum_t_value);
}
inline bool FinancialStatusIndicator_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, FinancialStatusIndicator* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<FinancialStatusIndicator>(
    FinancialStatusIndicator_descriptor(), name, value);
}
enum HaltAction : int {
  HaltAction_OPERATIONALLY_HALTED_ON_THE_IDENTIFIED_MARKET = 0,
  HaltAction_OPERATIONAL_HALT_HAS_BEEN_LIFTED_AND_TRADING_RESUMED = 1,
  HaltAction_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  HaltAction_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool HaltAction_IsValid(int value);
constexpr HaltAction HaltAction_MIN = HaltAction_OPERATIONALLY_HALTED_ON_THE_IDENTIFIED_MARKET;
constexpr HaltAction HaltAction_MAX = HaltAction_OPERATIONAL_HALT_HAS_BEEN_LIFTED_AND_TRADING_RESUMED;
constexpr int HaltAction_ARRAYSIZE = HaltAction_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* HaltAction_descriptor();
template<typename T>
inline const std::string& HaltAction_Name(T enum_t_value) {
  static_assert(::std::is_same<T, HaltAction>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function HaltAction_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    HaltAction_descriptor(), enum_t_value);
}
inline bool HaltAction_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, HaltAction* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<HaltAction>(
    HaltAction_descriptor(), name, value);
}
enum IPOQuotationReleaseQualifier : int {
  IPOQuotationReleaseQualifier_ANTICIPATED_QUOTATION_RELEASE_TIME = 0,
  IPOQuotationReleaseQualifier_IPO_RELEASE_CANCELED_POSTPONED = 1,
  IPOQuotationReleaseQualifier_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  IPOQuotationReleaseQualifier_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool IPOQuotationReleaseQualifier_IsValid(int value);
constexpr IPOQuotationReleaseQualifier IPOQuotationReleaseQualifier_MIN = IPOQuotationReleaseQualifier_ANTICIPATED_QUOTATION_RELEASE_TIME;
constexpr IPOQuotationReleaseQualifier IPOQuotationReleaseQualifier_MAX = IPOQuotationReleaseQualifier_IPO_RELEASE_CANCELED_POSTPONED;
constexpr int IPOQuotationReleaseQualifier_ARRAYSIZE = IPOQuotationReleaseQualifier_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* IPOQuotationReleaseQualifier_descriptor();
template<typename T>
inline const std::string& IPOQuotationReleaseQualifier_Name(T enum_t_value) {
  static_assert(::std::is_same<T, IPOQuotationReleaseQualifier>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function IPOQuotationReleaseQualifier_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    IPOQuotationReleaseQualifier_descriptor(), enum_t_value);
}
inline bool IPOQuotationReleaseQualifier_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, IPOQuotationReleaseQualifier* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<IPOQuotationReleaseQualifier>(
    IPOQuotationReleaseQualifier_descriptor(), name, value);
}
enum IndicatesIf : int {
  IndicatesIf_Y = 0,
  IndicatesIf_N = 1,
  IndicatesIf_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  IndicatesIf_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool IndicatesIf_IsValid(int value);
constexpr IndicatesIf IndicatesIf_MIN = IndicatesIf_Y;
constexpr IndicatesIf IndicatesIf_MAX = IndicatesIf_N;
constexpr int IndicatesIf_ARRAYSIZE = IndicatesIf_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* IndicatesIf_descriptor();
template<typename T>
inline const std::string& IndicatesIf_Name(T enum_t_value) {
  static_assert(::std::is_same<T, IndicatesIf>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function IndicatesIf_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    IndicatesIf_descriptor(), enum_t_value);
}
inline bool IndicatesIf_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, IndicatesIf* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<IndicatesIf>(
    IndicatesIf_descriptor(), name, value);
}
enum LULDRule : int {
  LULDRule_NMS_STOCKS_AND_SELECT_ETPS = 0,
  LULDRule_NMS_STOCKS = 1,
  LULDRule_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  LULDRule_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool LULDRule_IsValid(int value);
constexpr LULDRule LULDRule_MIN = LULDRule_NMS_STOCKS_AND_SELECT_ETPS;
constexpr LULDRule LULDRule_MAX = LULDRule_NMS_STOCKS;
constexpr int LULDRule_ARRAYSIZE = LULDRule_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* LULDRule_descriptor();
template<typename T>
inline const std::string& LULDRule_Name(T enum_t_value) {
  static_assert(::std::is_same<T, LULDRule>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function LULDRule_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    LULDRule_descriptor(), enum_t_value);
}
inline bool LULDRule_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, LULDRule* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<LULDRule>(
    LULDRule_descriptor(), name, value);
}
enum LevelFour : int {
  LevelFour_ACQUISITION = 0,
  LevelFour_BUNCHED = 1,
  LevelFour_DISTRIBUTION = 2,
  LevelFour_PRICE_VARIATION_TRANSACTION = 3,
  LevelFour_NASDAQ_OFFICIAL_CLOSE_PRICE = 4,
  LevelFour_PRIOR_REFERENCE_PRICE = 5,
  LevelFour_NASDAQ_OFFICIAL_OPENING_PRICE = 6,
  LevelFour_SPLIT_TRADE = 7,
  LevelFour_CONTINGENT_TRADE = 8,
  LevelFour_AVERAGE_PRICE_TRADE1 = 9,
  LevelFour_CROSS_TRADE = 10,
  LevelFour_ODD_LOT_EXECUTION = 11,
  LevelFour_ODD_LOT_CROSS_EXECUTION = 12,
  LevelFour_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  LevelFour_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool LevelFour_IsValid(int value);
constexpr LevelFour LevelFour_MIN = LevelFour_ACQUISITION;
constexpr LevelFour LevelFour_MAX = LevelFour_ODD_LOT_CROSS_EXECUTION;
constexpr int LevelFour_ARRAYSIZE = LevelFour_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* LevelFour_descriptor();
template<typename T>
inline const std::string& LevelFour_Name(T enum_t_value) {
  static_assert(::std::is_same<T, LevelFour>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function LevelFour_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    LevelFour_descriptor(), enum_t_value);
}
inline bool LevelFour_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, LevelFour* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<LevelFour>(
    LevelFour_descriptor(), name, value);
}
enum LevelOne : int {
  LevelOne_REGULAR = 0,
  LevelOne_CASH_SETTLEMENT = 1,
  LevelOne_NEXT_DAY_SETTLEMENT = 2,
  LevelOne_SELLER_SETTLEMENT = 3,
  LevelOne_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  LevelOne_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool LevelOne_IsValid(int value);
constexpr LevelOne LevelOne_MIN = LevelOne_REGULAR;
constexpr LevelOne LevelOne_MAX = LevelOne_SELLER_SETTLEMENT;
constexpr int LevelOne_ARRAYSIZE = LevelOne_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* LevelOne_descriptor();
template<typename T>
inline const std::string& LevelOne_Name(T enum_t_value) {
  static_assert(::std::is_same<T, LevelOne>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function LevelOne_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    LevelOne_descriptor(), enum_t_value);
}
inline bool LevelOne_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, LevelOne* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<LevelOne>(
    LevelOne_descriptor(), name, value);
}
enum LevelThree : int {
  LevelThree_EXTENDED_HOURS_TRADE = 0,
  LevelThree_SOLD_LAST_REPORTED_LATE_BUT_IN_SEQUENCE = 1,
  LevelThree_SOLD_OUT_OF_SEQUENCE = 2,
  LevelThree_EXTENDED_HOURS_TRADE_REPORTED_LATE_OR_OUT_OF_SEQUENCE = 3,
  LevelThree_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  LevelThree_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool LevelThree_IsValid(int value);
constexpr LevelThree LevelThree_MIN = LevelThree_EXTENDED_HOURS_TRADE;
constexpr LevelThree LevelThree_MAX = LevelThree_EXTENDED_HOURS_TRADE_REPORTED_LATE_OR_OUT_OF_SEQUENCE;
constexpr int LevelThree_ARRAYSIZE = LevelThree_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* LevelThree_descriptor();
template<typename T>
inline const std::string& LevelThree_Name(T enum_t_value) {
  static_assert(::std::is_same<T, LevelThree>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function LevelThree_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    LevelThree_descriptor(), enum_t_value);
}
inline bool LevelThree_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, LevelThree* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<LevelThree>(
    LevelThree_descriptor(), name, value);
}
enum LevelTwo : int {
  LevelTwo_INTERMARKET_SWEEP = 0,
  LevelTwo_OPENING_PRINT = 1,
  LevelTwo_DERIVATIVE_PRICED = 2,
  LevelTwo_RE_OPENING_PRINT = 3,
  LevelTwo_CLOSING_PRINT = 4,
  LevelTwo_QUALIFIED_CONTINGENT_TRADE = 5,
  LevelTwo_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  LevelTwo_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool LevelTwo_IsValid(int value);
constexpr LevelTwo LevelTwo_MIN = LevelTwo_INTERMARKET_SWEEP;
constexpr LevelTwo LevelTwo_MAX = LevelTwo_QUALIFIED_CONTINGENT_TRADE;
constexpr int LevelTwo_ARRAYSIZE = LevelTwo_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* LevelTwo_descriptor();
template<typename T>
inline const std::string& LevelTwo_Name(T enum_t_value) {
  static_assert(::std::is_same<T, LevelTwo>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function LevelTwo_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    LevelTwo_descriptor(), enum_t_value);
}
inline bool LevelTwo_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, LevelTwo* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<LevelTwo>(
    LevelTwo_descriptor(), name, value);
}
enum MarketCategory : int {
  MarketCategory_NASDAQ_GLOBAL_SELECT_MARKETSM = 0,
  MarketCategory_NASDAQ_GLOBAL_MARKETSM = 1,
  MarketCategory_NASDAQ_CAPITAL_MARKET_NON_NASDAQ_LISTED_INSTRUMENTS = 2,
  MarketCategory_NEW_YORK_STOCK__EXCHANGE_A_NYSE_MKT = 3,
  MarketCategory_NYSE_AMEX = 4,
  MarketCategory_NYSE_ARCA = 5,
  MarketCategory_BATS_Z_EXCHANGE = 6,
  MarketCategory_INVESTORS_EXCHANGE_LLC = 7,
  MarketCategory_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  MarketCategory_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool MarketCategory_IsValid(int value);
constexpr MarketCategory MarketCategory_MIN = MarketCategory_NASDAQ_GLOBAL_SELECT_MARKETSM;
constexpr MarketCategory MarketCategory_MAX = MarketCategory_INVESTORS_EXCHANGE_LLC;
constexpr int MarketCategory_ARRAYSIZE = MarketCategory_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MarketCategory_descriptor();
template<typename T>
inline const std::string& MarketCategory_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MarketCategory>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MarketCategory_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MarketCategory_descriptor(), enum_t_value);
}
inline bool MarketCategory_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, MarketCategory* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MarketCategory>(
    MarketCategory_descriptor(), name, value);
}
enum MessageType : int {
  MessageType_SYSTEM_EVENT_MESSAGE = 0,
  MessageType_TRADE_REPORT_FOR_NON_NEXT_SHARES = 1,
  MessageType_TRADE_REPORT_FOR_NEXTSHARES = 2,
  MessageType_TRADE_CANCEL_ERROR = 3,
  MessageType_TRADE_CANCEL_ERROR_NON = 4,
  MessageType_TRADING_ACTION = 5,
  MessageType_STOCK_DIRECTORY_MESSAGE = 6,
  MessageType_SHORT_SALE_RESTRICTION_INDICATOR = 7,
  MessageType_ADJUSTED_CLOSING_PRICE = 8,
  MessageType_END_OF_DAY_TRADE_SUMMARY = 9,
  MessageType_END_OF_DAY_TRADE_SUMMARY_NEXTSHARES = 10,
  MessageType_IPO_MESSAGE = 11,
  MessageType_IPO_QUOTING_PERIOD_UPDATE = 12,
  MessageType_MARKET_WIDE_CIRCUIT_BREAKER_DECLINE_LEVEL = 13,
  MessageType_MARKET_WIDE_CIRCUIT_BREAKER_STATUS = 14,
  MessageType_OPERATIONAL_HALT = 15,
  MessageType_TRADE_CORRECTION = 16,
  MessageType_TRADE_CORRECTION_NON = 17,
  MessageType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  MessageType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool MessageType_IsValid(int value);
constexpr MessageType MessageType_MIN = MessageType_SYSTEM_EVENT_MESSAGE;
constexpr MessageType MessageType_MAX = MessageType_TRADE_CORRECTION_NON;
constexpr int MessageType_ARRAYSIZE = MessageType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MessageType_descriptor();
template<typename T>
inline const std::string& MessageType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MessageType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MessageType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MessageType_descriptor(), enum_t_value);
}
inline bool MessageType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, MessageType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MessageType>(
    MessageType_descriptor(), name, value);
}
enum NetChange : int {
  NetChange_FIRST_TRADE_PRICE = 0,
  NetChange_UNDERWRITER_PRICE = 1,
  NetChange_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  NetChange_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool NetChange_IsValid(int value);
constexpr NetChange NetChange_MIN = NetChange_FIRST_TRADE_PRICE;
constexpr NetChange NetChange_MAX = NetChange_UNDERWRITER_PRICE;
constexpr int NetChange_ARRAYSIZE = NetChange_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* NetChange_descriptor();
template<typename T>
inline const std::string& NetChange_Name(T enum_t_value) {
  static_assert(::std::is_same<T, NetChange>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function NetChange_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    NetChange_descriptor(), enum_t_value);
}
inline bool NetChange_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, NetChange* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<NetChange>(
    NetChange_descriptor(), name, value);
}
enum OperationalHaltAction : int {
  OperationalHaltAction_OPERATIONALLY_HALTED_ON_THE_IDENTIFIED_MARKET = 0,
  OperationalHaltAction_OPERATIONAL_HALT_HAS_BEEN_LIFTED_AND_TRADING_RESUMED = 1,
  OperationalHaltAction_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  OperationalHaltAction_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool OperationalHaltAction_IsValid(int value);
constexpr OperationalHaltAction OperationalHaltAction_MIN = OperationalHaltAction_OPERATIONALLY_HALTED_ON_THE_IDENTIFIED_MARKET;
constexpr OperationalHaltAction OperationalHaltAction_MAX = OperationalHaltAction_OPERATIONAL_HALT_HAS_BEEN_LIFTED_AND_TRADING_RESUMED;
constexpr int OperationalHaltAction_ARRAYSIZE = OperationalHaltAction_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* OperationalHaltAction_descriptor();
template<typename T>
inline const std::string& OperationalHaltAction_Name(T enum_t_value) {
  static_assert(::std::is_same<T, OperationalHaltAction>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function OperationalHaltAction_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    OperationalHaltAction_descriptor(), enum_t_value);
}
inline bool OperationalHaltAction_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, OperationalHaltAction* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<OperationalHaltAction>(
    OperationalHaltAction_descriptor(), name, value);
}
enum OriginatingMarketCenterIdentifier : int {
  OriginatingMarketCenterIdentifier_THE_NASDAQ_STOCK_MARKET = 0,
  OriginatingMarketCenterIdentifier_FINRA_TRADE_REPORTING_FACILITY_TRF_CARTARET = 1,
  OriginatingMarketCenterIdentifier_FINRA_TRADE_REPORTING_FACILITY_TRF_CHICAGO = 2,
  OriginatingMarketCenterIdentifier_NASDAQ_BX = 3,
  OriginatingMarketCenterIdentifier_NASDAQ_PSX = 4,
  OriginatingMarketCenterIdentifier_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  OriginatingMarketCenterIdentifier_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool OriginatingMarketCenterIdentifier_IsValid(int value);
constexpr OriginatingMarketCenterIdentifier OriginatingMarketCenterIdentifier_MIN = OriginatingMarketCenterIdentifier_THE_NASDAQ_STOCK_MARKET;
constexpr OriginatingMarketCenterIdentifier OriginatingMarketCenterIdentifier_MAX = OriginatingMarketCenterIdentifier_NASDAQ_PSX;
constexpr int OriginatingMarketCenterIdentifier_ARRAYSIZE = OriginatingMarketCenterIdentifier_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* OriginatingMarketCenterIdentifier_descriptor();
template<typename T>
inline const std::string& OriginatingMarketCenterIdentifier_Name(T enum_t_value) {
  static_assert(::std::is_same<T, OriginatingMarketCenterIdentifier>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function OriginatingMarketCenterIdentifier_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    OriginatingMarketCenterIdentifier_descriptor(), enum_t_value);
}
inline bool OriginatingMarketCenterIdentifier_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, OriginatingMarketCenterIdentifier* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<OriginatingMarketCenterIdentifier>(
    OriginatingMarketCenterIdentifier_descriptor(), name, value);
}
enum QBBOMessageType : int {
  QBBOMessageType_STOCK_DIRECTORY_MESSAGE = 0,
  QBBOMessageType_TRADING_ACTION = 1,
  QBBOMessageType_REG_SHO_SHORT_SALE_PRICE_TEST_RESTRICTED_INDICATOR = 2,
  QBBOMessageType_MARKET_WIDE_CIRCUIT_BREAKER_DECLINE_LEVEL = 3,
  QBBOMessageType_MARKET_WIDE_CIRCUIT_BREAKER_STATUS_MESSAGE = 4,
  QBBOMessageType_OPERATIONAL_HALT = 5,
  QBBOMessageType_QUOTATION_MESSAGE = 6,
  QBBOMessageType_NEXTSHARES_QUOTATION_MESSAGE = 7,
  QBBOMessageType_IPO_RELEASE_MESSAGE = 8,
  QBBOMessageType_SYSTEM_EVENT = 9,
  QBBOMessageType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  QBBOMessageType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool QBBOMessageType_IsValid(int value);
constexpr QBBOMessageType QBBOMessageType_MIN = QBBOMessageType_STOCK_DIRECTORY_MESSAGE;
constexpr QBBOMessageType QBBOMessageType_MAX = QBBOMessageType_SYSTEM_EVENT;
constexpr int QBBOMessageType_ARRAYSIZE = QBBOMessageType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* QBBOMessageType_descriptor();
template<typename T>
inline const std::string& QBBOMessageType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, QBBOMessageType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function QBBOMessageType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    QBBOMessageType_descriptor(), enum_t_value);
}
inline bool QBBOMessageType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, QBBOMessageType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<QBBOMessageType>(
    QBBOMessageType_descriptor(), name, value);
}
enum QuotationReleaseQualifier : int {
  QuotationReleaseQualifier_ANTICIPATED_QUOTATION_RELEASE = 0,
  QuotationReleaseQualifier_IPO_RELEASE_CANCELED_POSTPONED = 1,
  QuotationReleaseQualifier_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  QuotationReleaseQualifier_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool QuotationReleaseQualifier_IsValid(int value);
constexpr QuotationReleaseQualifier QuotationReleaseQualifier_MIN = QuotationReleaseQualifier_ANTICIPATED_QUOTATION_RELEASE;
constexpr QuotationReleaseQualifier QuotationReleaseQualifier_MAX = QuotationReleaseQualifier_IPO_RELEASE_CANCELED_POSTPONED;
constexpr int QuotationReleaseQualifier_ARRAYSIZE = QuotationReleaseQualifier_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* QuotationReleaseQualifier_descriptor();
template<typename T>
inline const std::string& QuotationReleaseQualifier_Name(T enum_t_value) {
  static_assert(::std::is_same<T, QuotationReleaseQualifier>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function QuotationReleaseQualifier_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    QuotationReleaseQualifier_descriptor(), enum_t_value);
}
inline bool QuotationReleaseQualifier_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, QuotationReleaseQualifier* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<QuotationReleaseQualifier>(
    QuotationReleaseQualifier_descriptor(), name, value);
}
enum RegSHOAction : int {
  RegSHOAction_NO_PRICE_TEST_IN_PLACE = 0,
  RegSHOAction_INTRA_DAY_PRICE = 1,
  RegSHOAction_RESTRICTION_REMAINS_IN_EFFECT = 2,
  RegSHOAction_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  RegSHOAction_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool RegSHOAction_IsValid(int value);
constexpr RegSHOAction RegSHOAction_MIN = RegSHOAction_NO_PRICE_TEST_IN_PLACE;
constexpr RegSHOAction RegSHOAction_MAX = RegSHOAction_RESTRICTION_REMAINS_IN_EFFECT;
constexpr int RegSHOAction_ARRAYSIZE = RegSHOAction_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RegSHOAction_descriptor();
template<typename T>
inline const std::string& RegSHOAction_Name(T enum_t_value) {
  static_assert(::std::is_same<T, RegSHOAction>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function RegSHOAction_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    RegSHOAction_descriptor(), enum_t_value);
}
inline bool RegSHOAction_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, RegSHOAction* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<RegSHOAction>(
    RegSHOAction_descriptor(), name, value);
}
enum SecurityClass : int {
  SecurityClass_Nasdaq = 0,
  SecurityClass_NYSE = 1,
  SecurityClass_NYSE_MKT = 2,
  SecurityClass_NYSE_ARCA = 3,
  SecurityClass_BATS = 4,
  SecurityClass_Investors_Exchange_LLC = 5,
  SecurityClass_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  SecurityClass_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool SecurityClass_IsValid(int value);
constexpr SecurityClass SecurityClass_MIN = SecurityClass_Nasdaq;
constexpr SecurityClass SecurityClass_MAX = SecurityClass_Investors_Exchange_LLC;
constexpr int SecurityClass_ARRAYSIZE = SecurityClass_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SecurityClass_descriptor();
template<typename T>
inline const std::string& SecurityClass_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SecurityClass>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SecurityClass_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SecurityClass_descriptor(), enum_t_value);
}
inline bool SecurityClass_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SecurityClass* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SecurityClass>(
    SecurityClass_descriptor(), name, value);
}
enum BQMoreFlag : int {
  BQMoreFlag_MORE_BROKER_NUMBERS_EXIST_IN_THE_QUEUE = 0,
  BQMoreFlag_NO_MORE_EXIST = 1,
  BQMoreFlag_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  BQMoreFlag_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool BQMoreFlag_IsValid(int value);
constexpr BQMoreFlag BQMoreFlag_MIN = BQMoreFlag_MORE_BROKER_NUMBERS_EXIST_IN_THE_QUEUE;
constexpr BQMoreFlag BQMoreFlag_MAX = BQMoreFlag_NO_MORE_EXIST;
constexpr int BQMoreFlag_ARRAYSIZE = BQMoreFlag_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* BQMoreFlag_descriptor();
template<typename T>
inline const std::string& BQMoreFlag_Name(T enum_t_value) {
  static_assert(::std::is_same<T, BQMoreFlag>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function BQMoreFlag_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    BQMoreFlag_descriptor(), enum_t_value);
}
inline bool BQMoreFlag_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, BQMoreFlag* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<BQMoreFlag>(
    BQMoreFlag_descriptor(), name, value);
}
enum BrokerSide : int {
  BrokerSide_BUY = 0,
  BrokerSide_SELL = 1,
  BrokerSide_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  BrokerSide_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool BrokerSide_IsValid(int value);
constexpr BrokerSide BrokerSide_MIN = BrokerSide_BUY;
constexpr BrokerSide BrokerSide_MAX = BrokerSide_SELL;
constexpr int BrokerSide_ARRAYSIZE = BrokerSide_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* BrokerSide_descriptor();
template<typename T>
inline const std::string& BrokerSide_Name(T enum_t_value) {
  static_assert(::std::is_same<T, BrokerSide>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function BrokerSide_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    BrokerSide_descriptor(), enum_t_value);
}
inline bool BrokerSide_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, BrokerSide* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<BrokerSide>(
    BrokerSide_descriptor(), name, value);
}
enum CallPutFlag : int {
  CallPutFlag_C = 0,
  CallPutFlag_P = 1,
  CallPutFlag_O = 2,
  CallPutFlag_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  CallPutFlag_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool CallPutFlag_IsValid(int value);
constexpr CallPutFlag CallPutFlag_MIN = CallPutFlag_C;
constexpr CallPutFlag CallPutFlag_MAX = CallPutFlag_O;
constexpr int CallPutFlag_ARRAYSIZE = CallPutFlag_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CallPutFlag_descriptor();
template<typename T>
inline const std::string& CallPutFlag_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CallPutFlag>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CallPutFlag_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CallPutFlag_descriptor(), enum_t_value);
}
inline bool CallPutFlag_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CallPutFlag* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CallPutFlag>(
    CallPutFlag_descriptor(), name, value);
}
enum CancelFlag : int {
  CancelFlag_Cancelled = 0,
  CancelFlag_NotCancelled = 1,
  CancelFlag_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  CancelFlag_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool CancelFlag_IsValid(int value);
constexpr CancelFlag CancelFlag_MIN = CancelFlag_Cancelled;
constexpr CancelFlag CancelFlag_MAX = CancelFlag_NotCancelled;
constexpr int CancelFlag_ARRAYSIZE = CancelFlag_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CancelFlag_descriptor();
template<typename T>
inline const std::string& CancelFlag_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CancelFlag>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CancelFlag_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CancelFlag_descriptor(), enum_t_value);
}
inline bool CancelFlag_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CancelFlag* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CancelFlag>(
    CancelFlag_descriptor(), name, value);
}
enum CurrencyType : int {
  CurrencyType_BLANK = 0,
  CurrencyType_HKD = 1,
  CurrencyType_AUD = 2,
  CurrencyType_ATS = 3,
  CurrencyType_BDT = 4,
  CurrencyType_BHD = 5,
  CurrencyType_BEC = 6,
  CurrencyType_BEL = 7,
  CurrencyType_BND = 8,
  CurrencyType_BUK = 9,
  CurrencyType_CAD = 10,
  CurrencyType_LKR = 11,
  CurrencyType_CNY = 12,
  CurrencyType_CYP = 13,
  CurrencyType_DKK = 14,
  CurrencyType_DEM = 15,
  CurrencyType_NLG = 16,
  CurrencyType_FJD = 17,
  CurrencyType_FIM = 18,
  CurrencyType_FRF = 19,
  CurrencyType_INR = 20,
  CurrencyType_IDR = 21,
  CurrencyType_ITL = 22,
  CurrencyType_JPY = 23,
  CurrencyType_KWD = 24,
  CurrencyType_KES = 25,
  CurrencyType_LBP = 26,
  CurrencyType_MUR = 27,
  CurrencyType_MYR = 28,
  CurrencyType_NZD = 29,
  CurrencyType_NGN = 30,
  CurrencyType_NOK = 31,
  CurrencyType_OMR = 32,
  CurrencyType_PKR = 33,
  CurrencyType_PHP = 34,
  CurrencyType_PTE = 35,
  CurrencyType_QAR = 36,
  CurrencyType_SAR = 37,
  CurrencyType_SCR = 38,
  CurrencyType_SGD = 39,
  CurrencyType_SLL = 40,
  CurrencyType_ZAR = 41,
  CurrencyType_KRW = 42,
  CurrencyType_ESP = 43,
  CurrencyType_GBP = 44,
  CurrencyType_SEK = 45,
  CurrencyType_CHF = 46,
  CurrencyType_THB = 47,
  CurrencyType_AED = 48,
  CurrencyType_USD = 49,
  CurrencyType_IEP = 50,
  CurrencyType_SDR = 51,
  CurrencyType_MOP = 52,
  CurrencyType_BRC = 53,
  CurrencyType_ECU = 54,
  CurrencyType_EUR = 55,
  CurrencyType_MXN = 56,
  CurrencyType_CNH = 57,
  CurrencyType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  CurrencyType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool CurrencyType_IsValid(int value);
constexpr CurrencyType CurrencyType_MIN = CurrencyType_BLANK;
constexpr CurrencyType CurrencyType_MAX = CurrencyType_CNH;
constexpr int CurrencyType_ARRAYSIZE = CurrencyType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CurrencyType_descriptor();
template<typename T>
inline const std::string& CurrencyType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CurrencyType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CurrencyType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CurrencyType_descriptor(), enum_t_value);
}
inline bool CurrencyType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CurrencyType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CurrencyType>(
    CurrencyType_descriptor(), name, value);
}
enum IndexSource : int {
  IndexSource_CSI_AND_CES = 0,
  IndexSource_HSI = 1,
  IndexSource_S_P = 2,
  IndexSource_TR = 3,
  IndexSource_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  IndexSource_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool IndexSource_IsValid(int value);
constexpr IndexSource IndexSource_MIN = IndexSource_CSI_AND_CES;
constexpr IndexSource IndexSource_MAX = IndexSource_TR;
constexpr int IndexSource_ARRAYSIZE = IndexSource_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* IndexSource_descriptor();
template<typename T>
inline const std::string& IndexSource_Name(T enum_t_value) {
  static_assert(::std::is_same<T, IndexSource>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function IndexSource_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    IndexSource_descriptor(), enum_t_value);
}
inline bool IndexSource_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, IndexSource* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<IndexSource>(
    IndexSource_descriptor(), name, value);
}
enum IndexStatus : int {
  IndexStatus_CLOSING_VALUE_I_INDICATIVE = 0,
  IndexStatus_OPENING_INDEX = 1,
  IndexStatus_LAST_CLOSE_VALUE = 2,
  IndexStatus_PRELIMINARY_CLOSE = 3,
  IndexStatus_STOP_LOSS_INDEX = 4,
  IndexStatus_REALTIME_INDEX_VALUE = 5,
  IndexStatus_BLANK = 6,
  IndexStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  IndexStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool IndexStatus_IsValid(int value);
constexpr IndexStatus IndexStatus_MIN = IndexStatus_CLOSING_VALUE_I_INDICATIVE;
constexpr IndexStatus IndexStatus_MAX = IndexStatus_BLANK;
constexpr int IndexStatus_ARRAYSIZE = IndexStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* IndexStatus_descriptor();
template<typename T>
inline const std::string& IndexStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, IndexStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function IndexStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    IndexStatus_descriptor(), enum_t_value);
}
inline bool IndexStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, IndexStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<IndexStatus>(
    IndexStatus_descriptor(), name, value);
}
enum IndicatesType : int {
  IndicatesType_BROKERNUMBER = 0,
  IndicatesType_NUMBER_OF_SPREAD = 1,
  IndicatesType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  IndicatesType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool IndicatesType_IsValid(int value);
constexpr IndicatesType IndicatesType_MIN = IndicatesType_BROKERNUMBER;
constexpr IndicatesType IndicatesType_MAX = IndicatesType_NUMBER_OF_SPREAD;
constexpr int IndicatesType_ARRAYSIZE = IndicatesType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* IndicatesType_descriptor();
template<typename T>
inline const std::string& IndicatesType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, IndicatesType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function IndicatesType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    IndicatesType_descriptor(), enum_t_value);
}
inline bool IndicatesType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, IndicatesType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<IndicatesType>(
    IndicatesType_descriptor(), name, value);
}
enum IndicatesWhether : int {
  IndicatesWhether_Y = 0,
  IndicatesWhether_N = 1,
  IndicatesWhether_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  IndicatesWhether_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool IndicatesWhether_IsValid(int value);
constexpr IndicatesWhether IndicatesWhether_MIN = IndicatesWhether_Y;
constexpr IndicatesWhether IndicatesWhether_MAX = IndicatesWhether_N;
constexpr int IndicatesWhether_ARRAYSIZE = IndicatesWhether_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* IndicatesWhether_descriptor();
template<typename T>
inline const std::string& IndicatesWhether_Name(T enum_t_value) {
  static_assert(::std::is_same<T, IndicatesWhether>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function IndicatesWhether_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    IndicatesWhether_descriptor(), enum_t_value);
}
inline bool IndicatesWhether_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, IndicatesWhether* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<IndicatesWhether>(
    IndicatesWhether_descriptor(), name, value);
}
enum InstrumentType : int {
  InstrumentType_BOND = 0,
  InstrumentType_EQTY = 1,
  InstrumentType_TRST = 2,
  InstrumentType_WRNT = 3,
  InstrumentType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  InstrumentType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool InstrumentType_IsValid(int value);
constexpr InstrumentType InstrumentType_MIN = InstrumentType_BOND;
constexpr InstrumentType InstrumentType_MAX = InstrumentType_WRNT;
constexpr int InstrumentType_ARRAYSIZE = InstrumentType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* InstrumentType_descriptor();
template<typename T>
inline const std::string& InstrumentType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, InstrumentType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function InstrumentType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    InstrumentType_descriptor(), enum_t_value);
}
inline bool InstrumentType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, InstrumentType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<InstrumentType>(
    InstrumentType_descriptor(), name, value);
}
enum InvestorType : int {
  InvestorType_Retail_Investor = 0,
  InvestorType_Professional_Investor = 1,
  InvestorType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  InvestorType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool InvestorType_IsValid(int value);
constexpr InvestorType InvestorType_MIN = InvestorType_Retail_Investor;
constexpr InvestorType InvestorType_MAX = InvestorType_Professional_Investor;
constexpr int InvestorType_ARRAYSIZE = InvestorType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* InvestorType_descriptor();
template<typename T>
inline const std::string& InvestorType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, InvestorType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function InvestorType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    InvestorType_descriptor(), enum_t_value);
}
inline bool InvestorType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, InvestorType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<InvestorType>(
    InvestorType_descriptor(), name, value);
}
enum LastFragment : int {
  LastFragment_Complete = 0,
  LastFragment_NotComplete = 1,
  LastFragment_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  LastFragment_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool LastFragment_IsValid(int value);
constexpr LastFragment LastFragment_MIN = LastFragment_Complete;
constexpr LastFragment LastFragment_MAX = LastFragment_NotComplete;
constexpr int LastFragment_ARRAYSIZE = LastFragment_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* LastFragment_descriptor();
template<typename T>
inline const std::string& LastFragment_Name(T enum_t_value) {
  static_assert(::std::is_same<T, LastFragment>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function LastFragment_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    LastFragment_descriptor(), enum_t_value);
}
inline bool LastFragment_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, LastFragment* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<LastFragment>(
    LastFragment_descriptor(), name, value);
}
enum CnMarketCode : int {
  SSE = 0,
  SZSE = 1,
  CnMarketCode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  CnMarketCode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool CnMarketCode_IsValid(int value);
constexpr CnMarketCode CnMarketCode_MIN = SSE;
constexpr CnMarketCode CnMarketCode_MAX = SZSE;
constexpr int CnMarketCode_ARRAYSIZE = CnMarketCode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CnMarketCode_descriptor();
template<typename T>
inline const std::string& CnMarketCode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CnMarketCode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CnMarketCode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CnMarketCode_descriptor(), enum_t_value);
}
inline bool CnMarketCode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CnMarketCode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CnMarketCode>(
    CnMarketCode_descriptor(), name, value);
}
enum MarketCode : int {
  MarketCode_MAIN = 0,
  MarketCode_GEM = 1,
  MarketCode_NASD = 2,
  MarketCode_ETS = 3,
  MarketCode_NASDAQ = 4,
  MarketCode_BX = 5,
  MarketCode_PSX = 6,
  MarketCode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  MarketCode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool MarketCode_IsValid(int value);
constexpr MarketCode MarketCode_MIN = MarketCode_MAIN;
constexpr MarketCode MarketCode_MAX = MarketCode_PSX;
constexpr int MarketCode_ARRAYSIZE = MarketCode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MarketCode_descriptor();
template<typename T>
inline const std::string& MarketCode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MarketCode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MarketCode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MarketCode_descriptor(), enum_t_value);
}
inline bool MarketCode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, MarketCode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MarketCode>(
    MarketCode_descriptor(), name, value);
}
enum MsgType : int {
  MsgType_Blank = 0,
  MsgType_SequenceReset = 1,
  MsgType_Logon = 2,
  MsgType_LogonResponse = 3,
  MsgType_DisasterRecoverySignal = 4,
  MsgType_RetransmissionRequest = 5,
  MsgType_RetransmissionResponse = 6,
  MsgType_RefreshComplete = 7,
  MsgType_MarketDefinition = 8,
  MsgType_SecurityDefinition = 9,
  MsgType_LiquidityProvider = 10,
  MsgType_CurrencyRate = 11,
  MsgType_TradingSessionStatus = 12,
  MsgType_SecurityStatus = 13,
  MsgType_AddOrder = 14,
  MsgType_ModifyOrder = 15,
  MsgType_DeleteOrder = 16,
  MsgType_AddOddLotOder = 17,
  MsgType_DeleteOddLotOrder = 18,
  MsgType_AggregateOrderBookUpdate = 19,
  MsgType_BrokerQueue = 20,
  MsgType_OrderImbalance = 21,
  MsgType_Trade = 22,
  MsgType_TradeCancel = 23,
  MsgType_TradeTicker = 24,
  MsgType_ClosingPrice = 25,
  MsgType_NominalPrice = 26,
  MsgType_IndicativeEquilibriumPrice = 27,
  MsgType_ReferencePrice = 28,
  MsgType_VCMTrigger = 29,
  MsgType_Statistics = 30,
  MsgType_MarketTurnover = 31,
  MsgType_Yield = 32,
  MsgType_News = 33,
  MsgType_IndexDefinition = 34,
  MsgType_IndexData = 35,
  MsgType_StockConnectDailyQuotaBalance = 36,
  MsgType_StockConnectMarketTurnover = 37,
  MsgType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  MsgType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool MsgType_IsValid(int value);
constexpr MsgType MsgType_MIN = MsgType_Blank;
constexpr MsgType MsgType_MAX = MsgType_StockConnectMarketTurnover;
constexpr int MsgType_ARRAYSIZE = MsgType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MsgType_descriptor();
template<typename T>
inline const std::string& MsgType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MsgType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MsgType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MsgType_descriptor(), enum_t_value);
}
inline bool MsgType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, MsgType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MsgType>(
    MsgType_descriptor(), name, value);
}
enum NewsType : int {
  NewsType_EXCHANGE_NEWS = 0,
  NewsType_CHINESE_EXCHANGE_NEWS = 1,
  NewsType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  NewsType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool NewsType_IsValid(int value);
constexpr NewsType NewsType_MIN = NewsType_EXCHANGE_NEWS;
constexpr NewsType NewsType_MAX = NewsType_CHINESE_EXCHANGE_NEWS;
constexpr int NewsType_ARRAYSIZE = NewsType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* NewsType_descriptor();
template<typename T>
inline const std::string& NewsType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, NewsType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function NewsType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    NewsType_descriptor(), enum_t_value);
}
inline bool NewsType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, NewsType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<NewsType>(
    NewsType_descriptor(), name, value);
}
enum OrderImbalanceDirection : int {
  OrderImbalanceDirection_Buy = 0,
  OrderImbalanceDirection_BUY_SURPLUS = 1,
  OrderImbalanceDirection_SELL_SURPLUS = 2,
  OrderImbalanceDirection_BLANK = 3,
  OrderImbalanceDirection_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  OrderImbalanceDirection_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool OrderImbalanceDirection_IsValid(int value);
constexpr OrderImbalanceDirection OrderImbalanceDirection_MIN = OrderImbalanceDirection_Buy;
constexpr OrderImbalanceDirection OrderImbalanceDirection_MAX = OrderImbalanceDirection_BLANK;
constexpr int OrderImbalanceDirection_ARRAYSIZE = OrderImbalanceDirection_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* OrderImbalanceDirection_descriptor();
template<typename T>
inline const std::string& OrderImbalanceDirection_Name(T enum_t_value) {
  static_assert(::std::is_same<T, OrderImbalanceDirection>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function OrderImbalanceDirection_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    OrderImbalanceDirection_descriptor(), enum_t_value);
}
inline bool OrderImbalanceDirection_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, OrderImbalanceDirection* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<OrderImbalanceDirection>(
    OrderImbalanceDirection_descriptor(), name, value);
}
enum ProductType : int {
  ProductType_EQUITY_ORDINARY_SHARES = 0,
  ProductType_EQUITY_PREFERENCE_SHARES = 1,
  ProductType_EQUITY_RIGHTS = 2,
  ProductType_EQUITY_DEPOSITORY_RECEIPT_ORDINARY_SHARES = 3,
  ProductType_EQUITY_DEPOSITORY_RECEIPT_PREFERENCE_SHARES = 4,
  ProductType_EQUITY_SPAC_SHARES_WARRANT = 5,
  ProductType_WARRANT_DERIVATIVE_WARRANT = 6,
  ProductType_WARRANT_CALLABLE_BULL_BEAR_CONTRACT = 7,
  ProductType_WARRANT_EQUITY_WARRANT = 8,
  ProductType_WARRANT_EQUITY_LINKED_INSTRUMENT = 9,
  ProductType_WARRANT_INLINE_WARRANT = 10,
  ProductType_WARRANT_SPAC_WARRANTS_BOND = 11,
  ProductType_BOND_DEBT_SECURITY_TRUST = 12,
  ProductType_TRUST_REAL_ESTATE_INVESTMENT_TRUST = 13,
  ProductType_TRUST_OTHER_UNIT_TRUSTS = 14,
  ProductType_TRUST_LEVERAGED_AND_INVERSE_PRODUCT = 15,
  ProductType_TRUST_EQUITY_ETF = 16,
  ProductType_TRUST_FIXED_INCOME_AND_MONEY_MARKET_ETF = 17,
  ProductType_TRUST_COMMODITIES_ETF = 18,
  ProductType_OTHERS_NONE_OF_THE_ABOVE = 19,
  ProductType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ProductType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ProductType_IsValid(int value);
constexpr ProductType ProductType_MIN = ProductType_EQUITY_ORDINARY_SHARES;
constexpr ProductType ProductType_MAX = ProductType_OTHERS_NONE_OF_THE_ABOVE;
constexpr int ProductType_ARRAYSIZE = ProductType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ProductType_descriptor();
template<typename T>
inline const std::string& ProductType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ProductType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ProductType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ProductType_descriptor(), enum_t_value);
}
inline bool ProductType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ProductType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ProductType>(
    ProductType_descriptor(), name, value);
}
enum Side : int {
  Side_BID = 0,
  Side_OFFER = 1,
  Side_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Side_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Side_IsValid(int value);
constexpr Side Side_MIN = Side_BID;
constexpr Side Side_MAX = Side_OFFER;
constexpr int Side_ARRAYSIZE = Side_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Side_descriptor();
template<typename T>
inline const std::string& Side_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Side>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Side_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Side_descriptor(), enum_t_value);
}
inline bool Side_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Side* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Side>(
    Side_descriptor(), name, value);
}
enum SpreadTableCode : int {
  SpreadTableCode_Part_A = 0,
  SpreadTableCode_Part_B = 1,
  SpreadTableCode_FOR_INLINE_WARRANT = 2,
  SpreadTableCode_PART_D = 3,
  SpreadTableCode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  SpreadTableCode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool SpreadTableCode_IsValid(int value);
constexpr SpreadTableCode SpreadTableCode_MIN = SpreadTableCode_Part_A;
constexpr SpreadTableCode SpreadTableCode_MAX = SpreadTableCode_PART_D;
constexpr int SpreadTableCode_ARRAYSIZE = SpreadTableCode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SpreadTableCode_descriptor();
template<typename T>
inline const std::string& SpreadTableCode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SpreadTableCode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SpreadTableCode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SpreadTableCode_descriptor(), enum_t_value);
}
inline bool SpreadTableCode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SpreadTableCode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SpreadTableCode>(
    SpreadTableCode_descriptor(), name, value);
}
enum Style : int {
  Style_American_Style = 0,
  Style_European_Style = 1,
  Style_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Style_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Style_IsValid(int value);
constexpr Style Style_MIN = Style_American_Style;
constexpr Style Style_MAX = Style_European_Style;
constexpr int Style_ARRAYSIZE = Style_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Style_descriptor();
template<typename T>
inline const std::string& Style_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Style>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Style_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Style_descriptor(), enum_t_value);
}
inline bool Style_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Style* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Style>(
    Style_descriptor(), name, value);
}
enum TradingSesControlType : int {
  TradingSesControlType_AUTOMATIC = 0,
  TradingSesControlType_MANUAL = 1,
  TradingSesControlType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  TradingSesControlType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool TradingSesControlType_IsValid(int value);
constexpr TradingSesControlType TradingSesControlType_MIN = TradingSesControlType_AUTOMATIC;
constexpr TradingSesControlType TradingSesControlType_MAX = TradingSesControlType_MANUAL;
constexpr int TradingSesControlType_ARRAYSIZE = TradingSesControlType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TradingSesControlType_descriptor();
template<typename T>
inline const std::string& TradingSesControlType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TradingSesControlType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TradingSesControlType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TradingSesControlType_descriptor(), enum_t_value);
}
inline bool TradingSesControlType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TradingSesControlType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TradingSesControlType>(
    TradingSesControlType_descriptor(), name, value);
}
enum TradingSesStatus : int {
  TradingSesStatus_UNKNOWN = 0,
  TradingSesStatus_HALTED = 1,
  TradingSesStatus_PRE_OPEN = 2,
  TradingSesStatus_OPEN = 3,
  TradingSesStatus_PRE_CLOSE = 4,
  TradingSesStatus_CLOSED = 5,
  TradingSesStatus_DAY_CLOSED = 6,
  TradingSesStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  TradingSesStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool TradingSesStatus_IsValid(int value);
constexpr TradingSesStatus TradingSesStatus_MIN = TradingSesStatus_UNKNOWN;
constexpr TradingSesStatus TradingSesStatus_MAX = TradingSesStatus_DAY_CLOSED;
constexpr int TradingSesStatus_ARRAYSIZE = TradingSesStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TradingSesStatus_descriptor();
template<typename T>
inline const std::string& TradingSesStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TradingSesStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TradingSesStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TradingSesStatus_descriptor(), enum_t_value);
}
inline bool TradingSesStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TradingSesStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TradingSesStatus>(
    TradingSesStatus_descriptor(), name, value);
}
enum TradingSessionSubID : int {
  TradingSessionSubID_NOT_YET_OPEN = 0,
  TradingSessionSubID_ORDER_INPUT = 1,
  TradingSessionSubID_NO_CANCELLATION = 2,
  TradingSessionSubID_RANDOM_MATCHING = 3,
  TradingSessionSubID_ORDER_MATCHING = 4,
  TradingSessionSubID_BLOCKING = 5,
  TradingSessionSubID_CONTINUOUS_TRADING = 6,
  TradingSessionSubID_CAS_REFERENCE_PRICE_FIXING = 7,
  TradingSessionSubID_CAS_ORDER_INPUT = 8,
  TradingSessionSubID_CAS_NO_CANCELLATION = 9,
  TradingSessionSubID_CAS_RANDOM_CLOSE = 10,
  TradingSessionSubID_CAS_ORDER_MATCHING = 11,
  TradingSessionSubID_EXCHANGE_INTERVENTION = 12,
  TradingSessionSubID_CLOSE = 13,
  TradingSessionSubID_ORDER_CANCEL = 14,
  TradingSessionSubID_DAY_CLOSE = 15,
  TradingSessionSubID_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  TradingSessionSubID_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool TradingSessionSubID_IsValid(int value);
constexpr TradingSessionSubID TradingSessionSubID_MIN = TradingSessionSubID_NOT_YET_OPEN;
constexpr TradingSessionSubID TradingSessionSubID_MAX = TradingSessionSubID_DAY_CLOSE;
constexpr int TradingSessionSubID_ARRAYSIZE = TradingSessionSubID_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TradingSessionSubID_descriptor();
template<typename T>
inline const std::string& TradingSessionSubID_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TradingSessionSubID>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TradingSessionSubID_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TradingSessionSubID_descriptor(), enum_t_value);
}
inline bool TradingSessionSubID_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TradingSessionSubID* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TradingSessionSubID>(
    TradingSessionSubID_descriptor(), name, value);
}
enum TrdType : int {
  TrdType_AUTOMATCH_NORMAL = 0,
  TrdType_LATE_TRADE = 1,
  TrdType_NON_DIRECT_OFF__EXCHANGE_TRADE = 2,
  TrdType_AUTOMATCH_INTERNALIZED = 3,
  TrdType_DIRECT_OFF_EXCHANGE_TRADE = 4,
  TrdType_ODD_LOT_TRADE = 5,
  TrdType_AUCTION_TRADE = 6,
  TrdType_OVERSEAS_TRADE = 7,
  TrdType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  TrdType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool TrdType_IsValid(int value);
constexpr TrdType TrdType_MIN = TrdType_AUTOMATCH_NORMAL;
constexpr TrdType TrdType_MAX = TrdType_OVERSEAS_TRADE;
constexpr int TrdType_ARRAYSIZE = TrdType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TrdType_descriptor();
template<typename T>
inline const std::string& TrdType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TrdType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TrdType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TrdType_descriptor(), enum_t_value);
}
inline bool TrdType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TrdType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TrdType>(
    TrdType_descriptor(), name, value);
}
enum UpdateAction : int {
  UpdateAction_NEW = 0,
  UpdateAction_CHANGE = 1,
  UpdateAction_DELETE = 2,
  UpdateAction_ORDERBOOK_CLEAR = 3,
  UpdateAction_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  UpdateAction_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool UpdateAction_IsValid(int value);
constexpr UpdateAction UpdateAction_MIN = UpdateAction_NEW;
constexpr UpdateAction UpdateAction_MAX = UpdateAction_ORDERBOOK_CLEAR;
constexpr int UpdateAction_ARRAYSIZE = UpdateAction_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* UpdateAction_descriptor();
template<typename T>
inline const std::string& UpdateAction_Name(T enum_t_value) {
  static_assert(::std::is_same<T, UpdateAction>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function UpdateAction_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    UpdateAction_descriptor(), enum_t_value);
}
inline bool UpdateAction_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, UpdateAction* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<UpdateAction>(
    UpdateAction_descriptor(), name, value);
}
enum WarrantType : int {
  WarrantType_N = 0,
  WarrantType_X = 1,
  WarrantType_O = 2,
  WarrantType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  WarrantType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool WarrantType_IsValid(int value);
constexpr WarrantType WarrantType_MIN = WarrantType_N;
constexpr WarrantType WarrantType_MAX = WarrantType_O;
constexpr int WarrantType_ARRAYSIZE = WarrantType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* WarrantType_descriptor();
template<typename T>
inline const std::string& WarrantType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, WarrantType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function WarrantType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    WarrantType_descriptor(), enum_t_value);
}
inline bool WarrantType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, WarrantType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<WarrantType>(
    WarrantType_descriptor(), name, value);
}
// ===================================================================

class AdjustedClosingPrice final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:data.AdjustedClosingPrice) */ {
 public:
  inline AdjustedClosingPrice() : AdjustedClosingPrice(nullptr) {}
  ~AdjustedClosingPrice() override;
  explicit PROTOBUF_CONSTEXPR AdjustedClosingPrice(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AdjustedClosingPrice(const AdjustedClosingPrice& from);
  AdjustedClosingPrice(AdjustedClosingPrice&& from) noexcept
    : AdjustedClosingPrice() {
    *this = ::std::move(from);
  }

  inline AdjustedClosingPrice& operator=(const AdjustedClosingPrice& from) {
    CopyFrom(from);
    return *this;
  }
  inline AdjustedClosingPrice& operator=(AdjustedClosingPrice&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AdjustedClosingPrice& default_instance() {
    return *internal_default_instance();
  }
  static inline const AdjustedClosingPrice* internal_default_instance() {
    return reinterpret_cast<const AdjustedClosingPrice*>(
               &_AdjustedClosingPrice_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(AdjustedClosingPrice& a, AdjustedClosingPrice& b) {
    a.Swap(&b);
  }
  inline void Swap(AdjustedClosingPrice* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AdjustedClosingPrice* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AdjustedClosingPrice* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AdjustedClosingPrice>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AdjustedClosingPrice& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AdjustedClosingPrice& from) {
    AdjustedClosingPrice::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AdjustedClosingPrice* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "data.AdjustedClosingPrice";
  }
  protected:
  explicit AdjustedClosingPrice(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIssueSymbolFieldNumber = 1,
    kAdjustedClosingPriceFieldNumber = 3,
    kSecurityClassFieldNumber = 2,
  };
  // optional string issueSymbol = 1;
  bool has_issuesymbol() const;
  private:
  bool _internal_has_issuesymbol() const;
  public:
  void clear_issuesymbol();
  const std::string& issuesymbol() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_issuesymbol(ArgT0&& arg0, ArgT... args);
  std::string* mutable_issuesymbol();
  PROTOBUF_NODISCARD std::string* release_issuesymbol();
  void set_allocated_issuesymbol(std::string* issuesymbol);
  private:
  const std::string& _internal_issuesymbol() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_issuesymbol(const std::string& value);
  std::string* _internal_mutable_issuesymbol();
  public:

  // optional double adjustedClosingPrice = 3;
  bool has_adjustedclosingprice() const;
  private:
  bool _internal_has_adjustedclosingprice() const;
  public:
  void clear_adjustedclosingprice();
  double adjustedclosingprice() const;
  void set_adjustedclosingprice(double value);
  private:
  double _internal_adjustedclosingprice() const;
  void _internal_set_adjustedclosingprice(double value);
  public:

  // optional .data.SecurityClass securityClass = 2;
  bool has_securityclass() const;
  private:
  bool _internal_has_securityclass() const;
  public:
  void clear_securityclass();
  ::data::SecurityClass securityclass() const;
  void set_securityclass(::data::SecurityClass value);
  private:
  ::data::SecurityClass _internal_securityclass() const;
  void _internal_set_securityclass(::data::SecurityClass value);
  public:

  // @@protoc_insertion_point(class_scope:data.AdjustedClosingPrice)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr issuesymbol_;
    double adjustedclosingprice_;
    int securityclass_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_data_2eproto;
};
// -------------------------------------------------------------------

class DayTradeSummary final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:data.DayTradeSummary) */ {
 public:
  inline DayTradeSummary() : DayTradeSummary(nullptr) {}
  ~DayTradeSummary() override;
  explicit PROTOBUF_CONSTEXPR DayTradeSummary(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DayTradeSummary(const DayTradeSummary& from);
  DayTradeSummary(DayTradeSummary&& from) noexcept
    : DayTradeSummary() {
    *this = ::std::move(from);
  }

  inline DayTradeSummary& operator=(const DayTradeSummary& from) {
    CopyFrom(from);
    return *this;
  }
  inline DayTradeSummary& operator=(DayTradeSummary&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DayTradeSummary& default_instance() {
    return *internal_default_instance();
  }
  static inline const DayTradeSummary* internal_default_instance() {
    return reinterpret_cast<const DayTradeSummary*>(
               &_DayTradeSummary_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(DayTradeSummary& a, DayTradeSummary& b) {
    a.Swap(&b);
  }
  inline void Swap(DayTradeSummary* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DayTradeSummary* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DayTradeSummary* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DayTradeSummary>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DayTradeSummary& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DayTradeSummary& from) {
    DayTradeSummary::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DayTradeSummary* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "data.DayTradeSummary";
  }
  protected:
  explicit DayTradeSummary(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIssueSymbolFieldNumber = 1,
    kNasdaqHighPriceFieldNumber = 3,
    kNasdaqLowPriceFieldNumber = 4,
    kNasdaqClosingPriceFieldNumber = 5,
    kConsolidatedVolumeFieldNumber = 6,
    kMarketCategoryFieldNumber = 2,
  };
  // optional string issueSymbol = 1;
  bool has_issuesymbol() const;
  private:
  bool _internal_has_issuesymbol() const;
  public:
  void clear_issuesymbol();
  const std::string& issuesymbol() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_issuesymbol(ArgT0&& arg0, ArgT... args);
  std::string* mutable_issuesymbol();
  PROTOBUF_NODISCARD std::string* release_issuesymbol();
  void set_allocated_issuesymbol(std::string* issuesymbol);
  private:
  const std::string& _internal_issuesymbol() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_issuesymbol(const std::string& value);
  std::string* _internal_mutable_issuesymbol();
  public:

  // optional double nasdaqHighPrice = 3;
  bool has_nasdaqhighprice() const;
  private:
  bool _internal_has_nasdaqhighprice() const;
  public:
  void clear_nasdaqhighprice();
  double nasdaqhighprice() const;
  void set_nasdaqhighprice(double value);
  private:
  double _internal_nasdaqhighprice() const;
  void _internal_set_nasdaqhighprice(double value);
  public:

  // optional double nasdaqLowPrice = 4;
  bool has_nasdaqlowprice() const;
  private:
  bool _internal_has_nasdaqlowprice() const;
  public:
  void clear_nasdaqlowprice();
  double nasdaqlowprice() const;
  void set_nasdaqlowprice(double value);
  private:
  double _internal_nasdaqlowprice() const;
  void _internal_set_nasdaqlowprice(double value);
  public:

  // optional double nasdaqClosingPrice = 5;
  bool has_nasdaqclosingprice() const;
  private:
  bool _internal_has_nasdaqclosingprice() const;
  public:
  void clear_nasdaqclosingprice();
  double nasdaqclosingprice() const;
  void set_nasdaqclosingprice(double value);
  private:
  double _internal_nasdaqclosingprice() const;
  void _internal_set_nasdaqclosingprice(double value);
  public:

  // optional int64 consolidatedVolume = 6;
  bool has_consolidatedvolume() const;
  private:
  bool _internal_has_consolidatedvolume() const;
  public:
  void clear_consolidatedvolume();
  int64_t consolidatedvolume() const;
  void set_consolidatedvolume(int64_t value);
  private:
  int64_t _internal_consolidatedvolume() const;
  void _internal_set_consolidatedvolume(int64_t value);
  public:

  // optional .data.MarketCategory marketCategory = 2;
  bool has_marketcategory() const;
  private:
  bool _internal_has_marketcategory() const;
  public:
  void clear_marketcategory();
  ::data::MarketCategory marketcategory() const;
  void set_marketcategory(::data::MarketCategory value);
  private:
  ::data::MarketCategory _internal_marketcategory() const;
  void _internal_set_marketcategory(::data::MarketCategory value);
  public:

  // @@protoc_insertion_point(class_scope:data.DayTradeSummary)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr issuesymbol_;
    double nasdaqhighprice_;
    double nasdaqlowprice_;
    double nasdaqclosingprice_;
    int64_t consolidatedvolume_;
    int marketcategory_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_data_2eproto;
};
// -------------------------------------------------------------------

class DayTradeSummaryNextShares final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:data.DayTradeSummaryNextShares) */ {
 public:
  inline DayTradeSummaryNextShares() : DayTradeSummaryNextShares(nullptr) {}
  ~DayTradeSummaryNextShares() override;
  explicit PROTOBUF_CONSTEXPR DayTradeSummaryNextShares(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DayTradeSummaryNextShares(const DayTradeSummaryNextShares& from);
  DayTradeSummaryNextShares(DayTradeSummaryNextShares&& from) noexcept
    : DayTradeSummaryNextShares() {
    *this = ::std::move(from);
  }

  inline DayTradeSummaryNextShares& operator=(const DayTradeSummaryNextShares& from) {
    CopyFrom(from);
    return *this;
  }
  inline DayTradeSummaryNextShares& operator=(DayTradeSummaryNextShares&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DayTradeSummaryNextShares& default_instance() {
    return *internal_default_instance();
  }
  static inline const DayTradeSummaryNextShares* internal_default_instance() {
    return reinterpret_cast<const DayTradeSummaryNextShares*>(
               &_DayTradeSummaryNextShares_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(DayTradeSummaryNextShares& a, DayTradeSummaryNextShares& b) {
    a.Swap(&b);
  }
  inline void Swap(DayTradeSummaryNextShares* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DayTradeSummaryNextShares* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DayTradeSummaryNextShares* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DayTradeSummaryNextShares>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DayTradeSummaryNextShares& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DayTradeSummaryNextShares& from) {
    DayTradeSummaryNextShares::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DayTradeSummaryNextShares* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "data.DayTradeSummaryNextShares";
  }
  protected:
  explicit DayTradeSummaryNextShares(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIssueSymbolFieldNumber = 1,
    kNasdaqHighPriceFieldNumber = 3,
    kNAVOffsetAmountHighFieldNumber = 4,
    kNasdaqLowPriceFieldNumber = 5,
    kNAVOffsetAmountLowFieldNumber = 6,
    kNasdaqClosingPriceFieldNumber = 7,
    kNAVOffsetAmountCloseFieldNumber = 8,
    kConsolidatedVolumeFieldNumber = 9,
    kMarketCategoryFieldNumber = 2,
  };
  // optional string issueSymbol = 1;
  bool has_issuesymbol() const;
  private:
  bool _internal_has_issuesymbol() const;
  public:
  void clear_issuesymbol();
  const std::string& issuesymbol() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_issuesymbol(ArgT0&& arg0, ArgT... args);
  std::string* mutable_issuesymbol();
  PROTOBUF_NODISCARD std::string* release_issuesymbol();
  void set_allocated_issuesymbol(std::string* issuesymbol);
  private:
  const std::string& _internal_issuesymbol() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_issuesymbol(const std::string& value);
  std::string* _internal_mutable_issuesymbol();
  public:

  // optional double nasdaqHighPrice = 3;
  bool has_nasdaqhighprice() const;
  private:
  bool _internal_has_nasdaqhighprice() const;
  public:
  void clear_nasdaqhighprice();
  double nasdaqhighprice() const;
  void set_nasdaqhighprice(double value);
  private:
  double _internal_nasdaqhighprice() const;
  void _internal_set_nasdaqhighprice(double value);
  public:

  // optional double NAVOffsetAmountHigh = 4;
  bool has_navoffsetamounthigh() const;
  private:
  bool _internal_has_navoffsetamounthigh() const;
  public:
  void clear_navoffsetamounthigh();
  double navoffsetamounthigh() const;
  void set_navoffsetamounthigh(double value);
  private:
  double _internal_navoffsetamounthigh() const;
  void _internal_set_navoffsetamounthigh(double value);
  public:

  // optional double nasdaqLowPrice = 5;
  bool has_nasdaqlowprice() const;
  private:
  bool _internal_has_nasdaqlowprice() const;
  public:
  void clear_nasdaqlowprice();
  double nasdaqlowprice() const;
  void set_nasdaqlowprice(double value);
  private:
  double _internal_nasdaqlowprice() const;
  void _internal_set_nasdaqlowprice(double value);
  public:

  // optional double NAVOffsetAmountLow = 6;
  bool has_navoffsetamountlow() const;
  private:
  bool _internal_has_navoffsetamountlow() const;
  public:
  void clear_navoffsetamountlow();
  double navoffsetamountlow() const;
  void set_navoffsetamountlow(double value);
  private:
  double _internal_navoffsetamountlow() const;
  void _internal_set_navoffsetamountlow(double value);
  public:

  // optional double nasdaqClosingPrice = 7;
  bool has_nasdaqclosingprice() const;
  private:
  bool _internal_has_nasdaqclosingprice() const;
  public:
  void clear_nasdaqclosingprice();
  double nasdaqclosingprice() const;
  void set_nasdaqclosingprice(double value);
  private:
  double _internal_nasdaqclosingprice() const;
  void _internal_set_nasdaqclosingprice(double value);
  public:

  // optional double NAVOffsetAmountClose = 8;
  bool has_navoffsetamountclose() const;
  private:
  bool _internal_has_navoffsetamountclose() const;
  public:
  void clear_navoffsetamountclose();
  double navoffsetamountclose() const;
  void set_navoffsetamountclose(double value);
  private:
  double _internal_navoffsetamountclose() const;
  void _internal_set_navoffsetamountclose(double value);
  public:

  // optional int64 consolidatedVolume = 9;
  bool has_consolidatedvolume() const;
  private:
  bool _internal_has_consolidatedvolume() const;
  public:
  void clear_consolidatedvolume();
  int64_t consolidatedvolume() const;
  void set_consolidatedvolume(int64_t value);
  private:
  int64_t _internal_consolidatedvolume() const;
  void _internal_set_consolidatedvolume(int64_t value);
  public:

  // optional .data.MarketCategory marketCategory = 2;
  bool has_marketcategory() const;
  private:
  bool _internal_has_marketcategory() const;
  public:
  void clear_marketcategory();
  ::data::MarketCategory marketcategory() const;
  void set_marketcategory(::data::MarketCategory value);
  private:
  ::data::MarketCategory _internal_marketcategory() const;
  void _internal_set_marketcategory(::data::MarketCategory value);
  public:

  // @@protoc_insertion_point(class_scope:data.DayTradeSummaryNextShares)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr issuesymbol_;
    double nasdaqhighprice_;
    double navoffsetamounthigh_;
    double nasdaqlowprice_;
    double navoffsetamountlow_;
    double nasdaqclosingprice_;
    double navoffsetamountclose_;
    int64_t consolidatedvolume_;
    int marketcategory_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_data_2eproto;
};
// -------------------------------------------------------------------

class IPOInformation final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:data.IPOInformation) */ {
 public:
  inline IPOInformation() : IPOInformation(nullptr) {}
  ~IPOInformation() override;
  explicit PROTOBUF_CONSTEXPR IPOInformation(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IPOInformation(const IPOInformation& from);
  IPOInformation(IPOInformation&& from) noexcept
    : IPOInformation() {
    *this = ::std::move(from);
  }

  inline IPOInformation& operator=(const IPOInformation& from) {
    CopyFrom(from);
    return *this;
  }
  inline IPOInformation& operator=(IPOInformation&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IPOInformation& default_instance() {
    return *internal_default_instance();
  }
  static inline const IPOInformation* internal_default_instance() {
    return reinterpret_cast<const IPOInformation*>(
               &_IPOInformation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(IPOInformation& a, IPOInformation& b) {
    a.Swap(&b);
  }
  inline void Swap(IPOInformation* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IPOInformation* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IPOInformation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IPOInformation>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IPOInformation& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const IPOInformation& from) {
    IPOInformation::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IPOInformation* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "data.IPOInformation";
  }
  protected:
  explicit IPOInformation(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIssueSymbolFieldNumber = 1,
    kSecurityClassFieldNumber = 2,
    kReferenceForNetChangeFieldNumber = 3,
    kReferencePriceFieldNumber = 4,
  };
  // optional string issueSymbol = 1;
  bool has_issuesymbol() const;
  private:
  bool _internal_has_issuesymbol() const;
  public:
  void clear_issuesymbol();
  const std::string& issuesymbol() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_issuesymbol(ArgT0&& arg0, ArgT... args);
  std::string* mutable_issuesymbol();
  PROTOBUF_NODISCARD std::string* release_issuesymbol();
  void set_allocated_issuesymbol(std::string* issuesymbol);
  private:
  const std::string& _internal_issuesymbol() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_issuesymbol(const std::string& value);
  std::string* _internal_mutable_issuesymbol();
  public:

  // optional .data.SecurityClass securityClass = 2;
  bool has_securityclass() const;
  private:
  bool _internal_has_securityclass() const;
  public:
  void clear_securityclass();
  ::data::SecurityClass securityclass() const;
  void set_securityclass(::data::SecurityClass value);
  private:
  ::data::SecurityClass _internal_securityclass() const;
  void _internal_set_securityclass(::data::SecurityClass value);
  public:

  // optional .data.NetChange referenceForNetChange = 3;
  bool has_referencefornetchange() const;
  private:
  bool _internal_has_referencefornetchange() const;
  public:
  void clear_referencefornetchange();
  ::data::NetChange referencefornetchange() const;
  void set_referencefornetchange(::data::NetChange value);
  private:
  ::data::NetChange _internal_referencefornetchange() const;
  void _internal_set_referencefornetchange(::data::NetChange value);
  public:

  // optional double referencePrice = 4;
  bool has_referenceprice() const;
  private:
  bool _internal_has_referenceprice() const;
  public:
  void clear_referenceprice();
  double referenceprice() const;
  void set_referenceprice(double value);
  private:
  double _internal_referenceprice() const;
  void _internal_set_referenceprice(double value);
  public:

  // @@protoc_insertion_point(class_scope:data.IPOInformation)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr issuesymbol_;
    int securityclass_;
    int referencefornetchange_;
    double referenceprice_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_data_2eproto;
};
// -------------------------------------------------------------------

class IPOQuotingPeriodUpdate final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:data.IPOQuotingPeriodUpdate) */ {
 public:
  inline IPOQuotingPeriodUpdate() : IPOQuotingPeriodUpdate(nullptr) {}
  ~IPOQuotingPeriodUpdate() override;
  explicit PROTOBUF_CONSTEXPR IPOQuotingPeriodUpdate(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IPOQuotingPeriodUpdate(const IPOQuotingPeriodUpdate& from);
  IPOQuotingPeriodUpdate(IPOQuotingPeriodUpdate&& from) noexcept
    : IPOQuotingPeriodUpdate() {
    *this = ::std::move(from);
  }

  inline IPOQuotingPeriodUpdate& operator=(const IPOQuotingPeriodUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  inline IPOQuotingPeriodUpdate& operator=(IPOQuotingPeriodUpdate&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IPOQuotingPeriodUpdate& default_instance() {
    return *internal_default_instance();
  }
  static inline const IPOQuotingPeriodUpdate* internal_default_instance() {
    return reinterpret_cast<const IPOQuotingPeriodUpdate*>(
               &_IPOQuotingPeriodUpdate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(IPOQuotingPeriodUpdate& a, IPOQuotingPeriodUpdate& b) {
    a.Swap(&b);
  }
  inline void Swap(IPOQuotingPeriodUpdate* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IPOQuotingPeriodUpdate* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IPOQuotingPeriodUpdate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IPOQuotingPeriodUpdate>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IPOQuotingPeriodUpdate& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const IPOQuotingPeriodUpdate& from) {
    IPOQuotingPeriodUpdate::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IPOQuotingPeriodUpdate* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "data.IPOQuotingPeriodUpdate";
  }
  protected:
  explicit IPOQuotingPeriodUpdate(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStockFieldNumber = 1,
    kIPOQuotationReleaseTimeFieldNumber = 2,
    kIPOPriceFieldNumber = 4,
    kQuotationReleaseQualifierFieldNumber = 3,
  };
  // optional string stock = 1;
  bool has_stock() const;
  private:
  bool _internal_has_stock() const;
  public:
  void clear_stock();
  const std::string& stock() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_stock(ArgT0&& arg0, ArgT... args);
  std::string* mutable_stock();
  PROTOBUF_NODISCARD std::string* release_stock();
  void set_allocated_stock(std::string* stock);
  private:
  const std::string& _internal_stock() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_stock(const std::string& value);
  std::string* _internal_mutable_stock();
  public:

  // optional int64 iPOQuotationReleaseTime = 2;
  bool has_ipoquotationreleasetime() const;
  private:
  bool _internal_has_ipoquotationreleasetime() const;
  public:
  void clear_ipoquotationreleasetime();
  int64_t ipoquotationreleasetime() const;
  void set_ipoquotationreleasetime(int64_t value);
  private:
  int64_t _internal_ipoquotationreleasetime() const;
  void _internal_set_ipoquotationreleasetime(int64_t value);
  public:

  // optional double iPOPrice = 4;
  bool has_ipoprice() const;
  private:
  bool _internal_has_ipoprice() const;
  public:
  void clear_ipoprice();
  double ipoprice() const;
  void set_ipoprice(double value);
  private:
  double _internal_ipoprice() const;
  void _internal_set_ipoprice(double value);
  public:

  // optional .data.IPOQuotationReleaseQualifier quotationReleaseQualifier = 3;
  bool has_quotationreleasequalifier() const;
  private:
  bool _internal_has_quotationreleasequalifier() const;
  public:
  void clear_quotationreleasequalifier();
  ::data::IPOQuotationReleaseQualifier quotationreleasequalifier() const;
  void set_quotationreleasequalifier(::data::IPOQuotationReleaseQualifier value);
  private:
  ::data::IPOQuotationReleaseQualifier _internal_quotationreleasequalifier() const;
  void _internal_set_quotationreleasequalifier(::data::IPOQuotationReleaseQualifier value);
  public:

  // @@protoc_insertion_point(class_scope:data.IPOQuotingPeriodUpdate)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr stock_;
    int64_t ipoquotationreleasetime_;
    double ipoprice_;
    int quotationreleasequalifier_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_data_2eproto;
};
// -------------------------------------------------------------------

class MWCBStatusMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:data.MWCBStatusMessage) */ {
 public:
  inline MWCBStatusMessage() : MWCBStatusMessage(nullptr) {}
  ~MWCBStatusMessage() override;
  explicit PROTOBUF_CONSTEXPR MWCBStatusMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MWCBStatusMessage(const MWCBStatusMessage& from);
  MWCBStatusMessage(MWCBStatusMessage&& from) noexcept
    : MWCBStatusMessage() {
    *this = ::std::move(from);
  }

  inline MWCBStatusMessage& operator=(const MWCBStatusMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline MWCBStatusMessage& operator=(MWCBStatusMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MWCBStatusMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const MWCBStatusMessage* internal_default_instance() {
    return reinterpret_cast<const MWCBStatusMessage*>(
               &_MWCBStatusMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(MWCBStatusMessage& a, MWCBStatusMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(MWCBStatusMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MWCBStatusMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MWCBStatusMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MWCBStatusMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MWCBStatusMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MWCBStatusMessage& from) {
    MWCBStatusMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MWCBStatusMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "data.MWCBStatusMessage";
  }
  protected:
  explicit MWCBStatusMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBreachedLevelFieldNumber = 1,
  };
  // optional .data.BreachedLevel breachedLevel = 1;
  bool has_breachedlevel() const;
  private:
  bool _internal_has_breachedlevel() const;
  public:
  void clear_breachedlevel();
  ::data::BreachedLevel breachedlevel() const;
  void set_breachedlevel(::data::BreachedLevel value);
  private:
  ::data::BreachedLevel _internal_breachedlevel() const;
  void _internal_set_breachedlevel(::data::BreachedLevel value);
  public:

  // @@protoc_insertion_point(class_scope:data.MWCBStatusMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int breachedlevel_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_data_2eproto;
};
// -------------------------------------------------------------------

class MarketWideCircuitBreaker final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:data.MarketWideCircuitBreaker) */ {
 public:
  inline MarketWideCircuitBreaker() : MarketWideCircuitBreaker(nullptr) {}
  ~MarketWideCircuitBreaker() override;
  explicit PROTOBUF_CONSTEXPR MarketWideCircuitBreaker(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MarketWideCircuitBreaker(const MarketWideCircuitBreaker& from);
  MarketWideCircuitBreaker(MarketWideCircuitBreaker&& from) noexcept
    : MarketWideCircuitBreaker() {
    *this = ::std::move(from);
  }

  inline MarketWideCircuitBreaker& operator=(const MarketWideCircuitBreaker& from) {
    CopyFrom(from);
    return *this;
  }
  inline MarketWideCircuitBreaker& operator=(MarketWideCircuitBreaker&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MarketWideCircuitBreaker& default_instance() {
    return *internal_default_instance();
  }
  static inline const MarketWideCircuitBreaker* internal_default_instance() {
    return reinterpret_cast<const MarketWideCircuitBreaker*>(
               &_MarketWideCircuitBreaker_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(MarketWideCircuitBreaker& a, MarketWideCircuitBreaker& b) {
    a.Swap(&b);
  }
  inline void Swap(MarketWideCircuitBreaker* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MarketWideCircuitBreaker* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MarketWideCircuitBreaker* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MarketWideCircuitBreaker>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MarketWideCircuitBreaker& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MarketWideCircuitBreaker& from) {
    MarketWideCircuitBreaker::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MarketWideCircuitBreaker* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "data.MarketWideCircuitBreaker";
  }
  protected:
  explicit MarketWideCircuitBreaker(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLevel1FieldNumber = 1,
    kLevel2FieldNumber = 2,
    kLevel3FieldNumber = 3,
  };
  // optional double Level1 = 1;
  bool has_level1() const;
  private:
  bool _internal_has_level1() const;
  public:
  void clear_level1();
  double level1() const;
  void set_level1(double value);
  private:
  double _internal_level1() const;
  void _internal_set_level1(double value);
  public:

  // optional double Level2 = 2;
  bool has_level2() const;
  private:
  bool _internal_has_level2() const;
  public:
  void clear_level2();
  double level2() const;
  void set_level2(double value);
  private:
  double _internal_level2() const;
  void _internal_set_level2(double value);
  public:

  // optional double Level3 = 3;
  bool has_level3() const;
  private:
  bool _internal_has_level3() const;
  public:
  void clear_level3();
  double level3() const;
  void set_level3(double value);
  private:
  double _internal_level3() const;
  void _internal_set_level3(double value);
  public:

  // @@protoc_insertion_point(class_scope:data.MarketWideCircuitBreaker)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    double level1_;
    double level2_;
    double level3_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_data_2eproto;
};
// -------------------------------------------------------------------

class MessageHeader final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:data.MessageHeader) */ {
 public:
  inline MessageHeader() : MessageHeader(nullptr) {}
  ~MessageHeader() override;
  explicit PROTOBUF_CONSTEXPR MessageHeader(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MessageHeader(const MessageHeader& from);
  MessageHeader(MessageHeader&& from) noexcept
    : MessageHeader() {
    *this = ::std::move(from);
  }

  inline MessageHeader& operator=(const MessageHeader& from) {
    CopyFrom(from);
    return *this;
  }
  inline MessageHeader& operator=(MessageHeader&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MessageHeader& default_instance() {
    return *internal_default_instance();
  }
  static inline const MessageHeader* internal_default_instance() {
    return reinterpret_cast<const MessageHeader*>(
               &_MessageHeader_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(MessageHeader& a, MessageHeader& b) {
    a.Swap(&b);
  }
  inline void Swap(MessageHeader* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MessageHeader* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MessageHeader* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MessageHeader>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MessageHeader& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MessageHeader& from) {
    MessageHeader::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MessageHeader* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "data.MessageHeader";
  }
  protected:
  explicit MessageHeader(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTimestampFieldNumber = 2,
    kTrackingNumberFieldNumber = 1,
    kMessageTypeFieldNumber = 3,
  };
  // optional int64 timestamp = 2;
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  int64_t timestamp() const;
  void set_timestamp(int64_t value);
  private:
  int64_t _internal_timestamp() const;
  void _internal_set_timestamp(int64_t value);
  public:

  // optional int32 trackingNumber = 1;
  bool has_trackingnumber() const;
  private:
  bool _internal_has_trackingnumber() const;
  public:
  void clear_trackingnumber();
  int32_t trackingnumber() const;
  void set_trackingnumber(int32_t value);
  private:
  int32_t _internal_trackingnumber() const;
  void _internal_set_trackingnumber(int32_t value);
  public:

  // optional .data.MessageType messageType = 3;
  bool has_messagetype() const;
  private:
  bool _internal_has_messagetype() const;
  public:
  void clear_messagetype();
  ::data::MessageType messagetype() const;
  void set_messagetype(::data::MessageType value);
  private:
  ::data::MessageType _internal_messagetype() const;
  void _internal_set_messagetype(::data::MessageType value);
  public:

  // @@protoc_insertion_point(class_scope:data.MessageHeader)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int64_t timestamp_;
    int32_t trackingnumber_;
    int messagetype_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_data_2eproto;
};
// -------------------------------------------------------------------

class OperationalHalt final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:data.OperationalHalt) */ {
 public:
  inline OperationalHalt() : OperationalHalt(nullptr) {}
  ~OperationalHalt() override;
  explicit PROTOBUF_CONSTEXPR OperationalHalt(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OperationalHalt(const OperationalHalt& from);
  OperationalHalt(OperationalHalt&& from) noexcept
    : OperationalHalt() {
    *this = ::std::move(from);
  }

  inline OperationalHalt& operator=(const OperationalHalt& from) {
    CopyFrom(from);
    return *this;
  }
  inline OperationalHalt& operator=(OperationalHalt&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OperationalHalt& default_instance() {
    return *internal_default_instance();
  }
  static inline const OperationalHalt* internal_default_instance() {
    return reinterpret_cast<const OperationalHalt*>(
               &_OperationalHalt_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(OperationalHalt& a, OperationalHalt& b) {
    a.Swap(&b);
  }
  inline void Swap(OperationalHalt* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OperationalHalt* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OperationalHalt* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OperationalHalt>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OperationalHalt& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OperationalHalt& from) {
    OperationalHalt::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OperationalHalt* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "data.OperationalHalt";
  }
  protected:
  explicit OperationalHalt(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStockFieldNumber = 1,
    kMarketCodeFieldNumber = 2,
    kOperationalHaltActionFieldNumber = 3,
  };
  // optional string stock = 1;
  bool has_stock() const;
  private:
  bool _internal_has_stock() const;
  public:
  void clear_stock();
  const std::string& stock() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_stock(ArgT0&& arg0, ArgT... args);
  std::string* mutable_stock();
  PROTOBUF_NODISCARD std::string* release_stock();
  void set_allocated_stock(std::string* stock);
  private:
  const std::string& _internal_stock() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_stock(const std::string& value);
  std::string* _internal_mutable_stock();
  public:

  // optional .data.MarketCode marketCode = 2;
  bool has_marketcode() const;
  private:
  bool _internal_has_marketcode() const;
  public:
  void clear_marketcode();
  ::data::MarketCode marketcode() const;
  void set_marketcode(::data::MarketCode value);
  private:
  ::data::MarketCode _internal_marketcode() const;
  void _internal_set_marketcode(::data::MarketCode value);
  public:

  // optional .data.OperationalHaltAction operationalHaltAction = 3;
  bool has_operationalhaltaction() const;
  private:
  bool _internal_has_operationalhaltaction() const;
  public:
  void clear_operationalhaltaction();
  ::data::OperationalHaltAction operationalhaltaction() const;
  void set_operationalhaltaction(::data::OperationalHaltAction value);
  private:
  ::data::OperationalHaltAction _internal_operationalhaltaction() const;
  void _internal_set_operationalhaltaction(::data::OperationalHaltAction value);
  public:

  // @@protoc_insertion_point(class_scope:data.OperationalHalt)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr stock_;
    int marketcode_;
    int operationalhaltaction_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_data_2eproto;
};
// -------------------------------------------------------------------

class SaleConditionModifier final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:data.SaleConditionModifier) */ {
 public:
  inline SaleConditionModifier() : SaleConditionModifier(nullptr) {}
  ~SaleConditionModifier() override;
  explicit PROTOBUF_CONSTEXPR SaleConditionModifier(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SaleConditionModifier(const SaleConditionModifier& from);
  SaleConditionModifier(SaleConditionModifier&& from) noexcept
    : SaleConditionModifier() {
    *this = ::std::move(from);
  }

  inline SaleConditionModifier& operator=(const SaleConditionModifier& from) {
    CopyFrom(from);
    return *this;
  }
  inline SaleConditionModifier& operator=(SaleConditionModifier&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SaleConditionModifier& default_instance() {
    return *internal_default_instance();
  }
  static inline const SaleConditionModifier* internal_default_instance() {
    return reinterpret_cast<const SaleConditionModifier*>(
               &_SaleConditionModifier_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(SaleConditionModifier& a, SaleConditionModifier& b) {
    a.Swap(&b);
  }
  inline void Swap(SaleConditionModifier* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SaleConditionModifier* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SaleConditionModifier* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SaleConditionModifier>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SaleConditionModifier& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SaleConditionModifier& from) {
    SaleConditionModifier::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SaleConditionModifier* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "data.SaleConditionModifier";
  }
  protected:
  explicit SaleConditionModifier(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLevel1FieldNumber = 1,
    kLevel2FieldNumber = 2,
    kLevel3FieldNumber = 3,
    kLevel4FieldNumber = 4,
  };
  // optional .data.LevelOne level1 = 1;
  bool has_level1() const;
  private:
  bool _internal_has_level1() const;
  public:
  void clear_level1();
  ::data::LevelOne level1() const;
  void set_level1(::data::LevelOne value);
  private:
  ::data::LevelOne _internal_level1() const;
  void _internal_set_level1(::data::LevelOne value);
  public:

  // optional .data.LevelTwo level2 = 2;
  bool has_level2() const;
  private:
  bool _internal_has_level2() const;
  public:
  void clear_level2();
  ::data::LevelTwo level2() const;
  void set_level2(::data::LevelTwo value);
  private:
  ::data::LevelTwo _internal_level2() const;
  void _internal_set_level2(::data::LevelTwo value);
  public:

  // optional .data.LevelThree level3 = 3;
  bool has_level3() const;
  private:
  bool _internal_has_level3() const;
  public:
  void clear_level3();
  ::data::LevelThree level3() const;
  void set_level3(::data::LevelThree value);
  private:
  ::data::LevelThree _internal_level3() const;
  void _internal_set_level3(::data::LevelThree value);
  public:

  // optional .data.LevelFour level4 = 4;
  bool has_level4() const;
  private:
  bool _internal_has_level4() const;
  public:
  void clear_level4();
  ::data::LevelFour level4() const;
  void set_level4(::data::LevelFour value);
  private:
  ::data::LevelFour _internal_level4() const;
  void _internal_set_level4(::data::LevelFour value);
  public:

  // @@protoc_insertion_point(class_scope:data.SaleConditionModifier)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int level1_;
    int level2_;
    int level3_;
    int level4_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_data_2eproto;
};
// -------------------------------------------------------------------

class ShortSaleRestrictionIndicatorMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:data.ShortSaleRestrictionIndicatorMessage) */ {
 public:
  inline ShortSaleRestrictionIndicatorMessage() : ShortSaleRestrictionIndicatorMessage(nullptr) {}
  ~ShortSaleRestrictionIndicatorMessage() override;
  explicit PROTOBUF_CONSTEXPR ShortSaleRestrictionIndicatorMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ShortSaleRestrictionIndicatorMessage(const ShortSaleRestrictionIndicatorMessage& from);
  ShortSaleRestrictionIndicatorMessage(ShortSaleRestrictionIndicatorMessage&& from) noexcept
    : ShortSaleRestrictionIndicatorMessage() {
    *this = ::std::move(from);
  }

  inline ShortSaleRestrictionIndicatorMessage& operator=(const ShortSaleRestrictionIndicatorMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline ShortSaleRestrictionIndicatorMessage& operator=(ShortSaleRestrictionIndicatorMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ShortSaleRestrictionIndicatorMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const ShortSaleRestrictionIndicatorMessage* internal_default_instance() {
    return reinterpret_cast<const ShortSaleRestrictionIndicatorMessage*>(
               &_ShortSaleRestrictionIndicatorMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(ShortSaleRestrictionIndicatorMessage& a, ShortSaleRestrictionIndicatorMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(ShortSaleRestrictionIndicatorMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ShortSaleRestrictionIndicatorMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ShortSaleRestrictionIndicatorMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ShortSaleRestrictionIndicatorMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ShortSaleRestrictionIndicatorMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ShortSaleRestrictionIndicatorMessage& from) {
    ShortSaleRestrictionIndicatorMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ShortSaleRestrictionIndicatorMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "data.ShortSaleRestrictionIndicatorMessage";
  }
  protected:
  explicit ShortSaleRestrictionIndicatorMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIssueSymbolFieldNumber = 1,
    kRegSHOActionFieldNumber = 2,
  };
  // optional string issueSymbol = 1;
  bool has_issuesymbol() const;
  private:
  bool _internal_has_issuesymbol() const;
  public:
  void clear_issuesymbol();
  const std::string& issuesymbol() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_issuesymbol(ArgT0&& arg0, ArgT... args);
  std::string* mutable_issuesymbol();
  PROTOBUF_NODISCARD std::string* release_issuesymbol();
  void set_allocated_issuesymbol(std::string* issuesymbol);
  private:
  const std::string& _internal_issuesymbol() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_issuesymbol(const std::string& value);
  std::string* _internal_mutable_issuesymbol();
  public:

  // optional .data.RegSHOAction regSHOAction = 2;
  bool has_regshoaction() const;
  private:
  bool _internal_has_regshoaction() const;
  public:
  void clear_regshoaction();
  ::data::RegSHOAction regshoaction() const;
  void set_regshoaction(::data::RegSHOAction value);
  private:
  ::data::RegSHOAction _internal_regshoaction() const;
  void _internal_set_regshoaction(::data::RegSHOAction value);
  public:

  // @@protoc_insertion_point(class_scope:data.ShortSaleRestrictionIndicatorMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr issuesymbol_;
    int regshoaction_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_data_2eproto;
};
// -------------------------------------------------------------------

class StockDirectory final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:data.StockDirectory) */ {
 public:
  inline StockDirectory() : StockDirectory(nullptr) {}
  ~StockDirectory() override;
  explicit PROTOBUF_CONSTEXPR StockDirectory(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StockDirectory(const StockDirectory& from);
  StockDirectory(StockDirectory&& from) noexcept
    : StockDirectory() {
    *this = ::std::move(from);
  }

  inline StockDirectory& operator=(const StockDirectory& from) {
    CopyFrom(from);
    return *this;
  }
  inline StockDirectory& operator=(StockDirectory&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StockDirectory& default_instance() {
    return *internal_default_instance();
  }
  static inline const StockDirectory* internal_default_instance() {
    return reinterpret_cast<const StockDirectory*>(
               &_StockDirectory_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(StockDirectory& a, StockDirectory& b) {
    a.Swap(&b);
  }
  inline void Swap(StockDirectory* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StockDirectory* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StockDirectory* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StockDirectory>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StockDirectory& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StockDirectory& from) {
    StockDirectory::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StockDirectory* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "data.StockDirectory";
  }
  protected:
  explicit StockDirectory(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStockFieldNumber = 1,
    kIssueClassificationFieldNumber = 6,
    kIssueSubTypeFieldNumber = 7,
    kBloombergIDFieldNumber = 15,
    kMarketCategoryFieldNumber = 2,
    kFinancialStatusIndicatorFieldNumber = 3,
    kRoundLotsizeFieldNumber = 4,
    kRoundLotOnlyFieldNumber = 5,
    kAuthenticityFieldNumber = 8,
    kShortSaleThresholdIndicatorFieldNumber = 9,
    kIPOFlagFieldNumber = 10,
    kLULDReferencePriceTierFieldNumber = 11,
    kETPlagFieldNumber = 12,
    kETPLeverageFactorFieldNumber = 13,
    kInverseIndicatorFieldNumber = 14,
  };
  // optional string stock = 1;
  bool has_stock() const;
  private:
  bool _internal_has_stock() const;
  public:
  void clear_stock();
  const std::string& stock() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_stock(ArgT0&& arg0, ArgT... args);
  std::string* mutable_stock();
  PROTOBUF_NODISCARD std::string* release_stock();
  void set_allocated_stock(std::string* stock);
  private:
  const std::string& _internal_stock() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_stock(const std::string& value);
  std::string* _internal_mutable_stock();
  public:

  // optional string issueClassification = 6;
  bool has_issueclassification() const;
  private:
  bool _internal_has_issueclassification() const;
  public:
  void clear_issueclassification();
  const std::string& issueclassification() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_issueclassification(ArgT0&& arg0, ArgT... args);
  std::string* mutable_issueclassification();
  PROTOBUF_NODISCARD std::string* release_issueclassification();
  void set_allocated_issueclassification(std::string* issueclassification);
  private:
  const std::string& _internal_issueclassification() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_issueclassification(const std::string& value);
  std::string* _internal_mutable_issueclassification();
  public:

  // optional string issueSubType = 7;
  bool has_issuesubtype() const;
  private:
  bool _internal_has_issuesubtype() const;
  public:
  void clear_issuesubtype();
  const std::string& issuesubtype() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_issuesubtype(ArgT0&& arg0, ArgT... args);
  std::string* mutable_issuesubtype();
  PROTOBUF_NODISCARD std::string* release_issuesubtype();
  void set_allocated_issuesubtype(std::string* issuesubtype);
  private:
  const std::string& _internal_issuesubtype() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_issuesubtype(const std::string& value);
  std::string* _internal_mutable_issuesubtype();
  public:

  // optional string bloombergID = 15;
  bool has_bloombergid() const;
  private:
  bool _internal_has_bloombergid() const;
  public:
  void clear_bloombergid();
  const std::string& bloombergid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_bloombergid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_bloombergid();
  PROTOBUF_NODISCARD std::string* release_bloombergid();
  void set_allocated_bloombergid(std::string* bloombergid);
  private:
  const std::string& _internal_bloombergid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_bloombergid(const std::string& value);
  std::string* _internal_mutable_bloombergid();
  public:

  // optional .data.MarketCategory marketCategory = 2;
  bool has_marketcategory() const;
  private:
  bool _internal_has_marketcategory() const;
  public:
  void clear_marketcategory();
  ::data::MarketCategory marketcategory() const;
  void set_marketcategory(::data::MarketCategory value);
  private:
  ::data::MarketCategory _internal_marketcategory() const;
  void _internal_set_marketcategory(::data::MarketCategory value);
  public:

  // optional .data.FinancialStatusIndicator financialStatusIndicator = 3;
  bool has_financialstatusindicator() const;
  private:
  bool _internal_has_financialstatusindicator() const;
  public:
  void clear_financialstatusindicator();
  ::data::FinancialStatusIndicator financialstatusindicator() const;
  void set_financialstatusindicator(::data::FinancialStatusIndicator value);
  private:
  ::data::FinancialStatusIndicator _internal_financialstatusindicator() const;
  void _internal_set_financialstatusindicator(::data::FinancialStatusIndicator value);
  public:

  // optional int64 roundLotsize = 4;
  bool has_roundlotsize() const;
  private:
  bool _internal_has_roundlotsize() const;
  public:
  void clear_roundlotsize();
  int64_t roundlotsize() const;
  void set_roundlotsize(int64_t value);
  private:
  int64_t _internal_roundlotsize() const;
  void _internal_set_roundlotsize(int64_t value);
  public:

  // optional .data.IndicatesIf roundLotOnly = 5;
  bool has_roundlotonly() const;
  private:
  bool _internal_has_roundlotonly() const;
  public:
  void clear_roundlotonly();
  ::data::IndicatesIf roundlotonly() const;
  void set_roundlotonly(::data::IndicatesIf value);
  private:
  ::data::IndicatesIf _internal_roundlotonly() const;
  void _internal_set_roundlotonly(::data::IndicatesIf value);
  public:

  // optional .data.Authenticity authenticity = 8;
  bool has_authenticity() const;
  private:
  bool _internal_has_authenticity() const;
  public:
  void clear_authenticity();
  ::data::Authenticity authenticity() const;
  void set_authenticity(::data::Authenticity value);
  private:
  ::data::Authenticity _internal_authenticity() const;
  void _internal_set_authenticity(::data::Authenticity value);
  public:

  // optional .data.IndicatesIf shortSaleThresholdIndicator = 9;
  bool has_shortsalethresholdindicator() const;
  private:
  bool _internal_has_shortsalethresholdindicator() const;
  public:
  void clear_shortsalethresholdindicator();
  ::data::IndicatesIf shortsalethresholdindicator() const;
  void set_shortsalethresholdindicator(::data::IndicatesIf value);
  private:
  ::data::IndicatesIf _internal_shortsalethresholdindicator() const;
  void _internal_set_shortsalethresholdindicator(::data::IndicatesIf value);
  public:

  // optional .data.IndicatesIf IPOFlag = 10;
  bool has_ipoflag() const;
  private:
  bool _internal_has_ipoflag() const;
  public:
  void clear_ipoflag();
  ::data::IndicatesIf ipoflag() const;
  void set_ipoflag(::data::IndicatesIf value);
  private:
  ::data::IndicatesIf _internal_ipoflag() const;
  void _internal_set_ipoflag(::data::IndicatesIf value);
  public:

  // optional .data.LULDRule lULDReferencePriceTier = 11;
  bool has_luldreferencepricetier() const;
  private:
  bool _internal_has_luldreferencepricetier() const;
  public:
  void clear_luldreferencepricetier();
  ::data::LULDRule luldreferencepricetier() const;
  void set_luldreferencepricetier(::data::LULDRule value);
  private:
  ::data::LULDRule _internal_luldreferencepricetier() const;
  void _internal_set_luldreferencepricetier(::data::LULDRule value);
  public:

  // optional .data.IndicatesIf ETPlag = 12;
  bool has_etplag() const;
  private:
  bool _internal_has_etplag() const;
  public:
  void clear_etplag();
  ::data::IndicatesIf etplag() const;
  void set_etplag(::data::IndicatesIf value);
  private:
  ::data::IndicatesIf _internal_etplag() const;
  void _internal_set_etplag(::data::IndicatesIf value);
  public:

  // optional int64 ETPLeverageFactor = 13;
  bool has_etpleveragefactor() const;
  private:
  bool _internal_has_etpleveragefactor() const;
  public:
  void clear_etpleveragefactor();
  int64_t etpleveragefactor() const;
  void set_etpleveragefactor(int64_t value);
  private:
  int64_t _internal_etpleveragefactor() const;
  void _internal_set_etpleveragefactor(int64_t value);
  public:

  // optional .data.IndicatesIf inverseIndicator = 14;
  bool has_inverseindicator() const;
  private:
  bool _internal_has_inverseindicator() const;
  public:
  void clear_inverseindicator();
  ::data::IndicatesIf inverseindicator() const;
  void set_inverseindicator(::data::IndicatesIf value);
  private:
  ::data::IndicatesIf _internal_inverseindicator() const;
  void _internal_set_inverseindicator(::data::IndicatesIf value);
  public:

  // @@protoc_insertion_point(class_scope:data.StockDirectory)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr stock_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr issueclassification_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr issuesubtype_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr bloombergid_;
    int marketcategory_;
    int financialstatusindicator_;
    int64_t roundlotsize_;
    int roundlotonly_;
    int authenticity_;
    int shortsalethresholdindicator_;
    int ipoflag_;
    int luldreferencepricetier_;
    int etplag_;
    int64_t etpleveragefactor_;
    int inverseindicator_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_data_2eproto;
};
// -------------------------------------------------------------------

class StockTradingAction final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:data.StockTradingAction) */ {
 public:
  inline StockTradingAction() : StockTradingAction(nullptr) {}
  ~StockTradingAction() override;
  explicit PROTOBUF_CONSTEXPR StockTradingAction(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StockTradingAction(const StockTradingAction& from);
  StockTradingAction(StockTradingAction&& from) noexcept
    : StockTradingAction() {
    *this = ::std::move(from);
  }

  inline StockTradingAction& operator=(const StockTradingAction& from) {
    CopyFrom(from);
    return *this;
  }
  inline StockTradingAction& operator=(StockTradingAction&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StockTradingAction& default_instance() {
    return *internal_default_instance();
  }
  static inline const StockTradingAction* internal_default_instance() {
    return reinterpret_cast<const StockTradingAction*>(
               &_StockTradingAction_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(StockTradingAction& a, StockTradingAction& b) {
    a.Swap(&b);
  }
  inline void Swap(StockTradingAction* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StockTradingAction* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StockTradingAction* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StockTradingAction>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StockTradingAction& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StockTradingAction& from) {
    StockTradingAction::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StockTradingAction* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "data.StockTradingAction";
  }
  protected:
  explicit StockTradingAction(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReservedFieldNumber = 1,
    kIssueSymbolFieldNumber = 2,
    kReasonFieldNumber = 5,
    kSecurityClassFieldNumber = 3,
    kCurrentTradingStateFieldNumber = 4,
  };
  // optional string reserved = 1;
  bool has_reserved() const;
  private:
  bool _internal_has_reserved() const;
  public:
  void clear_reserved();
  const std::string& reserved() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_reserved(ArgT0&& arg0, ArgT... args);
  std::string* mutable_reserved();
  PROTOBUF_NODISCARD std::string* release_reserved();
  void set_allocated_reserved(std::string* reserved);
  private:
  const std::string& _internal_reserved() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_reserved(const std::string& value);
  std::string* _internal_mutable_reserved();
  public:

  // optional string issueSymbol = 2;
  bool has_issuesymbol() const;
  private:
  bool _internal_has_issuesymbol() const;
  public:
  void clear_issuesymbol();
  const std::string& issuesymbol() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_issuesymbol(ArgT0&& arg0, ArgT... args);
  std::string* mutable_issuesymbol();
  PROTOBUF_NODISCARD std::string* release_issuesymbol();
  void set_allocated_issuesymbol(std::string* issuesymbol);
  private:
  const std::string& _internal_issuesymbol() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_issuesymbol(const std::string& value);
  std::string* _internal_mutable_issuesymbol();
  public:

  // optional string reason = 5;
  bool has_reason() const;
  private:
  bool _internal_has_reason() const;
  public:
  void clear_reason();
  const std::string& reason() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_reason(ArgT0&& arg0, ArgT... args);
  std::string* mutable_reason();
  PROTOBUF_NODISCARD std::string* release_reason();
  void set_allocated_reason(std::string* reason);
  private:
  const std::string& _internal_reason() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_reason(const std::string& value);
  std::string* _internal_mutable_reason();
  public:

  // optional .data.SecurityClass securityClass = 3;
  bool has_securityclass() const;
  private:
  bool _internal_has_securityclass() const;
  public:
  void clear_securityclass();
  ::data::SecurityClass securityclass() const;
  void set_securityclass(::data::SecurityClass value);
  private:
  ::data::SecurityClass _internal_securityclass() const;
  void _internal_set_securityclass(::data::SecurityClass value);
  public:

  // optional .data.CurrentTradingState currentTradingState = 4;
  bool has_currenttradingstate() const;
  private:
  bool _internal_has_currenttradingstate() const;
  public:
  void clear_currenttradingstate();
  ::data::CurrentTradingState currenttradingstate() const;
  void set_currenttradingstate(::data::CurrentTradingState value);
  private:
  ::data::CurrentTradingState _internal_currenttradingstate() const;
  void _internal_set_currenttradingstate(::data::CurrentTradingState value);
  public:

  // @@protoc_insertion_point(class_scope:data.StockTradingAction)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr reserved_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr issuesymbol_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr reason_;
    int securityclass_;
    int currenttradingstate_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_data_2eproto;
};
// -------------------------------------------------------------------

class SystemEventMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:data.SystemEventMessage) */ {
 public:
  inline SystemEventMessage() : SystemEventMessage(nullptr) {}
  ~SystemEventMessage() override;
  explicit PROTOBUF_CONSTEXPR SystemEventMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SystemEventMessage(const SystemEventMessage& from);
  SystemEventMessage(SystemEventMessage&& from) noexcept
    : SystemEventMessage() {
    *this = ::std::move(from);
  }

  inline SystemEventMessage& operator=(const SystemEventMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline SystemEventMessage& operator=(SystemEventMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SystemEventMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const SystemEventMessage* internal_default_instance() {
    return reinterpret_cast<const SystemEventMessage*>(
               &_SystemEventMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(SystemEventMessage& a, SystemEventMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(SystemEventMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SystemEventMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SystemEventMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SystemEventMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SystemEventMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SystemEventMessage& from) {
    SystemEventMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SystemEventMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "data.SystemEventMessage";
  }
  protected:
  explicit SystemEventMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEventCodeFieldNumber = 1,
  };
  // optional .data.EventCode eventCode = 1;
  bool has_eventcode() const;
  private:
  bool _internal_has_eventcode() const;
  public:
  void clear_eventcode();
  ::data::EventCode eventcode() const;
  void set_eventcode(::data::EventCode value);
  private:
  ::data::EventCode _internal_eventcode() const;
  void _internal_set_eventcode(::data::EventCode value);
  public:

  // @@protoc_insertion_point(class_scope:data.SystemEventMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int eventcode_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_data_2eproto;
};
// -------------------------------------------------------------------

class TradeCancelForNextsharesTrades final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:data.TradeCancelForNextsharesTrades) */ {
 public:
  inline TradeCancelForNextsharesTrades() : TradeCancelForNextsharesTrades(nullptr) {}
  ~TradeCancelForNextsharesTrades() override;
  explicit PROTOBUF_CONSTEXPR TradeCancelForNextsharesTrades(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TradeCancelForNextsharesTrades(const TradeCancelForNextsharesTrades& from);
  TradeCancelForNextsharesTrades(TradeCancelForNextsharesTrades&& from) noexcept
    : TradeCancelForNextsharesTrades() {
    *this = ::std::move(from);
  }

  inline TradeCancelForNextsharesTrades& operator=(const TradeCancelForNextsharesTrades& from) {
    CopyFrom(from);
    return *this;
  }
  inline TradeCancelForNextsharesTrades& operator=(TradeCancelForNextsharesTrades&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TradeCancelForNextsharesTrades& default_instance() {
    return *internal_default_instance();
  }
  static inline const TradeCancelForNextsharesTrades* internal_default_instance() {
    return reinterpret_cast<const TradeCancelForNextsharesTrades*>(
               &_TradeCancelForNextsharesTrades_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(TradeCancelForNextsharesTrades& a, TradeCancelForNextsharesTrades& b) {
    a.Swap(&b);
  }
  inline void Swap(TradeCancelForNextsharesTrades* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TradeCancelForNextsharesTrades* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TradeCancelForNextsharesTrades* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TradeCancelForNextsharesTrades>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TradeCancelForNextsharesTrades& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TradeCancelForNextsharesTrades& from) {
    TradeCancelForNextsharesTrades::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TradeCancelForNextsharesTrades* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "data.TradeCancelForNextsharesTrades";
  }
  protected:
  explicit TradeCancelForNextsharesTrades(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIssueSymbolFieldNumber = 2,
    kOriginalTradeControlNumberFieldNumber = 4,
    kOriginalSaleConditionModifierFieldNumber = 8,
    kMarketCenterIdentifierFieldNumber = 1,
    kSecurityClassFieldNumber = 3,
    kOriginalProxyPriceFieldNumber = 5,
    kOriginalNAVOffsetAmountFieldNumber = 6,
    kOriginalTradeSizeFieldNumber = 7,
    kConsolidatedVolumeFieldNumber = 9,
  };
  // optional string issueSymbol = 2;
  bool has_issuesymbol() const;
  private:
  bool _internal_has_issuesymbol() const;
  public:
  void clear_issuesymbol();
  const std::string& issuesymbol() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_issuesymbol(ArgT0&& arg0, ArgT... args);
  std::string* mutable_issuesymbol();
  PROTOBUF_NODISCARD std::string* release_issuesymbol();
  void set_allocated_issuesymbol(std::string* issuesymbol);
  private:
  const std::string& _internal_issuesymbol() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_issuesymbol(const std::string& value);
  std::string* _internal_mutable_issuesymbol();
  public:

  // optional string originalTradeControlNumber = 4;
  bool has_originaltradecontrolnumber() const;
  private:
  bool _internal_has_originaltradecontrolnumber() const;
  public:
  void clear_originaltradecontrolnumber();
  const std::string& originaltradecontrolnumber() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_originaltradecontrolnumber(ArgT0&& arg0, ArgT... args);
  std::string* mutable_originaltradecontrolnumber();
  PROTOBUF_NODISCARD std::string* release_originaltradecontrolnumber();
  void set_allocated_originaltradecontrolnumber(std::string* originaltradecontrolnumber);
  private:
  const std::string& _internal_originaltradecontrolnumber() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_originaltradecontrolnumber(const std::string& value);
  std::string* _internal_mutable_originaltradecontrolnumber();
  public:

  // optional string originalSaleConditionModifier = 8;
  bool has_originalsaleconditionmodifier() const;
  private:
  bool _internal_has_originalsaleconditionmodifier() const;
  public:
  void clear_originalsaleconditionmodifier();
  const std::string& originalsaleconditionmodifier() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_originalsaleconditionmodifier(ArgT0&& arg0, ArgT... args);
  std::string* mutable_originalsaleconditionmodifier();
  PROTOBUF_NODISCARD std::string* release_originalsaleconditionmodifier();
  void set_allocated_originalsaleconditionmodifier(std::string* originalsaleconditionmodifier);
  private:
  const std::string& _internal_originalsaleconditionmodifier() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_originalsaleconditionmodifier(const std::string& value);
  std::string* _internal_mutable_originalsaleconditionmodifier();
  public:

  // optional .data.OriginatingMarketCenterIdentifier marketCenterIdentifier = 1;
  bool has_marketcenteridentifier() const;
  private:
  bool _internal_has_marketcenteridentifier() const;
  public:
  void clear_marketcenteridentifier();
  ::data::OriginatingMarketCenterIdentifier marketcenteridentifier() const;
  void set_marketcenteridentifier(::data::OriginatingMarketCenterIdentifier value);
  private:
  ::data::OriginatingMarketCenterIdentifier _internal_marketcenteridentifier() const;
  void _internal_set_marketcenteridentifier(::data::OriginatingMarketCenterIdentifier value);
  public:

  // optional .data.SecurityClass securityClass = 3;
  bool has_securityclass() const;
  private:
  bool _internal_has_securityclass() const;
  public:
  void clear_securityclass();
  ::data::SecurityClass securityclass() const;
  void set_securityclass(::data::SecurityClass value);
  private:
  ::data::SecurityClass _internal_securityclass() const;
  void _internal_set_securityclass(::data::SecurityClass value);
  public:

  // optional double originalProxyPrice = 5;
  bool has_originalproxyprice() const;
  private:
  bool _internal_has_originalproxyprice() const;
  public:
  void clear_originalproxyprice();
  double originalproxyprice() const;
  void set_originalproxyprice(double value);
  private:
  double _internal_originalproxyprice() const;
  void _internal_set_originalproxyprice(double value);
  public:

  // optional double originalNAVOffsetAmount = 6;
  bool has_originalnavoffsetamount() const;
  private:
  bool _internal_has_originalnavoffsetamount() const;
  public:
  void clear_originalnavoffsetamount();
  double originalnavoffsetamount() const;
  void set_originalnavoffsetamount(double value);
  private:
  double _internal_originalnavoffsetamount() const;
  void _internal_set_originalnavoffsetamount(double value);
  public:

  // optional int64 originalTradeSize = 7;
  bool has_originaltradesize() const;
  private:
  bool _internal_has_originaltradesize() const;
  public:
  void clear_originaltradesize();
  int64_t originaltradesize() const;
  void set_originaltradesize(int64_t value);
  private:
  int64_t _internal_originaltradesize() const;
  void _internal_set_originaltradesize(int64_t value);
  public:

  // optional int64 consolidatedVolume = 9;
  bool has_consolidatedvolume() const;
  private:
  bool _internal_has_consolidatedvolume() const;
  public:
  void clear_consolidatedvolume();
  int64_t consolidatedvolume() const;
  void set_consolidatedvolume(int64_t value);
  private:
  int64_t _internal_consolidatedvolume() const;
  void _internal_set_consolidatedvolume(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:data.TradeCancelForNextsharesTrades)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr issuesymbol_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr originaltradecontrolnumber_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr originalsaleconditionmodifier_;
    int marketcenteridentifier_;
    int securityclass_;
    double originalproxyprice_;
    double originalnavoffsetamount_;
    int64_t originaltradesize_;
    int64_t consolidatedvolume_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_data_2eproto;
};
// -------------------------------------------------------------------

class TradeCancelForNonNextSharesTrades final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:data.TradeCancelForNonNextSharesTrades) */ {
 public:
  inline TradeCancelForNonNextSharesTrades() : TradeCancelForNonNextSharesTrades(nullptr) {}
  ~TradeCancelForNonNextSharesTrades() override;
  explicit PROTOBUF_CONSTEXPR TradeCancelForNonNextSharesTrades(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TradeCancelForNonNextSharesTrades(const TradeCancelForNonNextSharesTrades& from);
  TradeCancelForNonNextSharesTrades(TradeCancelForNonNextSharesTrades&& from) noexcept
    : TradeCancelForNonNextSharesTrades() {
    *this = ::std::move(from);
  }

  inline TradeCancelForNonNextSharesTrades& operator=(const TradeCancelForNonNextSharesTrades& from) {
    CopyFrom(from);
    return *this;
  }
  inline TradeCancelForNonNextSharesTrades& operator=(TradeCancelForNonNextSharesTrades&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TradeCancelForNonNextSharesTrades& default_instance() {
    return *internal_default_instance();
  }
  static inline const TradeCancelForNonNextSharesTrades* internal_default_instance() {
    return reinterpret_cast<const TradeCancelForNonNextSharesTrades*>(
               &_TradeCancelForNonNextSharesTrades_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(TradeCancelForNonNextSharesTrades& a, TradeCancelForNonNextSharesTrades& b) {
    a.Swap(&b);
  }
  inline void Swap(TradeCancelForNonNextSharesTrades* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TradeCancelForNonNextSharesTrades* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TradeCancelForNonNextSharesTrades* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TradeCancelForNonNextSharesTrades>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TradeCancelForNonNextSharesTrades& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TradeCancelForNonNextSharesTrades& from) {
    TradeCancelForNonNextSharesTrades::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TradeCancelForNonNextSharesTrades* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "data.TradeCancelForNonNextSharesTrades";
  }
  protected:
  explicit TradeCancelForNonNextSharesTrades(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIssueSymbolFieldNumber = 2,
    kOriginalControlNumberFieldNumber = 4,
    kOriginalSaleConditionModifierFieldNumber = 7,
    kMarketCenterIdentifierFieldNumber = 1,
    kSecurityClassFieldNumber = 3,
    kOriginalTradePriceFieldNumber = 5,
    kOriginalTradeSizeFieldNumber = 6,
    kConsolidatedVolumeFieldNumber = 8,
  };
  // optional string issueSymbol = 2;
  bool has_issuesymbol() const;
  private:
  bool _internal_has_issuesymbol() const;
  public:
  void clear_issuesymbol();
  const std::string& issuesymbol() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_issuesymbol(ArgT0&& arg0, ArgT... args);
  std::string* mutable_issuesymbol();
  PROTOBUF_NODISCARD std::string* release_issuesymbol();
  void set_allocated_issuesymbol(std::string* issuesymbol);
  private:
  const std::string& _internal_issuesymbol() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_issuesymbol(const std::string& value);
  std::string* _internal_mutable_issuesymbol();
  public:

  // optional string originalControlNumber = 4;
  bool has_originalcontrolnumber() const;
  private:
  bool _internal_has_originalcontrolnumber() const;
  public:
  void clear_originalcontrolnumber();
  const std::string& originalcontrolnumber() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_originalcontrolnumber(ArgT0&& arg0, ArgT... args);
  std::string* mutable_originalcontrolnumber();
  PROTOBUF_NODISCARD std::string* release_originalcontrolnumber();
  void set_allocated_originalcontrolnumber(std::string* originalcontrolnumber);
  private:
  const std::string& _internal_originalcontrolnumber() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_originalcontrolnumber(const std::string& value);
  std::string* _internal_mutable_originalcontrolnumber();
  public:

  // optional .data.SaleConditionModifier originalSaleConditionModifier = 7;
  bool has_originalsaleconditionmodifier() const;
  private:
  bool _internal_has_originalsaleconditionmodifier() const;
  public:
  void clear_originalsaleconditionmodifier();
  const ::data::SaleConditionModifier& originalsaleconditionmodifier() const;
  PROTOBUF_NODISCARD ::data::SaleConditionModifier* release_originalsaleconditionmodifier();
  ::data::SaleConditionModifier* mutable_originalsaleconditionmodifier();
  void set_allocated_originalsaleconditionmodifier(::data::SaleConditionModifier* originalsaleconditionmodifier);
  private:
  const ::data::SaleConditionModifier& _internal_originalsaleconditionmodifier() const;
  ::data::SaleConditionModifier* _internal_mutable_originalsaleconditionmodifier();
  public:
  void unsafe_arena_set_allocated_originalsaleconditionmodifier(
      ::data::SaleConditionModifier* originalsaleconditionmodifier);
  ::data::SaleConditionModifier* unsafe_arena_release_originalsaleconditionmodifier();

  // optional .data.OriginatingMarketCenterIdentifier marketCenterIdentifier = 1;
  bool has_marketcenteridentifier() const;
  private:
  bool _internal_has_marketcenteridentifier() const;
  public:
  void clear_marketcenteridentifier();
  ::data::OriginatingMarketCenterIdentifier marketcenteridentifier() const;
  void set_marketcenteridentifier(::data::OriginatingMarketCenterIdentifier value);
  private:
  ::data::OriginatingMarketCenterIdentifier _internal_marketcenteridentifier() const;
  void _internal_set_marketcenteridentifier(::data::OriginatingMarketCenterIdentifier value);
  public:

  // optional .data.SecurityClass securityClass = 3;
  bool has_securityclass() const;
  private:
  bool _internal_has_securityclass() const;
  public:
  void clear_securityclass();
  ::data::SecurityClass securityclass() const;
  void set_securityclass(::data::SecurityClass value);
  private:
  ::data::SecurityClass _internal_securityclass() const;
  void _internal_set_securityclass(::data::SecurityClass value);
  public:

  // optional double originalTradePrice = 5;
  bool has_originaltradeprice() const;
  private:
  bool _internal_has_originaltradeprice() const;
  public:
  void clear_originaltradeprice();
  double originaltradeprice() const;
  void set_originaltradeprice(double value);
  private:
  double _internal_originaltradeprice() const;
  void _internal_set_originaltradeprice(double value);
  public:

  // optional int64 originalTradeSize = 6;
  bool has_originaltradesize() const;
  private:
  bool _internal_has_originaltradesize() const;
  public:
  void clear_originaltradesize();
  int64_t originaltradesize() const;
  void set_originaltradesize(int64_t value);
  private:
  int64_t _internal_originaltradesize() const;
  void _internal_set_originaltradesize(int64_t value);
  public:

  // optional int64 consolidatedVolume = 8;
  bool has_consolidatedvolume() const;
  private:
  bool _internal_has_consolidatedvolume() const;
  public:
  void clear_consolidatedvolume();
  int64_t consolidatedvolume() const;
  void set_consolidatedvolume(int64_t value);
  private:
  int64_t _internal_consolidatedvolume() const;
  void _internal_set_consolidatedvolume(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:data.TradeCancelForNonNextSharesTrades)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr issuesymbol_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr originalcontrolnumber_;
    ::data::SaleConditionModifier* originalsaleconditionmodifier_;
    int marketcenteridentifier_;
    int securityclass_;
    double originaltradeprice_;
    int64_t originaltradesize_;
    int64_t consolidatedvolume_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_data_2eproto;
};
// -------------------------------------------------------------------

class TradeCorrectionForNextsharesTrades final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:data.TradeCorrectionForNextsharesTrades) */ {
 public:
  inline TradeCorrectionForNextsharesTrades() : TradeCorrectionForNextsharesTrades(nullptr) {}
  ~TradeCorrectionForNextsharesTrades() override;
  explicit PROTOBUF_CONSTEXPR TradeCorrectionForNextsharesTrades(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TradeCorrectionForNextsharesTrades(const TradeCorrectionForNextsharesTrades& from);
  TradeCorrectionForNextsharesTrades(TradeCorrectionForNextsharesTrades&& from) noexcept
    : TradeCorrectionForNextsharesTrades() {
    *this = ::std::move(from);
  }

  inline TradeCorrectionForNextsharesTrades& operator=(const TradeCorrectionForNextsharesTrades& from) {
    CopyFrom(from);
    return *this;
  }
  inline TradeCorrectionForNextsharesTrades& operator=(TradeCorrectionForNextsharesTrades&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TradeCorrectionForNextsharesTrades& default_instance() {
    return *internal_default_instance();
  }
  static inline const TradeCorrectionForNextsharesTrades* internal_default_instance() {
    return reinterpret_cast<const TradeCorrectionForNextsharesTrades*>(
               &_TradeCorrectionForNextsharesTrades_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(TradeCorrectionForNextsharesTrades& a, TradeCorrectionForNextsharesTrades& b) {
    a.Swap(&b);
  }
  inline void Swap(TradeCorrectionForNextsharesTrades* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TradeCorrectionForNextsharesTrades* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TradeCorrectionForNextsharesTrades* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TradeCorrectionForNextsharesTrades>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TradeCorrectionForNextsharesTrades& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TradeCorrectionForNextsharesTrades& from) {
    TradeCorrectionForNextsharesTrades::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TradeCorrectionForNextsharesTrades* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "data.TradeCorrectionForNextsharesTrades";
  }
  protected:
  explicit TradeCorrectionForNextsharesTrades(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIssueSymbolFieldNumber = 2,
    kOriginalControlNumberFieldNumber = 4,
    kOriginalConditionModifierFieldNumber = 8,
    kCorrectedTradeControlNumberFieldNumber = 9,
    kCorrectedSaleConditionModifierFieldNumber = 13,
    kMarketCenterIdentifierFieldNumber = 1,
    kSecurityClassFieldNumber = 3,
    kOriginalProxyPriceFieldNumber = 5,
    kOriginalNAVOffsetAmountFieldNumber = 6,
    kOriginalTradeSizeFieldNumber = 7,
    kCorrectedTradePriceFieldNumber = 10,
    kCorrectedNAVOffsetAmountFieldNumber = 11,
    kCorrectedTradeSizeFieldNumber = 12,
    kConsolidatedVolumeFieldNumber = 14,
  };
  // optional string issueSymbol = 2;
  bool has_issuesymbol() const;
  private:
  bool _internal_has_issuesymbol() const;
  public:
  void clear_issuesymbol();
  const std::string& issuesymbol() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_issuesymbol(ArgT0&& arg0, ArgT... args);
  std::string* mutable_issuesymbol();
  PROTOBUF_NODISCARD std::string* release_issuesymbol();
  void set_allocated_issuesymbol(std::string* issuesymbol);
  private:
  const std::string& _internal_issuesymbol() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_issuesymbol(const std::string& value);
  std::string* _internal_mutable_issuesymbol();
  public:

  // optional string originalControlNumber = 4;
  bool has_originalcontrolnumber() const;
  private:
  bool _internal_has_originalcontrolnumber() const;
  public:
  void clear_originalcontrolnumber();
  const std::string& originalcontrolnumber() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_originalcontrolnumber(ArgT0&& arg0, ArgT... args);
  std::string* mutable_originalcontrolnumber();
  PROTOBUF_NODISCARD std::string* release_originalcontrolnumber();
  void set_allocated_originalcontrolnumber(std::string* originalcontrolnumber);
  private:
  const std::string& _internal_originalcontrolnumber() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_originalcontrolnumber(const std::string& value);
  std::string* _internal_mutable_originalcontrolnumber();
  public:

  // optional string originalConditionModifier = 8;
  bool has_originalconditionmodifier() const;
  private:
  bool _internal_has_originalconditionmodifier() const;
  public:
  void clear_originalconditionmodifier();
  const std::string& originalconditionmodifier() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_originalconditionmodifier(ArgT0&& arg0, ArgT... args);
  std::string* mutable_originalconditionmodifier();
  PROTOBUF_NODISCARD std::string* release_originalconditionmodifier();
  void set_allocated_originalconditionmodifier(std::string* originalconditionmodifier);
  private:
  const std::string& _internal_originalconditionmodifier() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_originalconditionmodifier(const std::string& value);
  std::string* _internal_mutable_originalconditionmodifier();
  public:

  // optional string correctedTradeControlNumber = 9;
  bool has_correctedtradecontrolnumber() const;
  private:
  bool _internal_has_correctedtradecontrolnumber() const;
  public:
  void clear_correctedtradecontrolnumber();
  const std::string& correctedtradecontrolnumber() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_correctedtradecontrolnumber(ArgT0&& arg0, ArgT... args);
  std::string* mutable_correctedtradecontrolnumber();
  PROTOBUF_NODISCARD std::string* release_correctedtradecontrolnumber();
  void set_allocated_correctedtradecontrolnumber(std::string* correctedtradecontrolnumber);
  private:
  const std::string& _internal_correctedtradecontrolnumber() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_correctedtradecontrolnumber(const std::string& value);
  std::string* _internal_mutable_correctedtradecontrolnumber();
  public:

  // optional string CorrectedSaleConditionModifier = 13;
  bool has_correctedsaleconditionmodifier() const;
  private:
  bool _internal_has_correctedsaleconditionmodifier() const;
  public:
  void clear_correctedsaleconditionmodifier();
  const std::string& correctedsaleconditionmodifier() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_correctedsaleconditionmodifier(ArgT0&& arg0, ArgT... args);
  std::string* mutable_correctedsaleconditionmodifier();
  PROTOBUF_NODISCARD std::string* release_correctedsaleconditionmodifier();
  void set_allocated_correctedsaleconditionmodifier(std::string* correctedsaleconditionmodifier);
  private:
  const std::string& _internal_correctedsaleconditionmodifier() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_correctedsaleconditionmodifier(const std::string& value);
  std::string* _internal_mutable_correctedsaleconditionmodifier();
  public:

  // optional .data.OriginatingMarketCenterIdentifier marketCenterIdentifier = 1;
  bool has_marketcenteridentifier() const;
  private:
  bool _internal_has_marketcenteridentifier() const;
  public:
  void clear_marketcenteridentifier();
  ::data::OriginatingMarketCenterIdentifier marketcenteridentifier() const;
  void set_marketcenteridentifier(::data::OriginatingMarketCenterIdentifier value);
  private:
  ::data::OriginatingMarketCenterIdentifier _internal_marketcenteridentifier() const;
  void _internal_set_marketcenteridentifier(::data::OriginatingMarketCenterIdentifier value);
  public:

  // optional .data.SecurityClass securityClass = 3;
  bool has_securityclass() const;
  private:
  bool _internal_has_securityclass() const;
  public:
  void clear_securityclass();
  ::data::SecurityClass securityclass() const;
  void set_securityclass(::data::SecurityClass value);
  private:
  ::data::SecurityClass _internal_securityclass() const;
  void _internal_set_securityclass(::data::SecurityClass value);
  public:

  // optional double originalProxyPrice = 5;
  bool has_originalproxyprice() const;
  private:
  bool _internal_has_originalproxyprice() const;
  public:
  void clear_originalproxyprice();
  double originalproxyprice() const;
  void set_originalproxyprice(double value);
  private:
  double _internal_originalproxyprice() const;
  void _internal_set_originalproxyprice(double value);
  public:

  // optional double originalNAVOffsetAmount = 6;
  bool has_originalnavoffsetamount() const;
  private:
  bool _internal_has_originalnavoffsetamount() const;
  public:
  void clear_originalnavoffsetamount();
  double originalnavoffsetamount() const;
  void set_originalnavoffsetamount(double value);
  private:
  double _internal_originalnavoffsetamount() const;
  void _internal_set_originalnavoffsetamount(double value);
  public:

  // optional int64 originalTradeSize = 7;
  bool has_originaltradesize() const;
  private:
  bool _internal_has_originaltradesize() const;
  public:
  void clear_originaltradesize();
  int64_t originaltradesize() const;
  void set_originaltradesize(int64_t value);
  private:
  int64_t _internal_originaltradesize() const;
  void _internal_set_originaltradesize(int64_t value);
  public:

  // optional double correctedTradePrice = 10;
  bool has_correctedtradeprice() const;
  private:
  bool _internal_has_correctedtradeprice() const;
  public:
  void clear_correctedtradeprice();
  double correctedtradeprice() const;
  void set_correctedtradeprice(double value);
  private:
  double _internal_correctedtradeprice() const;
  void _internal_set_correctedtradeprice(double value);
  public:

  // optional double correctedNAVOffsetAmount = 11;
  bool has_correctednavoffsetamount() const;
  private:
  bool _internal_has_correctednavoffsetamount() const;
  public:
  void clear_correctednavoffsetamount();
  double correctednavoffsetamount() const;
  void set_correctednavoffsetamount(double value);
  private:
  double _internal_correctednavoffsetamount() const;
  void _internal_set_correctednavoffsetamount(double value);
  public:

  // optional int64 CorrectedTradeSize = 12;
  bool has_correctedtradesize() const;
  private:
  bool _internal_has_correctedtradesize() const;
  public:
  void clear_correctedtradesize();
  int64_t correctedtradesize() const;
  void set_correctedtradesize(int64_t value);
  private:
  int64_t _internal_correctedtradesize() const;
  void _internal_set_correctedtradesize(int64_t value);
  public:

  // optional int64 consolidatedVolume = 14;
  bool has_consolidatedvolume() const;
  private:
  bool _internal_has_consolidatedvolume() const;
  public:
  void clear_consolidatedvolume();
  int64_t consolidatedvolume() const;
  void set_consolidatedvolume(int64_t value);
  private:
  int64_t _internal_consolidatedvolume() const;
  void _internal_set_consolidatedvolume(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:data.TradeCorrectionForNextsharesTrades)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr issuesymbol_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr originalcontrolnumber_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr originalconditionmodifier_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr correctedtradecontrolnumber_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr correctedsaleconditionmodifier_;
    int marketcenteridentifier_;
    int securityclass_;
    double originalproxyprice_;
    double originalnavoffsetamount_;
    int64_t originaltradesize_;
    double correctedtradeprice_;
    double correctednavoffsetamount_;
    int64_t correctedtradesize_;
    int64_t consolidatedvolume_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_data_2eproto;
};
// -------------------------------------------------------------------

class TradeCorrectionForNonNextsharesTrades final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:data.TradeCorrectionForNonNextsharesTrades) */ {
 public:
  inline TradeCorrectionForNonNextsharesTrades() : TradeCorrectionForNonNextsharesTrades(nullptr) {}
  ~TradeCorrectionForNonNextsharesTrades() override;
  explicit PROTOBUF_CONSTEXPR TradeCorrectionForNonNextsharesTrades(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TradeCorrectionForNonNextsharesTrades(const TradeCorrectionForNonNextsharesTrades& from);
  TradeCorrectionForNonNextsharesTrades(TradeCorrectionForNonNextsharesTrades&& from) noexcept
    : TradeCorrectionForNonNextsharesTrades() {
    *this = ::std::move(from);
  }

  inline TradeCorrectionForNonNextsharesTrades& operator=(const TradeCorrectionForNonNextsharesTrades& from) {
    CopyFrom(from);
    return *this;
  }
  inline TradeCorrectionForNonNextsharesTrades& operator=(TradeCorrectionForNonNextsharesTrades&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TradeCorrectionForNonNextsharesTrades& default_instance() {
    return *internal_default_instance();
  }
  static inline const TradeCorrectionForNonNextsharesTrades* internal_default_instance() {
    return reinterpret_cast<const TradeCorrectionForNonNextsharesTrades*>(
               &_TradeCorrectionForNonNextsharesTrades_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(TradeCorrectionForNonNextsharesTrades& a, TradeCorrectionForNonNextsharesTrades& b) {
    a.Swap(&b);
  }
  inline void Swap(TradeCorrectionForNonNextsharesTrades* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TradeCorrectionForNonNextsharesTrades* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TradeCorrectionForNonNextsharesTrades* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TradeCorrectionForNonNextsharesTrades>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TradeCorrectionForNonNextsharesTrades& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TradeCorrectionForNonNextsharesTrades& from) {
    TradeCorrectionForNonNextsharesTrades::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TradeCorrectionForNonNextsharesTrades* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "data.TradeCorrectionForNonNextsharesTrades";
  }
  protected:
  explicit TradeCorrectionForNonNextsharesTrades(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIssueSymbolFieldNumber = 2,
    kOriginalControlNumberFieldNumber = 4,
    kOriginalConditionModifierFieldNumber = 7,
    kCorrectedTradeControlNumberFieldNumber = 8,
    kCorrectedSaleConditionModifierFieldNumber = 11,
    kMarketCenterIdentifierFieldNumber = 1,
    kSecurityClassFieldNumber = 3,
    kOriginalTradePriceFieldNumber = 5,
    kOriginalTradeSizeFieldNumber = 6,
    kCorrectedTradePriceFieldNumber = 9,
    kCorrectedTradeSizeFieldNumber = 10,
    kConsolidatedVolumeFieldNumber = 12,
  };
  // optional string issueSymbol = 2;
  bool has_issuesymbol() const;
  private:
  bool _internal_has_issuesymbol() const;
  public:
  void clear_issuesymbol();
  const std::string& issuesymbol() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_issuesymbol(ArgT0&& arg0, ArgT... args);
  std::string* mutable_issuesymbol();
  PROTOBUF_NODISCARD std::string* release_issuesymbol();
  void set_allocated_issuesymbol(std::string* issuesymbol);
  private:
  const std::string& _internal_issuesymbol() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_issuesymbol(const std::string& value);
  std::string* _internal_mutable_issuesymbol();
  public:

  // optional string originalControlNumber = 4;
  bool has_originalcontrolnumber() const;
  private:
  bool _internal_has_originalcontrolnumber() const;
  public:
  void clear_originalcontrolnumber();
  const std::string& originalcontrolnumber() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_originalcontrolnumber(ArgT0&& arg0, ArgT... args);
  std::string* mutable_originalcontrolnumber();
  PROTOBUF_NODISCARD std::string* release_originalcontrolnumber();
  void set_allocated_originalcontrolnumber(std::string* originalcontrolnumber);
  private:
  const std::string& _internal_originalcontrolnumber() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_originalcontrolnumber(const std::string& value);
  std::string* _internal_mutable_originalcontrolnumber();
  public:

  // optional string originalConditionModifier = 7;
  bool has_originalconditionmodifier() const;
  private:
  bool _internal_has_originalconditionmodifier() const;
  public:
  void clear_originalconditionmodifier();
  const std::string& originalconditionmodifier() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_originalconditionmodifier(ArgT0&& arg0, ArgT... args);
  std::string* mutable_originalconditionmodifier();
  PROTOBUF_NODISCARD std::string* release_originalconditionmodifier();
  void set_allocated_originalconditionmodifier(std::string* originalconditionmodifier);
  private:
  const std::string& _internal_originalconditionmodifier() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_originalconditionmodifier(const std::string& value);
  std::string* _internal_mutable_originalconditionmodifier();
  public:

  // optional string correctedTradeControlNumber = 8;
  bool has_correctedtradecontrolnumber() const;
  private:
  bool _internal_has_correctedtradecontrolnumber() const;
  public:
  void clear_correctedtradecontrolnumber();
  const std::string& correctedtradecontrolnumber() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_correctedtradecontrolnumber(ArgT0&& arg0, ArgT... args);
  std::string* mutable_correctedtradecontrolnumber();
  PROTOBUF_NODISCARD std::string* release_correctedtradecontrolnumber();
  void set_allocated_correctedtradecontrolnumber(std::string* correctedtradecontrolnumber);
  private:
  const std::string& _internal_correctedtradecontrolnumber() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_correctedtradecontrolnumber(const std::string& value);
  std::string* _internal_mutable_correctedtradecontrolnumber();
  public:

  // optional string CorrectedSaleConditionModifier = 11;
  bool has_correctedsaleconditionmodifier() const;
  private:
  bool _internal_has_correctedsaleconditionmodifier() const;
  public:
  void clear_correctedsaleconditionmodifier();
  const std::string& correctedsaleconditionmodifier() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_correctedsaleconditionmodifier(ArgT0&& arg0, ArgT... args);
  std::string* mutable_correctedsaleconditionmodifier();
  PROTOBUF_NODISCARD std::string* release_correctedsaleconditionmodifier();
  void set_allocated_correctedsaleconditionmodifier(std::string* correctedsaleconditionmodifier);
  private:
  const std::string& _internal_correctedsaleconditionmodifier() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_correctedsaleconditionmodifier(const std::string& value);
  std::string* _internal_mutable_correctedsaleconditionmodifier();
  public:

  // optional .data.OriginatingMarketCenterIdentifier marketCenterIdentifier = 1;
  bool has_marketcenteridentifier() const;
  private:
  bool _internal_has_marketcenteridentifier() const;
  public:
  void clear_marketcenteridentifier();
  ::data::OriginatingMarketCenterIdentifier marketcenteridentifier() const;
  void set_marketcenteridentifier(::data::OriginatingMarketCenterIdentifier value);
  private:
  ::data::OriginatingMarketCenterIdentifier _internal_marketcenteridentifier() const;
  void _internal_set_marketcenteridentifier(::data::OriginatingMarketCenterIdentifier value);
  public:

  // optional .data.SecurityClass securityClass = 3;
  bool has_securityclass() const;
  private:
  bool _internal_has_securityclass() const;
  public:
  void clear_securityclass();
  ::data::SecurityClass securityclass() const;
  void set_securityclass(::data::SecurityClass value);
  private:
  ::data::SecurityClass _internal_securityclass() const;
  void _internal_set_securityclass(::data::SecurityClass value);
  public:

  // optional double originalTradePrice = 5;
  bool has_originaltradeprice() const;
  private:
  bool _internal_has_originaltradeprice() const;
  public:
  void clear_originaltradeprice();
  double originaltradeprice() const;
  void set_originaltradeprice(double value);
  private:
  double _internal_originaltradeprice() const;
  void _internal_set_originaltradeprice(double value);
  public:

  // optional int64 originalTradeSize = 6;
  bool has_originaltradesize() const;
  private:
  bool _internal_has_originaltradesize() const;
  public:
  void clear_originaltradesize();
  int64_t originaltradesize() const;
  void set_originaltradesize(int64_t value);
  private:
  int64_t _internal_originaltradesize() const;
  void _internal_set_originaltradesize(int64_t value);
  public:

  // optional double correctedTradePrice = 9;
  bool has_correctedtradeprice() const;
  private:
  bool _internal_has_correctedtradeprice() const;
  public:
  void clear_correctedtradeprice();
  double correctedtradeprice() const;
  void set_correctedtradeprice(double value);
  private:
  double _internal_correctedtradeprice() const;
  void _internal_set_correctedtradeprice(double value);
  public:

  // optional int64 CorrectedTradeSize = 10;
  bool has_correctedtradesize() const;
  private:
  bool _internal_has_correctedtradesize() const;
  public:
  void clear_correctedtradesize();
  int64_t correctedtradesize() const;
  void set_correctedtradesize(int64_t value);
  private:
  int64_t _internal_correctedtradesize() const;
  void _internal_set_correctedtradesize(int64_t value);
  public:

  // optional int64 consolidatedVolume = 12;
  bool has_consolidatedvolume() const;
  private:
  bool _internal_has_consolidatedvolume() const;
  public:
  void clear_consolidatedvolume();
  int64_t consolidatedvolume() const;
  void set_consolidatedvolume(int64_t value);
  private:
  int64_t _internal_consolidatedvolume() const;
  void _internal_set_consolidatedvolume(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:data.TradeCorrectionForNonNextsharesTrades)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr issuesymbol_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr originalcontrolnumber_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr originalconditionmodifier_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr correctedtradecontrolnumber_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr correctedsaleconditionmodifier_;
    int marketcenteridentifier_;
    int securityclass_;
    double originaltradeprice_;
    int64_t originaltradesize_;
    double correctedtradeprice_;
    int64_t correctedtradesize_;
    int64_t consolidatedvolume_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_data_2eproto;
};
// -------------------------------------------------------------------

class TradeReportForNextshares final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:data.TradeReportForNextshares) */ {
 public:
  inline TradeReportForNextshares() : TradeReportForNextshares(nullptr) {}
  ~TradeReportForNextshares() override;
  explicit PROTOBUF_CONSTEXPR TradeReportForNextshares(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TradeReportForNextshares(const TradeReportForNextshares& from);
  TradeReportForNextshares(TradeReportForNextshares&& from) noexcept
    : TradeReportForNextshares() {
    *this = ::std::move(from);
  }

  inline TradeReportForNextshares& operator=(const TradeReportForNextshares& from) {
    CopyFrom(from);
    return *this;
  }
  inline TradeReportForNextshares& operator=(TradeReportForNextshares&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TradeReportForNextshares& default_instance() {
    return *internal_default_instance();
  }
  static inline const TradeReportForNextshares* internal_default_instance() {
    return reinterpret_cast<const TradeReportForNextshares*>(
               &_TradeReportForNextshares_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(TradeReportForNextshares& a, TradeReportForNextshares& b) {
    a.Swap(&b);
  }
  inline void Swap(TradeReportForNextshares* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TradeReportForNextshares* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TradeReportForNextshares* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TradeReportForNextshares>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TradeReportForNextshares& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TradeReportForNextshares& from) {
    TradeReportForNextshares::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TradeReportForNextshares* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "data.TradeReportForNextshares";
  }
  protected:
  explicit TradeReportForNextshares(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNextsharesSymbolFieldNumber = 2,
    kTradeControlNumberFieldNumber = 4,
    kSaleConditionModifierFieldNumber = 8,
    kOriginatingMarketCenterIdentifierFieldNumber = 1,
    kSecurityClassFieldNumber = 3,
    kProxyPriceFieldNumber = 5,
    kTradeSizeFieldNumber = 6,
    kNAVOffsetAmountFieldNumber = 7,
    kConsolidatedVolumeFieldNumber = 9,
  };
  // optional string nextsharesSymbol = 2;
  bool has_nextsharessymbol() const;
  private:
  bool _internal_has_nextsharessymbol() const;
  public:
  void clear_nextsharessymbol();
  const std::string& nextsharessymbol() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_nextsharessymbol(ArgT0&& arg0, ArgT... args);
  std::string* mutable_nextsharessymbol();
  PROTOBUF_NODISCARD std::string* release_nextsharessymbol();
  void set_allocated_nextsharessymbol(std::string* nextsharessymbol);
  private:
  const std::string& _internal_nextsharessymbol() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_nextsharessymbol(const std::string& value);
  std::string* _internal_mutable_nextsharessymbol();
  public:

  // optional string tradeControlNumber = 4;
  bool has_tradecontrolnumber() const;
  private:
  bool _internal_has_tradecontrolnumber() const;
  public:
  void clear_tradecontrolnumber();
  const std::string& tradecontrolnumber() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tradecontrolnumber(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tradecontrolnumber();
  PROTOBUF_NODISCARD std::string* release_tradecontrolnumber();
  void set_allocated_tradecontrolnumber(std::string* tradecontrolnumber);
  private:
  const std::string& _internal_tradecontrolnumber() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tradecontrolnumber(const std::string& value);
  std::string* _internal_mutable_tradecontrolnumber();
  public:

  // optional .data.SaleConditionModifier saleConditionModifier = 8;
  bool has_saleconditionmodifier() const;
  private:
  bool _internal_has_saleconditionmodifier() const;
  public:
  void clear_saleconditionmodifier();
  const ::data::SaleConditionModifier& saleconditionmodifier() const;
  PROTOBUF_NODISCARD ::data::SaleConditionModifier* release_saleconditionmodifier();
  ::data::SaleConditionModifier* mutable_saleconditionmodifier();
  void set_allocated_saleconditionmodifier(::data::SaleConditionModifier* saleconditionmodifier);
  private:
  const ::data::SaleConditionModifier& _internal_saleconditionmodifier() const;
  ::data::SaleConditionModifier* _internal_mutable_saleconditionmodifier();
  public:
  void unsafe_arena_set_allocated_saleconditionmodifier(
      ::data::SaleConditionModifier* saleconditionmodifier);
  ::data::SaleConditionModifier* unsafe_arena_release_saleconditionmodifier();

  // optional .data.OriginatingMarketCenterIdentifier originatingMarketCenterIdentifier = 1;
  bool has_originatingmarketcenteridentifier() const;
  private:
  bool _internal_has_originatingmarketcenteridentifier() const;
  public:
  void clear_originatingmarketcenteridentifier();
  ::data::OriginatingMarketCenterIdentifier originatingmarketcenteridentifier() const;
  void set_originatingmarketcenteridentifier(::data::OriginatingMarketCenterIdentifier value);
  private:
  ::data::OriginatingMarketCenterIdentifier _internal_originatingmarketcenteridentifier() const;
  void _internal_set_originatingmarketcenteridentifier(::data::OriginatingMarketCenterIdentifier value);
  public:

  // optional .data.SecurityClass securityClass = 3;
  bool has_securityclass() const;
  private:
  bool _internal_has_securityclass() const;
  public:
  void clear_securityclass();
  ::data::SecurityClass securityclass() const;
  void set_securityclass(::data::SecurityClass value);
  private:
  ::data::SecurityClass _internal_securityclass() const;
  void _internal_set_securityclass(::data::SecurityClass value);
  public:

  // optional double proxyPrice = 5;
  bool has_proxyprice() const;
  private:
  bool _internal_has_proxyprice() const;
  public:
  void clear_proxyprice();
  double proxyprice() const;
  void set_proxyprice(double value);
  private:
  double _internal_proxyprice() const;
  void _internal_set_proxyprice(double value);
  public:

  // optional int64 tradeSize = 6;
  bool has_tradesize() const;
  private:
  bool _internal_has_tradesize() const;
  public:
  void clear_tradesize();
  int64_t tradesize() const;
  void set_tradesize(int64_t value);
  private:
  int64_t _internal_tradesize() const;
  void _internal_set_tradesize(int64_t value);
  public:

  // optional double NAVOffsetAmount = 7;
  bool has_navoffsetamount() const;
  private:
  bool _internal_has_navoffsetamount() const;
  public:
  void clear_navoffsetamount();
  double navoffsetamount() const;
  void set_navoffsetamount(double value);
  private:
  double _internal_navoffsetamount() const;
  void _internal_set_navoffsetamount(double value);
  public:

  // optional int32 consolidatedVolume = 9;
  bool has_consolidatedvolume() const;
  private:
  bool _internal_has_consolidatedvolume() const;
  public:
  void clear_consolidatedvolume();
  int32_t consolidatedvolume() const;
  void set_consolidatedvolume(int32_t value);
  private:
  int32_t _internal_consolidatedvolume() const;
  void _internal_set_consolidatedvolume(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:data.TradeReportForNextshares)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr nextsharessymbol_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tradecontrolnumber_;
    ::data::SaleConditionModifier* saleconditionmodifier_;
    int originatingmarketcenteridentifier_;
    int securityclass_;
    double proxyprice_;
    int64_t tradesize_;
    double navoffsetamount_;
    int32_t consolidatedvolume_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_data_2eproto;
};
// -------------------------------------------------------------------

class TradeReportForNonNextshares final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:data.TradeReportForNonNextshares) */ {
 public:
  inline TradeReportForNonNextshares() : TradeReportForNonNextshares(nullptr) {}
  ~TradeReportForNonNextshares() override;
  explicit PROTOBUF_CONSTEXPR TradeReportForNonNextshares(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TradeReportForNonNextshares(const TradeReportForNonNextshares& from);
  TradeReportForNonNextshares(TradeReportForNonNextshares&& from) noexcept
    : TradeReportForNonNextshares() {
    *this = ::std::move(from);
  }

  inline TradeReportForNonNextshares& operator=(const TradeReportForNonNextshares& from) {
    CopyFrom(from);
    return *this;
  }
  inline TradeReportForNonNextshares& operator=(TradeReportForNonNextshares&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TradeReportForNonNextshares& default_instance() {
    return *internal_default_instance();
  }
  static inline const TradeReportForNonNextshares* internal_default_instance() {
    return reinterpret_cast<const TradeReportForNonNextshares*>(
               &_TradeReportForNonNextshares_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(TradeReportForNonNextshares& a, TradeReportForNonNextshares& b) {
    a.Swap(&b);
  }
  inline void Swap(TradeReportForNonNextshares* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TradeReportForNonNextshares* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TradeReportForNonNextshares* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TradeReportForNonNextshares>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TradeReportForNonNextshares& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TradeReportForNonNextshares& from) {
    TradeReportForNonNextshares::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TradeReportForNonNextshares* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "data.TradeReportForNonNextshares";
  }
  protected:
  explicit TradeReportForNonNextshares(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIssueSymbolFieldNumber = 2,
    kTradeControlNumberFieldNumber = 4,
    kSaleConditionModifierFieldNumber = 7,
    kOriginatingMarketCenterIdentifierFieldNumber = 1,
    kSecurityClassFieldNumber = 3,
    kTradePriceFieldNumber = 5,
    kTradeSizeFieldNumber = 6,
    kConsolidatedVolumeFieldNumber = 8,
  };
  // optional string issueSymbol = 2;
  bool has_issuesymbol() const;
  private:
  bool _internal_has_issuesymbol() const;
  public:
  void clear_issuesymbol();
  const std::string& issuesymbol() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_issuesymbol(ArgT0&& arg0, ArgT... args);
  std::string* mutable_issuesymbol();
  PROTOBUF_NODISCARD std::string* release_issuesymbol();
  void set_allocated_issuesymbol(std::string* issuesymbol);
  private:
  const std::string& _internal_issuesymbol() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_issuesymbol(const std::string& value);
  std::string* _internal_mutable_issuesymbol();
  public:

  // optional string tradeControlNumber = 4;
  bool has_tradecontrolnumber() const;
  private:
  bool _internal_has_tradecontrolnumber() const;
  public:
  void clear_tradecontrolnumber();
  const std::string& tradecontrolnumber() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tradecontrolnumber(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tradecontrolnumber();
  PROTOBUF_NODISCARD std::string* release_tradecontrolnumber();
  void set_allocated_tradecontrolnumber(std::string* tradecontrolnumber);
  private:
  const std::string& _internal_tradecontrolnumber() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tradecontrolnumber(const std::string& value);
  std::string* _internal_mutable_tradecontrolnumber();
  public:

  // optional .data.SaleConditionModifier saleConditionModifier = 7;
  bool has_saleconditionmodifier() const;
  private:
  bool _internal_has_saleconditionmodifier() const;
  public:
  void clear_saleconditionmodifier();
  const ::data::SaleConditionModifier& saleconditionmodifier() const;
  PROTOBUF_NODISCARD ::data::SaleConditionModifier* release_saleconditionmodifier();
  ::data::SaleConditionModifier* mutable_saleconditionmodifier();
  void set_allocated_saleconditionmodifier(::data::SaleConditionModifier* saleconditionmodifier);
  private:
  const ::data::SaleConditionModifier& _internal_saleconditionmodifier() const;
  ::data::SaleConditionModifier* _internal_mutable_saleconditionmodifier();
  public:
  void unsafe_arena_set_allocated_saleconditionmodifier(
      ::data::SaleConditionModifier* saleconditionmodifier);
  ::data::SaleConditionModifier* unsafe_arena_release_saleconditionmodifier();

  // optional .data.OriginatingMarketCenterIdentifier originatingMarketCenterIdentifier = 1;
  bool has_originatingmarketcenteridentifier() const;
  private:
  bool _internal_has_originatingmarketcenteridentifier() const;
  public:
  void clear_originatingmarketcenteridentifier();
  ::data::OriginatingMarketCenterIdentifier originatingmarketcenteridentifier() const;
  void set_originatingmarketcenteridentifier(::data::OriginatingMarketCenterIdentifier value);
  private:
  ::data::OriginatingMarketCenterIdentifier _internal_originatingmarketcenteridentifier() const;
  void _internal_set_originatingmarketcenteridentifier(::data::OriginatingMarketCenterIdentifier value);
  public:

  // optional .data.SecurityClass securityClass = 3;
  bool has_securityclass() const;
  private:
  bool _internal_has_securityclass() const;
  public:
  void clear_securityclass();
  ::data::SecurityClass securityclass() const;
  void set_securityclass(::data::SecurityClass value);
  private:
  ::data::SecurityClass _internal_securityclass() const;
  void _internal_set_securityclass(::data::SecurityClass value);
  public:

  // optional double tradePrice = 5;
  bool has_tradeprice() const;
  private:
  bool _internal_has_tradeprice() const;
  public:
  void clear_tradeprice();
  double tradeprice() const;
  void set_tradeprice(double value);
  private:
  double _internal_tradeprice() const;
  void _internal_set_tradeprice(double value);
  public:

  // optional int64 tradeSize = 6;
  bool has_tradesize() const;
  private:
  bool _internal_has_tradesize() const;
  public:
  void clear_tradesize();
  int64_t tradesize() const;
  void set_tradesize(int64_t value);
  private:
  int64_t _internal_tradesize() const;
  void _internal_set_tradesize(int64_t value);
  public:

  // optional int64 consolidatedVolume = 8;
  bool has_consolidatedvolume() const;
  private:
  bool _internal_has_consolidatedvolume() const;
  public:
  void clear_consolidatedvolume();
  int64_t consolidatedvolume() const;
  void set_consolidatedvolume(int64_t value);
  private:
  int64_t _internal_consolidatedvolume() const;
  void _internal_set_consolidatedvolume(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:data.TradeReportForNonNextshares)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr issuesymbol_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tradecontrolnumber_;
    ::data::SaleConditionModifier* saleconditionmodifier_;
    int originatingmarketcenteridentifier_;
    int securityclass_;
    double tradeprice_;
    int64_t tradesize_;
    int64_t consolidatedvolume_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_data_2eproto;
};
// -------------------------------------------------------------------

class QBBOMWCBBreachMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:data.QBBOMWCBBreachMessage) */ {
 public:
  inline QBBOMWCBBreachMessage() : QBBOMWCBBreachMessage(nullptr) {}
  ~QBBOMWCBBreachMessage() override;
  explicit PROTOBUF_CONSTEXPR QBBOMWCBBreachMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QBBOMWCBBreachMessage(const QBBOMWCBBreachMessage& from);
  QBBOMWCBBreachMessage(QBBOMWCBBreachMessage&& from) noexcept
    : QBBOMWCBBreachMessage() {
    *this = ::std::move(from);
  }

  inline QBBOMWCBBreachMessage& operator=(const QBBOMWCBBreachMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline QBBOMWCBBreachMessage& operator=(QBBOMWCBBreachMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QBBOMWCBBreachMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const QBBOMWCBBreachMessage* internal_default_instance() {
    return reinterpret_cast<const QBBOMWCBBreachMessage*>(
               &_QBBOMWCBBreachMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(QBBOMWCBBreachMessage& a, QBBOMWCBBreachMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(QBBOMWCBBreachMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QBBOMWCBBreachMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QBBOMWCBBreachMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QBBOMWCBBreachMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QBBOMWCBBreachMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QBBOMWCBBreachMessage& from) {
    QBBOMWCBBreachMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QBBOMWCBBreachMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "data.QBBOMWCBBreachMessage";
  }
  protected:
  explicit QBBOMWCBBreachMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBreachedLevelFieldNumber = 1,
  };
  // optional string breachedLevel = 1;
  bool has_breachedlevel() const;
  private:
  bool _internal_has_breachedlevel() const;
  public:
  void clear_breachedlevel();
  const std::string& breachedlevel() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_breachedlevel(ArgT0&& arg0, ArgT... args);
  std::string* mutable_breachedlevel();
  PROTOBUF_NODISCARD std::string* release_breachedlevel();
  void set_allocated_breachedlevel(std::string* breachedlevel);
  private:
  const std::string& _internal_breachedlevel() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_breachedlevel(const std::string& value);
  std::string* _internal_mutable_breachedlevel();
  public:

  // @@protoc_insertion_point(class_scope:data.QBBOMWCBBreachMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr breachedlevel_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_data_2eproto;
};
// -------------------------------------------------------------------

class QBBOMWCBDeclineLevelMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:data.QBBOMWCBDeclineLevelMessage) */ {
 public:
  inline QBBOMWCBDeclineLevelMessage() : QBBOMWCBDeclineLevelMessage(nullptr) {}
  ~QBBOMWCBDeclineLevelMessage() override;
  explicit PROTOBUF_CONSTEXPR QBBOMWCBDeclineLevelMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QBBOMWCBDeclineLevelMessage(const QBBOMWCBDeclineLevelMessage& from);
  QBBOMWCBDeclineLevelMessage(QBBOMWCBDeclineLevelMessage&& from) noexcept
    : QBBOMWCBDeclineLevelMessage() {
    *this = ::std::move(from);
  }

  inline QBBOMWCBDeclineLevelMessage& operator=(const QBBOMWCBDeclineLevelMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline QBBOMWCBDeclineLevelMessage& operator=(QBBOMWCBDeclineLevelMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QBBOMWCBDeclineLevelMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const QBBOMWCBDeclineLevelMessage* internal_default_instance() {
    return reinterpret_cast<const QBBOMWCBDeclineLevelMessage*>(
               &_QBBOMWCBDeclineLevelMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(QBBOMWCBDeclineLevelMessage& a, QBBOMWCBDeclineLevelMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(QBBOMWCBDeclineLevelMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QBBOMWCBDeclineLevelMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QBBOMWCBDeclineLevelMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QBBOMWCBDeclineLevelMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QBBOMWCBDeclineLevelMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QBBOMWCBDeclineLevelMessage& from) {
    QBBOMWCBDeclineLevelMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QBBOMWCBDeclineLevelMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "data.QBBOMWCBDeclineLevelMessage";
  }
  protected:
  explicit QBBOMWCBDeclineLevelMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLevel1FieldNumber = 1,
    kLevel2FieldNumber = 2,
    kLevel3FieldNumber = 3,
  };
  // optional double Level1 = 1;
  bool has_level1() const;
  private:
  bool _internal_has_level1() const;
  public:
  void clear_level1();
  double level1() const;
  void set_level1(double value);
  private:
  double _internal_level1() const;
  void _internal_set_level1(double value);
  public:

  // optional double Level2 = 2;
  bool has_level2() const;
  private:
  bool _internal_has_level2() const;
  public:
  void clear_level2();
  double level2() const;
  void set_level2(double value);
  private:
  double _internal_level2() const;
  void _internal_set_level2(double value);
  public:

  // optional double Level3 = 3;
  bool has_level3() const;
  private:
  bool _internal_has_level3() const;
  public:
  void clear_level3();
  double level3() const;
  void set_level3(double value);
  private:
  double _internal_level3() const;
  void _internal_set_level3(double value);
  public:

  // @@protoc_insertion_point(class_scope:data.QBBOMWCBDeclineLevelMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    double level1_;
    double level2_;
    double level3_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_data_2eproto;
};
// -------------------------------------------------------------------

class QBBOMessageHeader final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:data.QBBOMessageHeader) */ {
 public:
  inline QBBOMessageHeader() : QBBOMessageHeader(nullptr) {}
  ~QBBOMessageHeader() override;
  explicit PROTOBUF_CONSTEXPR QBBOMessageHeader(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QBBOMessageHeader(const QBBOMessageHeader& from);
  QBBOMessageHeader(QBBOMessageHeader&& from) noexcept
    : QBBOMessageHeader() {
    *this = ::std::move(from);
  }

  inline QBBOMessageHeader& operator=(const QBBOMessageHeader& from) {
    CopyFrom(from);
    return *this;
  }
  inline QBBOMessageHeader& operator=(QBBOMessageHeader&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QBBOMessageHeader& default_instance() {
    return *internal_default_instance();
  }
  static inline const QBBOMessageHeader* internal_default_instance() {
    return reinterpret_cast<const QBBOMessageHeader*>(
               &_QBBOMessageHeader_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(QBBOMessageHeader& a, QBBOMessageHeader& b) {
    a.Swap(&b);
  }
  inline void Swap(QBBOMessageHeader* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QBBOMessageHeader* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QBBOMessageHeader* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QBBOMessageHeader>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QBBOMessageHeader& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QBBOMessageHeader& from) {
    QBBOMessageHeader::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QBBOMessageHeader* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "data.QBBOMessageHeader";
  }
  protected:
  explicit QBBOMessageHeader(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageTypeFieldNumber = 1,
    kTrackingNumberFieldNumber = 2,
    kTimestampFieldNumber = 3,
  };
  // optional .data.QBBOMessageType messageType = 1;
  bool has_messagetype() const;
  private:
  bool _internal_has_messagetype() const;
  public:
  void clear_messagetype();
  ::data::QBBOMessageType messagetype() const;
  void set_messagetype(::data::QBBOMessageType value);
  private:
  ::data::QBBOMessageType _internal_messagetype() const;
  void _internal_set_messagetype(::data::QBBOMessageType value);
  public:

  // optional int32 trackingNumber = 2;
  bool has_trackingnumber() const;
  private:
  bool _internal_has_trackingnumber() const;
  public:
  void clear_trackingnumber();
  int32_t trackingnumber() const;
  void set_trackingnumber(int32_t value);
  private:
  int32_t _internal_trackingnumber() const;
  void _internal_set_trackingnumber(int32_t value);
  public:

  // optional int64 timestamp = 3;
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  int64_t timestamp() const;
  void set_timestamp(int64_t value);
  private:
  int64_t _internal_timestamp() const;
  void _internal_set_timestamp(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:data.QBBOMessageHeader)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int messagetype_;
    int32_t trackingnumber_;
    int64_t timestamp_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_data_2eproto;
};
// -------------------------------------------------------------------

class QBBONextSharesQuotationMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:data.QBBONextSharesQuotationMessage) */ {
 public:
  inline QBBONextSharesQuotationMessage() : QBBONextSharesQuotationMessage(nullptr) {}
  ~QBBONextSharesQuotationMessage() override;
  explicit PROTOBUF_CONSTEXPR QBBONextSharesQuotationMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QBBONextSharesQuotationMessage(const QBBONextSharesQuotationMessage& from);
  QBBONextSharesQuotationMessage(QBBONextSharesQuotationMessage&& from) noexcept
    : QBBONextSharesQuotationMessage() {
    *this = ::std::move(from);
  }

  inline QBBONextSharesQuotationMessage& operator=(const QBBONextSharesQuotationMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline QBBONextSharesQuotationMessage& operator=(QBBONextSharesQuotationMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QBBONextSharesQuotationMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const QBBONextSharesQuotationMessage* internal_default_instance() {
    return reinterpret_cast<const QBBONextSharesQuotationMessage*>(
               &_QBBONextSharesQuotationMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(QBBONextSharesQuotationMessage& a, QBBONextSharesQuotationMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(QBBONextSharesQuotationMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QBBONextSharesQuotationMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QBBONextSharesQuotationMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QBBONextSharesQuotationMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QBBONextSharesQuotationMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QBBONextSharesQuotationMessage& from) {
    QBBONextSharesQuotationMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QBBONextSharesQuotationMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "data.QBBONextSharesQuotationMessage";
  }
  protected:
  explicit QBBONextSharesQuotationMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNextsharesSymbolFieldNumber = 1,
    kNasdaqBestBidFieldNumber = 3,
    kNasdaqBestBidSizeFieldNumber = 4,
    kNasdaqBestBidDiscountAmountFieldNumber = 5,
    kNasdaqBestOfferProxyPriceFieldNumber = 6,
    kNasdaqBestOfferSizeFieldNumber = 7,
    kNasdaqBestOfferDiscountAmountFieldNumber = 8,
    kSecurityClassFieldNumber = 2,
  };
  // optional string nextsharesSymbol = 1;
  bool has_nextsharessymbol() const;
  private:
  bool _internal_has_nextsharessymbol() const;
  public:
  void clear_nextsharessymbol();
  const std::string& nextsharessymbol() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_nextsharessymbol(ArgT0&& arg0, ArgT... args);
  std::string* mutable_nextsharessymbol();
  PROTOBUF_NODISCARD std::string* release_nextsharessymbol();
  void set_allocated_nextsharessymbol(std::string* nextsharessymbol);
  private:
  const std::string& _internal_nextsharessymbol() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_nextsharessymbol(const std::string& value);
  std::string* _internal_mutable_nextsharessymbol();
  public:

  // optional double nasdaqBestBid = 3;
  bool has_nasdaqbestbid() const;
  private:
  bool _internal_has_nasdaqbestbid() const;
  public:
  void clear_nasdaqbestbid();
  double nasdaqbestbid() const;
  void set_nasdaqbestbid(double value);
  private:
  double _internal_nasdaqbestbid() const;
  void _internal_set_nasdaqbestbid(double value);
  public:

  // optional int64 nasdaqBestBidSize = 4;
  bool has_nasdaqbestbidsize() const;
  private:
  bool _internal_has_nasdaqbestbidsize() const;
  public:
  void clear_nasdaqbestbidsize();
  int64_t nasdaqbestbidsize() const;
  void set_nasdaqbestbidsize(int64_t value);
  private:
  int64_t _internal_nasdaqbestbidsize() const;
  void _internal_set_nasdaqbestbidsize(int64_t value);
  public:

  // optional double nasdaqBestBidDiscountAmount = 5;
  bool has_nasdaqbestbiddiscountamount() const;
  private:
  bool _internal_has_nasdaqbestbiddiscountamount() const;
  public:
  void clear_nasdaqbestbiddiscountamount();
  double nasdaqbestbiddiscountamount() const;
  void set_nasdaqbestbiddiscountamount(double value);
  private:
  double _internal_nasdaqbestbiddiscountamount() const;
  void _internal_set_nasdaqbestbiddiscountamount(double value);
  public:

  // optional double nasdaqBestOfferProxyPrice = 6;
  bool has_nasdaqbestofferproxyprice() const;
  private:
  bool _internal_has_nasdaqbestofferproxyprice() const;
  public:
  void clear_nasdaqbestofferproxyprice();
  double nasdaqbestofferproxyprice() const;
  void set_nasdaqbestofferproxyprice(double value);
  private:
  double _internal_nasdaqbestofferproxyprice() const;
  void _internal_set_nasdaqbestofferproxyprice(double value);
  public:

  // optional int64 nasdaqBestOfferSize = 7;
  bool has_nasdaqbestoffersize() const;
  private:
  bool _internal_has_nasdaqbestoffersize() const;
  public:
  void clear_nasdaqbestoffersize();
  int64_t nasdaqbestoffersize() const;
  void set_nasdaqbestoffersize(int64_t value);
  private:
  int64_t _internal_nasdaqbestoffersize() const;
  void _internal_set_nasdaqbestoffersize(int64_t value);
  public:

  // optional double nasdaqBestOfferDiscountAmount = 8;
  bool has_nasdaqbestofferdiscountamount() const;
  private:
  bool _internal_has_nasdaqbestofferdiscountamount() const;
  public:
  void clear_nasdaqbestofferdiscountamount();
  double nasdaqbestofferdiscountamount() const;
  void set_nasdaqbestofferdiscountamount(double value);
  private:
  double _internal_nasdaqbestofferdiscountamount() const;
  void _internal_set_nasdaqbestofferdiscountamount(double value);
  public:

  // optional .data.SecurityClass securityClass = 2;
  bool has_securityclass() const;
  private:
  bool _internal_has_securityclass() const;
  public:
  void clear_securityclass();
  ::data::SecurityClass securityclass() const;
  void set_securityclass(::data::SecurityClass value);
  private:
  ::data::SecurityClass _internal_securityclass() const;
  void _internal_set_securityclass(::data::SecurityClass value);
  public:

  // @@protoc_insertion_point(class_scope:data.QBBONextSharesQuotationMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr nextsharessymbol_;
    double nasdaqbestbid_;
    int64_t nasdaqbestbidsize_;
    double nasdaqbestbiddiscountamount_;
    double nasdaqbestofferproxyprice_;
    int64_t nasdaqbestoffersize_;
    double nasdaqbestofferdiscountamount_;
    int securityclass_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_data_2eproto;
};
// -------------------------------------------------------------------

class QBBOOperationalHalt final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:data.QBBOOperationalHalt) */ {
 public:
  inline QBBOOperationalHalt() : QBBOOperationalHalt(nullptr) {}
  ~QBBOOperationalHalt() override;
  explicit PROTOBUF_CONSTEXPR QBBOOperationalHalt(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QBBOOperationalHalt(const QBBOOperationalHalt& from);
  QBBOOperationalHalt(QBBOOperationalHalt&& from) noexcept
    : QBBOOperationalHalt() {
    *this = ::std::move(from);
  }

  inline QBBOOperationalHalt& operator=(const QBBOOperationalHalt& from) {
    CopyFrom(from);
    return *this;
  }
  inline QBBOOperationalHalt& operator=(QBBOOperationalHalt&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QBBOOperationalHalt& default_instance() {
    return *internal_default_instance();
  }
  static inline const QBBOOperationalHalt* internal_default_instance() {
    return reinterpret_cast<const QBBOOperationalHalt*>(
               &_QBBOOperationalHalt_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(QBBOOperationalHalt& a, QBBOOperationalHalt& b) {
    a.Swap(&b);
  }
  inline void Swap(QBBOOperationalHalt* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QBBOOperationalHalt* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QBBOOperationalHalt* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QBBOOperationalHalt>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QBBOOperationalHalt& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QBBOOperationalHalt& from) {
    QBBOOperationalHalt::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QBBOOperationalHalt* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "data.QBBOOperationalHalt";
  }
  protected:
  explicit QBBOOperationalHalt(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStockFieldNumber = 1,
    kMarketCodeFieldNumber = 2,
    kOperationalHaltActionFieldNumber = 3,
  };
  // optional string stock = 1;
  bool has_stock() const;
  private:
  bool _internal_has_stock() const;
  public:
  void clear_stock();
  const std::string& stock() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_stock(ArgT0&& arg0, ArgT... args);
  std::string* mutable_stock();
  PROTOBUF_NODISCARD std::string* release_stock();
  void set_allocated_stock(std::string* stock);
  private:
  const std::string& _internal_stock() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_stock(const std::string& value);
  std::string* _internal_mutable_stock();
  public:

  // optional .data.MarketCode marketCode = 2;
  bool has_marketcode() const;
  private:
  bool _internal_has_marketcode() const;
  public:
  void clear_marketcode();
  ::data::MarketCode marketcode() const;
  void set_marketcode(::data::MarketCode value);
  private:
  ::data::MarketCode _internal_marketcode() const;
  void _internal_set_marketcode(::data::MarketCode value);
  public:

  // optional .data.HaltAction operationalHaltAction = 3;
  bool has_operationalhaltaction() const;
  private:
  bool _internal_has_operationalhaltaction() const;
  public:
  void clear_operationalhaltaction();
  ::data::HaltAction operationalhaltaction() const;
  void set_operationalhaltaction(::data::HaltAction value);
  private:
  ::data::HaltAction _internal_operationalhaltaction() const;
  void _internal_set_operationalhaltaction(::data::HaltAction value);
  public:

  // @@protoc_insertion_point(class_scope:data.QBBOOperationalHalt)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr stock_;
    int marketcode_;
    int operationalhaltaction_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_data_2eproto;
};
// -------------------------------------------------------------------

class QBBOQuotationMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:data.QBBOQuotationMessage) */ {
 public:
  inline QBBOQuotationMessage() : QBBOQuotationMessage(nullptr) {}
  ~QBBOQuotationMessage() override;
  explicit PROTOBUF_CONSTEXPR QBBOQuotationMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QBBOQuotationMessage(const QBBOQuotationMessage& from);
  QBBOQuotationMessage(QBBOQuotationMessage&& from) noexcept
    : QBBOQuotationMessage() {
    *this = ::std::move(from);
  }

  inline QBBOQuotationMessage& operator=(const QBBOQuotationMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline QBBOQuotationMessage& operator=(QBBOQuotationMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QBBOQuotationMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const QBBOQuotationMessage* internal_default_instance() {
    return reinterpret_cast<const QBBOQuotationMessage*>(
               &_QBBOQuotationMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(QBBOQuotationMessage& a, QBBOQuotationMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(QBBOQuotationMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QBBOQuotationMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QBBOQuotationMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QBBOQuotationMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QBBOQuotationMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QBBOQuotationMessage& from) {
    QBBOQuotationMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QBBOQuotationMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "data.QBBOQuotationMessage";
  }
  protected:
  explicit QBBOQuotationMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStockFieldNumber = 1,
    kNasdaqBestBidPriceFieldNumber = 3,
    kNasdaqBestBidSizeFieldNumber = 4,
    kNasdaqBestOfferPriceFieldNumber = 5,
    kNasdaqBestOfferSizeFieldNumber = 6,
    kSecurityClassFieldNumber = 2,
  };
  // optional string stock = 1;
  bool has_stock() const;
  private:
  bool _internal_has_stock() const;
  public:
  void clear_stock();
  const std::string& stock() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_stock(ArgT0&& arg0, ArgT... args);
  std::string* mutable_stock();
  PROTOBUF_NODISCARD std::string* release_stock();
  void set_allocated_stock(std::string* stock);
  private:
  const std::string& _internal_stock() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_stock(const std::string& value);
  std::string* _internal_mutable_stock();
  public:

  // optional double nasdaqBestBidPrice = 3;
  bool has_nasdaqbestbidprice() const;
  private:
  bool _internal_has_nasdaqbestbidprice() const;
  public:
  void clear_nasdaqbestbidprice();
  double nasdaqbestbidprice() const;
  void set_nasdaqbestbidprice(double value);
  private:
  double _internal_nasdaqbestbidprice() const;
  void _internal_set_nasdaqbestbidprice(double value);
  public:

  // optional int64 nasdaqBestBidSize = 4;
  bool has_nasdaqbestbidsize() const;
  private:
  bool _internal_has_nasdaqbestbidsize() const;
  public:
  void clear_nasdaqbestbidsize();
  int64_t nasdaqbestbidsize() const;
  void set_nasdaqbestbidsize(int64_t value);
  private:
  int64_t _internal_nasdaqbestbidsize() const;
  void _internal_set_nasdaqbestbidsize(int64_t value);
  public:

  // optional double nasdaqBestOfferPrice = 5;
  bool has_nasdaqbestofferprice() const;
  private:
  bool _internal_has_nasdaqbestofferprice() const;
  public:
  void clear_nasdaqbestofferprice();
  double nasdaqbestofferprice() const;
  void set_nasdaqbestofferprice(double value);
  private:
  double _internal_nasdaqbestofferprice() const;
  void _internal_set_nasdaqbestofferprice(double value);
  public:

  // optional int64 nasdaqBestOfferSize = 6;
  bool has_nasdaqbestoffersize() const;
  private:
  bool _internal_has_nasdaqbestoffersize() const;
  public:
  void clear_nasdaqbestoffersize();
  int64_t nasdaqbestoffersize() const;
  void set_nasdaqbestoffersize(int64_t value);
  private:
  int64_t _internal_nasdaqbestoffersize() const;
  void _internal_set_nasdaqbestoffersize(int64_t value);
  public:

  // optional .data.SecurityClass securityClass = 2;
  bool has_securityclass() const;
  private:
  bool _internal_has_securityclass() const;
  public:
  void clear_securityclass();
  ::data::SecurityClass securityclass() const;
  void set_securityclass(::data::SecurityClass value);
  private:
  ::data::SecurityClass _internal_securityclass() const;
  void _internal_set_securityclass(::data::SecurityClass value);
  public:

  // @@protoc_insertion_point(class_scope:data.QBBOQuotationMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr stock_;
    double nasdaqbestbidprice_;
    int64_t nasdaqbestbidsize_;
    double nasdaqbestofferprice_;
    int64_t nasdaqbestoffersize_;
    int securityclass_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_data_2eproto;
};
// -------------------------------------------------------------------

class QBBORegShoRestriction final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:data.QBBORegShoRestriction) */ {
 public:
  inline QBBORegShoRestriction() : QBBORegShoRestriction(nullptr) {}
  ~QBBORegShoRestriction() override;
  explicit PROTOBUF_CONSTEXPR QBBORegShoRestriction(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QBBORegShoRestriction(const QBBORegShoRestriction& from);
  QBBORegShoRestriction(QBBORegShoRestriction&& from) noexcept
    : QBBORegShoRestriction() {
    *this = ::std::move(from);
  }

  inline QBBORegShoRestriction& operator=(const QBBORegShoRestriction& from) {
    CopyFrom(from);
    return *this;
  }
  inline QBBORegShoRestriction& operator=(QBBORegShoRestriction&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QBBORegShoRestriction& default_instance() {
    return *internal_default_instance();
  }
  static inline const QBBORegShoRestriction* internal_default_instance() {
    return reinterpret_cast<const QBBORegShoRestriction*>(
               &_QBBORegShoRestriction_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(QBBORegShoRestriction& a, QBBORegShoRestriction& b) {
    a.Swap(&b);
  }
  inline void Swap(QBBORegShoRestriction* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QBBORegShoRestriction* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QBBORegShoRestriction* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QBBORegShoRestriction>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QBBORegShoRestriction& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QBBORegShoRestriction& from) {
    QBBORegShoRestriction::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QBBORegShoRestriction* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "data.QBBORegShoRestriction";
  }
  protected:
  explicit QBBORegShoRestriction(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStockFieldNumber = 1,
    kRegSHOActionFieldNumber = 2,
  };
  // optional string stock = 1;
  bool has_stock() const;
  private:
  bool _internal_has_stock() const;
  public:
  void clear_stock();
  const std::string& stock() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_stock(ArgT0&& arg0, ArgT... args);
  std::string* mutable_stock();
  PROTOBUF_NODISCARD std::string* release_stock();
  void set_allocated_stock(std::string* stock);
  private:
  const std::string& _internal_stock() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_stock(const std::string& value);
  std::string* _internal_mutable_stock();
  public:

  // optional .data.RegSHOAction regSHOAction = 2;
  bool has_regshoaction() const;
  private:
  bool _internal_has_regshoaction() const;
  public:
  void clear_regshoaction();
  ::data::RegSHOAction regshoaction() const;
  void set_regshoaction(::data::RegSHOAction value);
  private:
  ::data::RegSHOAction _internal_regshoaction() const;
  void _internal_set_regshoaction(::data::RegSHOAction value);
  public:

  // @@protoc_insertion_point(class_scope:data.QBBORegShoRestriction)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr stock_;
    int regshoaction_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_data_2eproto;
};
// -------------------------------------------------------------------

class QBBOStockDirectory final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:data.QBBOStockDirectory) */ {
 public:
  inline QBBOStockDirectory() : QBBOStockDirectory(nullptr) {}
  ~QBBOStockDirectory() override;
  explicit PROTOBUF_CONSTEXPR QBBOStockDirectory(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QBBOStockDirectory(const QBBOStockDirectory& from);
  QBBOStockDirectory(QBBOStockDirectory&& from) noexcept
    : QBBOStockDirectory() {
    *this = ::std::move(from);
  }

  inline QBBOStockDirectory& operator=(const QBBOStockDirectory& from) {
    CopyFrom(from);
    return *this;
  }
  inline QBBOStockDirectory& operator=(QBBOStockDirectory&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QBBOStockDirectory& default_instance() {
    return *internal_default_instance();
  }
  static inline const QBBOStockDirectory* internal_default_instance() {
    return reinterpret_cast<const QBBOStockDirectory*>(
               &_QBBOStockDirectory_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(QBBOStockDirectory& a, QBBOStockDirectory& b) {
    a.Swap(&b);
  }
  inline void Swap(QBBOStockDirectory* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QBBOStockDirectory* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QBBOStockDirectory* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QBBOStockDirectory>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QBBOStockDirectory& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QBBOStockDirectory& from) {
    QBBOStockDirectory::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QBBOStockDirectory* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "data.QBBOStockDirectory";
  }
  protected:
  explicit QBBOStockDirectory(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStockFieldNumber = 1,
    kIssueClassificationFieldNumber = 6,
    kIssueSubTypeFieldNumber = 7,
    kMarketCategoryFieldNumber = 2,
    kFinancialStatusIndicatorFieldNumber = 3,
    kRoundLotsizeFieldNumber = 4,
    kRoundLotOnlyFieldNumber = 5,
    kAuthenticityFieldNumber = 8,
    kShortSaleThresholdIndicatorFieldNumber = 9,
    kIPOFlagFieldNumber = 10,
    kLULDReferencePriceTierFieldNumber = 11,
    kETPlagFieldNumber = 12,
    kETPLeverageFactorFieldNumber = 13,
    kInverseIndicatorFieldNumber = 14,
  };
  // optional string stock = 1;
  bool has_stock() const;
  private:
  bool _internal_has_stock() const;
  public:
  void clear_stock();
  const std::string& stock() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_stock(ArgT0&& arg0, ArgT... args);
  std::string* mutable_stock();
  PROTOBUF_NODISCARD std::string* release_stock();
  void set_allocated_stock(std::string* stock);
  private:
  const std::string& _internal_stock() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_stock(const std::string& value);
  std::string* _internal_mutable_stock();
  public:

  // optional string issueClassification = 6;
  bool has_issueclassification() const;
  private:
  bool _internal_has_issueclassification() const;
  public:
  void clear_issueclassification();
  const std::string& issueclassification() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_issueclassification(ArgT0&& arg0, ArgT... args);
  std::string* mutable_issueclassification();
  PROTOBUF_NODISCARD std::string* release_issueclassification();
  void set_allocated_issueclassification(std::string* issueclassification);
  private:
  const std::string& _internal_issueclassification() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_issueclassification(const std::string& value);
  std::string* _internal_mutable_issueclassification();
  public:

  // optional string issueSubType = 7;
  bool has_issuesubtype() const;
  private:
  bool _internal_has_issuesubtype() const;
  public:
  void clear_issuesubtype();
  const std::string& issuesubtype() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_issuesubtype(ArgT0&& arg0, ArgT... args);
  std::string* mutable_issuesubtype();
  PROTOBUF_NODISCARD std::string* release_issuesubtype();
  void set_allocated_issuesubtype(std::string* issuesubtype);
  private:
  const std::string& _internal_issuesubtype() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_issuesubtype(const std::string& value);
  std::string* _internal_mutable_issuesubtype();
  public:

  // optional .data.MarketCategory marketCategory = 2;
  bool has_marketcategory() const;
  private:
  bool _internal_has_marketcategory() const;
  public:
  void clear_marketcategory();
  ::data::MarketCategory marketcategory() const;
  void set_marketcategory(::data::MarketCategory value);
  private:
  ::data::MarketCategory _internal_marketcategory() const;
  void _internal_set_marketcategory(::data::MarketCategory value);
  public:

  // optional .data.FinancialStatusIndicator financialStatusIndicator = 3;
  bool has_financialstatusindicator() const;
  private:
  bool _internal_has_financialstatusindicator() const;
  public:
  void clear_financialstatusindicator();
  ::data::FinancialStatusIndicator financialstatusindicator() const;
  void set_financialstatusindicator(::data::FinancialStatusIndicator value);
  private:
  ::data::FinancialStatusIndicator _internal_financialstatusindicator() const;
  void _internal_set_financialstatusindicator(::data::FinancialStatusIndicator value);
  public:

  // optional int64 roundLotsize = 4;
  bool has_roundlotsize() const;
  private:
  bool _internal_has_roundlotsize() const;
  public:
  void clear_roundlotsize();
  int64_t roundlotsize() const;
  void set_roundlotsize(int64_t value);
  private:
  int64_t _internal_roundlotsize() const;
  void _internal_set_roundlotsize(int64_t value);
  public:

  // optional .data.IndicatesIf roundLotOnly = 5;
  bool has_roundlotonly() const;
  private:
  bool _internal_has_roundlotonly() const;
  public:
  void clear_roundlotonly();
  ::data::IndicatesIf roundlotonly() const;
  void set_roundlotonly(::data::IndicatesIf value);
  private:
  ::data::IndicatesIf _internal_roundlotonly() const;
  void _internal_set_roundlotonly(::data::IndicatesIf value);
  public:

  // optional .data.Authenticity authenticity = 8;
  bool has_authenticity() const;
  private:
  bool _internal_has_authenticity() const;
  public:
  void clear_authenticity();
  ::data::Authenticity authenticity() const;
  void set_authenticity(::data::Authenticity value);
  private:
  ::data::Authenticity _internal_authenticity() const;
  void _internal_set_authenticity(::data::Authenticity value);
  public:

  // optional .data.IndicatesIf shortSaleThresholdIndicator = 9;
  bool has_shortsalethresholdindicator() const;
  private:
  bool _internal_has_shortsalethresholdindicator() const;
  public:
  void clear_shortsalethresholdindicator();
  ::data::IndicatesIf shortsalethresholdindicator() const;
  void set_shortsalethresholdindicator(::data::IndicatesIf value);
  private:
  ::data::IndicatesIf _internal_shortsalethresholdindicator() const;
  void _internal_set_shortsalethresholdindicator(::data::IndicatesIf value);
  public:

  // optional .data.IndicatesIf IPOFlag = 10;
  bool has_ipoflag() const;
  private:
  bool _internal_has_ipoflag() const;
  public:
  void clear_ipoflag();
  ::data::IndicatesIf ipoflag() const;
  void set_ipoflag(::data::IndicatesIf value);
  private:
  ::data::IndicatesIf _internal_ipoflag() const;
  void _internal_set_ipoflag(::data::IndicatesIf value);
  public:

  // optional .data.LULDRule lULDReferencePriceTier = 11;
  bool has_luldreferencepricetier() const;
  private:
  bool _internal_has_luldreferencepricetier() const;
  public:
  void clear_luldreferencepricetier();
  ::data::LULDRule luldreferencepricetier() const;
  void set_luldreferencepricetier(::data::LULDRule value);
  private:
  ::data::LULDRule _internal_luldreferencepricetier() const;
  void _internal_set_luldreferencepricetier(::data::LULDRule value);
  public:

  // optional .data.IndicatesIf ETPlag = 12;
  bool has_etplag() const;
  private:
  bool _internal_has_etplag() const;
  public:
  void clear_etplag();
  ::data::IndicatesIf etplag() const;
  void set_etplag(::data::IndicatesIf value);
  private:
  ::data::IndicatesIf _internal_etplag() const;
  void _internal_set_etplag(::data::IndicatesIf value);
  public:

  // optional int64 ETPLeverageFactor = 13;
  bool has_etpleveragefactor() const;
  private:
  bool _internal_has_etpleveragefactor() const;
  public:
  void clear_etpleveragefactor();
  int64_t etpleveragefactor() const;
  void set_etpleveragefactor(int64_t value);
  private:
  int64_t _internal_etpleveragefactor() const;
  void _internal_set_etpleveragefactor(int64_t value);
  public:

  // optional .data.IndicatesIf inverseIndicator = 14;
  bool has_inverseindicator() const;
  private:
  bool _internal_has_inverseindicator() const;
  public:
  void clear_inverseindicator();
  ::data::IndicatesIf inverseindicator() const;
  void set_inverseindicator(::data::IndicatesIf value);
  private:
  ::data::IndicatesIf _internal_inverseindicator() const;
  void _internal_set_inverseindicator(::data::IndicatesIf value);
  public:

  // @@protoc_insertion_point(class_scope:data.QBBOStockDirectory)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr stock_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr issueclassification_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr issuesubtype_;
    int marketcategory_;
    int financialstatusindicator_;
    int64_t roundlotsize_;
    int roundlotonly_;
    int authenticity_;
    int shortsalethresholdindicator_;
    int ipoflag_;
    int luldreferencepricetier_;
    int etplag_;
    int64_t etpleveragefactor_;
    int inverseindicator_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_data_2eproto;
};
// -------------------------------------------------------------------

class QBBOStockTradingAction final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:data.QBBOStockTradingAction) */ {
 public:
  inline QBBOStockTradingAction() : QBBOStockTradingAction(nullptr) {}
  ~QBBOStockTradingAction() override;
  explicit PROTOBUF_CONSTEXPR QBBOStockTradingAction(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QBBOStockTradingAction(const QBBOStockTradingAction& from);
  QBBOStockTradingAction(QBBOStockTradingAction&& from) noexcept
    : QBBOStockTradingAction() {
    *this = ::std::move(from);
  }

  inline QBBOStockTradingAction& operator=(const QBBOStockTradingAction& from) {
    CopyFrom(from);
    return *this;
  }
  inline QBBOStockTradingAction& operator=(QBBOStockTradingAction&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QBBOStockTradingAction& default_instance() {
    return *internal_default_instance();
  }
  static inline const QBBOStockTradingAction* internal_default_instance() {
    return reinterpret_cast<const QBBOStockTradingAction*>(
               &_QBBOStockTradingAction_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(QBBOStockTradingAction& a, QBBOStockTradingAction& b) {
    a.Swap(&b);
  }
  inline void Swap(QBBOStockTradingAction* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QBBOStockTradingAction* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QBBOStockTradingAction* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QBBOStockTradingAction>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QBBOStockTradingAction& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QBBOStockTradingAction& from) {
    QBBOStockTradingAction::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QBBOStockTradingAction* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "data.QBBOStockTradingAction";
  }
  protected:
  explicit QBBOStockTradingAction(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStockFieldNumber = 1,
    kReasonFieldNumber = 4,
    kSecurityClassFieldNumber = 2,
    kCurrentTradingStateFieldNumber = 3,
  };
  // optional string stock = 1;
  bool has_stock() const;
  private:
  bool _internal_has_stock() const;
  public:
  void clear_stock();
  const std::string& stock() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_stock(ArgT0&& arg0, ArgT... args);
  std::string* mutable_stock();
  PROTOBUF_NODISCARD std::string* release_stock();
  void set_allocated_stock(std::string* stock);
  private:
  const std::string& _internal_stock() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_stock(const std::string& value);
  std::string* _internal_mutable_stock();
  public:

  // optional string reason = 4;
  bool has_reason() const;
  private:
  bool _internal_has_reason() const;
  public:
  void clear_reason();
  const std::string& reason() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_reason(ArgT0&& arg0, ArgT... args);
  std::string* mutable_reason();
  PROTOBUF_NODISCARD std::string* release_reason();
  void set_allocated_reason(std::string* reason);
  private:
  const std::string& _internal_reason() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_reason(const std::string& value);
  std::string* _internal_mutable_reason();
  public:

  // optional .data.SecurityClass securityClass = 2;
  bool has_securityclass() const;
  private:
  bool _internal_has_securityclass() const;
  public:
  void clear_securityclass();
  ::data::SecurityClass securityclass() const;
  void set_securityclass(::data::SecurityClass value);
  private:
  ::data::SecurityClass _internal_securityclass() const;
  void _internal_set_securityclass(::data::SecurityClass value);
  public:

  // optional .data.CurrentTradingState currentTradingState = 3;
  bool has_currenttradingstate() const;
  private:
  bool _internal_has_currenttradingstate() const;
  public:
  void clear_currenttradingstate();
  ::data::CurrentTradingState currenttradingstate() const;
  void set_currenttradingstate(::data::CurrentTradingState value);
  private:
  ::data::CurrentTradingState _internal_currenttradingstate() const;
  void _internal_set_currenttradingstate(::data::CurrentTradingState value);
  public:

  // @@protoc_insertion_point(class_scope:data.QBBOStockTradingAction)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr stock_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr reason_;
    int securityclass_;
    int currenttradingstate_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_data_2eproto;
};
// -------------------------------------------------------------------

class QBBOSystemEventMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:data.QBBOSystemEventMessage) */ {
 public:
  inline QBBOSystemEventMessage() : QBBOSystemEventMessage(nullptr) {}
  ~QBBOSystemEventMessage() override;
  explicit PROTOBUF_CONSTEXPR QBBOSystemEventMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QBBOSystemEventMessage(const QBBOSystemEventMessage& from);
  QBBOSystemEventMessage(QBBOSystemEventMessage&& from) noexcept
    : QBBOSystemEventMessage() {
    *this = ::std::move(from);
  }

  inline QBBOSystemEventMessage& operator=(const QBBOSystemEventMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline QBBOSystemEventMessage& operator=(QBBOSystemEventMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QBBOSystemEventMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const QBBOSystemEventMessage* internal_default_instance() {
    return reinterpret_cast<const QBBOSystemEventMessage*>(
               &_QBBOSystemEventMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(QBBOSystemEventMessage& a, QBBOSystemEventMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(QBBOSystemEventMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QBBOSystemEventMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QBBOSystemEventMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QBBOSystemEventMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QBBOSystemEventMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QBBOSystemEventMessage& from) {
    QBBOSystemEventMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QBBOSystemEventMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "data.QBBOSystemEventMessage";
  }
  protected:
  explicit QBBOSystemEventMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEventCodeFieldNumber = 1,
  };
  // optional .data.EventCode eventCode = 1;
  bool has_eventcode() const;
  private:
  bool _internal_has_eventcode() const;
  public:
  void clear_eventcode();
  ::data::EventCode eventcode() const;
  void set_eventcode(::data::EventCode value);
  private:
  ::data::EventCode _internal_eventcode() const;
  void _internal_set_eventcode(::data::EventCode value);
  public:

  // @@protoc_insertion_point(class_scope:data.QBBOSystemEventMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int eventcode_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_data_2eproto;
};
// -------------------------------------------------------------------

class AddOddLotOrder final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:data.AddOddLotOrder) */ {
 public:
  inline AddOddLotOrder() : AddOddLotOrder(nullptr) {}
  ~AddOddLotOrder() override;
  explicit PROTOBUF_CONSTEXPR AddOddLotOrder(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AddOddLotOrder(const AddOddLotOrder& from);
  AddOddLotOrder(AddOddLotOrder&& from) noexcept
    : AddOddLotOrder() {
    *this = ::std::move(from);
  }

  inline AddOddLotOrder& operator=(const AddOddLotOrder& from) {
    CopyFrom(from);
    return *this;
  }
  inline AddOddLotOrder& operator=(AddOddLotOrder&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AddOddLotOrder& default_instance() {
    return *internal_default_instance();
  }
  static inline const AddOddLotOrder* internal_default_instance() {
    return reinterpret_cast<const AddOddLotOrder*>(
               &_AddOddLotOrder_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(AddOddLotOrder& a, AddOddLotOrder& b) {
    a.Swap(&b);
  }
  inline void Swap(AddOddLotOrder* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AddOddLotOrder* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AddOddLotOrder* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AddOddLotOrder>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AddOddLotOrder& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AddOddLotOrder& from) {
    AddOddLotOrder::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AddOddLotOrder* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "data.AddOddLotOrder";
  }
  protected:
  explicit AddOddLotOrder(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSecurityCodeFieldNumber = 1,
    kOrderIdFieldNumber = 2,
    kPriceFieldNumber = 3,
    kQuantityFieldNumber = 4,
    kBrokerIDFieldNumber = 5,
    kSideFieldNumber = 6,
  };
  // optional int64 securityCode = 1;
  bool has_securitycode() const;
  private:
  bool _internal_has_securitycode() const;
  public:
  void clear_securitycode();
  int64_t securitycode() const;
  void set_securitycode(int64_t value);
  private:
  int64_t _internal_securitycode() const;
  void _internal_set_securitycode(int64_t value);
  public:

  // optional int64 orderId = 2;
  bool has_orderid() const;
  private:
  bool _internal_has_orderid() const;
  public:
  void clear_orderid();
  int64_t orderid() const;
  void set_orderid(int64_t value);
  private:
  int64_t _internal_orderid() const;
  void _internal_set_orderid(int64_t value);
  public:

  // optional double price = 3;
  bool has_price() const;
  private:
  bool _internal_has_price() const;
  public:
  void clear_price();
  double price() const;
  void set_price(double value);
  private:
  double _internal_price() const;
  void _internal_set_price(double value);
  public:

  // optional int64 quantity = 4;
  bool has_quantity() const;
  private:
  bool _internal_has_quantity() const;
  public:
  void clear_quantity();
  int64_t quantity() const;
  void set_quantity(int64_t value);
  private:
  int64_t _internal_quantity() const;
  void _internal_set_quantity(int64_t value);
  public:

  // optional int32 brokerID = 5;
  bool has_brokerid() const;
  private:
  bool _internal_has_brokerid() const;
  public:
  void clear_brokerid();
  int32_t brokerid() const;
  void set_brokerid(int32_t value);
  private:
  int32_t _internal_brokerid() const;
  void _internal_set_brokerid(int32_t value);
  public:

  // optional .data.Side side = 6;
  bool has_side() const;
  private:
  bool _internal_has_side() const;
  public:
  void clear_side();
  ::data::Side side() const;
  void set_side(::data::Side value);
  private:
  ::data::Side _internal_side() const;
  void _internal_set_side(::data::Side value);
  public:

  // @@protoc_insertion_point(class_scope:data.AddOddLotOrder)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int64_t securitycode_;
    int64_t orderid_;
    double price_;
    int64_t quantity_;
    int32_t brokerid_;
    int side_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_data_2eproto;
};
// -------------------------------------------------------------------

class AggregateOrderBookUpdate final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:data.AggregateOrderBookUpdate) */ {
 public:
  inline AggregateOrderBookUpdate() : AggregateOrderBookUpdate(nullptr) {}
  ~AggregateOrderBookUpdate() override;
  explicit PROTOBUF_CONSTEXPR AggregateOrderBookUpdate(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AggregateOrderBookUpdate(const AggregateOrderBookUpdate& from);
  AggregateOrderBookUpdate(AggregateOrderBookUpdate&& from) noexcept
    : AggregateOrderBookUpdate() {
    *this = ::std::move(from);
  }

  inline AggregateOrderBookUpdate& operator=(const AggregateOrderBookUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  inline AggregateOrderBookUpdate& operator=(AggregateOrderBookUpdate&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AggregateOrderBookUpdate& default_instance() {
    return *internal_default_instance();
  }
  static inline const AggregateOrderBookUpdate* internal_default_instance() {
    return reinterpret_cast<const AggregateOrderBookUpdate*>(
               &_AggregateOrderBookUpdate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(AggregateOrderBookUpdate& a, AggregateOrderBookUpdate& b) {
    a.Swap(&b);
  }
  inline void Swap(AggregateOrderBookUpdate* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AggregateOrderBookUpdate* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AggregateOrderBookUpdate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AggregateOrderBookUpdate>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AggregateOrderBookUpdate& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AggregateOrderBookUpdate& from) {
    AggregateOrderBookUpdate::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AggregateOrderBookUpdate* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "data.AggregateOrderBookUpdate";
  }
  protected:
  explicit AggregateOrderBookUpdate(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNoEntriesFieldNumber = 2,
    kSecurityCodeFieldNumber = 1,
  };
  // repeated .data.NoEntry noEntries = 2;
  int noentries_size() const;
  private:
  int _internal_noentries_size() const;
  public:
  void clear_noentries();
  ::data::NoEntry* mutable_noentries(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::data::NoEntry >*
      mutable_noentries();
  private:
  const ::data::NoEntry& _internal_noentries(int index) const;
  ::data::NoEntry* _internal_add_noentries();
  public:
  const ::data::NoEntry& noentries(int index) const;
  ::data::NoEntry* add_noentries();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::data::NoEntry >&
      noentries() const;

  // optional int64 securityCode = 1;
  bool has_securitycode() const;
  private:
  bool _internal_has_securitycode() const;
  public:
  void clear_securitycode();
  int64_t securitycode() const;
  void set_securitycode(int64_t value);
  private:
  int64_t _internal_securitycode() const;
  void _internal_set_securitycode(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:data.AggregateOrderBookUpdate)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::data::NoEntry > noentries_;
    int64_t securitycode_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_data_2eproto;
};
// -------------------------------------------------------------------

class BQMoreItem final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:data.BQMoreItem) */ {
 public:
  inline BQMoreItem() : BQMoreItem(nullptr) {}
  ~BQMoreItem() override;
  explicit PROTOBUF_CONSTEXPR BQMoreItem(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BQMoreItem(const BQMoreItem& from);
  BQMoreItem(BQMoreItem&& from) noexcept
    : BQMoreItem() {
    *this = ::std::move(from);
  }

  inline BQMoreItem& operator=(const BQMoreItem& from) {
    CopyFrom(from);
    return *this;
  }
  inline BQMoreItem& operator=(BQMoreItem&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BQMoreItem& default_instance() {
    return *internal_default_instance();
  }
  static inline const BQMoreItem* internal_default_instance() {
    return reinterpret_cast<const BQMoreItem*>(
               &_BQMoreItem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(BQMoreItem& a, BQMoreItem& b) {
    a.Swap(&b);
  }
  inline void Swap(BQMoreItem* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BQMoreItem* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BQMoreItem* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BQMoreItem>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BQMoreItem& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BQMoreItem& from) {
    BQMoreItem::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BQMoreItem* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "data.BQMoreItem";
  }
  protected:
  explicit BQMoreItem(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemFieldNumber = 1,
    kTypeFieldNumber = 2,
  };
  // optional int32 item = 1;
  bool has_item() const;
  private:
  bool _internal_has_item() const;
  public:
  void clear_item();
  int32_t item() const;
  void set_item(int32_t value);
  private:
  int32_t _internal_item() const;
  void _internal_set_item(int32_t value);
  public:

  // optional .data.IndicatesType type = 2;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::data::IndicatesType type() const;
  void set_type(::data::IndicatesType value);
  private:
  ::data::IndicatesType _internal_type() const;
  void _internal_set_type(::data::IndicatesType value);
  public:

  // @@protoc_insertion_point(class_scope:data.BQMoreItem)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int32_t item_;
    int type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_data_2eproto;
};
// -------------------------------------------------------------------

class BrokerQueue final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:data.BrokerQueue) */ {
 public:
  inline BrokerQueue() : BrokerQueue(nullptr) {}
  ~BrokerQueue() override;
  explicit PROTOBUF_CONSTEXPR BrokerQueue(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BrokerQueue(const BrokerQueue& from);
  BrokerQueue(BrokerQueue&& from) noexcept
    : BrokerQueue() {
    *this = ::std::move(from);
  }

  inline BrokerQueue& operator=(const BrokerQueue& from) {
    CopyFrom(from);
    return *this;
  }
  inline BrokerQueue& operator=(BrokerQueue&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BrokerQueue& default_instance() {
    return *internal_default_instance();
  }
  static inline const BrokerQueue* internal_default_instance() {
    return reinterpret_cast<const BrokerQueue*>(
               &_BrokerQueue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(BrokerQueue& a, BrokerQueue& b) {
    a.Swap(&b);
  }
  inline void Swap(BrokerQueue* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BrokerQueue* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BrokerQueue* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BrokerQueue>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BrokerQueue& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BrokerQueue& from) {
    BrokerQueue::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BrokerQueue* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "data.BrokerQueue";
  }
  protected:
  explicit BrokerQueue(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 5,
    kSecurityCodeFieldNumber = 1,
    kItemCountFieldNumber = 2,
    kSideFieldNumber = 3,
    kBQMoreFlagFieldNumber = 4,
  };
  // repeated .data.BQMoreItem items = 5;
  int items_size() const;
  private:
  int _internal_items_size() const;
  public:
  void clear_items();
  ::data::BQMoreItem* mutable_items(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::data::BQMoreItem >*
      mutable_items();
  private:
  const ::data::BQMoreItem& _internal_items(int index) const;
  ::data::BQMoreItem* _internal_add_items();
  public:
  const ::data::BQMoreItem& items(int index) const;
  ::data::BQMoreItem* add_items();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::data::BQMoreItem >&
      items() const;

  // optional int64 securityCode = 1;
  bool has_securitycode() const;
  private:
  bool _internal_has_securitycode() const;
  public:
  void clear_securitycode();
  int64_t securitycode() const;
  void set_securitycode(int64_t value);
  private:
  int64_t _internal_securitycode() const;
  void _internal_set_securitycode(int64_t value);
  public:

  // optional int32 itemCount = 2;
  bool has_itemcount() const;
  private:
  bool _internal_has_itemcount() const;
  public:
  void clear_itemcount();
  int32_t itemcount() const;
  void set_itemcount(int32_t value);
  private:
  int32_t _internal_itemcount() const;
  void _internal_set_itemcount(int32_t value);
  public:

  // optional .data.BrokerSide side = 3;
  bool has_side() const;
  private:
  bool _internal_has_side() const;
  public:
  void clear_side();
  ::data::BrokerSide side() const;
  void set_side(::data::BrokerSide value);
  private:
  ::data::BrokerSide _internal_side() const;
  void _internal_set_side(::data::BrokerSide value);
  public:

  // optional .data.BQMoreFlag bQMoreFlag = 4;
  bool has_bqmoreflag() const;
  private:
  bool _internal_has_bqmoreflag() const;
  public:
  void clear_bqmoreflag();
  ::data::BQMoreFlag bqmoreflag() const;
  void set_bqmoreflag(::data::BQMoreFlag value);
  private:
  ::data::BQMoreFlag _internal_bqmoreflag() const;
  void _internal_set_bqmoreflag(::data::BQMoreFlag value);
  public:

  // @@protoc_insertion_point(class_scope:data.BrokerQueue)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::data::BQMoreItem > items_;
    int64_t securitycode_;
    int32_t itemcount_;
    int side_;
    int bqmoreflag_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_data_2eproto;
};
// -------------------------------------------------------------------

class ClosingPrice final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:data.ClosingPrice) */ {
 public:
  inline ClosingPrice() : ClosingPrice(nullptr) {}
  ~ClosingPrice() override;
  explicit PROTOBUF_CONSTEXPR ClosingPrice(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ClosingPrice(const ClosingPrice& from);
  ClosingPrice(ClosingPrice&& from) noexcept
    : ClosingPrice() {
    *this = ::std::move(from);
  }

  inline ClosingPrice& operator=(const ClosingPrice& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClosingPrice& operator=(ClosingPrice&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ClosingPrice& default_instance() {
    return *internal_default_instance();
  }
  static inline const ClosingPrice* internal_default_instance() {
    return reinterpret_cast<const ClosingPrice*>(
               &_ClosingPrice_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(ClosingPrice& a, ClosingPrice& b) {
    a.Swap(&b);
  }
  inline void Swap(ClosingPrice* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClosingPrice* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ClosingPrice* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ClosingPrice>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ClosingPrice& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ClosingPrice& from) {
    ClosingPrice::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClosingPrice* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "data.ClosingPrice";
  }
  protected:
  explicit ClosingPrice(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSecurityCodeFieldNumber = 1,
    kClosingPriceFieldNumber = 2,
    kNumberOfTradesFieldNumber = 3,
  };
  // optional int64 securityCode = 1;
  bool has_securitycode() const;
  private:
  bool _internal_has_securitycode() const;
  public:
  void clear_securitycode();
  int64_t securitycode() const;
  void set_securitycode(int64_t value);
  private:
  int64_t _internal_securitycode() const;
  void _internal_set_securitycode(int64_t value);
  public:

  // optional double closingPrice = 2;
  bool has_closingprice() const;
  private:
  bool _internal_has_closingprice() const;
  public:
  void clear_closingprice();
  double closingprice() const;
  void set_closingprice(double value);
  private:
  double _internal_closingprice() const;
  void _internal_set_closingprice(double value);
  public:

  // optional int64 numberOfTrades = 3;
  bool has_numberoftrades() const;
  private:
  bool _internal_has_numberoftrades() const;
  public:
  void clear_numberoftrades();
  int64_t numberoftrades() const;
  void set_numberoftrades(int64_t value);
  private:
  int64_t _internal_numberoftrades() const;
  void _internal_set_numberoftrades(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:data.ClosingPrice)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int64_t securitycode_;
    double closingprice_;
    int64_t numberoftrades_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_data_2eproto;
};
// -------------------------------------------------------------------

class CurrencyRate final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:data.CurrencyRate) */ {
 public:
  inline CurrencyRate() : CurrencyRate(nullptr) {}
  ~CurrencyRate() override;
  explicit PROTOBUF_CONSTEXPR CurrencyRate(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CurrencyRate(const CurrencyRate& from);
  CurrencyRate(CurrencyRate&& from) noexcept
    : CurrencyRate() {
    *this = ::std::move(from);
  }

  inline CurrencyRate& operator=(const CurrencyRate& from) {
    CopyFrom(from);
    return *this;
  }
  inline CurrencyRate& operator=(CurrencyRate&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CurrencyRate& default_instance() {
    return *internal_default_instance();
  }
  static inline const CurrencyRate* internal_default_instance() {
    return reinterpret_cast<const CurrencyRate*>(
               &_CurrencyRate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(CurrencyRate& a, CurrencyRate& b) {
    a.Swap(&b);
  }
  inline void Swap(CurrencyRate* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CurrencyRate* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CurrencyRate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CurrencyRate>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CurrencyRate& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CurrencyRate& from) {
    CurrencyRate::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CurrencyRate* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "data.CurrencyRate";
  }
  protected:
  explicit CurrencyRate(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCurrencyCodeFieldNumber = 1,
    kCurrencyFactorFieldNumber = 2,
    kCurrencyRateFieldNumber = 3,
  };
  // optional .data.CurrencyType currencyCode = 1;
  bool has_currencycode() const;
  private:
  bool _internal_has_currencycode() const;
  public:
  void clear_currencycode();
  ::data::CurrencyType currencycode() const;
  void set_currencycode(::data::CurrencyType value);
  private:
  ::data::CurrencyType _internal_currencycode() const;
  void _internal_set_currencycode(::data::CurrencyType value);
  public:

  // optional int32 currencyFactor = 2;
  bool has_currencyfactor() const;
  private:
  bool _internal_has_currencyfactor() const;
  public:
  void clear_currencyfactor();
  int32_t currencyfactor() const;
  void set_currencyfactor(int32_t value);
  private:
  int32_t _internal_currencyfactor() const;
  void _internal_set_currencyfactor(int32_t value);
  public:

  // optional double currencyRate = 3;
  bool has_currencyrate() const;
  private:
  bool _internal_has_currencyrate() const;
  public:
  void clear_currencyrate();
  double currencyrate() const;
  void set_currencyrate(double value);
  private:
  double _internal_currencyrate() const;
  void _internal_set_currencyrate(double value);
  public:

  // @@protoc_insertion_point(class_scope:data.CurrencyRate)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int currencycode_;
    int32_t currencyfactor_;
    double currencyrate_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_data_2eproto;
};
// -------------------------------------------------------------------

class DeleteOddLotOrder final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:data.DeleteOddLotOrder) */ {
 public:
  inline DeleteOddLotOrder() : DeleteOddLotOrder(nullptr) {}
  ~DeleteOddLotOrder() override;
  explicit PROTOBUF_CONSTEXPR DeleteOddLotOrder(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteOddLotOrder(const DeleteOddLotOrder& from);
  DeleteOddLotOrder(DeleteOddLotOrder&& from) noexcept
    : DeleteOddLotOrder() {
    *this = ::std::move(from);
  }

  inline DeleteOddLotOrder& operator=(const DeleteOddLotOrder& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteOddLotOrder& operator=(DeleteOddLotOrder&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteOddLotOrder& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteOddLotOrder* internal_default_instance() {
    return reinterpret_cast<const DeleteOddLotOrder*>(
               &_DeleteOddLotOrder_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(DeleteOddLotOrder& a, DeleteOddLotOrder& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteOddLotOrder* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteOddLotOrder* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteOddLotOrder* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteOddLotOrder>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteOddLotOrder& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DeleteOddLotOrder& from) {
    DeleteOddLotOrder::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteOddLotOrder* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "data.DeleteOddLotOrder";
  }
  protected:
  explicit DeleteOddLotOrder(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSecurityCodeFieldNumber = 1,
    kOrderIdFieldNumber = 2,
    kBrokerIDFieldNumber = 3,
    kSideFieldNumber = 4,
  };
  // optional int64 securityCode = 1;
  bool has_securitycode() const;
  private:
  bool _internal_has_securitycode() const;
  public:
  void clear_securitycode();
  int64_t securitycode() const;
  void set_securitycode(int64_t value);
  private:
  int64_t _internal_securitycode() const;
  void _internal_set_securitycode(int64_t value);
  public:

  // optional int64 orderId = 2;
  bool has_orderid() const;
  private:
  bool _internal_has_orderid() const;
  public:
  void clear_orderid();
  int64_t orderid() const;
  void set_orderid(int64_t value);
  private:
  int64_t _internal_orderid() const;
  void _internal_set_orderid(int64_t value);
  public:

  // optional int32 brokerID = 3;
  bool has_brokerid() const;
  private:
  bool _internal_has_brokerid() const;
  public:
  void clear_brokerid();
  int32_t brokerid() const;
  void set_brokerid(int32_t value);
  private:
  int32_t _internal_brokerid() const;
  void _internal_set_brokerid(int32_t value);
  public:

  // optional .data.Side side = 4;
  bool has_side() const;
  private:
  bool _internal_has_side() const;
  public:
  void clear_side();
  ::data::Side side() const;
  void set_side(::data::Side value);
  private:
  ::data::Side _internal_side() const;
  void _internal_set_side(::data::Side value);
  public:

  // @@protoc_insertion_point(class_scope:data.DeleteOddLotOrder)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int64_t securitycode_;
    int64_t orderid_;
    int32_t brokerid_;
    int side_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_data_2eproto;
};
// -------------------------------------------------------------------

class IndexData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:data.IndexData) */ {
 public:
  inline IndexData() : IndexData(nullptr) {}
  ~IndexData() override;
  explicit PROTOBUF_CONSTEXPR IndexData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IndexData(const IndexData& from);
  IndexData(IndexData&& from) noexcept
    : IndexData() {
    *this = ::std::move(from);
  }

  inline IndexData& operator=(const IndexData& from) {
    CopyFrom(from);
    return *this;
  }
  inline IndexData& operator=(IndexData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IndexData& default_instance() {
    return *internal_default_instance();
  }
  static inline const IndexData* internal_default_instance() {
    return reinterpret_cast<const IndexData*>(
               &_IndexData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  friend void swap(IndexData& a, IndexData& b) {
    a.Swap(&b);
  }
  inline void Swap(IndexData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IndexData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IndexData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IndexData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IndexData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const IndexData& from) {
    IndexData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IndexData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "data.IndexData";
  }
  protected:
  explicit IndexData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIndexCodeFieldNumber = 1,
    kExceptionFieldNumber = 15,
    kIndexTimeFieldNumber = 3,
    kIndexValueFieldNumber = 4,
    kNetChgPrevDayFieldNumber = 5,
    kHighValueFieldNumber = 6,
    kLowValueFieldNumber = 7,
    kEASValueFieldNumber = 8,
    kIndexTurnoverFieldNumber = 9,
    kOpeningValueFieldNumber = 10,
    kClosingValueFieldNumber = 11,
    kPreviousSesCloseFieldNumber = 12,
    kIndexVolumeFieldNumber = 13,
    kNetChgPrevDayPctFieldNumber = 14,
    kIndexStatusFieldNumber = 2,
  };
  // optional string indexCode = 1;
  bool has_indexcode() const;
  private:
  bool _internal_has_indexcode() const;
  public:
  void clear_indexcode();
  const std::string& indexcode() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_indexcode(ArgT0&& arg0, ArgT... args);
  std::string* mutable_indexcode();
  PROTOBUF_NODISCARD std::string* release_indexcode();
  void set_allocated_indexcode(std::string* indexcode);
  private:
  const std::string& _internal_indexcode() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_indexcode(const std::string& value);
  std::string* _internal_mutable_indexcode();
  public:

  // optional string exception = 15;
  bool has_exception() const;
  private:
  bool _internal_has_exception() const;
  public:
  void clear_exception();
  const std::string& exception() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_exception(ArgT0&& arg0, ArgT... args);
  std::string* mutable_exception();
  PROTOBUF_NODISCARD std::string* release_exception();
  void set_allocated_exception(std::string* exception);
  private:
  const std::string& _internal_exception() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_exception(const std::string& value);
  std::string* _internal_mutable_exception();
  public:

  // optional int64 indexTime = 3;
  bool has_indextime() const;
  private:
  bool _internal_has_indextime() const;
  public:
  void clear_indextime();
  int64_t indextime() const;
  void set_indextime(int64_t value);
  private:
  int64_t _internal_indextime() const;
  void _internal_set_indextime(int64_t value);
  public:

  // optional double indexValue = 4;
  bool has_indexvalue() const;
  private:
  bool _internal_has_indexvalue() const;
  public:
  void clear_indexvalue();
  double indexvalue() const;
  void set_indexvalue(double value);
  private:
  double _internal_indexvalue() const;
  void _internal_set_indexvalue(double value);
  public:

  // optional double netChgPrevDay = 5;
  bool has_netchgprevday() const;
  private:
  bool _internal_has_netchgprevday() const;
  public:
  void clear_netchgprevday();
  double netchgprevday() const;
  void set_netchgprevday(double value);
  private:
  double _internal_netchgprevday() const;
  void _internal_set_netchgprevday(double value);
  public:

  // optional double highValue = 6;
  bool has_highvalue() const;
  private:
  bool _internal_has_highvalue() const;
  public:
  void clear_highvalue();
  double highvalue() const;
  void set_highvalue(double value);
  private:
  double _internal_highvalue() const;
  void _internal_set_highvalue(double value);
  public:

  // optional double lowValue = 7;
  bool has_lowvalue() const;
  private:
  bool _internal_has_lowvalue() const;
  public:
  void clear_lowvalue();
  double lowvalue() const;
  void set_lowvalue(double value);
  private:
  double _internal_lowvalue() const;
  void _internal_set_lowvalue(double value);
  public:

  // optional double eASValue = 8;
  bool has_easvalue() const;
  private:
  bool _internal_has_easvalue() const;
  public:
  void clear_easvalue();
  double easvalue() const;
  void set_easvalue(double value);
  private:
  double _internal_easvalue() const;
  void _internal_set_easvalue(double value);
  public:

  // optional double indexTurnover = 9;
  bool has_indexturnover() const;
  private:
  bool _internal_has_indexturnover() const;
  public:
  void clear_indexturnover();
  double indexturnover() const;
  void set_indexturnover(double value);
  private:
  double _internal_indexturnover() const;
  void _internal_set_indexturnover(double value);
  public:

  // optional double openingValue = 10;
  bool has_openingvalue() const;
  private:
  bool _internal_has_openingvalue() const;
  public:
  void clear_openingvalue();
  double openingvalue() const;
  void set_openingvalue(double value);
  private:
  double _internal_openingvalue() const;
  void _internal_set_openingvalue(double value);
  public:

  // optional double closingValue = 11;
  bool has_closingvalue() const;
  private:
  bool _internal_has_closingvalue() const;
  public:
  void clear_closingvalue();
  double closingvalue() const;
  void set_closingvalue(double value);
  private:
  double _internal_closingvalue() const;
  void _internal_set_closingvalue(double value);
  public:

  // optional double previousSesClose = 12;
  bool has_previoussesclose() const;
  private:
  bool _internal_has_previoussesclose() const;
  public:
  void clear_previoussesclose();
  double previoussesclose() const;
  void set_previoussesclose(double value);
  private:
  double _internal_previoussesclose() const;
  void _internal_set_previoussesclose(double value);
  public:

  // optional int64 indexVolume = 13;
  bool has_indexvolume() const;
  private:
  bool _internal_has_indexvolume() const;
  public:
  void clear_indexvolume();
  int64_t indexvolume() const;
  void set_indexvolume(int64_t value);
  private:
  int64_t _internal_indexvolume() const;
  void _internal_set_indexvolume(int64_t value);
  public:

  // optional double netChgPrevDayPct = 14;
  bool has_netchgprevdaypct() const;
  private:
  bool _internal_has_netchgprevdaypct() const;
  public:
  void clear_netchgprevdaypct();
  double netchgprevdaypct() const;
  void set_netchgprevdaypct(double value);
  private:
  double _internal_netchgprevdaypct() const;
  void _internal_set_netchgprevdaypct(double value);
  public:

  // optional .data.IndexStatus indexStatus = 2;
  bool has_indexstatus() const;
  private:
  bool _internal_has_indexstatus() const;
  public:
  void clear_indexstatus();
  ::data::IndexStatus indexstatus() const;
  void set_indexstatus(::data::IndexStatus value);
  private:
  ::data::IndexStatus _internal_indexstatus() const;
  void _internal_set_indexstatus(::data::IndexStatus value);
  public:

  // @@protoc_insertion_point(class_scope:data.IndexData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr indexcode_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr exception_;
    int64_t indextime_;
    double indexvalue_;
    double netchgprevday_;
    double highvalue_;
    double lowvalue_;
    double easvalue_;
    double indexturnover_;
    double openingvalue_;
    double closingvalue_;
    double previoussesclose_;
    int64_t indexvolume_;
    double netchgprevdaypct_;
    int indexstatus_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_data_2eproto;
};
// -------------------------------------------------------------------

class IndexDefinition final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:data.IndexDefinition) */ {
 public:
  inline IndexDefinition() : IndexDefinition(nullptr) {}
  ~IndexDefinition() override;
  explicit PROTOBUF_CONSTEXPR IndexDefinition(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IndexDefinition(const IndexDefinition& from);
  IndexDefinition(IndexDefinition&& from) noexcept
    : IndexDefinition() {
    *this = ::std::move(from);
  }

  inline IndexDefinition& operator=(const IndexDefinition& from) {
    CopyFrom(from);
    return *this;
  }
  inline IndexDefinition& operator=(IndexDefinition&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IndexDefinition& default_instance() {
    return *internal_default_instance();
  }
  static inline const IndexDefinition* internal_default_instance() {
    return reinterpret_cast<const IndexDefinition*>(
               &_IndexDefinition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  friend void swap(IndexDefinition& a, IndexDefinition& b) {
    a.Swap(&b);
  }
  inline void Swap(IndexDefinition* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IndexDefinition* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IndexDefinition* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IndexDefinition>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IndexDefinition& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const IndexDefinition& from) {
    IndexDefinition::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IndexDefinition* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "data.IndexDefinition";
  }
  protected:
  explicit IndexDefinition(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIndexCodeFieldNumber = 1,
    kIndexSourceFieldNumber = 2,
    kCurrencyCodeFieldNumber = 3,
  };
  // optional string indexCode = 1;
  bool has_indexcode() const;
  private:
  bool _internal_has_indexcode() const;
  public:
  void clear_indexcode();
  const std::string& indexcode() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_indexcode(ArgT0&& arg0, ArgT... args);
  std::string* mutable_indexcode();
  PROTOBUF_NODISCARD std::string* release_indexcode();
  void set_allocated_indexcode(std::string* indexcode);
  private:
  const std::string& _internal_indexcode() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_indexcode(const std::string& value);
  std::string* _internal_mutable_indexcode();
  public:

  // optional .data.IndexSource indexSource = 2;
  bool has_indexsource() const;
  private:
  bool _internal_has_indexsource() const;
  public:
  void clear_indexsource();
  ::data::IndexSource indexsource() const;
  void set_indexsource(::data::IndexSource value);
  private:
  ::data::IndexSource _internal_indexsource() const;
  void _internal_set_indexsource(::data::IndexSource value);
  public:

  // optional .data.CurrencyType currencyCode = 3;
  bool has_currencycode() const;
  private:
  bool _internal_has_currencycode() const;
  public:
  void clear_currencycode();
  ::data::CurrencyType currencycode() const;
  void set_currencycode(::data::CurrencyType value);
  private:
  ::data::CurrencyType _internal_currencycode() const;
  void _internal_set_currencycode(::data::CurrencyType value);
  public:

  // @@protoc_insertion_point(class_scope:data.IndexDefinition)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr indexcode_;
    int indexsource_;
    int currencycode_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_data_2eproto;
};
// -------------------------------------------------------------------

class IndicativeEquilibriumPrice final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:data.IndicativeEquilibriumPrice) */ {
 public:
  inline IndicativeEquilibriumPrice() : IndicativeEquilibriumPrice(nullptr) {}
  ~IndicativeEquilibriumPrice() override;
  explicit PROTOBUF_CONSTEXPR IndicativeEquilibriumPrice(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IndicativeEquilibriumPrice(const IndicativeEquilibriumPrice& from);
  IndicativeEquilibriumPrice(IndicativeEquilibriumPrice&& from) noexcept
    : IndicativeEquilibriumPrice() {
    *this = ::std::move(from);
  }

  inline IndicativeEquilibriumPrice& operator=(const IndicativeEquilibriumPrice& from) {
    CopyFrom(from);
    return *this;
  }
  inline IndicativeEquilibriumPrice& operator=(IndicativeEquilibriumPrice&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IndicativeEquilibriumPrice& default_instance() {
    return *internal_default_instance();
  }
  static inline const IndicativeEquilibriumPrice* internal_default_instance() {
    return reinterpret_cast<const IndicativeEquilibriumPrice*>(
               &_IndicativeEquilibriumPrice_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  friend void swap(IndicativeEquilibriumPrice& a, IndicativeEquilibriumPrice& b) {
    a.Swap(&b);
  }
  inline void Swap(IndicativeEquilibriumPrice* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IndicativeEquilibriumPrice* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IndicativeEquilibriumPrice* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IndicativeEquilibriumPrice>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IndicativeEquilibriumPrice& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const IndicativeEquilibriumPrice& from) {
    IndicativeEquilibriumPrice::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IndicativeEquilibriumPrice* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "data.IndicativeEquilibriumPrice";
  }
  protected:
  explicit IndicativeEquilibriumPrice(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSecurityCodeFieldNumber = 1,
    kPriceFieldNumber = 2,
    kAggregateQuantityFieldNumber = 3,
  };
  // optional int64 securityCode = 1;
  bool has_securitycode() const;
  private:
  bool _internal_has_securitycode() const;
  public:
  void clear_securitycode();
  int64_t securitycode() const;
  void set_securitycode(int64_t value);
  private:
  int64_t _internal_securitycode() const;
  void _internal_set_securitycode(int64_t value);
  public:

  // optional double price = 2;
  bool has_price() const;
  private:
  bool _internal_has_price() const;
  public:
  void clear_price();
  double price() const;
  void set_price(double value);
  private:
  double _internal_price() const;
  void _internal_set_price(double value);
  public:

  // optional int64 aggregateQuantity = 3;
  bool has_aggregatequantity() const;
  private:
  bool _internal_has_aggregatequantity() const;
  public:
  void clear_aggregatequantity();
  int64_t aggregatequantity() const;
  void set_aggregatequantity(int64_t value);
  private:
  int64_t _internal_aggregatequantity() const;
  void _internal_set_aggregatequantity(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:data.IndicativeEquilibriumPrice)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int64_t securitycode_;
    double price_;
    int64_t aggregatequantity_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_data_2eproto;
};
// -------------------------------------------------------------------

class LiquidityProvider final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:data.LiquidityProvider) */ {
 public:
  inline LiquidityProvider() : LiquidityProvider(nullptr) {}
  ~LiquidityProvider() override;
  explicit PROTOBUF_CONSTEXPR LiquidityProvider(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LiquidityProvider(const LiquidityProvider& from);
  LiquidityProvider(LiquidityProvider&& from) noexcept
    : LiquidityProvider() {
    *this = ::std::move(from);
  }

  inline LiquidityProvider& operator=(const LiquidityProvider& from) {
    CopyFrom(from);
    return *this;
  }
  inline LiquidityProvider& operator=(LiquidityProvider&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LiquidityProvider& default_instance() {
    return *internal_default_instance();
  }
  static inline const LiquidityProvider* internal_default_instance() {
    return reinterpret_cast<const LiquidityProvider*>(
               &_LiquidityProvider_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    40;

  friend void swap(LiquidityProvider& a, LiquidityProvider& b) {
    a.Swap(&b);
  }
  inline void Swap(LiquidityProvider* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LiquidityProvider* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LiquidityProvider* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LiquidityProvider>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LiquidityProvider& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LiquidityProvider& from) {
    LiquidityProvider::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LiquidityProvider* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "data.LiquidityProvider";
  }
  protected:
  explicit LiquidityProvider(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNoLiquidityProvidersFieldNumber = 2,
    kSecurityCodeFieldNumber = 1,
  };
  // repeated .data.NoLiquidityProvider noLiquidityProviders = 2;
  int noliquidityproviders_size() const;
  private:
  int _internal_noliquidityproviders_size() const;
  public:
  void clear_noliquidityproviders();
  ::data::NoLiquidityProvider* mutable_noliquidityproviders(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::data::NoLiquidityProvider >*
      mutable_noliquidityproviders();
  private:
  const ::data::NoLiquidityProvider& _internal_noliquidityproviders(int index) const;
  ::data::NoLiquidityProvider* _internal_add_noliquidityproviders();
  public:
  const ::data::NoLiquidityProvider& noliquidityproviders(int index) const;
  ::data::NoLiquidityProvider* add_noliquidityproviders();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::data::NoLiquidityProvider >&
      noliquidityproviders() const;

  // optional int64 securityCode = 1;
  bool has_securitycode() const;
  private:
  bool _internal_has_securitycode() const;
  public:
  void clear_securitycode();
  int64_t securitycode() const;
  void set_securitycode(int64_t value);
  private:
  int64_t _internal_securitycode() const;
  void _internal_set_securitycode(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:data.LiquidityProvider)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::data::NoLiquidityProvider > noliquidityproviders_;
    int64_t securitycode_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_data_2eproto;
};
// -------------------------------------------------------------------

class MarketDefinition final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:data.MarketDefinition) */ {
 public:
  inline MarketDefinition() : MarketDefinition(nullptr) {}
  ~MarketDefinition() override;
  explicit PROTOBUF_CONSTEXPR MarketDefinition(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MarketDefinition(const MarketDefinition& from);
  MarketDefinition(MarketDefinition&& from) noexcept
    : MarketDefinition() {
    *this = ::std::move(from);
  }

  inline MarketDefinition& operator=(const MarketDefinition& from) {
    CopyFrom(from);
    return *this;
  }
  inline MarketDefinition& operator=(MarketDefinition&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MarketDefinition& default_instance() {
    return *internal_default_instance();
  }
  static inline const MarketDefinition* internal_default_instance() {
    return reinterpret_cast<const MarketDefinition*>(
               &_MarketDefinition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    41;

  friend void swap(MarketDefinition& a, MarketDefinition& b) {
    a.Swap(&b);
  }
  inline void Swap(MarketDefinition* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MarketDefinition* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MarketDefinition* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MarketDefinition>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MarketDefinition& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MarketDefinition& from) {
    MarketDefinition::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MarketDefinition* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "data.MarketDefinition";
  }
  protected:
  explicit MarketDefinition(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMarketNameFieldNumber = 2,
    kMarketCodeFieldNumber = 1,
    kCurrencyCodeFieldNumber = 3,
    kNumberOfSecuritiesFieldNumber = 4,
  };
  // optional string marketName = 2;
  bool has_marketname() const;
  private:
  bool _internal_has_marketname() const;
  public:
  void clear_marketname();
  const std::string& marketname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_marketname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_marketname();
  PROTOBUF_NODISCARD std::string* release_marketname();
  void set_allocated_marketname(std::string* marketname);
  private:
  const std::string& _internal_marketname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_marketname(const std::string& value);
  std::string* _internal_mutable_marketname();
  public:

  // optional .data.MarketCode marketCode = 1;
  bool has_marketcode() const;
  private:
  bool _internal_has_marketcode() const;
  public:
  void clear_marketcode();
  ::data::MarketCode marketcode() const;
  void set_marketcode(::data::MarketCode value);
  private:
  ::data::MarketCode _internal_marketcode() const;
  void _internal_set_marketcode(::data::MarketCode value);
  public:

  // optional .data.CurrencyType currencyCode = 3;
  bool has_currencycode() const;
  private:
  bool _internal_has_currencycode() const;
  public:
  void clear_currencycode();
  ::data::CurrencyType currencycode() const;
  void set_currencycode(::data::CurrencyType value);
  private:
  ::data::CurrencyType _internal_currencycode() const;
  void _internal_set_currencycode(::data::CurrencyType value);
  public:

  // optional int64 numberOfSecurities = 4;
  bool has_numberofsecurities() const;
  private:
  bool _internal_has_numberofsecurities() const;
  public:
  void clear_numberofsecurities();
  int64_t numberofsecurities() const;
  void set_numberofsecurities(int64_t value);
  private:
  int64_t _internal_numberofsecurities() const;
  void _internal_set_numberofsecurities(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:data.MarketDefinition)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr marketname_;
    int marketcode_;
    int currencycode_;
    int64_t numberofsecurities_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_data_2eproto;
};
// -------------------------------------------------------------------

class MarketTurnover final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:data.MarketTurnover) */ {
 public:
  inline MarketTurnover() : MarketTurnover(nullptr) {}
  ~MarketTurnover() override;
  explicit PROTOBUF_CONSTEXPR MarketTurnover(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MarketTurnover(const MarketTurnover& from);
  MarketTurnover(MarketTurnover&& from) noexcept
    : MarketTurnover() {
    *this = ::std::move(from);
  }

  inline MarketTurnover& operator=(const MarketTurnover& from) {
    CopyFrom(from);
    return *this;
  }
  inline MarketTurnover& operator=(MarketTurnover&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MarketTurnover& default_instance() {
    return *internal_default_instance();
  }
  static inline const MarketTurnover* internal_default_instance() {
    return reinterpret_cast<const MarketTurnover*>(
               &_MarketTurnover_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    42;

  friend void swap(MarketTurnover& a, MarketTurnover& b) {
    a.Swap(&b);
  }
  inline void Swap(MarketTurnover* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MarketTurnover* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MarketTurnover* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MarketTurnover>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MarketTurnover& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MarketTurnover& from) {
    MarketTurnover::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MarketTurnover* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "data.MarketTurnover";
  }
  protected:
  explicit MarketTurnover(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMarketCodeFieldNumber = 1,
    kCurrencyCodeFieldNumber = 2,
    kTurnoverFieldNumber = 3,
  };
  // optional .data.MarketCode marketCode = 1;
  bool has_marketcode() const;
  private:
  bool _internal_has_marketcode() const;
  public:
  void clear_marketcode();
  ::data::MarketCode marketcode() const;
  void set_marketcode(::data::MarketCode value);
  private:
  ::data::MarketCode _internal_marketcode() const;
  void _internal_set_marketcode(::data::MarketCode value);
  public:

  // optional .data.CurrencyType currencyCode = 2;
  bool has_currencycode() const;
  private:
  bool _internal_has_currencycode() const;
  public:
  void clear_currencycode();
  ::data::CurrencyType currencycode() const;
  void set_currencycode(::data::CurrencyType value);
  private:
  ::data::CurrencyType _internal_currencycode() const;
  void _internal_set_currencycode(::data::CurrencyType value);
  public:

  // optional double turnover = 3;
  bool has_turnover() const;
  private:
  bool _internal_has_turnover() const;
  public:
  void clear_turnover();
  double turnover() const;
  void set_turnover(double value);
  private:
  double _internal_turnover() const;
  void _internal_set_turnover(double value);
  public:

  // @@protoc_insertion_point(class_scope:data.MarketTurnover)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int marketcode_;
    int currencycode_;
    double turnover_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_data_2eproto;
};
// -------------------------------------------------------------------

class News final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:data.News) */ {
 public:
  inline News() : News(nullptr) {}
  ~News() override;
  explicit PROTOBUF_CONSTEXPR News(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  News(const News& from);
  News(News&& from) noexcept
    : News() {
    *this = ::std::move(from);
  }

  inline News& operator=(const News& from) {
    CopyFrom(from);
    return *this;
  }
  inline News& operator=(News&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const News& default_instance() {
    return *internal_default_instance();
  }
  static inline const News* internal_default_instance() {
    return reinterpret_cast<const News*>(
               &_News_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    43;

  friend void swap(News& a, News& b) {
    a.Swap(&b);
  }
  inline void Swap(News* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(News* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  News* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<News>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const News& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const News& from) {
    News::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(News* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "data.News";
  }
  protected:
  explicit News(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNoMarketCodesFieldNumber = 7,
    kNoSecurityCodesFieldNumber = 8,
    kNoNewsLinesFieldNumber = 9,
    kNewsIDFieldNumber = 2,
    kHeadlineFieldNumber = 3,
    kNewsTypeFieldNumber = 1,
    kCancelFlagFieldNumber = 4,
    kReleaseTimeFieldNumber = 6,
    kLastFragmentFieldNumber = 5,
  };
  // repeated .data.NoMarketCode noMarketCodes = 7;
  int nomarketcodes_size() const;
  private:
  int _internal_nomarketcodes_size() const;
  public:
  void clear_nomarketcodes();
  ::data::NoMarketCode* mutable_nomarketcodes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::data::NoMarketCode >*
      mutable_nomarketcodes();
  private:
  const ::data::NoMarketCode& _internal_nomarketcodes(int index) const;
  ::data::NoMarketCode* _internal_add_nomarketcodes();
  public:
  const ::data::NoMarketCode& nomarketcodes(int index) const;
  ::data::NoMarketCode* add_nomarketcodes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::data::NoMarketCode >&
      nomarketcodes() const;

  // repeated .data.NoSecurityCode noSecurityCodes = 8;
  int nosecuritycodes_size() const;
  private:
  int _internal_nosecuritycodes_size() const;
  public:
  void clear_nosecuritycodes();
  ::data::NoSecurityCode* mutable_nosecuritycodes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::data::NoSecurityCode >*
      mutable_nosecuritycodes();
  private:
  const ::data::NoSecurityCode& _internal_nosecuritycodes(int index) const;
  ::data::NoSecurityCode* _internal_add_nosecuritycodes();
  public:
  const ::data::NoSecurityCode& nosecuritycodes(int index) const;
  ::data::NoSecurityCode* add_nosecuritycodes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::data::NoSecurityCode >&
      nosecuritycodes() const;

  // repeated .data.NoNewsLine noNewsLines = 9;
  int nonewslines_size() const;
  private:
  int _internal_nonewslines_size() const;
  public:
  void clear_nonewslines();
  ::data::NoNewsLine* mutable_nonewslines(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::data::NoNewsLine >*
      mutable_nonewslines();
  private:
  const ::data::NoNewsLine& _internal_nonewslines(int index) const;
  ::data::NoNewsLine* _internal_add_nonewslines();
  public:
  const ::data::NoNewsLine& nonewslines(int index) const;
  ::data::NoNewsLine* add_nonewslines();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::data::NoNewsLine >&
      nonewslines() const;

  // optional string newsID = 2;
  bool has_newsid() const;
  private:
  bool _internal_has_newsid() const;
  public:
  void clear_newsid();
  const std::string& newsid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_newsid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_newsid();
  PROTOBUF_NODISCARD std::string* release_newsid();
  void set_allocated_newsid(std::string* newsid);
  private:
  const std::string& _internal_newsid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_newsid(const std::string& value);
  std::string* _internal_mutable_newsid();
  public:

  // optional string headline = 3;
  bool has_headline() const;
  private:
  bool _internal_has_headline() const;
  public:
  void clear_headline();
  const std::string& headline() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_headline(ArgT0&& arg0, ArgT... args);
  std::string* mutable_headline();
  PROTOBUF_NODISCARD std::string* release_headline();
  void set_allocated_headline(std::string* headline);
  private:
  const std::string& _internal_headline() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_headline(const std::string& value);
  std::string* _internal_mutable_headline();
  public:

  // optional .data.NewsType newsType = 1;
  bool has_newstype() const;
  private:
  bool _internal_has_newstype() const;
  public:
  void clear_newstype();
  ::data::NewsType newstype() const;
  void set_newstype(::data::NewsType value);
  private:
  ::data::NewsType _internal_newstype() const;
  void _internal_set_newstype(::data::NewsType value);
  public:

  // optional .data.CancelFlag cancelFlag = 4;
  bool has_cancelflag() const;
  private:
  bool _internal_has_cancelflag() const;
  public:
  void clear_cancelflag();
  ::data::CancelFlag cancelflag() const;
  void set_cancelflag(::data::CancelFlag value);
  private:
  ::data::CancelFlag _internal_cancelflag() const;
  void _internal_set_cancelflag(::data::CancelFlag value);
  public:

  // optional int64 releaseTime = 6;
  bool has_releasetime() const;
  private:
  bool _internal_has_releasetime() const;
  public:
  void clear_releasetime();
  int64_t releasetime() const;
  void set_releasetime(int64_t value);
  private:
  int64_t _internal_releasetime() const;
  void _internal_set_releasetime(int64_t value);
  public:

  // optional .data.LastFragment lastFragment = 5;
  bool has_lastfragment() const;
  private:
  bool _internal_has_lastfragment() const;
  public:
  void clear_lastfragment();
  ::data::LastFragment lastfragment() const;
  void set_lastfragment(::data::LastFragment value);
  private:
  ::data::LastFragment _internal_lastfragment() const;
  void _internal_set_lastfragment(::data::LastFragment value);
  public:

  // @@protoc_insertion_point(class_scope:data.News)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::data::NoMarketCode > nomarketcodes_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::data::NoSecurityCode > nosecuritycodes_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::data::NoNewsLine > nonewslines_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr newsid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr headline_;
    int newstype_;
    int cancelflag_;
    int64_t releasetime_;
    int lastfragment_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_data_2eproto;
};
// -------------------------------------------------------------------

class NoEntry final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:data.NoEntry) */ {
 public:
  inline NoEntry() : NoEntry(nullptr) {}
  ~NoEntry() override;
  explicit PROTOBUF_CONSTEXPR NoEntry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NoEntry(const NoEntry& from);
  NoEntry(NoEntry&& from) noexcept
    : NoEntry() {
    *this = ::std::move(from);
  }

  inline NoEntry& operator=(const NoEntry& from) {
    CopyFrom(from);
    return *this;
  }
  inline NoEntry& operator=(NoEntry&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NoEntry& default_instance() {
    return *internal_default_instance();
  }
  static inline const NoEntry* internal_default_instance() {
    return reinterpret_cast<const NoEntry*>(
               &_NoEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    44;

  friend void swap(NoEntry& a, NoEntry& b) {
    a.Swap(&b);
  }
  inline void Swap(NoEntry* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NoEntry* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NoEntry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NoEntry>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NoEntry& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NoEntry& from) {
    NoEntry::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NoEntry* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "data.NoEntry";
  }
  protected:
  explicit NoEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAggregateQuantityFieldNumber = 1,
    kPriceFieldNumber = 2,
    kNumberOfOrdersFieldNumber = 3,
    kSideFieldNumber = 4,
    kPriceLevelFieldNumber = 5,
    kUpdateActionFieldNumber = 6,
  };
  // optional int64 aggregateQuantity = 1;
  bool has_aggregatequantity() const;
  private:
  bool _internal_has_aggregatequantity() const;
  public:
  void clear_aggregatequantity();
  int64_t aggregatequantity() const;
  void set_aggregatequantity(int64_t value);
  private:
  int64_t _internal_aggregatequantity() const;
  void _internal_set_aggregatequantity(int64_t value);
  public:

  // optional double price = 2;
  bool has_price() const;
  private:
  bool _internal_has_price() const;
  public:
  void clear_price();
  double price() const;
  void set_price(double value);
  private:
  double _internal_price() const;
  void _internal_set_price(double value);
  public:

  // optional int64 numberOfOrders = 3;
  bool has_numberoforders() const;
  private:
  bool _internal_has_numberoforders() const;
  public:
  void clear_numberoforders();
  int64_t numberoforders() const;
  void set_numberoforders(int64_t value);
  private:
  int64_t _internal_numberoforders() const;
  void _internal_set_numberoforders(int64_t value);
  public:

  // optional .data.Side side = 4;
  bool has_side() const;
  private:
  bool _internal_has_side() const;
  public:
  void clear_side();
  ::data::Side side() const;
  void set_side(::data::Side value);
  private:
  ::data::Side _internal_side() const;
  void _internal_set_side(::data::Side value);
  public:

  // optional int32 priceLevel = 5;
  bool has_pricelevel() const;
  private:
  bool _internal_has_pricelevel() const;
  public:
  void clear_pricelevel();
  int32_t pricelevel() const;
  void set_pricelevel(int32_t value);
  private:
  int32_t _internal_pricelevel() const;
  void _internal_set_pricelevel(int32_t value);
  public:

  // optional .data.UpdateAction updateAction = 6;
  bool has_updateaction() const;
  private:
  bool _internal_has_updateaction() const;
  public:
  void clear_updateaction();
  ::data::UpdateAction updateaction() const;
  void set_updateaction(::data::UpdateAction value);
  private:
  ::data::UpdateAction _internal_updateaction() const;
  void _internal_set_updateaction(::data::UpdateAction value);
  public:

  // @@protoc_insertion_point(class_scope:data.NoEntry)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int64_t aggregatequantity_;
    double price_;
    int64_t numberoforders_;
    int side_;
    int32_t pricelevel_;
    int updateaction_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_data_2eproto;
};
// -------------------------------------------------------------------

class NoLiquidityProvider final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:data.NoLiquidityProvider) */ {
 public:
  inline NoLiquidityProvider() : NoLiquidityProvider(nullptr) {}
  ~NoLiquidityProvider() override;
  explicit PROTOBUF_CONSTEXPR NoLiquidityProvider(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NoLiquidityProvider(const NoLiquidityProvider& from);
  NoLiquidityProvider(NoLiquidityProvider&& from) noexcept
    : NoLiquidityProvider() {
    *this = ::std::move(from);
  }

  inline NoLiquidityProvider& operator=(const NoLiquidityProvider& from) {
    CopyFrom(from);
    return *this;
  }
  inline NoLiquidityProvider& operator=(NoLiquidityProvider&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NoLiquidityProvider& default_instance() {
    return *internal_default_instance();
  }
  static inline const NoLiquidityProvider* internal_default_instance() {
    return reinterpret_cast<const NoLiquidityProvider*>(
               &_NoLiquidityProvider_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    45;

  friend void swap(NoLiquidityProvider& a, NoLiquidityProvider& b) {
    a.Swap(&b);
  }
  inline void Swap(NoLiquidityProvider* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NoLiquidityProvider* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NoLiquidityProvider* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NoLiquidityProvider>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NoLiquidityProvider& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NoLiquidityProvider& from) {
    NoLiquidityProvider::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NoLiquidityProvider* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "data.NoLiquidityProvider";
  }
  protected:
  explicit NoLiquidityProvider(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLPBrokerNumberFieldNumber = 1,
  };
  // optional int32 lPBrokerNumber = 1;
  bool has_lpbrokernumber() const;
  private:
  bool _internal_has_lpbrokernumber() const;
  public:
  void clear_lpbrokernumber();
  int32_t lpbrokernumber() const;
  void set_lpbrokernumber(int32_t value);
  private:
  int32_t _internal_lpbrokernumber() const;
  void _internal_set_lpbrokernumber(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:data.NoLiquidityProvider)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int32_t lpbrokernumber_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_data_2eproto;
};
// -------------------------------------------------------------------

class NoMarketCode final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:data.NoMarketCode) */ {
 public:
  inline NoMarketCode() : NoMarketCode(nullptr) {}
  ~NoMarketCode() override;
  explicit PROTOBUF_CONSTEXPR NoMarketCode(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NoMarketCode(const NoMarketCode& from);
  NoMarketCode(NoMarketCode&& from) noexcept
    : NoMarketCode() {
    *this = ::std::move(from);
  }

  inline NoMarketCode& operator=(const NoMarketCode& from) {
    CopyFrom(from);
    return *this;
  }
  inline NoMarketCode& operator=(NoMarketCode&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NoMarketCode& default_instance() {
    return *internal_default_instance();
  }
  static inline const NoMarketCode* internal_default_instance() {
    return reinterpret_cast<const NoMarketCode*>(
               &_NoMarketCode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    46;

  friend void swap(NoMarketCode& a, NoMarketCode& b) {
    a.Swap(&b);
  }
  inline void Swap(NoMarketCode* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NoMarketCode* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NoMarketCode* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NoMarketCode>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NoMarketCode& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NoMarketCode& from) {
    NoMarketCode::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NoMarketCode* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "data.NoMarketCode";
  }
  protected:
  explicit NoMarketCode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMarketCodeFieldNumber = 1,
  };
  // optional .data.MarketCode marketCode = 1;
  bool has_marketcode() const;
  private:
  bool _internal_has_marketcode() const;
  public:
  void clear_marketcode();
  ::data::MarketCode marketcode() const;
  void set_marketcode(::data::MarketCode value);
  private:
  ::data::MarketCode _internal_marketcode() const;
  void _internal_set_marketcode(::data::MarketCode value);
  public:

  // @@protoc_insertion_point(class_scope:data.NoMarketCode)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int marketcode_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_data_2eproto;
};
// -------------------------------------------------------------------

class NoNewsLine final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:data.NoNewsLine) */ {
 public:
  inline NoNewsLine() : NoNewsLine(nullptr) {}
  ~NoNewsLine() override;
  explicit PROTOBUF_CONSTEXPR NoNewsLine(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NoNewsLine(const NoNewsLine& from);
  NoNewsLine(NoNewsLine&& from) noexcept
    : NoNewsLine() {
    *this = ::std::move(from);
  }

  inline NoNewsLine& operator=(const NoNewsLine& from) {
    CopyFrom(from);
    return *this;
  }
  inline NoNewsLine& operator=(NoNewsLine&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NoNewsLine& default_instance() {
    return *internal_default_instance();
  }
  static inline const NoNewsLine* internal_default_instance() {
    return reinterpret_cast<const NoNewsLine*>(
               &_NoNewsLine_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    47;

  friend void swap(NoNewsLine& a, NoNewsLine& b) {
    a.Swap(&b);
  }
  inline void Swap(NoNewsLine* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NoNewsLine* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NoNewsLine* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NoNewsLine>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NoNewsLine& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NoNewsLine& from) {
    NoNewsLine::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NoNewsLine* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "data.NoNewsLine";
  }
  protected:
  explicit NoNewsLine(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNewsLineFieldNumber = 1,
  };
  // optional string newsLine = 1;
  bool has_newsline() const;
  private:
  bool _internal_has_newsline() const;
  public:
  void clear_newsline();
  const std::string& newsline() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_newsline(ArgT0&& arg0, ArgT... args);
  std::string* mutable_newsline();
  PROTOBUF_NODISCARD std::string* release_newsline();
  void set_allocated_newsline(std::string* newsline);
  private:
  const std::string& _internal_newsline() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_newsline(const std::string& value);
  std::string* _internal_mutable_newsline();
  public:

  // @@protoc_insertion_point(class_scope:data.NoNewsLine)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr newsline_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_data_2eproto;
};
// -------------------------------------------------------------------

class NoSecurityCode final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:data.NoSecurityCode) */ {
 public:
  inline NoSecurityCode() : NoSecurityCode(nullptr) {}
  ~NoSecurityCode() override;
  explicit PROTOBUF_CONSTEXPR NoSecurityCode(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NoSecurityCode(const NoSecurityCode& from);
  NoSecurityCode(NoSecurityCode&& from) noexcept
    : NoSecurityCode() {
    *this = ::std::move(from);
  }

  inline NoSecurityCode& operator=(const NoSecurityCode& from) {
    CopyFrom(from);
    return *this;
  }
  inline NoSecurityCode& operator=(NoSecurityCode&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NoSecurityCode& default_instance() {
    return *internal_default_instance();
  }
  static inline const NoSecurityCode* internal_default_instance() {
    return reinterpret_cast<const NoSecurityCode*>(
               &_NoSecurityCode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    48;

  friend void swap(NoSecurityCode& a, NoSecurityCode& b) {
    a.Swap(&b);
  }
  inline void Swap(NoSecurityCode* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NoSecurityCode* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NoSecurityCode* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NoSecurityCode>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NoSecurityCode& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NoSecurityCode& from) {
    NoSecurityCode::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NoSecurityCode* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "data.NoSecurityCode";
  }
  protected:
  explicit NoSecurityCode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSecurityCodeFieldNumber = 1,
  };
  // optional int64 securityCode = 1;
  bool has_securitycode() const;
  private:
  bool _internal_has_securitycode() const;
  public:
  void clear_securitycode();
  int64_t securitycode() const;
  void set_securitycode(int64_t value);
  private:
  int64_t _internal_securitycode() const;
  void _internal_set_securitycode(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:data.NoSecurityCode)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int64_t securitycode_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_data_2eproto;
};
// -------------------------------------------------------------------

class NoUnderlyingSecurity final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:data.NoUnderlyingSecurity) */ {
 public:
  inline NoUnderlyingSecurity() : NoUnderlyingSecurity(nullptr) {}
  ~NoUnderlyingSecurity() override;
  explicit PROTOBUF_CONSTEXPR NoUnderlyingSecurity(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NoUnderlyingSecurity(const NoUnderlyingSecurity& from);
  NoUnderlyingSecurity(NoUnderlyingSecurity&& from) noexcept
    : NoUnderlyingSecurity() {
    *this = ::std::move(from);
  }

  inline NoUnderlyingSecurity& operator=(const NoUnderlyingSecurity& from) {
    CopyFrom(from);
    return *this;
  }
  inline NoUnderlyingSecurity& operator=(NoUnderlyingSecurity&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NoUnderlyingSecurity& default_instance() {
    return *internal_default_instance();
  }
  static inline const NoUnderlyingSecurity* internal_default_instance() {
    return reinterpret_cast<const NoUnderlyingSecurity*>(
               &_NoUnderlyingSecurity_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    49;

  friend void swap(NoUnderlyingSecurity& a, NoUnderlyingSecurity& b) {
    a.Swap(&b);
  }
  inline void Swap(NoUnderlyingSecurity* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NoUnderlyingSecurity* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NoUnderlyingSecurity* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NoUnderlyingSecurity>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NoUnderlyingSecurity& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NoUnderlyingSecurity& from) {
    NoUnderlyingSecurity::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NoUnderlyingSecurity* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "data.NoUnderlyingSecurity";
  }
  protected:
  explicit NoUnderlyingSecurity(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUnderlyingSecurityCodeFieldNumber = 1,
  };
  // optional int64 underlyingSecurityCode = 1;
  bool has_underlyingsecuritycode() const;
  private:
  bool _internal_has_underlyingsecuritycode() const;
  public:
  void clear_underlyingsecuritycode();
  int64_t underlyingsecuritycode() const;
  void set_underlyingsecuritycode(int64_t value);
  private:
  int64_t _internal_underlyingsecuritycode() const;
  void _internal_set_underlyingsecuritycode(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:data.NoUnderlyingSecurity)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int64_t underlyingsecuritycode_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_data_2eproto;
};
// -------------------------------------------------------------------

class NominalPrice final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:data.NominalPrice) */ {
 public:
  inline NominalPrice() : NominalPrice(nullptr) {}
  ~NominalPrice() override;
  explicit PROTOBUF_CONSTEXPR NominalPrice(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NominalPrice(const NominalPrice& from);
  NominalPrice(NominalPrice&& from) noexcept
    : NominalPrice() {
    *this = ::std::move(from);
  }

  inline NominalPrice& operator=(const NominalPrice& from) {
    CopyFrom(from);
    return *this;
  }
  inline NominalPrice& operator=(NominalPrice&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NominalPrice& default_instance() {
    return *internal_default_instance();
  }
  static inline const NominalPrice* internal_default_instance() {
    return reinterpret_cast<const NominalPrice*>(
               &_NominalPrice_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    50;

  friend void swap(NominalPrice& a, NominalPrice& b) {
    a.Swap(&b);
  }
  inline void Swap(NominalPrice* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NominalPrice* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NominalPrice* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NominalPrice>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NominalPrice& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NominalPrice& from) {
    NominalPrice::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NominalPrice* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "data.NominalPrice";
  }
  protected:
  explicit NominalPrice(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSecurityCodeFieldNumber = 1,
    kNominalPriceFieldNumber = 2,
  };
  // optional int64 securityCode = 1;
  bool has_securitycode() const;
  private:
  bool _internal_has_securitycode() const;
  public:
  void clear_securitycode();
  int64_t securitycode() const;
  void set_securitycode(int64_t value);
  private:
  int64_t _internal_securitycode() const;
  void _internal_set_securitycode(int64_t value);
  public:

  // optional double nominalPrice = 2;
  bool has_nominalprice() const;
  private:
  bool _internal_has_nominalprice() const;
  public:
  void clear_nominalprice();
  double nominalprice() const;
  void set_nominalprice(double value);
  private:
  double _internal_nominalprice() const;
  void _internal_set_nominalprice(double value);
  public:

  // @@protoc_insertion_point(class_scope:data.NominalPrice)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int64_t securitycode_;
    double nominalprice_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_data_2eproto;
};
// -------------------------------------------------------------------

class OrderImbalance final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:data.OrderImbalance) */ {
 public:
  inline OrderImbalance() : OrderImbalance(nullptr) {}
  ~OrderImbalance() override;
  explicit PROTOBUF_CONSTEXPR OrderImbalance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OrderImbalance(const OrderImbalance& from);
  OrderImbalance(OrderImbalance&& from) noexcept
    : OrderImbalance() {
    *this = ::std::move(from);
  }

  inline OrderImbalance& operator=(const OrderImbalance& from) {
    CopyFrom(from);
    return *this;
  }
  inline OrderImbalance& operator=(OrderImbalance&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OrderImbalance& default_instance() {
    return *internal_default_instance();
  }
  static inline const OrderImbalance* internal_default_instance() {
    return reinterpret_cast<const OrderImbalance*>(
               &_OrderImbalance_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    51;

  friend void swap(OrderImbalance& a, OrderImbalance& b) {
    a.Swap(&b);
  }
  inline void Swap(OrderImbalance* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OrderImbalance* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OrderImbalance* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OrderImbalance>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OrderImbalance& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OrderImbalance& from) {
    OrderImbalance::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OrderImbalance* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "data.OrderImbalance";
  }
  protected:
  explicit OrderImbalance(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSecurityCodeFieldNumber = 1,
    kOrderImbalanceQuantityFieldNumber = 3,
    kOrderImbalanceDirectionFieldNumber = 2,
  };
  // optional int64 securityCode = 1;
  bool has_securitycode() const;
  private:
  bool _internal_has_securitycode() const;
  public:
  void clear_securitycode();
  int64_t securitycode() const;
  void set_securitycode(int64_t value);
  private:
  int64_t _internal_securitycode() const;
  void _internal_set_securitycode(int64_t value);
  public:

  // optional int64 orderImbalanceQuantity = 3;
  bool has_orderimbalancequantity() const;
  private:
  bool _internal_has_orderimbalancequantity() const;
  public:
  void clear_orderimbalancequantity();
  int64_t orderimbalancequantity() const;
  void set_orderimbalancequantity(int64_t value);
  private:
  int64_t _internal_orderimbalancequantity() const;
  void _internal_set_orderimbalancequantity(int64_t value);
  public:

  // optional .data.OrderImbalanceDirection orderImbalanceDirection = 2;
  bool has_orderimbalancedirection() const;
  private:
  bool _internal_has_orderimbalancedirection() const;
  public:
  void clear_orderimbalancedirection();
  ::data::OrderImbalanceDirection orderimbalancedirection() const;
  void set_orderimbalancedirection(::data::OrderImbalanceDirection value);
  private:
  ::data::OrderImbalanceDirection _internal_orderimbalancedirection() const;
  void _internal_set_orderimbalancedirection(::data::OrderImbalanceDirection value);
  public:

  // @@protoc_insertion_point(class_scope:data.OrderImbalance)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int64_t securitycode_;
    int64_t orderimbalancequantity_;
    int orderimbalancedirection_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_data_2eproto;
};
// -------------------------------------------------------------------

class PacketHeader final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:data.PacketHeader) */ {
 public:
  inline PacketHeader() : PacketHeader(nullptr) {}
  ~PacketHeader() override;
  explicit PROTOBUF_CONSTEXPR PacketHeader(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PacketHeader(const PacketHeader& from);
  PacketHeader(PacketHeader&& from) noexcept
    : PacketHeader() {
    *this = ::std::move(from);
  }

  inline PacketHeader& operator=(const PacketHeader& from) {
    CopyFrom(from);
    return *this;
  }
  inline PacketHeader& operator=(PacketHeader&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PacketHeader& default_instance() {
    return *internal_default_instance();
  }
  static inline const PacketHeader* internal_default_instance() {
    return reinterpret_cast<const PacketHeader*>(
               &_PacketHeader_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    52;

  friend void swap(PacketHeader& a, PacketHeader& b) {
    a.Swap(&b);
  }
  inline void Swap(PacketHeader* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PacketHeader* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PacketHeader* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PacketHeader>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PacketHeader& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PacketHeader& from) {
    PacketHeader::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PacketHeader* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "data.PacketHeader";
  }
  protected:
  explicit PacketHeader(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFillerFieldNumber = 3,
    kPktSizeFieldNumber = 1,
    kMsgCountFieldNumber = 2,
    kSeqNumFieldNumber = 4,
    kSendTimeFieldNumber = 5,
  };
  // optional string filler = 3;
  bool has_filler() const;
  private:
  bool _internal_has_filler() const;
  public:
  void clear_filler();
  const std::string& filler() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_filler(ArgT0&& arg0, ArgT... args);
  std::string* mutable_filler();
  PROTOBUF_NODISCARD std::string* release_filler();
  void set_allocated_filler(std::string* filler);
  private:
  const std::string& _internal_filler() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_filler(const std::string& value);
  std::string* _internal_mutable_filler();
  public:

  // optional int32 pktSize = 1;
  bool has_pktsize() const;
  private:
  bool _internal_has_pktsize() const;
  public:
  void clear_pktsize();
  int32_t pktsize() const;
  void set_pktsize(int32_t value);
  private:
  int32_t _internal_pktsize() const;
  void _internal_set_pktsize(int32_t value);
  public:

  // optional int32 msgCount = 2;
  bool has_msgcount() const;
  private:
  bool _internal_has_msgcount() const;
  public:
  void clear_msgcount();
  int32_t msgcount() const;
  void set_msgcount(int32_t value);
  private:
  int32_t _internal_msgcount() const;
  void _internal_set_msgcount(int32_t value);
  public:

  // optional int64 seqNum = 4;
  bool has_seqnum() const;
  private:
  bool _internal_has_seqnum() const;
  public:
  void clear_seqnum();
  int64_t seqnum() const;
  void set_seqnum(int64_t value);
  private:
  int64_t _internal_seqnum() const;
  void _internal_set_seqnum(int64_t value);
  public:

  // optional int64 sendTime = 5;
  bool has_sendtime() const;
  private:
  bool _internal_has_sendtime() const;
  public:
  void clear_sendtime();
  int64_t sendtime() const;
  void set_sendtime(int64_t value);
  private:
  int64_t _internal_sendtime() const;
  void _internal_set_sendtime(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:data.PacketHeader)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr filler_;
    int32_t pktsize_;
    int32_t msgcount_;
    int64_t seqnum_;
    int64_t sendtime_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_data_2eproto;
};
// -------------------------------------------------------------------

class LongAdjustedClosingPrice final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:data.LongAdjustedClosingPrice) */ {
 public:
  inline LongAdjustedClosingPrice() : LongAdjustedClosingPrice(nullptr) {}
  ~LongAdjustedClosingPrice() override;
  explicit PROTOBUF_CONSTEXPR LongAdjustedClosingPrice(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LongAdjustedClosingPrice(const LongAdjustedClosingPrice& from);
  LongAdjustedClosingPrice(LongAdjustedClosingPrice&& from) noexcept
    : LongAdjustedClosingPrice() {
    *this = ::std::move(from);
  }

  inline LongAdjustedClosingPrice& operator=(const LongAdjustedClosingPrice& from) {
    CopyFrom(from);
    return *this;
  }
  inline LongAdjustedClosingPrice& operator=(LongAdjustedClosingPrice&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LongAdjustedClosingPrice& default_instance() {
    return *internal_default_instance();
  }
  static inline const LongAdjustedClosingPrice* internal_default_instance() {
    return reinterpret_cast<const LongAdjustedClosingPrice*>(
               &_LongAdjustedClosingPrice_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    53;

  friend void swap(LongAdjustedClosingPrice& a, LongAdjustedClosingPrice& b) {
    a.Swap(&b);
  }
  inline void Swap(LongAdjustedClosingPrice* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LongAdjustedClosingPrice* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LongAdjustedClosingPrice* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LongAdjustedClosingPrice>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LongAdjustedClosingPrice& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LongAdjustedClosingPrice& from) {
    LongAdjustedClosingPrice::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LongAdjustedClosingPrice* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "data.LongAdjustedClosingPrice";
  }
  protected:
  explicit LongAdjustedClosingPrice(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIssueSymbolFieldNumber = 1,
    kAdjustedClosingPriceFieldNumber = 3,
    kSecurityClassFieldNumber = 2,
  };
  // optional string issueSymbol = 1;
  bool has_issuesymbol() const;
  private:
  bool _internal_has_issuesymbol() const;
  public:
  void clear_issuesymbol();
  const std::string& issuesymbol() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_issuesymbol(ArgT0&& arg0, ArgT... args);
  std::string* mutable_issuesymbol();
  PROTOBUF_NODISCARD std::string* release_issuesymbol();
  void set_allocated_issuesymbol(std::string* issuesymbol);
  private:
  const std::string& _internal_issuesymbol() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_issuesymbol(const std::string& value);
  std::string* _internal_mutable_issuesymbol();
  public:

  // optional double adjustedClosingPrice = 3;
  bool has_adjustedclosingprice() const;
  private:
  bool _internal_has_adjustedclosingprice() const;
  public:
  void clear_adjustedclosingprice();
  double adjustedclosingprice() const;
  void set_adjustedclosingprice(double value);
  private:
  double _internal_adjustedclosingprice() const;
  void _internal_set_adjustedclosingprice(double value);
  public:

  // optional .data.SecurityClass securityClass = 2;
  bool has_securityclass() const;
  private:
  bool _internal_has_securityclass() const;
  public:
  void clear_securityclass();
  ::data::SecurityClass securityclass() const;
  void set_securityclass(::data::SecurityClass value);
  private:
  ::data::SecurityClass _internal_securityclass() const;
  void _internal_set_securityclass(::data::SecurityClass value);
  public:

  // @@protoc_insertion_point(class_scope:data.LongAdjustedClosingPrice)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr issuesymbol_;
    double adjustedclosingprice_;
    int securityclass_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_data_2eproto;
};
// -------------------------------------------------------------------

class LongDayTradeSummary final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:data.LongDayTradeSummary) */ {
 public:
  inline LongDayTradeSummary() : LongDayTradeSummary(nullptr) {}
  ~LongDayTradeSummary() override;
  explicit PROTOBUF_CONSTEXPR LongDayTradeSummary(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LongDayTradeSummary(const LongDayTradeSummary& from);
  LongDayTradeSummary(LongDayTradeSummary&& from) noexcept
    : LongDayTradeSummary() {
    *this = ::std::move(from);
  }

  inline LongDayTradeSummary& operator=(const LongDayTradeSummary& from) {
    CopyFrom(from);
    return *this;
  }
  inline LongDayTradeSummary& operator=(LongDayTradeSummary&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LongDayTradeSummary& default_instance() {
    return *internal_default_instance();
  }
  static inline const LongDayTradeSummary* internal_default_instance() {
    return reinterpret_cast<const LongDayTradeSummary*>(
               &_LongDayTradeSummary_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    54;

  friend void swap(LongDayTradeSummary& a, LongDayTradeSummary& b) {
    a.Swap(&b);
  }
  inline void Swap(LongDayTradeSummary* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LongDayTradeSummary* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LongDayTradeSummary* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LongDayTradeSummary>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LongDayTradeSummary& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LongDayTradeSummary& from) {
    LongDayTradeSummary::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LongDayTradeSummary* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "data.LongDayTradeSummary";
  }
  protected:
  explicit LongDayTradeSummary(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIssueSymbolFieldNumber = 1,
    kNasdaqHighPriceFieldNumber = 3,
    kNasdaqLowPriceFieldNumber = 4,
    kNasdaqClosingPriceFieldNumber = 5,
    kConsolidatedVolumeFieldNumber = 6,
    kConsolidatedOpenPriceFieldNumber = 7,
    kMarketCategoryFieldNumber = 2,
  };
  // optional string issueSymbol = 1;
  bool has_issuesymbol() const;
  private:
  bool _internal_has_issuesymbol() const;
  public:
  void clear_issuesymbol();
  const std::string& issuesymbol() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_issuesymbol(ArgT0&& arg0, ArgT... args);
  std::string* mutable_issuesymbol();
  PROTOBUF_NODISCARD std::string* release_issuesymbol();
  void set_allocated_issuesymbol(std::string* issuesymbol);
  private:
  const std::string& _internal_issuesymbol() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_issuesymbol(const std::string& value);
  std::string* _internal_mutable_issuesymbol();
  public:

  // optional double nasdaqHighPrice = 3;
  bool has_nasdaqhighprice() const;
  private:
  bool _internal_has_nasdaqhighprice() const;
  public:
  void clear_nasdaqhighprice();
  double nasdaqhighprice() const;
  void set_nasdaqhighprice(double value);
  private:
  double _internal_nasdaqhighprice() const;
  void _internal_set_nasdaqhighprice(double value);
  public:

  // optional double nasdaqLowPrice = 4;
  bool has_nasdaqlowprice() const;
  private:
  bool _internal_has_nasdaqlowprice() const;
  public:
  void clear_nasdaqlowprice();
  double nasdaqlowprice() const;
  void set_nasdaqlowprice(double value);
  private:
  double _internal_nasdaqlowprice() const;
  void _internal_set_nasdaqlowprice(double value);
  public:

  // optional double nasdaqClosingPrice = 5;
  bool has_nasdaqclosingprice() const;
  private:
  bool _internal_has_nasdaqclosingprice() const;
  public:
  void clear_nasdaqclosingprice();
  double nasdaqclosingprice() const;
  void set_nasdaqclosingprice(double value);
  private:
  double _internal_nasdaqclosingprice() const;
  void _internal_set_nasdaqclosingprice(double value);
  public:

  // optional int64 consolidatedVolume = 6;
  bool has_consolidatedvolume() const;
  private:
  bool _internal_has_consolidatedvolume() const;
  public:
  void clear_consolidatedvolume();
  int64_t consolidatedvolume() const;
  void set_consolidatedvolume(int64_t value);
  private:
  int64_t _internal_consolidatedvolume() const;
  void _internal_set_consolidatedvolume(int64_t value);
  public:

  // optional double consolidatedOpenPrice = 7;
  bool has_consolidatedopenprice() const;
  private:
  bool _internal_has_consolidatedopenprice() const;
  public:
  void clear_consolidatedopenprice();
  double consolidatedopenprice() const;
  void set_consolidatedopenprice(double value);
  private:
  double _internal_consolidatedopenprice() const;
  void _internal_set_consolidatedopenprice(double value);
  public:

  // optional .data.MarketCategory marketCategory = 2;
  bool has_marketcategory() const;
  private:
  bool _internal_has_marketcategory() const;
  public:
  void clear_marketcategory();
  ::data::MarketCategory marketcategory() const;
  void set_marketcategory(::data::MarketCategory value);
  private:
  ::data::MarketCategory _internal_marketcategory() const;
  void _internal_set_marketcategory(::data::MarketCategory value);
  public:

  // @@protoc_insertion_point(class_scope:data.LongDayTradeSummary)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr issuesymbol_;
    double nasdaqhighprice_;
    double nasdaqlowprice_;
    double nasdaqclosingprice_;
    int64_t consolidatedvolume_;
    double consolidatedopenprice_;
    int marketcategory_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_data_2eproto;
};
// -------------------------------------------------------------------

class LongTradeCancelForNonNextSharesTrades final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:data.LongTradeCancelForNonNextSharesTrades) */ {
 public:
  inline LongTradeCancelForNonNextSharesTrades() : LongTradeCancelForNonNextSharesTrades(nullptr) {}
  ~LongTradeCancelForNonNextSharesTrades() override;
  explicit PROTOBUF_CONSTEXPR LongTradeCancelForNonNextSharesTrades(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LongTradeCancelForNonNextSharesTrades(const LongTradeCancelForNonNextSharesTrades& from);
  LongTradeCancelForNonNextSharesTrades(LongTradeCancelForNonNextSharesTrades&& from) noexcept
    : LongTradeCancelForNonNextSharesTrades() {
    *this = ::std::move(from);
  }

  inline LongTradeCancelForNonNextSharesTrades& operator=(const LongTradeCancelForNonNextSharesTrades& from) {
    CopyFrom(from);
    return *this;
  }
  inline LongTradeCancelForNonNextSharesTrades& operator=(LongTradeCancelForNonNextSharesTrades&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LongTradeCancelForNonNextSharesTrades& default_instance() {
    return *internal_default_instance();
  }
  static inline const LongTradeCancelForNonNextSharesTrades* internal_default_instance() {
    return reinterpret_cast<const LongTradeCancelForNonNextSharesTrades*>(
               &_LongTradeCancelForNonNextSharesTrades_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    55;

  friend void swap(LongTradeCancelForNonNextSharesTrades& a, LongTradeCancelForNonNextSharesTrades& b) {
    a.Swap(&b);
  }
  inline void Swap(LongTradeCancelForNonNextSharesTrades* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LongTradeCancelForNonNextSharesTrades* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LongTradeCancelForNonNextSharesTrades* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LongTradeCancelForNonNextSharesTrades>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LongTradeCancelForNonNextSharesTrades& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LongTradeCancelForNonNextSharesTrades& from) {
    LongTradeCancelForNonNextSharesTrades::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LongTradeCancelForNonNextSharesTrades* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "data.LongTradeCancelForNonNextSharesTrades";
  }
  protected:
  explicit LongTradeCancelForNonNextSharesTrades(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIssueSymbolFieldNumber = 2,
    kOriginalControlNumberFieldNumber = 4,
    kOriginalSaleConditionModifierFieldNumber = 7,
    kMarketCenterIdentifierFieldNumber = 1,
    kSecurityClassFieldNumber = 3,
    kOriginalTradePriceFieldNumber = 5,
    kOriginalTradeSizeFieldNumber = 6,
    kConsolidatedVolumeFieldNumber = 8,
  };
  // optional string issueSymbol = 2;
  bool has_issuesymbol() const;
  private:
  bool _internal_has_issuesymbol() const;
  public:
  void clear_issuesymbol();
  const std::string& issuesymbol() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_issuesymbol(ArgT0&& arg0, ArgT... args);
  std::string* mutable_issuesymbol();
  PROTOBUF_NODISCARD std::string* release_issuesymbol();
  void set_allocated_issuesymbol(std::string* issuesymbol);
  private:
  const std::string& _internal_issuesymbol() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_issuesymbol(const std::string& value);
  std::string* _internal_mutable_issuesymbol();
  public:

  // optional string originalControlNumber = 4;
  bool has_originalcontrolnumber() const;
  private:
  bool _internal_has_originalcontrolnumber() const;
  public:
  void clear_originalcontrolnumber();
  const std::string& originalcontrolnumber() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_originalcontrolnumber(ArgT0&& arg0, ArgT... args);
  std::string* mutable_originalcontrolnumber();
  PROTOBUF_NODISCARD std::string* release_originalcontrolnumber();
  void set_allocated_originalcontrolnumber(std::string* originalcontrolnumber);
  private:
  const std::string& _internal_originalcontrolnumber() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_originalcontrolnumber(const std::string& value);
  std::string* _internal_mutable_originalcontrolnumber();
  public:

  // optional .data.SaleConditionModifier originalSaleConditionModifier = 7;
  bool has_originalsaleconditionmodifier() const;
  private:
  bool _internal_has_originalsaleconditionmodifier() const;
  public:
  void clear_originalsaleconditionmodifier();
  const ::data::SaleConditionModifier& originalsaleconditionmodifier() const;
  PROTOBUF_NODISCARD ::data::SaleConditionModifier* release_originalsaleconditionmodifier();
  ::data::SaleConditionModifier* mutable_originalsaleconditionmodifier();
  void set_allocated_originalsaleconditionmodifier(::data::SaleConditionModifier* originalsaleconditionmodifier);
  private:
  const ::data::SaleConditionModifier& _internal_originalsaleconditionmodifier() const;
  ::data::SaleConditionModifier* _internal_mutable_originalsaleconditionmodifier();
  public:
  void unsafe_arena_set_allocated_originalsaleconditionmodifier(
      ::data::SaleConditionModifier* originalsaleconditionmodifier);
  ::data::SaleConditionModifier* unsafe_arena_release_originalsaleconditionmodifier();

  // optional .data.OriginatingMarketCenterIdentifier marketCenterIdentifier = 1;
  bool has_marketcenteridentifier() const;
  private:
  bool _internal_has_marketcenteridentifier() const;
  public:
  void clear_marketcenteridentifier();
  ::data::OriginatingMarketCenterIdentifier marketcenteridentifier() const;
  void set_marketcenteridentifier(::data::OriginatingMarketCenterIdentifier value);
  private:
  ::data::OriginatingMarketCenterIdentifier _internal_marketcenteridentifier() const;
  void _internal_set_marketcenteridentifier(::data::OriginatingMarketCenterIdentifier value);
  public:

  // optional .data.SecurityClass securityClass = 3;
  bool has_securityclass() const;
  private:
  bool _internal_has_securityclass() const;
  public:
  void clear_securityclass();
  ::data::SecurityClass securityclass() const;
  void set_securityclass(::data::SecurityClass value);
  private:
  ::data::SecurityClass _internal_securityclass() const;
  void _internal_set_securityclass(::data::SecurityClass value);
  public:

  // optional double originalTradePrice = 5;
  bool has_originaltradeprice() const;
  private:
  bool _internal_has_originaltradeprice() const;
  public:
  void clear_originaltradeprice();
  double originaltradeprice() const;
  void set_originaltradeprice(double value);
  private:
  double _internal_originaltradeprice() const;
  void _internal_set_originaltradeprice(double value);
  public:

  // optional int64 originalTradeSize = 6;
  bool has_originaltradesize() const;
  private:
  bool _internal_has_originaltradesize() const;
  public:
  void clear_originaltradesize();
  int64_t originaltradesize() const;
  void set_originaltradesize(int64_t value);
  private:
  int64_t _internal_originaltradesize() const;
  void _internal_set_originaltradesize(int64_t value);
  public:

  // optional int64 consolidatedVolume = 8;
  bool has_consolidatedvolume() const;
  private:
  bool _internal_has_consolidatedvolume() const;
  public:
  void clear_consolidatedvolume();
  int64_t consolidatedvolume() const;
  void set_consolidatedvolume(int64_t value);
  private:
  int64_t _internal_consolidatedvolume() const;
  void _internal_set_consolidatedvolume(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:data.LongTradeCancelForNonNextSharesTrades)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr issuesymbol_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr originalcontrolnumber_;
    ::data::SaleConditionModifier* originalsaleconditionmodifier_;
    int marketcenteridentifier_;
    int securityclass_;
    double originaltradeprice_;
    int64_t originaltradesize_;
    int64_t consolidatedvolume_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_data_2eproto;
};
// -------------------------------------------------------------------

class LongTradeCorrectionForNonNextsharesTrades final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:data.LongTradeCorrectionForNonNextsharesTrades) */ {
 public:
  inline LongTradeCorrectionForNonNextsharesTrades() : LongTradeCorrectionForNonNextsharesTrades(nullptr) {}
  ~LongTradeCorrectionForNonNextsharesTrades() override;
  explicit PROTOBUF_CONSTEXPR LongTradeCorrectionForNonNextsharesTrades(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LongTradeCorrectionForNonNextsharesTrades(const LongTradeCorrectionForNonNextsharesTrades& from);
  LongTradeCorrectionForNonNextsharesTrades(LongTradeCorrectionForNonNextsharesTrades&& from) noexcept
    : LongTradeCorrectionForNonNextsharesTrades() {
    *this = ::std::move(from);
  }

  inline LongTradeCorrectionForNonNextsharesTrades& operator=(const LongTradeCorrectionForNonNextsharesTrades& from) {
    CopyFrom(from);
    return *this;
  }
  inline LongTradeCorrectionForNonNextsharesTrades& operator=(LongTradeCorrectionForNonNextsharesTrades&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LongTradeCorrectionForNonNextsharesTrades& default_instance() {
    return *internal_default_instance();
  }
  static inline const LongTradeCorrectionForNonNextsharesTrades* internal_default_instance() {
    return reinterpret_cast<const LongTradeCorrectionForNonNextsharesTrades*>(
               &_LongTradeCorrectionForNonNextsharesTrades_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    56;

  friend void swap(LongTradeCorrectionForNonNextsharesTrades& a, LongTradeCorrectionForNonNextsharesTrades& b) {
    a.Swap(&b);
  }
  inline void Swap(LongTradeCorrectionForNonNextsharesTrades* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LongTradeCorrectionForNonNextsharesTrades* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LongTradeCorrectionForNonNextsharesTrades* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LongTradeCorrectionForNonNextsharesTrades>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LongTradeCorrectionForNonNextsharesTrades& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LongTradeCorrectionForNonNextsharesTrades& from) {
    LongTradeCorrectionForNonNextsharesTrades::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LongTradeCorrectionForNonNextsharesTrades* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "data.LongTradeCorrectionForNonNextsharesTrades";
  }
  protected:
  explicit LongTradeCorrectionForNonNextsharesTrades(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIssueSymbolFieldNumber = 2,
    kOriginalControlNumberFieldNumber = 4,
    kOriginalConditionModifierFieldNumber = 7,
    kCorrectedTradeControlNumberFieldNumber = 8,
    kCorrectedSaleConditionModifierFieldNumber = 11,
    kMarketCenterIdentifierFieldNumber = 1,
    kSecurityClassFieldNumber = 3,
    kOriginalTradePriceFieldNumber = 5,
    kOriginalTradeSizeFieldNumber = 6,
    kCorrectedTradePriceFieldNumber = 9,
    kCorrectedTradeSizeFieldNumber = 10,
    kConsolidatedVolumeFieldNumber = 12,
  };
  // optional string issueSymbol = 2;
  bool has_issuesymbol() const;
  private:
  bool _internal_has_issuesymbol() const;
  public:
  void clear_issuesymbol();
  const std::string& issuesymbol() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_issuesymbol(ArgT0&& arg0, ArgT... args);
  std::string* mutable_issuesymbol();
  PROTOBUF_NODISCARD std::string* release_issuesymbol();
  void set_allocated_issuesymbol(std::string* issuesymbol);
  private:
  const std::string& _internal_issuesymbol() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_issuesymbol(const std::string& value);
  std::string* _internal_mutable_issuesymbol();
  public:

  // optional string originalControlNumber = 4;
  bool has_originalcontrolnumber() const;
  private:
  bool _internal_has_originalcontrolnumber() const;
  public:
  void clear_originalcontrolnumber();
  const std::string& originalcontrolnumber() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_originalcontrolnumber(ArgT0&& arg0, ArgT... args);
  std::string* mutable_originalcontrolnumber();
  PROTOBUF_NODISCARD std::string* release_originalcontrolnumber();
  void set_allocated_originalcontrolnumber(std::string* originalcontrolnumber);
  private:
  const std::string& _internal_originalcontrolnumber() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_originalcontrolnumber(const std::string& value);
  std::string* _internal_mutable_originalcontrolnumber();
  public:

  // optional string originalConditionModifier = 7;
  bool has_originalconditionmodifier() const;
  private:
  bool _internal_has_originalconditionmodifier() const;
  public:
  void clear_originalconditionmodifier();
  const std::string& originalconditionmodifier() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_originalconditionmodifier(ArgT0&& arg0, ArgT... args);
  std::string* mutable_originalconditionmodifier();
  PROTOBUF_NODISCARD std::string* release_originalconditionmodifier();
  void set_allocated_originalconditionmodifier(std::string* originalconditionmodifier);
  private:
  const std::string& _internal_originalconditionmodifier() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_originalconditionmodifier(const std::string& value);
  std::string* _internal_mutable_originalconditionmodifier();
  public:

  // optional string correctedTradeControlNumber = 8;
  bool has_correctedtradecontrolnumber() const;
  private:
  bool _internal_has_correctedtradecontrolnumber() const;
  public:
  void clear_correctedtradecontrolnumber();
  const std::string& correctedtradecontrolnumber() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_correctedtradecontrolnumber(ArgT0&& arg0, ArgT... args);
  std::string* mutable_correctedtradecontrolnumber();
  PROTOBUF_NODISCARD std::string* release_correctedtradecontrolnumber();
  void set_allocated_correctedtradecontrolnumber(std::string* correctedtradecontrolnumber);
  private:
  const std::string& _internal_correctedtradecontrolnumber() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_correctedtradecontrolnumber(const std::string& value);
  std::string* _internal_mutable_correctedtradecontrolnumber();
  public:

  // optional string CorrectedSaleConditionModifier = 11;
  bool has_correctedsaleconditionmodifier() const;
  private:
  bool _internal_has_correctedsaleconditionmodifier() const;
  public:
  void clear_correctedsaleconditionmodifier();
  const std::string& correctedsaleconditionmodifier() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_correctedsaleconditionmodifier(ArgT0&& arg0, ArgT... args);
  std::string* mutable_correctedsaleconditionmodifier();
  PROTOBUF_NODISCARD std::string* release_correctedsaleconditionmodifier();
  void set_allocated_correctedsaleconditionmodifier(std::string* correctedsaleconditionmodifier);
  private:
  const std::string& _internal_correctedsaleconditionmodifier() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_correctedsaleconditionmodifier(const std::string& value);
  std::string* _internal_mutable_correctedsaleconditionmodifier();
  public:

  // optional .data.OriginatingMarketCenterIdentifier marketCenterIdentifier = 1;
  bool has_marketcenteridentifier() const;
  private:
  bool _internal_has_marketcenteridentifier() const;
  public:
  void clear_marketcenteridentifier();
  ::data::OriginatingMarketCenterIdentifier marketcenteridentifier() const;
  void set_marketcenteridentifier(::data::OriginatingMarketCenterIdentifier value);
  private:
  ::data::OriginatingMarketCenterIdentifier _internal_marketcenteridentifier() const;
  void _internal_set_marketcenteridentifier(::data::OriginatingMarketCenterIdentifier value);
  public:

  // optional .data.SecurityClass securityClass = 3;
  bool has_securityclass() const;
  private:
  bool _internal_has_securityclass() const;
  public:
  void clear_securityclass();
  ::data::SecurityClass securityclass() const;
  void set_securityclass(::data::SecurityClass value);
  private:
  ::data::SecurityClass _internal_securityclass() const;
  void _internal_set_securityclass(::data::SecurityClass value);
  public:

  // optional double originalTradePrice = 5;
  bool has_originaltradeprice() const;
  private:
  bool _internal_has_originaltradeprice() const;
  public:
  void clear_originaltradeprice();
  double originaltradeprice() const;
  void set_originaltradeprice(double value);
  private:
  double _internal_originaltradeprice() const;
  void _internal_set_originaltradeprice(double value);
  public:

  // optional int64 originalTradeSize = 6;
  bool has_originaltradesize() const;
  private:
  bool _internal_has_originaltradesize() const;
  public:
  void clear_originaltradesize();
  int64_t originaltradesize() const;
  void set_originaltradesize(int64_t value);
  private:
  int64_t _internal_originaltradesize() const;
  void _internal_set_originaltradesize(int64_t value);
  public:

  // optional double correctedTradePrice = 9;
  bool has_correctedtradeprice() const;
  private:
  bool _internal_has_correctedtradeprice() const;
  public:
  void clear_correctedtradeprice();
  double correctedtradeprice() const;
  void set_correctedtradeprice(double value);
  private:
  double _internal_correctedtradeprice() const;
  void _internal_set_correctedtradeprice(double value);
  public:

  // optional int64 CorrectedTradeSize = 10;
  bool has_correctedtradesize() const;
  private:
  bool _internal_has_correctedtradesize() const;
  public:
  void clear_correctedtradesize();
  int64_t correctedtradesize() const;
  void set_correctedtradesize(int64_t value);
  private:
  int64_t _internal_correctedtradesize() const;
  void _internal_set_correctedtradesize(int64_t value);
  public:

  // optional int64 consolidatedVolume = 12;
  bool has_consolidatedvolume() const;
  private:
  bool _internal_has_consolidatedvolume() const;
  public:
  void clear_consolidatedvolume();
  int64_t consolidatedvolume() const;
  void set_consolidatedvolume(int64_t value);
  private:
  int64_t _internal_consolidatedvolume() const;
  void _internal_set_consolidatedvolume(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:data.LongTradeCorrectionForNonNextsharesTrades)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr issuesymbol_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr originalcontrolnumber_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr originalconditionmodifier_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr correctedtradecontrolnumber_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr correctedsaleconditionmodifier_;
    int marketcenteridentifier_;
    int securityclass_;
    double originaltradeprice_;
    int64_t originaltradesize_;
    double correctedtradeprice_;
    int64_t correctedtradesize_;
    int64_t consolidatedvolume_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_data_2eproto;
};
// -------------------------------------------------------------------

class LongTradeReportForNonNextshares final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:data.LongTradeReportForNonNextshares) */ {
 public:
  inline LongTradeReportForNonNextshares() : LongTradeReportForNonNextshares(nullptr) {}
  ~LongTradeReportForNonNextshares() override;
  explicit PROTOBUF_CONSTEXPR LongTradeReportForNonNextshares(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LongTradeReportForNonNextshares(const LongTradeReportForNonNextshares& from);
  LongTradeReportForNonNextshares(LongTradeReportForNonNextshares&& from) noexcept
    : LongTradeReportForNonNextshares() {
    *this = ::std::move(from);
  }

  inline LongTradeReportForNonNextshares& operator=(const LongTradeReportForNonNextshares& from) {
    CopyFrom(from);
    return *this;
  }
  inline LongTradeReportForNonNextshares& operator=(LongTradeReportForNonNextshares&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LongTradeReportForNonNextshares& default_instance() {
    return *internal_default_instance();
  }
  static inline const LongTradeReportForNonNextshares* internal_default_instance() {
    return reinterpret_cast<const LongTradeReportForNonNextshares*>(
               &_LongTradeReportForNonNextshares_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    57;

  friend void swap(LongTradeReportForNonNextshares& a, LongTradeReportForNonNextshares& b) {
    a.Swap(&b);
  }
  inline void Swap(LongTradeReportForNonNextshares* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LongTradeReportForNonNextshares* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LongTradeReportForNonNextshares* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LongTradeReportForNonNextshares>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LongTradeReportForNonNextshares& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LongTradeReportForNonNextshares& from) {
    LongTradeReportForNonNextshares::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LongTradeReportForNonNextshares* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "data.LongTradeReportForNonNextshares";
  }
  protected:
  explicit LongTradeReportForNonNextshares(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConsolidatedVolumeFieldNumber = 1,
  };
  // optional int64 consolidatedVolume = 1;
  bool has_consolidatedvolume() const;
  private:
  bool _internal_has_consolidatedvolume() const;
  public:
  void clear_consolidatedvolume();
  int64_t consolidatedvolume() const;
  void set_consolidatedvolume(int64_t value);
  private:
  int64_t _internal_consolidatedvolume() const;
  void _internal_set_consolidatedvolume(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:data.LongTradeReportForNonNextshares)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int64_t consolidatedvolume_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_data_2eproto;
};
// -------------------------------------------------------------------

class ReferencePrice final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:data.ReferencePrice) */ {
 public:
  inline ReferencePrice() : ReferencePrice(nullptr) {}
  ~ReferencePrice() override;
  explicit PROTOBUF_CONSTEXPR ReferencePrice(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReferencePrice(const ReferencePrice& from);
  ReferencePrice(ReferencePrice&& from) noexcept
    : ReferencePrice() {
    *this = ::std::move(from);
  }

  inline ReferencePrice& operator=(const ReferencePrice& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReferencePrice& operator=(ReferencePrice&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReferencePrice& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReferencePrice* internal_default_instance() {
    return reinterpret_cast<const ReferencePrice*>(
               &_ReferencePrice_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    58;

  friend void swap(ReferencePrice& a, ReferencePrice& b) {
    a.Swap(&b);
  }
  inline void Swap(ReferencePrice* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReferencePrice* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReferencePrice* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReferencePrice>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReferencePrice& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ReferencePrice& from) {
    ReferencePrice::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReferencePrice* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "data.ReferencePrice";
  }
  protected:
  explicit ReferencePrice(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSecurityCodeFieldNumber = 1,
    kReferencePriceFieldNumber = 2,
    kLowerPriceFieldNumber = 3,
    kUpperPriceFieldNumber = 4,
  };
  // optional int64 securityCode = 1;
  bool has_securitycode() const;
  private:
  bool _internal_has_securitycode() const;
  public:
  void clear_securitycode();
  int64_t securitycode() const;
  void set_securitycode(int64_t value);
  private:
  int64_t _internal_securitycode() const;
  void _internal_set_securitycode(int64_t value);
  public:

  // optional double referencePrice = 2;
  bool has_referenceprice() const;
  private:
  bool _internal_has_referenceprice() const;
  public:
  void clear_referenceprice();
  double referenceprice() const;
  void set_referenceprice(double value);
  private:
  double _internal_referenceprice() const;
  void _internal_set_referenceprice(double value);
  public:

  // optional double lowerPrice = 3;
  bool has_lowerprice() const;
  private:
  bool _internal_has_lowerprice() const;
  public:
  void clear_lowerprice();
  double lowerprice() const;
  void set_lowerprice(double value);
  private:
  double _internal_lowerprice() const;
  void _internal_set_lowerprice(double value);
  public:

  // optional double upperPrice = 4;
  bool has_upperprice() const;
  private:
  bool _internal_has_upperprice() const;
  public:
  void clear_upperprice();
  double upperprice() const;
  void set_upperprice(double value);
  private:
  double _internal_upperprice() const;
  void _internal_set_upperprice(double value);
  public:

  // @@protoc_insertion_point(class_scope:data.ReferencePrice)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int64_t securitycode_;
    double referenceprice_;
    double lowerprice_;
    double upperprice_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_data_2eproto;
};
// -------------------------------------------------------------------

class QBBOIPOQuotingPeriodUpdate final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:data.QBBOIPOQuotingPeriodUpdate) */ {
 public:
  inline QBBOIPOQuotingPeriodUpdate() : QBBOIPOQuotingPeriodUpdate(nullptr) {}
  ~QBBOIPOQuotingPeriodUpdate() override;
  explicit PROTOBUF_CONSTEXPR QBBOIPOQuotingPeriodUpdate(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QBBOIPOQuotingPeriodUpdate(const QBBOIPOQuotingPeriodUpdate& from);
  QBBOIPOQuotingPeriodUpdate(QBBOIPOQuotingPeriodUpdate&& from) noexcept
    : QBBOIPOQuotingPeriodUpdate() {
    *this = ::std::move(from);
  }

  inline QBBOIPOQuotingPeriodUpdate& operator=(const QBBOIPOQuotingPeriodUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  inline QBBOIPOQuotingPeriodUpdate& operator=(QBBOIPOQuotingPeriodUpdate&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QBBOIPOQuotingPeriodUpdate& default_instance() {
    return *internal_default_instance();
  }
  static inline const QBBOIPOQuotingPeriodUpdate* internal_default_instance() {
    return reinterpret_cast<const QBBOIPOQuotingPeriodUpdate*>(
               &_QBBOIPOQuotingPeriodUpdate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    59;

  friend void swap(QBBOIPOQuotingPeriodUpdate& a, QBBOIPOQuotingPeriodUpdate& b) {
    a.Swap(&b);
  }
  inline void Swap(QBBOIPOQuotingPeriodUpdate* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QBBOIPOQuotingPeriodUpdate* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QBBOIPOQuotingPeriodUpdate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QBBOIPOQuotingPeriodUpdate>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QBBOIPOQuotingPeriodUpdate& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QBBOIPOQuotingPeriodUpdate& from) {
    QBBOIPOQuotingPeriodUpdate::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QBBOIPOQuotingPeriodUpdate* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "data.QBBOIPOQuotingPeriodUpdate";
  }
  protected:
  explicit QBBOIPOQuotingPeriodUpdate(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStockFieldNumber = 1,
    kIPOQuotationReleaseTimeFieldNumber = 2,
    kIPOPriceFieldNumber = 4,
    kQuotationReleaseQualifierFieldNumber = 3,
  };
  // optional string stock = 1;
  bool has_stock() const;
  private:
  bool _internal_has_stock() const;
  public:
  void clear_stock();
  const std::string& stock() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_stock(ArgT0&& arg0, ArgT... args);
  std::string* mutable_stock();
  PROTOBUF_NODISCARD std::string* release_stock();
  void set_allocated_stock(std::string* stock);
  private:
  const std::string& _internal_stock() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_stock(const std::string& value);
  std::string* _internal_mutable_stock();
  public:

  // optional int64 iPOQuotationReleaseTime = 2;
  bool has_ipoquotationreleasetime() const;
  private:
  bool _internal_has_ipoquotationreleasetime() const;
  public:
  void clear_ipoquotationreleasetime();
  int64_t ipoquotationreleasetime() const;
  void set_ipoquotationreleasetime(int64_t value);
  private:
  int64_t _internal_ipoquotationreleasetime() const;
  void _internal_set_ipoquotationreleasetime(int64_t value);
  public:

  // optional double iPOPrice = 4;
  bool has_ipoprice() const;
  private:
  bool _internal_has_ipoprice() const;
  public:
  void clear_ipoprice();
  double ipoprice() const;
  void set_ipoprice(double value);
  private:
  double _internal_ipoprice() const;
  void _internal_set_ipoprice(double value);
  public:

  // optional .data.IPOQuotationReleaseQualifier quotationReleaseQualifier = 3;
  bool has_quotationreleasequalifier() const;
  private:
  bool _internal_has_quotationreleasequalifier() const;
  public:
  void clear_quotationreleasequalifier();
  ::data::IPOQuotationReleaseQualifier quotationreleasequalifier() const;
  void set_quotationreleasequalifier(::data::IPOQuotationReleaseQualifier value);
  private:
  ::data::IPOQuotationReleaseQualifier _internal_quotationreleasequalifier() const;
  void _internal_set_quotationreleasequalifier(::data::IPOQuotationReleaseQualifier value);
  public:

  // @@protoc_insertion_point(class_scope:data.QBBOIPOQuotingPeriodUpdate)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr stock_;
    int64_t ipoquotationreleasetime_;
    double ipoprice_;
    int quotationreleasequalifier_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_data_2eproto;
};
// -------------------------------------------------------------------

class SecurityDefinition final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:data.SecurityDefinition) */ {
 public:
  inline SecurityDefinition() : SecurityDefinition(nullptr) {}
  ~SecurityDefinition() override;
  explicit PROTOBUF_CONSTEXPR SecurityDefinition(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SecurityDefinition(const SecurityDefinition& from);
  SecurityDefinition(SecurityDefinition&& from) noexcept
    : SecurityDefinition() {
    *this = ::std::move(from);
  }

  inline SecurityDefinition& operator=(const SecurityDefinition& from) {
    CopyFrom(from);
    return *this;
  }
  inline SecurityDefinition& operator=(SecurityDefinition&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SecurityDefinition& default_instance() {
    return *internal_default_instance();
  }
  static inline const SecurityDefinition* internal_default_instance() {
    return reinterpret_cast<const SecurityDefinition*>(
               &_SecurityDefinition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    60;

  friend void swap(SecurityDefinition& a, SecurityDefinition& b) {
    a.Swap(&b);
  }
  inline void Swap(SecurityDefinition* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SecurityDefinition* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SecurityDefinition* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SecurityDefinition>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SecurityDefinition& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SecurityDefinition& from) {
    SecurityDefinition::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SecurityDefinition* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "data.SecurityDefinition";
  }
  protected:
  explicit SecurityDefinition(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNoUnderlyingSecuritiesFieldNumber = 45,
    kIsinCodeFieldNumber = 3,
    kSecurityShortNameFieldNumber = 7,
    kSecurityNameGCCSFieldNumber = 9,
    kSecurityNameGBFieldNumber = 10,
    kVCMFlagFieldNumber = 13,
    kFreeTextFieldNumber = 21,
    kFaceValueCurrencyFieldNumber = 30,
    kWarrantTypeFieldNumber = 39,
    kSecurityCodeFieldNumber = 1,
    kMarketCodeFieldNumber = 2,
    kInstrumentTypeFieldNumber = 4,
    kProductTypeFieldNumber = 5,
    kSpreadTableCodeFieldNumber = 6,
    kLotSizeFieldNumber = 11,
    kCurrencyCodeFieldNumber = 8,
    kShortSellFlagFieldNumber = 14,
    kPreviousClosingPriceFieldNumber = 12,
    kCasFlagFieldNumber = 15,
    kCCASSFlagFieldNumber = 16,
    kDummySecurityFlagFieldNumber = 17,
    kStampDutyFlagFieldNumber = 18,
    kListingDateFieldNumber = 19,
    kDelistingDateFieldNumber = 20,
    kPosFlagFieldNumber = 22,
    kPosUpperLimitFieldNumber = 23,
    kPosLowerLimitFieldNumber = 24,
    kEFNFlagFieldNumber = 25,
    kAccruedInterestFieldNumber = 26,
    kCouponRateFieldNumber = 27,
    kFaceValueFieldNumber = 28,
    kDecimalsInFaceValueFieldNumber = 29,
    kInvestorTypeFieldNumber = 32,
    kBondMaturityDateFieldNumber = 31,
    kConversionRatioFieldNumber = 33,
    kStrikePrice1FieldNumber = 34,
    kStrikePrice2FieldNumber = 35,
    kWarrantMaturityDateFieldNumber = 36,
    kCallPutFlagFieldNumber = 37,
    kStyleFieldNumber = 38,
    kCallPriceFieldNumber = 40,
    kDecimalsInCallPriceFieldNumber = 41,
    kEntitlementFieldNumber = 42,
    kDecimalsInEntitlementFieldNumber = 43,
    kNoWarrantsPerEntitlementFieldNumber = 44,
  };
  // repeated .data.NoUnderlyingSecurity noUnderlyingSecurities = 45;
  int nounderlyingsecurities_size() const;
  private:
  int _internal_nounderlyingsecurities_size() const;
  public:
  void clear_nounderlyingsecurities();
  ::data::NoUnderlyingSecurity* mutable_nounderlyingsecurities(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::data::NoUnderlyingSecurity >*
      mutable_nounderlyingsecurities();
  private:
  const ::data::NoUnderlyingSecurity& _internal_nounderlyingsecurities(int index) const;
  ::data::NoUnderlyingSecurity* _internal_add_nounderlyingsecurities();
  public:
  const ::data::NoUnderlyingSecurity& nounderlyingsecurities(int index) const;
  ::data::NoUnderlyingSecurity* add_nounderlyingsecurities();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::data::NoUnderlyingSecurity >&
      nounderlyingsecurities() const;

  // optional string isinCode = 3;
  bool has_isincode() const;
  private:
  bool _internal_has_isincode() const;
  public:
  void clear_isincode();
  const std::string& isincode() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_isincode(ArgT0&& arg0, ArgT... args);
  std::string* mutable_isincode();
  PROTOBUF_NODISCARD std::string* release_isincode();
  void set_allocated_isincode(std::string* isincode);
  private:
  const std::string& _internal_isincode() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_isincode(const std::string& value);
  std::string* _internal_mutable_isincode();
  public:

  // optional string securityShortName = 7;
  bool has_securityshortname() const;
  private:
  bool _internal_has_securityshortname() const;
  public:
  void clear_securityshortname();
  const std::string& securityshortname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_securityshortname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_securityshortname();
  PROTOBUF_NODISCARD std::string* release_securityshortname();
  void set_allocated_securityshortname(std::string* securityshortname);
  private:
  const std::string& _internal_securityshortname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_securityshortname(const std::string& value);
  std::string* _internal_mutable_securityshortname();
  public:

  // optional string securityNameGCCS = 9;
  bool has_securitynamegccs() const;
  private:
  bool _internal_has_securitynamegccs() const;
  public:
  void clear_securitynamegccs();
  const std::string& securitynamegccs() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_securitynamegccs(ArgT0&& arg0, ArgT... args);
  std::string* mutable_securitynamegccs();
  PROTOBUF_NODISCARD std::string* release_securitynamegccs();
  void set_allocated_securitynamegccs(std::string* securitynamegccs);
  private:
  const std::string& _internal_securitynamegccs() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_securitynamegccs(const std::string& value);
  std::string* _internal_mutable_securitynamegccs();
  public:

  // optional string securityNameGB = 10;
  bool has_securitynamegb() const;
  private:
  bool _internal_has_securitynamegb() const;
  public:
  void clear_securitynamegb();
  const std::string& securitynamegb() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_securitynamegb(ArgT0&& arg0, ArgT... args);
  std::string* mutable_securitynamegb();
  PROTOBUF_NODISCARD std::string* release_securitynamegb();
  void set_allocated_securitynamegb(std::string* securitynamegb);
  private:
  const std::string& _internal_securitynamegb() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_securitynamegb(const std::string& value);
  std::string* _internal_mutable_securitynamegb();
  public:

  // optional string VCMFlag = 13;
  bool has_vcmflag() const;
  private:
  bool _internal_has_vcmflag() const;
  public:
  void clear_vcmflag();
  const std::string& vcmflag() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_vcmflag(ArgT0&& arg0, ArgT... args);
  std::string* mutable_vcmflag();
  PROTOBUF_NODISCARD std::string* release_vcmflag();
  void set_allocated_vcmflag(std::string* vcmflag);
  private:
  const std::string& _internal_vcmflag() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_vcmflag(const std::string& value);
  std::string* _internal_mutable_vcmflag();
  public:

  // optional string freeText = 21;
  bool has_freetext() const;
  private:
  bool _internal_has_freetext() const;
  public:
  void clear_freetext();
  const std::string& freetext() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_freetext(ArgT0&& arg0, ArgT... args);
  std::string* mutable_freetext();
  PROTOBUF_NODISCARD std::string* release_freetext();
  void set_allocated_freetext(std::string* freetext);
  private:
  const std::string& _internal_freetext() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_freetext(const std::string& value);
  std::string* _internal_mutable_freetext();
  public:

  // optional string faceValueCurrency = 30;
  bool has_facevaluecurrency() const;
  private:
  bool _internal_has_facevaluecurrency() const;
  public:
  void clear_facevaluecurrency();
  const std::string& facevaluecurrency() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_facevaluecurrency(ArgT0&& arg0, ArgT... args);
  std::string* mutable_facevaluecurrency();
  PROTOBUF_NODISCARD std::string* release_facevaluecurrency();
  void set_allocated_facevaluecurrency(std::string* facevaluecurrency);
  private:
  const std::string& _internal_facevaluecurrency() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_facevaluecurrency(const std::string& value);
  std::string* _internal_mutable_facevaluecurrency();
  public:

  // optional string warrantType = 39;
  bool has_warranttype() const;
  private:
  bool _internal_has_warranttype() const;
  public:
  void clear_warranttype();
  const std::string& warranttype() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_warranttype(ArgT0&& arg0, ArgT... args);
  std::string* mutable_warranttype();
  PROTOBUF_NODISCARD std::string* release_warranttype();
  void set_allocated_warranttype(std::string* warranttype);
  private:
  const std::string& _internal_warranttype() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_warranttype(const std::string& value);
  std::string* _internal_mutable_warranttype();
  public:

  // optional int64 securityCode = 1;
  bool has_securitycode() const;
  private:
  bool _internal_has_securitycode() const;
  public:
  void clear_securitycode();
  int64_t securitycode() const;
  void set_securitycode(int64_t value);
  private:
  int64_t _internal_securitycode() const;
  void _internal_set_securitycode(int64_t value);
  public:

  // optional .data.MarketCode marketCode = 2;
  bool has_marketcode() const;
  private:
  bool _internal_has_marketcode() const;
  public:
  void clear_marketcode();
  ::data::MarketCode marketcode() const;
  void set_marketcode(::data::MarketCode value);
  private:
  ::data::MarketCode _internal_marketcode() const;
  void _internal_set_marketcode(::data::MarketCode value);
  public:

  // optional .data.InstrumentType instrumentType = 4;
  bool has_instrumenttype() const;
  private:
  bool _internal_has_instrumenttype() const;
  public:
  void clear_instrumenttype();
  ::data::InstrumentType instrumenttype() const;
  void set_instrumenttype(::data::InstrumentType value);
  private:
  ::data::InstrumentType _internal_instrumenttype() const;
  void _internal_set_instrumenttype(::data::InstrumentType value);
  public:

  // optional .data.ProductType productType = 5;
  bool has_producttype() const;
  private:
  bool _internal_has_producttype() const;
  public:
  void clear_producttype();
  ::data::ProductType producttype() const;
  void set_producttype(::data::ProductType value);
  private:
  ::data::ProductType _internal_producttype() const;
  void _internal_set_producttype(::data::ProductType value);
  public:

  // optional .data.SpreadTableCode spreadTableCode = 6;
  bool has_spreadtablecode() const;
  private:
  bool _internal_has_spreadtablecode() const;
  public:
  void clear_spreadtablecode();
  ::data::SpreadTableCode spreadtablecode() const;
  void set_spreadtablecode(::data::SpreadTableCode value);
  private:
  ::data::SpreadTableCode _internal_spreadtablecode() const;
  void _internal_set_spreadtablecode(::data::SpreadTableCode value);
  public:

  // optional int64 lotSize = 11;
  bool has_lotsize() const;
  private:
  bool _internal_has_lotsize() const;
  public:
  void clear_lotsize();
  int64_t lotsize() const;
  void set_lotsize(int64_t value);
  private:
  int64_t _internal_lotsize() const;
  void _internal_set_lotsize(int64_t value);
  public:

  // optional .data.CurrencyType currencyCode = 8;
  bool has_currencycode() const;
  private:
  bool _internal_has_currencycode() const;
  public:
  void clear_currencycode();
  ::data::CurrencyType currencycode() const;
  void set_currencycode(::data::CurrencyType value);
  private:
  ::data::CurrencyType _internal_currencycode() const;
  void _internal_set_currencycode(::data::CurrencyType value);
  public:

  // optional .data.IndicatesWhether shortSellFlag = 14;
  bool has_shortsellflag() const;
  private:
  bool _internal_has_shortsellflag() const;
  public:
  void clear_shortsellflag();
  ::data::IndicatesWhether shortsellflag() const;
  void set_shortsellflag(::data::IndicatesWhether value);
  private:
  ::data::IndicatesWhether _internal_shortsellflag() const;
  void _internal_set_shortsellflag(::data::IndicatesWhether value);
  public:

  // optional double previousClosingPrice = 12;
  bool has_previousclosingprice() const;
  private:
  bool _internal_has_previousclosingprice() const;
  public:
  void clear_previousclosingprice();
  double previousclosingprice() const;
  void set_previousclosingprice(double value);
  private:
  double _internal_previousclosingprice() const;
  void _internal_set_previousclosingprice(double value);
  public:

  // optional .data.IndicatesWhether casFlag = 15;
  bool has_casflag() const;
  private:
  bool _internal_has_casflag() const;
  public:
  void clear_casflag();
  ::data::IndicatesWhether casflag() const;
  void set_casflag(::data::IndicatesWhether value);
  private:
  ::data::IndicatesWhether _internal_casflag() const;
  void _internal_set_casflag(::data::IndicatesWhether value);
  public:

  // optional .data.IndicatesWhether CCASSFlag = 16;
  bool has_ccassflag() const;
  private:
  bool _internal_has_ccassflag() const;
  public:
  void clear_ccassflag();
  ::data::IndicatesWhether ccassflag() const;
  void set_ccassflag(::data::IndicatesWhether value);
  private:
  ::data::IndicatesWhether _internal_ccassflag() const;
  void _internal_set_ccassflag(::data::IndicatesWhether value);
  public:

  // optional .data.IndicatesWhether dummySecurityFlag = 17;
  bool has_dummysecurityflag() const;
  private:
  bool _internal_has_dummysecurityflag() const;
  public:
  void clear_dummysecurityflag();
  ::data::IndicatesWhether dummysecurityflag() const;
  void set_dummysecurityflag(::data::IndicatesWhether value);
  private:
  ::data::IndicatesWhether _internal_dummysecurityflag() const;
  void _internal_set_dummysecurityflag(::data::IndicatesWhether value);
  public:

  // optional .data.IndicatesWhether stampDutyFlag = 18;
  bool has_stampdutyflag() const;
  private:
  bool _internal_has_stampdutyflag() const;
  public:
  void clear_stampdutyflag();
  ::data::IndicatesWhether stampdutyflag() const;
  void set_stampdutyflag(::data::IndicatesWhether value);
  private:
  ::data::IndicatesWhether _internal_stampdutyflag() const;
  void _internal_set_stampdutyflag(::data::IndicatesWhether value);
  public:

  // optional int64 listingDate = 19;
  bool has_listingdate() const;
  private:
  bool _internal_has_listingdate() const;
  public:
  void clear_listingdate();
  int64_t listingdate() const;
  void set_listingdate(int64_t value);
  private:
  int64_t _internal_listingdate() const;
  void _internal_set_listingdate(int64_t value);
  public:

  // optional int64 delistingDate = 20;
  bool has_delistingdate() const;
  private:
  bool _internal_has_delistingdate() const;
  public:
  void clear_delistingdate();
  int64_t delistingdate() const;
  void set_delistingdate(int64_t value);
  private:
  int64_t _internal_delistingdate() const;
  void _internal_set_delistingdate(int64_t value);
  public:

  // optional .data.IndicatesWhether posFlag = 22;
  bool has_posflag() const;
  private:
  bool _internal_has_posflag() const;
  public:
  void clear_posflag();
  ::data::IndicatesWhether posflag() const;
  void set_posflag(::data::IndicatesWhether value);
  private:
  ::data::IndicatesWhether _internal_posflag() const;
  void _internal_set_posflag(::data::IndicatesWhether value);
  public:

  // optional int32 posUpperLimit = 23;
  bool has_posupperlimit() const;
  private:
  bool _internal_has_posupperlimit() const;
  public:
  void clear_posupperlimit();
  int32_t posupperlimit() const;
  void set_posupperlimit(int32_t value);
  private:
  int32_t _internal_posupperlimit() const;
  void _internal_set_posupperlimit(int32_t value);
  public:

  // optional int32 posLowerLimit = 24;
  bool has_poslowerlimit() const;
  private:
  bool _internal_has_poslowerlimit() const;
  public:
  void clear_poslowerlimit();
  int32_t poslowerlimit() const;
  void set_poslowerlimit(int32_t value);
  private:
  int32_t _internal_poslowerlimit() const;
  void _internal_set_poslowerlimit(int32_t value);
  public:

  // optional .data.IndicatesWhether EFNFlag = 25;
  bool has_efnflag() const;
  private:
  bool _internal_has_efnflag() const;
  public:
  void clear_efnflag();
  ::data::IndicatesWhether efnflag() const;
  void set_efnflag(::data::IndicatesWhether value);
  private:
  ::data::IndicatesWhether _internal_efnflag() const;
  void _internal_set_efnflag(::data::IndicatesWhether value);
  public:

  // optional double accruedInterest = 26;
  bool has_accruedinterest() const;
  private:
  bool _internal_has_accruedinterest() const;
  public:
  void clear_accruedinterest();
  double accruedinterest() const;
  void set_accruedinterest(double value);
  private:
  double _internal_accruedinterest() const;
  void _internal_set_accruedinterest(double value);
  public:

  // optional double couponRate = 27;
  bool has_couponrate() const;
  private:
  bool _internal_has_couponrate() const;
  public:
  void clear_couponrate();
  double couponrate() const;
  void set_couponrate(double value);
  private:
  double _internal_couponrate() const;
  void _internal_set_couponrate(double value);
  public:

  // optional int64 faceValue = 28;
  bool has_facevalue() const;
  private:
  bool _internal_has_facevalue() const;
  public:
  void clear_facevalue();
  int64_t facevalue() const;
  void set_facevalue(int64_t value);
  private:
  int64_t _internal_facevalue() const;
  void _internal_set_facevalue(int64_t value);
  public:

  // optional int32 decimalsInFaceValue = 29;
  bool has_decimalsinfacevalue() const;
  private:
  bool _internal_has_decimalsinfacevalue() const;
  public:
  void clear_decimalsinfacevalue();
  int32_t decimalsinfacevalue() const;
  void set_decimalsinfacevalue(int32_t value);
  private:
  int32_t _internal_decimalsinfacevalue() const;
  void _internal_set_decimalsinfacevalue(int32_t value);
  public:

  // optional .data.InvestorType investorType = 32;
  bool has_investortype() const;
  private:
  bool _internal_has_investortype() const;
  public:
  void clear_investortype();
  ::data::InvestorType investortype() const;
  void set_investortype(::data::InvestorType value);
  private:
  ::data::InvestorType _internal_investortype() const;
  void _internal_set_investortype(::data::InvestorType value);
  public:

  // optional int64 bondMaturityDate = 31;
  bool has_bondmaturitydate() const;
  private:
  bool _internal_has_bondmaturitydate() const;
  public:
  void clear_bondmaturitydate();
  int64_t bondmaturitydate() const;
  void set_bondmaturitydate(int64_t value);
  private:
  int64_t _internal_bondmaturitydate() const;
  void _internal_set_bondmaturitydate(int64_t value);
  public:

  // optional double conversionRatio = 33;
  bool has_conversionratio() const;
  private:
  bool _internal_has_conversionratio() const;
  public:
  void clear_conversionratio();
  double conversionratio() const;
  void set_conversionratio(double value);
  private:
  double _internal_conversionratio() const;
  void _internal_set_conversionratio(double value);
  public:

  // optional double strikePrice1 = 34;
  bool has_strikeprice1() const;
  private:
  bool _internal_has_strikeprice1() const;
  public:
  void clear_strikeprice1();
  double strikeprice1() const;
  void set_strikeprice1(double value);
  private:
  double _internal_strikeprice1() const;
  void _internal_set_strikeprice1(double value);
  public:

  // optional double strikePrice2 = 35;
  bool has_strikeprice2() const;
  private:
  bool _internal_has_strikeprice2() const;
  public:
  void clear_strikeprice2();
  double strikeprice2() const;
  void set_strikeprice2(double value);
  private:
  double _internal_strikeprice2() const;
  void _internal_set_strikeprice2(double value);
  public:

  // optional int64 warrantMaturityDate = 36;
  bool has_warrantmaturitydate() const;
  private:
  bool _internal_has_warrantmaturitydate() const;
  public:
  void clear_warrantmaturitydate();
  int64_t warrantmaturitydate() const;
  void set_warrantmaturitydate(int64_t value);
  private:
  int64_t _internal_warrantmaturitydate() const;
  void _internal_set_warrantmaturitydate(int64_t value);
  public:

  // optional .data.CallPutFlag callPutFlag = 37;
  bool has_callputflag() const;
  private:
  bool _internal_has_callputflag() const;
  public:
  void clear_callputflag();
  ::data::CallPutFlag callputflag() const;
  void set_callputflag(::data::CallPutFlag value);
  private:
  ::data::CallPutFlag _internal_callputflag() const;
  void _internal_set_callputflag(::data::CallPutFlag value);
  public:

  // optional .data.Style style = 38;
  bool has_style() const;
  private:
  bool _internal_has_style() const;
  public:
  void clear_style();
  ::data::Style style() const;
  void set_style(::data::Style value);
  private:
  ::data::Style _internal_style() const;
  void _internal_set_style(::data::Style value);
  public:

  // optional int32 callPrice = 40;
  bool has_callprice() const;
  private:
  bool _internal_has_callprice() const;
  public:
  void clear_callprice();
  int32_t callprice() const;
  void set_callprice(int32_t value);
  private:
  int32_t _internal_callprice() const;
  void _internal_set_callprice(int32_t value);
  public:

  // optional int32 DecimalsInCallPrice = 41;
  bool has_decimalsincallprice() const;
  private:
  bool _internal_has_decimalsincallprice() const;
  public:
  void clear_decimalsincallprice();
  int32_t decimalsincallprice() const;
  void set_decimalsincallprice(int32_t value);
  private:
  int32_t _internal_decimalsincallprice() const;
  void _internal_set_decimalsincallprice(int32_t value);
  public:

  // optional int32 entitlement = 42;
  bool has_entitlement() const;
  private:
  bool _internal_has_entitlement() const;
  public:
  void clear_entitlement();
  int32_t entitlement() const;
  void set_entitlement(int32_t value);
  private:
  int32_t _internal_entitlement() const;
  void _internal_set_entitlement(int32_t value);
  public:

  // optional int32 decimalsInEntitlement = 43;
  bool has_decimalsinentitlement() const;
  private:
  bool _internal_has_decimalsinentitlement() const;
  public:
  void clear_decimalsinentitlement();
  int32_t decimalsinentitlement() const;
  void set_decimalsinentitlement(int32_t value);
  private:
  int32_t _internal_decimalsinentitlement() const;
  void _internal_set_decimalsinentitlement(int32_t value);
  public:

  // optional int64 noWarrantsPerEntitlement = 44;
  bool has_nowarrantsperentitlement() const;
  private:
  bool _internal_has_nowarrantsperentitlement() const;
  public:
  void clear_nowarrantsperentitlement();
  int64_t nowarrantsperentitlement() const;
  void set_nowarrantsperentitlement(int64_t value);
  private:
  int64_t _internal_nowarrantsperentitlement() const;
  void _internal_set_nowarrantsperentitlement(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:data.SecurityDefinition)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<2> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::data::NoUnderlyingSecurity > nounderlyingsecurities_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr isincode_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr securityshortname_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr securitynamegccs_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr securitynamegb_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr vcmflag_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr freetext_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr facevaluecurrency_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr warranttype_;
    int64_t securitycode_;
    int marketcode_;
    int instrumenttype_;
    int producttype_;
    int spreadtablecode_;
    int64_t lotsize_;
    int currencycode_;
    int shortsellflag_;
    double previousclosingprice_;
    int casflag_;
    int ccassflag_;
    int dummysecurityflag_;
    int stampdutyflag_;
    int64_t listingdate_;
    int64_t delistingdate_;
    int posflag_;
    int32_t posupperlimit_;
    int32_t poslowerlimit_;
    int efnflag_;
    double accruedinterest_;
    double couponrate_;
    int64_t facevalue_;
    int32_t decimalsinfacevalue_;
    int investortype_;
    int64_t bondmaturitydate_;
    double conversionratio_;
    double strikeprice1_;
    double strikeprice2_;
    int64_t warrantmaturitydate_;
    int callputflag_;
    int style_;
    int32_t callprice_;
    int32_t decimalsincallprice_;
    int32_t entitlement_;
    int32_t decimalsinentitlement_;
    int64_t nowarrantsperentitlement_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_data_2eproto;
};
// -------------------------------------------------------------------

class SecurityStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:data.SecurityStatus) */ {
 public:
  inline SecurityStatus() : SecurityStatus(nullptr) {}
  ~SecurityStatus() override;
  explicit PROTOBUF_CONSTEXPR SecurityStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SecurityStatus(const SecurityStatus& from);
  SecurityStatus(SecurityStatus&& from) noexcept
    : SecurityStatus() {
    *this = ::std::move(from);
  }

  inline SecurityStatus& operator=(const SecurityStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline SecurityStatus& operator=(SecurityStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SecurityStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const SecurityStatus* internal_default_instance() {
    return reinterpret_cast<const SecurityStatus*>(
               &_SecurityStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    61;

  friend void swap(SecurityStatus& a, SecurityStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(SecurityStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SecurityStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SecurityStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SecurityStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SecurityStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SecurityStatus& from) {
    SecurityStatus::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SecurityStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "data.SecurityStatus";
  }
  protected:
  explicit SecurityStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSecurityCodeFieldNumber = 1,
    kSuspensionIndicatorFieldNumber = 2,
  };
  // optional int64 securityCode = 1;
  bool has_securitycode() const;
  private:
  bool _internal_has_securitycode() const;
  public:
  void clear_securitycode();
  int64_t securitycode() const;
  void set_securitycode(int64_t value);
  private:
  int64_t _internal_securitycode() const;
  void _internal_set_securitycode(int64_t value);
  public:

  // optional .data.SuspensionIndicator suspensionIndicator = 2;
  bool has_suspensionindicator() const;
  private:
  bool _internal_has_suspensionindicator() const;
  public:
  void clear_suspensionindicator();
  ::data::SuspensionIndicator suspensionindicator() const;
  void set_suspensionindicator(::data::SuspensionIndicator value);
  private:
  ::data::SuspensionIndicator _internal_suspensionindicator() const;
  void _internal_set_suspensionindicator(::data::SuspensionIndicator value);
  public:

  // @@protoc_insertion_point(class_scope:data.SecurityStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int64_t securitycode_;
    int suspensionindicator_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_data_2eproto;
};
// -------------------------------------------------------------------

class Statistics final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:data.Statistics) */ {
 public:
  inline Statistics() : Statistics(nullptr) {}
  ~Statistics() override;
  explicit PROTOBUF_CONSTEXPR Statistics(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Statistics(const Statistics& from);
  Statistics(Statistics&& from) noexcept
    : Statistics() {
    *this = ::std::move(from);
  }

  inline Statistics& operator=(const Statistics& from) {
    CopyFrom(from);
    return *this;
  }
  inline Statistics& operator=(Statistics&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Statistics& default_instance() {
    return *internal_default_instance();
  }
  static inline const Statistics* internal_default_instance() {
    return reinterpret_cast<const Statistics*>(
               &_Statistics_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    62;

  friend void swap(Statistics& a, Statistics& b) {
    a.Swap(&b);
  }
  inline void Swap(Statistics* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Statistics* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Statistics* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Statistics>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Statistics& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Statistics& from) {
    Statistics::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Statistics* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "data.Statistics";
  }
  protected:
  explicit Statistics(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSecurityCodeFieldNumber = 1,
    kSharesTradedFieldNumber = 2,
    kVCMReferencePriceFieldNumber = 3,
    kHighPriceFieldNumber = 4,
    kLowPriceFieldNumber = 5,
    kLastPriceFieldNumber = 6,
    kVwapFieldNumber = 7,
    kShortSellSharesTradedFieldNumber = 8,
    kShortSellTurnoverFieldNumber = 9,
  };
  // optional int64 securityCode = 1;
  bool has_securitycode() const;
  private:
  bool _internal_has_securitycode() const;
  public:
  void clear_securitycode();
  int64_t securitycode() const;
  void set_securitycode(int64_t value);
  private:
  int64_t _internal_securitycode() const;
  void _internal_set_securitycode(int64_t value);
  public:

  // optional int64 sharesTraded = 2;
  bool has_sharestraded() const;
  private:
  bool _internal_has_sharestraded() const;
  public:
  void clear_sharestraded();
  int64_t sharestraded() const;
  void set_sharestraded(int64_t value);
  private:
  int64_t _internal_sharestraded() const;
  void _internal_set_sharestraded(int64_t value);
  public:

  // optional double vCMReferencePrice = 3;
  bool has_vcmreferenceprice() const;
  private:
  bool _internal_has_vcmreferenceprice() const;
  public:
  void clear_vcmreferenceprice();
  double vcmreferenceprice() const;
  void set_vcmreferenceprice(double value);
  private:
  double _internal_vcmreferenceprice() const;
  void _internal_set_vcmreferenceprice(double value);
  public:

  // optional double highPrice = 4;
  bool has_highprice() const;
  private:
  bool _internal_has_highprice() const;
  public:
  void clear_highprice();
  double highprice() const;
  void set_highprice(double value);
  private:
  double _internal_highprice() const;
  void _internal_set_highprice(double value);
  public:

  // optional double lowPrice = 5;
  bool has_lowprice() const;
  private:
  bool _internal_has_lowprice() const;
  public:
  void clear_lowprice();
  double lowprice() const;
  void set_lowprice(double value);
  private:
  double _internal_lowprice() const;
  void _internal_set_lowprice(double value);
  public:

  // optional double lastPrice = 6;
  bool has_lastprice() const;
  private:
  bool _internal_has_lastprice() const;
  public:
  void clear_lastprice();
  double lastprice() const;
  void set_lastprice(double value);
  private:
  double _internal_lastprice() const;
  void _internal_set_lastprice(double value);
  public:

  // optional double vwap = 7;
  bool has_vwap() const;
  private:
  bool _internal_has_vwap() const;
  public:
  void clear_vwap();
  double vwap() const;
  void set_vwap(double value);
  private:
  double _internal_vwap() const;
  void _internal_set_vwap(double value);
  public:

  // optional int64 shortSellSharesTraded = 8;
  bool has_shortsellsharestraded() const;
  private:
  bool _internal_has_shortsellsharestraded() const;
  public:
  void clear_shortsellsharestraded();
  int64_t shortsellsharestraded() const;
  void set_shortsellsharestraded(int64_t value);
  private:
  int64_t _internal_shortsellsharestraded() const;
  void _internal_set_shortsellsharestraded(int64_t value);
  public:

  // optional double shortSellTurnover = 9;
  bool has_shortsellturnover() const;
  private:
  bool _internal_has_shortsellturnover() const;
  public:
  void clear_shortsellturnover();
  double shortsellturnover() const;
  void set_shortsellturnover(double value);
  private:
  double _internal_shortsellturnover() const;
  void _internal_set_shortsellturnover(double value);
  public:

  // @@protoc_insertion_point(class_scope:data.Statistics)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int64_t securitycode_;
    int64_t sharestraded_;
    double vcmreferenceprice_;
    double highprice_;
    double lowprice_;
    double lastprice_;
    double vwap_;
    int64_t shortsellsharestraded_;
    double shortsellturnover_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_data_2eproto;
};
// -------------------------------------------------------------------

class StockConnectDailyQuotaBalance final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:data.StockConnectDailyQuotaBalance) */ {
 public:
  inline StockConnectDailyQuotaBalance() : StockConnectDailyQuotaBalance(nullptr) {}
  ~StockConnectDailyQuotaBalance() override;
  explicit PROTOBUF_CONSTEXPR StockConnectDailyQuotaBalance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StockConnectDailyQuotaBalance(const StockConnectDailyQuotaBalance& from);
  StockConnectDailyQuotaBalance(StockConnectDailyQuotaBalance&& from) noexcept
    : StockConnectDailyQuotaBalance() {
    *this = ::std::move(from);
  }

  inline StockConnectDailyQuotaBalance& operator=(const StockConnectDailyQuotaBalance& from) {
    CopyFrom(from);
    return *this;
  }
  inline StockConnectDailyQuotaBalance& operator=(StockConnectDailyQuotaBalance&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StockConnectDailyQuotaBalance& default_instance() {
    return *internal_default_instance();
  }
  static inline const StockConnectDailyQuotaBalance* internal_default_instance() {
    return reinterpret_cast<const StockConnectDailyQuotaBalance*>(
               &_StockConnectDailyQuotaBalance_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    63;

  friend void swap(StockConnectDailyQuotaBalance& a, StockConnectDailyQuotaBalance& b) {
    a.Swap(&b);
  }
  inline void Swap(StockConnectDailyQuotaBalance* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StockConnectDailyQuotaBalance* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StockConnectDailyQuotaBalance* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StockConnectDailyQuotaBalance>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StockConnectDailyQuotaBalance& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StockConnectDailyQuotaBalance& from) {
    StockConnectDailyQuotaBalance::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StockConnectDailyQuotaBalance* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "data.StockConnectDailyQuotaBalance";
  }
  protected:
  explicit StockConnectDailyQuotaBalance(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStockConnectMarketFieldNumber = 1,
    kTradingDirectionFieldNumber = 2,
    kDailyQuotaBalanceFieldNumber = 3,
    kDailyQuotaBalanceTimeFieldNumber = 4,
  };
  // optional string stockConnectMarket = 1;
  bool has_stockconnectmarket() const;
  private:
  bool _internal_has_stockconnectmarket() const;
  public:
  void clear_stockconnectmarket();
  const std::string& stockconnectmarket() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_stockconnectmarket(ArgT0&& arg0, ArgT... args);
  std::string* mutable_stockconnectmarket();
  PROTOBUF_NODISCARD std::string* release_stockconnectmarket();
  void set_allocated_stockconnectmarket(std::string* stockconnectmarket);
  private:
  const std::string& _internal_stockconnectmarket() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_stockconnectmarket(const std::string& value);
  std::string* _internal_mutable_stockconnectmarket();
  public:

  // optional string tradingDirection = 2;
  bool has_tradingdirection() const;
  private:
  bool _internal_has_tradingdirection() const;
  public:
  void clear_tradingdirection();
  const std::string& tradingdirection() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tradingdirection(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tradingdirection();
  PROTOBUF_NODISCARD std::string* release_tradingdirection();
  void set_allocated_tradingdirection(std::string* tradingdirection);
  private:
  const std::string& _internal_tradingdirection() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tradingdirection(const std::string& value);
  std::string* _internal_mutable_tradingdirection();
  public:

  // optional int64 dailyQuotaBalance = 3;
  bool has_dailyquotabalance() const;
  private:
  bool _internal_has_dailyquotabalance() const;
  public:
  void clear_dailyquotabalance();
  int64_t dailyquotabalance() const;
  void set_dailyquotabalance(int64_t value);
  private:
  int64_t _internal_dailyquotabalance() const;
  void _internal_set_dailyquotabalance(int64_t value);
  public:

  // optional int64 dailyQuotaBalanceTime = 4;
  bool has_dailyquotabalancetime() const;
  private:
  bool _internal_has_dailyquotabalancetime() const;
  public:
  void clear_dailyquotabalancetime();
  int64_t dailyquotabalancetime() const;
  void set_dailyquotabalancetime(int64_t value);
  private:
  int64_t _internal_dailyquotabalancetime() const;
  void _internal_set_dailyquotabalancetime(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:data.StockConnectDailyQuotaBalance)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr stockconnectmarket_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tradingdirection_;
    int64_t dailyquotabalance_;
    int64_t dailyquotabalancetime_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_data_2eproto;
};
// -------------------------------------------------------------------

class StockConnectMarketTurnover final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:data.StockConnectMarketTurnover) */ {
 public:
  inline StockConnectMarketTurnover() : StockConnectMarketTurnover(nullptr) {}
  ~StockConnectMarketTurnover() override;
  explicit PROTOBUF_CONSTEXPR StockConnectMarketTurnover(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StockConnectMarketTurnover(const StockConnectMarketTurnover& from);
  StockConnectMarketTurnover(StockConnectMarketTurnover&& from) noexcept
    : StockConnectMarketTurnover() {
    *this = ::std::move(from);
  }

  inline StockConnectMarketTurnover& operator=(const StockConnectMarketTurnover& from) {
    CopyFrom(from);
    return *this;
  }
  inline StockConnectMarketTurnover& operator=(StockConnectMarketTurnover&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StockConnectMarketTurnover& default_instance() {
    return *internal_default_instance();
  }
  static inline const StockConnectMarketTurnover* internal_default_instance() {
    return reinterpret_cast<const StockConnectMarketTurnover*>(
               &_StockConnectMarketTurnover_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    64;

  friend void swap(StockConnectMarketTurnover& a, StockConnectMarketTurnover& b) {
    a.Swap(&b);
  }
  inline void Swap(StockConnectMarketTurnover* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StockConnectMarketTurnover* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StockConnectMarketTurnover* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StockConnectMarketTurnover>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StockConnectMarketTurnover& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StockConnectMarketTurnover& from) {
    StockConnectMarketTurnover::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StockConnectMarketTurnover* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "data.StockConnectMarketTurnover";
  }
  protected:
  explicit StockConnectMarketTurnover(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStockConnectMarketFieldNumber = 1,
    kTradingDirectionFieldNumber = 2,
    kBuyTurnoverFieldNumber = 3,
    kSellTurnoverFieldNumber = 4,
    kBuySellTurnoverFieldNumber = 5,
  };
  // optional string stockConnectMarket = 1;
  bool has_stockconnectmarket() const;
  private:
  bool _internal_has_stockconnectmarket() const;
  public:
  void clear_stockconnectmarket();
  const std::string& stockconnectmarket() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_stockconnectmarket(ArgT0&& arg0, ArgT... args);
  std::string* mutable_stockconnectmarket();
  PROTOBUF_NODISCARD std::string* release_stockconnectmarket();
  void set_allocated_stockconnectmarket(std::string* stockconnectmarket);
  private:
  const std::string& _internal_stockconnectmarket() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_stockconnectmarket(const std::string& value);
  std::string* _internal_mutable_stockconnectmarket();
  public:

  // optional string tradingDirection = 2;
  bool has_tradingdirection() const;
  private:
  bool _internal_has_tradingdirection() const;
  public:
  void clear_tradingdirection();
  const std::string& tradingdirection() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tradingdirection(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tradingdirection();
  PROTOBUF_NODISCARD std::string* release_tradingdirection();
  void set_allocated_tradingdirection(std::string* tradingdirection);
  private:
  const std::string& _internal_tradingdirection() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tradingdirection(const std::string& value);
  std::string* _internal_mutable_tradingdirection();
  public:

  // optional int64 buyTurnover = 3;
  bool has_buyturnover() const;
  private:
  bool _internal_has_buyturnover() const;
  public:
  void clear_buyturnover();
  int64_t buyturnover() const;
  void set_buyturnover(int64_t value);
  private:
  int64_t _internal_buyturnover() const;
  void _internal_set_buyturnover(int64_t value);
  public:

  // optional int64 sellTurnover = 4;
  bool has_sellturnover() const;
  private:
  bool _internal_has_sellturnover() const;
  public:
  void clear_sellturnover();
  int64_t sellturnover() const;
  void set_sellturnover(int64_t value);
  private:
  int64_t _internal_sellturnover() const;
  void _internal_set_sellturnover(int64_t value);
  public:

  // optional int64 buySellTurnover = 5;
  bool has_buysellturnover() const;
  private:
  bool _internal_has_buysellturnover() const;
  public:
  void clear_buysellturnover();
  int64_t buysellturnover() const;
  void set_buysellturnover(int64_t value);
  private:
  int64_t _internal_buysellturnover() const;
  void _internal_set_buysellturnover(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:data.StockConnectMarketTurnover)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr stockconnectmarket_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tradingdirection_;
    int64_t buyturnover_;
    int64_t sellturnover_;
    int64_t buysellturnover_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_data_2eproto;
};
// -------------------------------------------------------------------

class Trade final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:data.Trade) */ {
 public:
  inline Trade() : Trade(nullptr) {}
  ~Trade() override;
  explicit PROTOBUF_CONSTEXPR Trade(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Trade(const Trade& from);
  Trade(Trade&& from) noexcept
    : Trade() {
    *this = ::std::move(from);
  }

  inline Trade& operator=(const Trade& from) {
    CopyFrom(from);
    return *this;
  }
  inline Trade& operator=(Trade&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Trade& default_instance() {
    return *internal_default_instance();
  }
  static inline const Trade* internal_default_instance() {
    return reinterpret_cast<const Trade*>(
               &_Trade_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    65;

  friend void swap(Trade& a, Trade& b) {
    a.Swap(&b);
  }
  inline void Swap(Trade* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Trade* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Trade* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Trade>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Trade& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Trade& from) {
    Trade::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Trade* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "data.Trade";
  }
  protected:
  explicit Trade(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSecurityCodeFieldNumber = 1,
    kTradeIdFieldNumber = 2,
    kPriceFieldNumber = 3,
    kQuantityFieldNumber = 4,
    kTradeTimeFieldNumber = 6,
    kTrdTypeFieldNumber = 5,
  };
  // optional int64 securityCode = 1;
  bool has_securitycode() const;
  private:
  bool _internal_has_securitycode() const;
  public:
  void clear_securitycode();
  int64_t securitycode() const;
  void set_securitycode(int64_t value);
  private:
  int64_t _internal_securitycode() const;
  void _internal_set_securitycode(int64_t value);
  public:

  // optional int64 tradeId = 2;
  bool has_tradeid() const;
  private:
  bool _internal_has_tradeid() const;
  public:
  void clear_tradeid();
  int64_t tradeid() const;
  void set_tradeid(int64_t value);
  private:
  int64_t _internal_tradeid() const;
  void _internal_set_tradeid(int64_t value);
  public:

  // optional double price = 3;
  bool has_price() const;
  private:
  bool _internal_has_price() const;
  public:
  void clear_price();
  double price() const;
  void set_price(double value);
  private:
  double _internal_price() const;
  void _internal_set_price(double value);
  public:

  // optional int64 quantity = 4;
  bool has_quantity() const;
  private:
  bool _internal_has_quantity() const;
  public:
  void clear_quantity();
  int64_t quantity() const;
  void set_quantity(int64_t value);
  private:
  int64_t _internal_quantity() const;
  void _internal_set_quantity(int64_t value);
  public:

  // optional int64 TradeTime = 6;
  bool has_tradetime() const;
  private:
  bool _internal_has_tradetime() const;
  public:
  void clear_tradetime();
  int64_t tradetime() const;
  void set_tradetime(int64_t value);
  private:
  int64_t _internal_tradetime() const;
  void _internal_set_tradetime(int64_t value);
  public:

  // optional .data.TrdType trdType = 5;
  bool has_trdtype() const;
  private:
  bool _internal_has_trdtype() const;
  public:
  void clear_trdtype();
  ::data::TrdType trdtype() const;
  void set_trdtype(::data::TrdType value);
  private:
  ::data::TrdType _internal_trdtype() const;
  void _internal_set_trdtype(::data::TrdType value);
  public:

  // @@protoc_insertion_point(class_scope:data.Trade)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int64_t securitycode_;
    int64_t tradeid_;
    double price_;
    int64_t quantity_;
    int64_t tradetime_;
    int trdtype_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_data_2eproto;
};
// -------------------------------------------------------------------

class TradeCancel final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:data.TradeCancel) */ {
 public:
  inline TradeCancel() : TradeCancel(nullptr) {}
  ~TradeCancel() override;
  explicit PROTOBUF_CONSTEXPR TradeCancel(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TradeCancel(const TradeCancel& from);
  TradeCancel(TradeCancel&& from) noexcept
    : TradeCancel() {
    *this = ::std::move(from);
  }

  inline TradeCancel& operator=(const TradeCancel& from) {
    CopyFrom(from);
    return *this;
  }
  inline TradeCancel& operator=(TradeCancel&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TradeCancel& default_instance() {
    return *internal_default_instance();
  }
  static inline const TradeCancel* internal_default_instance() {
    return reinterpret_cast<const TradeCancel*>(
               &_TradeCancel_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    66;

  friend void swap(TradeCancel& a, TradeCancel& b) {
    a.Swap(&b);
  }
  inline void Swap(TradeCancel* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TradeCancel* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TradeCancel* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TradeCancel>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TradeCancel& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TradeCancel& from) {
    TradeCancel::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TradeCancel* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "data.TradeCancel";
  }
  protected:
  explicit TradeCancel(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSecurityCodeFieldNumber = 1,
    kTradeIdFieldNumber = 2,
  };
  // optional int64 securityCode = 1;
  bool has_securitycode() const;
  private:
  bool _internal_has_securitycode() const;
  public:
  void clear_securitycode();
  int64_t securitycode() const;
  void set_securitycode(int64_t value);
  private:
  int64_t _internal_securitycode() const;
  void _internal_set_securitycode(int64_t value);
  public:

  // optional int64 tradeId = 2;
  bool has_tradeid() const;
  private:
  bool _internal_has_tradeid() const;
  public:
  void clear_tradeid();
  int64_t tradeid() const;
  void set_tradeid(int64_t value);
  private:
  int64_t _internal_tradeid() const;
  void _internal_set_tradeid(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:data.TradeCancel)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int64_t securitycode_;
    int64_t tradeid_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_data_2eproto;
};
// -------------------------------------------------------------------

class TradingSessionStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:data.TradingSessionStatus) */ {
 public:
  inline TradingSessionStatus() : TradingSessionStatus(nullptr) {}
  ~TradingSessionStatus() override;
  explicit PROTOBUF_CONSTEXPR TradingSessionStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TradingSessionStatus(const TradingSessionStatus& from);
  TradingSessionStatus(TradingSessionStatus&& from) noexcept
    : TradingSessionStatus() {
    *this = ::std::move(from);
  }

  inline TradingSessionStatus& operator=(const TradingSessionStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline TradingSessionStatus& operator=(TradingSessionStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TradingSessionStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const TradingSessionStatus* internal_default_instance() {
    return reinterpret_cast<const TradingSessionStatus*>(
               &_TradingSessionStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    67;

  friend void swap(TradingSessionStatus& a, TradingSessionStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(TradingSessionStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TradingSessionStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TradingSessionStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TradingSessionStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TradingSessionStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TradingSessionStatus& from) {
    TradingSessionStatus::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TradingSessionStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "data.TradingSessionStatus";
  }
  protected:
  explicit TradingSessionStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMarketCodeFieldNumber = 1,
    kTradingSessionSubIDFieldNumber = 2,
    kTradingSesStatusFieldNumber = 3,
    kTradingSesControlFlagFieldNumber = 4,
    kStartDateTimeFieldNumber = 5,
    kEndDateTimeFieldNumber = 6,
  };
  // optional .data.MarketCode marketCode = 1;
  bool has_marketcode() const;
  private:
  bool _internal_has_marketcode() const;
  public:
  void clear_marketcode();
  ::data::MarketCode marketcode() const;
  void set_marketcode(::data::MarketCode value);
  private:
  ::data::MarketCode _internal_marketcode() const;
  void _internal_set_marketcode(::data::MarketCode value);
  public:

  // optional .data.TradingSessionSubID tradingSessionSubID = 2;
  bool has_tradingsessionsubid() const;
  private:
  bool _internal_has_tradingsessionsubid() const;
  public:
  void clear_tradingsessionsubid();
  ::data::TradingSessionSubID tradingsessionsubid() const;
  void set_tradingsessionsubid(::data::TradingSessionSubID value);
  private:
  ::data::TradingSessionSubID _internal_tradingsessionsubid() const;
  void _internal_set_tradingsessionsubid(::data::TradingSessionSubID value);
  public:

  // optional .data.TradingSesStatus tradingSesStatus = 3;
  bool has_tradingsesstatus() const;
  private:
  bool _internal_has_tradingsesstatus() const;
  public:
  void clear_tradingsesstatus();
  ::data::TradingSesStatus tradingsesstatus() const;
  void set_tradingsesstatus(::data::TradingSesStatus value);
  private:
  ::data::TradingSesStatus _internal_tradingsesstatus() const;
  void _internal_set_tradingsesstatus(::data::TradingSesStatus value);
  public:

  // optional .data.TradingSesControlType TradingSesControlFlag = 4;
  bool has_tradingsescontrolflag() const;
  private:
  bool _internal_has_tradingsescontrolflag() const;
  public:
  void clear_tradingsescontrolflag();
  ::data::TradingSesControlType tradingsescontrolflag() const;
  void set_tradingsescontrolflag(::data::TradingSesControlType value);
  private:
  ::data::TradingSesControlType _internal_tradingsescontrolflag() const;
  void _internal_set_tradingsescontrolflag(::data::TradingSesControlType value);
  public:

  // optional int64 startDateTime = 5;
  bool has_startdatetime() const;
  private:
  bool _internal_has_startdatetime() const;
  public:
  void clear_startdatetime();
  int64_t startdatetime() const;
  void set_startdatetime(int64_t value);
  private:
  int64_t _internal_startdatetime() const;
  void _internal_set_startdatetime(int64_t value);
  public:

  // optional int64 endDateTime = 6;
  bool has_enddatetime() const;
  private:
  bool _internal_has_enddatetime() const;
  public:
  void clear_enddatetime();
  int64_t enddatetime() const;
  void set_enddatetime(int64_t value);
  private:
  int64_t _internal_enddatetime() const;
  void _internal_set_enddatetime(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:data.TradingSessionStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int marketcode_;
    int tradingsessionsubid_;
    int tradingsesstatus_;
    int tradingsescontrolflag_;
    int64_t startdatetime_;
    int64_t enddatetime_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_data_2eproto;
};
// -------------------------------------------------------------------

class VCMTrigger final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:data.VCMTrigger) */ {
 public:
  inline VCMTrigger() : VCMTrigger(nullptr) {}
  ~VCMTrigger() override;
  explicit PROTOBUF_CONSTEXPR VCMTrigger(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VCMTrigger(const VCMTrigger& from);
  VCMTrigger(VCMTrigger&& from) noexcept
    : VCMTrigger() {
    *this = ::std::move(from);
  }

  inline VCMTrigger& operator=(const VCMTrigger& from) {
    CopyFrom(from);
    return *this;
  }
  inline VCMTrigger& operator=(VCMTrigger&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VCMTrigger& default_instance() {
    return *internal_default_instance();
  }
  static inline const VCMTrigger* internal_default_instance() {
    return reinterpret_cast<const VCMTrigger*>(
               &_VCMTrigger_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    68;

  friend void swap(VCMTrigger& a, VCMTrigger& b) {
    a.Swap(&b);
  }
  inline void Swap(VCMTrigger* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VCMTrigger* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VCMTrigger* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VCMTrigger>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VCMTrigger& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const VCMTrigger& from) {
    VCMTrigger::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VCMTrigger* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "data.VCMTrigger";
  }
  protected:
  explicit VCMTrigger(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSecurityCodeFieldNumber = 1,
    kCoolingOffStartTimeFieldNumber = 2,
    kCoolingOffEndTimeFieldNumber = 3,
    kVCMReferencePriceFieldNumber = 4,
    kVCMLowerPriceFieldNumber = 5,
    kVCMUpperPriceFieldNumber = 6,
  };
  // optional int64 securityCode = 1;
  bool has_securitycode() const;
  private:
  bool _internal_has_securitycode() const;
  public:
  void clear_securitycode();
  int64_t securitycode() const;
  void set_securitycode(int64_t value);
  private:
  int64_t _internal_securitycode() const;
  void _internal_set_securitycode(int64_t value);
  public:

  // optional int64 coolingOffStartTime = 2;
  bool has_coolingoffstarttime() const;
  private:
  bool _internal_has_coolingoffstarttime() const;
  public:
  void clear_coolingoffstarttime();
  int64_t coolingoffstarttime() const;
  void set_coolingoffstarttime(int64_t value);
  private:
  int64_t _internal_coolingoffstarttime() const;
  void _internal_set_coolingoffstarttime(int64_t value);
  public:

  // optional int64 coolingOffEndTime = 3;
  bool has_coolingoffendtime() const;
  private:
  bool _internal_has_coolingoffendtime() const;
  public:
  void clear_coolingoffendtime();
  int64_t coolingoffendtime() const;
  void set_coolingoffendtime(int64_t value);
  private:
  int64_t _internal_coolingoffendtime() const;
  void _internal_set_coolingoffendtime(int64_t value);
  public:

  // optional double vCMReferencePrice = 4;
  bool has_vcmreferenceprice() const;
  private:
  bool _internal_has_vcmreferenceprice() const;
  public:
  void clear_vcmreferenceprice();
  double vcmreferenceprice() const;
  void set_vcmreferenceprice(double value);
  private:
  double _internal_vcmreferenceprice() const;
  void _internal_set_vcmreferenceprice(double value);
  public:

  // optional double vCMLowerPrice = 5;
  bool has_vcmlowerprice() const;
  private:
  bool _internal_has_vcmlowerprice() const;
  public:
  void clear_vcmlowerprice();
  double vcmlowerprice() const;
  void set_vcmlowerprice(double value);
  private:
  double _internal_vcmlowerprice() const;
  void _internal_set_vcmlowerprice(double value);
  public:

  // optional double vCMUpperPrice = 6;
  bool has_vcmupperprice() const;
  private:
  bool _internal_has_vcmupperprice() const;
  public:
  void clear_vcmupperprice();
  double vcmupperprice() const;
  void set_vcmupperprice(double value);
  private:
  double _internal_vcmupperprice() const;
  void _internal_set_vcmupperprice(double value);
  public:

  // @@protoc_insertion_point(class_scope:data.VCMTrigger)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int64_t securitycode_;
    int64_t coolingoffstarttime_;
    int64_t coolingoffendtime_;
    double vcmreferenceprice_;
    double vcmlowerprice_;
    double vcmupperprice_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_data_2eproto;
};
// -------------------------------------------------------------------

class Yield final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:data.Yield) */ {
 public:
  inline Yield() : Yield(nullptr) {}
  ~Yield() override;
  explicit PROTOBUF_CONSTEXPR Yield(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Yield(const Yield& from);
  Yield(Yield&& from) noexcept
    : Yield() {
    *this = ::std::move(from);
  }

  inline Yield& operator=(const Yield& from) {
    CopyFrom(from);
    return *this;
  }
  inline Yield& operator=(Yield&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Yield& default_instance() {
    return *internal_default_instance();
  }
  static inline const Yield* internal_default_instance() {
    return reinterpret_cast<const Yield*>(
               &_Yield_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    69;

  friend void swap(Yield& a, Yield& b) {
    a.Swap(&b);
  }
  inline void Swap(Yield* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Yield* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Yield* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Yield>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Yield& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Yield& from) {
    Yield::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Yield* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "data.Yield";
  }
  protected:
  explicit Yield(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSecurityCodeFieldNumber = 1,
    kYieldFieldNumber = 2,
  };
  // optional int64 securityCode = 1;
  bool has_securitycode() const;
  private:
  bool _internal_has_securitycode() const;
  public:
  void clear_securitycode();
  int64_t securitycode() const;
  void set_securitycode(int64_t value);
  private:
  int64_t _internal_securitycode() const;
  void _internal_set_securitycode(int64_t value);
  public:

  // optional int32 yield = 2;
  bool has_yield() const;
  private:
  bool _internal_has_yield() const;
  public:
  void clear_yield();
  int32_t yield() const;
  void set_yield(int32_t value);
  private:
  int32_t _internal_yield() const;
  void _internal_set_yield(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:data.Yield)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int64_t securitycode_;
    int32_t yield_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_data_2eproto;
};
// -------------------------------------------------------------------

class CNMarketDefinition final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:data.CNMarketDefinition) */ {
 public:
  inline CNMarketDefinition() : CNMarketDefinition(nullptr) {}
  ~CNMarketDefinition() override;
  explicit PROTOBUF_CONSTEXPR CNMarketDefinition(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CNMarketDefinition(const CNMarketDefinition& from);
  CNMarketDefinition(CNMarketDefinition&& from) noexcept
    : CNMarketDefinition() {
    *this = ::std::move(from);
  }

  inline CNMarketDefinition& operator=(const CNMarketDefinition& from) {
    CopyFrom(from);
    return *this;
  }
  inline CNMarketDefinition& operator=(CNMarketDefinition&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CNMarketDefinition& default_instance() {
    return *internal_default_instance();
  }
  static inline const CNMarketDefinition* internal_default_instance() {
    return reinterpret_cast<const CNMarketDefinition*>(
               &_CNMarketDefinition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    70;

  friend void swap(CNMarketDefinition& a, CNMarketDefinition& b) {
    a.Swap(&b);
  }
  inline void Swap(CNMarketDefinition* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CNMarketDefinition* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CNMarketDefinition* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CNMarketDefinition>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CNMarketDefinition& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CNMarketDefinition& from) {
    CNMarketDefinition::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CNMarketDefinition* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "data.CNMarketDefinition";
  }
  protected:
  explicit CNMarketDefinition(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMarketNameFieldNumber = 2,
    kMarketCodeFieldNumber = 1,
    kCurrencyCodeFieldNumber = 3,
    kNumberOfSecuritiesFieldNumber = 4,
  };
  // optional string marketName = 2;
  bool has_marketname() const;
  private:
  bool _internal_has_marketname() const;
  public:
  void clear_marketname();
  const std::string& marketname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_marketname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_marketname();
  PROTOBUF_NODISCARD std::string* release_marketname();
  void set_allocated_marketname(std::string* marketname);
  private:
  const std::string& _internal_marketname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_marketname(const std::string& value);
  std::string* _internal_mutable_marketname();
  public:

  // optional .data.CnMarketCode marketCode = 1;
  bool has_marketcode() const;
  private:
  bool _internal_has_marketcode() const;
  public:
  void clear_marketcode();
  ::data::CnMarketCode marketcode() const;
  void set_marketcode(::data::CnMarketCode value);
  private:
  ::data::CnMarketCode _internal_marketcode() const;
  void _internal_set_marketcode(::data::CnMarketCode value);
  public:

  // optional .data.CurrencyType currencyCode = 3;
  bool has_currencycode() const;
  private:
  bool _internal_has_currencycode() const;
  public:
  void clear_currencycode();
  ::data::CurrencyType currencycode() const;
  void set_currencycode(::data::CurrencyType value);
  private:
  ::data::CurrencyType _internal_currencycode() const;
  void _internal_set_currencycode(::data::CurrencyType value);
  public:

  // optional int64 numberOfSecurities = 4;
  bool has_numberofsecurities() const;
  private:
  bool _internal_has_numberofsecurities() const;
  public:
  void clear_numberofsecurities();
  int64_t numberofsecurities() const;
  void set_numberofsecurities(int64_t value);
  private:
  int64_t _internal_numberofsecurities() const;
  void _internal_set_numberofsecurities(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:data.CNMarketDefinition)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr marketname_;
    int marketcode_;
    int currencycode_;
    int64_t numberofsecurities_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_data_2eproto;
};
// -------------------------------------------------------------------

class CNSecurityDefinition final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:data.CNSecurityDefinition) */ {
 public:
  inline CNSecurityDefinition() : CNSecurityDefinition(nullptr) {}
  ~CNSecurityDefinition() override;
  explicit PROTOBUF_CONSTEXPR CNSecurityDefinition(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CNSecurityDefinition(const CNSecurityDefinition& from);
  CNSecurityDefinition(CNSecurityDefinition&& from) noexcept
    : CNSecurityDefinition() {
    *this = ::std::move(from);
  }

  inline CNSecurityDefinition& operator=(const CNSecurityDefinition& from) {
    CopyFrom(from);
    return *this;
  }
  inline CNSecurityDefinition& operator=(CNSecurityDefinition&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CNSecurityDefinition& default_instance() {
    return *internal_default_instance();
  }
  static inline const CNSecurityDefinition* internal_default_instance() {
    return reinterpret_cast<const CNSecurityDefinition*>(
               &_CNSecurityDefinition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    71;

  friend void swap(CNSecurityDefinition& a, CNSecurityDefinition& b) {
    a.Swap(&b);
  }
  inline void Swap(CNSecurityDefinition* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CNSecurityDefinition* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CNSecurityDefinition* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CNSecurityDefinition>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CNSecurityDefinition& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CNSecurityDefinition& from) {
    CNSecurityDefinition::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CNSecurityDefinition* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "data.CNSecurityDefinition";
  }
  protected:
  explicit CNSecurityDefinition(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIsinCodeFieldNumber = 3,
    kSecurityShortNameFieldNumber = 5,
    kSecurityNameGBFieldNumber = 7,
    kSecurityCodeFieldNumber = 1,
    kMarketCodeFieldNumber = 2,
    kInstrumentTypeFieldNumber = 4,
    kLotSizeFieldNumber = 8,
    kCurrencyCodeFieldNumber = 6,
    kShortSellFlagFieldNumber = 10,
    kPreviousClosingPriceFieldNumber = 9,
    kListingDateFieldNumber = 11,
  };
  // optional string isinCode = 3;
  bool has_isincode() const;
  private:
  bool _internal_has_isincode() const;
  public:
  void clear_isincode();
  const std::string& isincode() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_isincode(ArgT0&& arg0, ArgT... args);
  std::string* mutable_isincode();
  PROTOBUF_NODISCARD std::string* release_isincode();
  void set_allocated_isincode(std::string* isincode);
  private:
  const std::string& _internal_isincode() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_isincode(const std::string& value);
  std::string* _internal_mutable_isincode();
  public:

  // optional string securityShortName = 5;
  bool has_securityshortname() const;
  private:
  bool _internal_has_securityshortname() const;
  public:
  void clear_securityshortname();
  const std::string& securityshortname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_securityshortname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_securityshortname();
  PROTOBUF_NODISCARD std::string* release_securityshortname();
  void set_allocated_securityshortname(std::string* securityshortname);
  private:
  const std::string& _internal_securityshortname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_securityshortname(const std::string& value);
  std::string* _internal_mutable_securityshortname();
  public:

  // optional string securityNameGB = 7;
  bool has_securitynamegb() const;
  private:
  bool _internal_has_securitynamegb() const;
  public:
  void clear_securitynamegb();
  const std::string& securitynamegb() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_securitynamegb(ArgT0&& arg0, ArgT... args);
  std::string* mutable_securitynamegb();
  PROTOBUF_NODISCARD std::string* release_securitynamegb();
  void set_allocated_securitynamegb(std::string* securitynamegb);
  private:
  const std::string& _internal_securitynamegb() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_securitynamegb(const std::string& value);
  std::string* _internal_mutable_securitynamegb();
  public:

  // optional int64 securityCode = 1;
  bool has_securitycode() const;
  private:
  bool _internal_has_securitycode() const;
  public:
  void clear_securitycode();
  int64_t securitycode() const;
  void set_securitycode(int64_t value);
  private:
  int64_t _internal_securitycode() const;
  void _internal_set_securitycode(int64_t value);
  public:

  // optional .data.CnMarketCode marketCode = 2;
  bool has_marketcode() const;
  private:
  bool _internal_has_marketcode() const;
  public:
  void clear_marketcode();
  ::data::CnMarketCode marketcode() const;
  void set_marketcode(::data::CnMarketCode value);
  private:
  ::data::CnMarketCode _internal_marketcode() const;
  void _internal_set_marketcode(::data::CnMarketCode value);
  public:

  // optional .data.InstrumentType instrumentType = 4;
  bool has_instrumenttype() const;
  private:
  bool _internal_has_instrumenttype() const;
  public:
  void clear_instrumenttype();
  ::data::InstrumentType instrumenttype() const;
  void set_instrumenttype(::data::InstrumentType value);
  private:
  ::data::InstrumentType _internal_instrumenttype() const;
  void _internal_set_instrumenttype(::data::InstrumentType value);
  public:

  // optional int64 lotSize = 8;
  bool has_lotsize() const;
  private:
  bool _internal_has_lotsize() const;
  public:
  void clear_lotsize();
  int64_t lotsize() const;
  void set_lotsize(int64_t value);
  private:
  int64_t _internal_lotsize() const;
  void _internal_set_lotsize(int64_t value);
  public:

  // optional .data.CurrencyType currencyCode = 6;
  bool has_currencycode() const;
  private:
  bool _internal_has_currencycode() const;
  public:
  void clear_currencycode();
  ::data::CurrencyType currencycode() const;
  void set_currencycode(::data::CurrencyType value);
  private:
  ::data::CurrencyType _internal_currencycode() const;
  void _internal_set_currencycode(::data::CurrencyType value);
  public:

  // optional .data.IndicatesWhether shortSellFlag = 10;
  bool has_shortsellflag() const;
  private:
  bool _internal_has_shortsellflag() const;
  public:
  void clear_shortsellflag();
  ::data::IndicatesWhether shortsellflag() const;
  void set_shortsellflag(::data::IndicatesWhether value);
  private:
  ::data::IndicatesWhether _internal_shortsellflag() const;
  void _internal_set_shortsellflag(::data::IndicatesWhether value);
  public:

  // optional double previousClosingPrice = 9;
  bool has_previousclosingprice() const;
  private:
  bool _internal_has_previousclosingprice() const;
  public:
  void clear_previousclosingprice();
  double previousclosingprice() const;
  void set_previousclosingprice(double value);
  private:
  double _internal_previousclosingprice() const;
  void _internal_set_previousclosingprice(double value);
  public:

  // optional int64 listingDate = 11;
  bool has_listingdate() const;
  private:
  bool _internal_has_listingdate() const;
  public:
  void clear_listingdate();
  int64_t listingdate() const;
  void set_listingdate(int64_t value);
  private:
  int64_t _internal_listingdate() const;
  void _internal_set_listingdate(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:data.CNSecurityDefinition)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr isincode_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr securityshortname_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr securitynamegb_;
    int64_t securitycode_;
    int marketcode_;
    int instrumenttype_;
    int64_t lotsize_;
    int currencycode_;
    int shortsellflag_;
    double previousclosingprice_;
    int64_t listingdate_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_data_2eproto;
};
// -------------------------------------------------------------------

class CNSecurityStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:data.CNSecurityStatus) */ {
 public:
  inline CNSecurityStatus() : CNSecurityStatus(nullptr) {}
  ~CNSecurityStatus() override;
  explicit PROTOBUF_CONSTEXPR CNSecurityStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CNSecurityStatus(const CNSecurityStatus& from);
  CNSecurityStatus(CNSecurityStatus&& from) noexcept
    : CNSecurityStatus() {
    *this = ::std::move(from);
  }

  inline CNSecurityStatus& operator=(const CNSecurityStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline CNSecurityStatus& operator=(CNSecurityStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CNSecurityStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const CNSecurityStatus* internal_default_instance() {
    return reinterpret_cast<const CNSecurityStatus*>(
               &_CNSecurityStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    72;

  friend void swap(CNSecurityStatus& a, CNSecurityStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(CNSecurityStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CNSecurityStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CNSecurityStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CNSecurityStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CNSecurityStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CNSecurityStatus& from) {
    CNSecurityStatus::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CNSecurityStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "data.CNSecurityStatus";
  }
  protected:
  explicit CNSecurityStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTradingPhaseCodeFieldNumber = 3,
    kSecurityCodeFieldNumber = 1,
    kSecurityTradingStatusFieldNumber = 2,
  };
  // optional string tradingPhaseCode = 3;
  bool has_tradingphasecode() const;
  private:
  bool _internal_has_tradingphasecode() const;
  public:
  void clear_tradingphasecode();
  const std::string& tradingphasecode() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tradingphasecode(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tradingphasecode();
  PROTOBUF_NODISCARD std::string* release_tradingphasecode();
  void set_allocated_tradingphasecode(std::string* tradingphasecode);
  private:
  const std::string& _internal_tradingphasecode() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tradingphasecode(const std::string& value);
  std::string* _internal_mutable_tradingphasecode();
  public:

  // optional int64 securityCode = 1;
  bool has_securitycode() const;
  private:
  bool _internal_has_securitycode() const;
  public:
  void clear_securitycode();
  int64_t securitycode() const;
  void set_securitycode(int64_t value);
  private:
  int64_t _internal_securitycode() const;
  void _internal_set_securitycode(int64_t value);
  public:

  // optional .data.SecurityTradingStatus securityTradingStatus = 2;
  bool has_securitytradingstatus() const;
  private:
  bool _internal_has_securitytradingstatus() const;
  public:
  void clear_securitytradingstatus();
  ::data::SecurityTradingStatus securitytradingstatus() const;
  void set_securitytradingstatus(::data::SecurityTradingStatus value);
  private:
  ::data::SecurityTradingStatus _internal_securitytradingstatus() const;
  void _internal_set_securitytradingstatus(::data::SecurityTradingStatus value);
  public:

  // @@protoc_insertion_point(class_scope:data.CNSecurityStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tradingphasecode_;
    int64_t securitycode_;
    int securitytradingstatus_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_data_2eproto;
};
// -------------------------------------------------------------------

class CNStatistics final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:data.CNStatistics) */ {
 public:
  inline CNStatistics() : CNStatistics(nullptr) {}
  ~CNStatistics() override;
  explicit PROTOBUF_CONSTEXPR CNStatistics(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CNStatistics(const CNStatistics& from);
  CNStatistics(CNStatistics&& from) noexcept
    : CNStatistics() {
    *this = ::std::move(from);
  }

  inline CNStatistics& operator=(const CNStatistics& from) {
    CopyFrom(from);
    return *this;
  }
  inline CNStatistics& operator=(CNStatistics&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CNStatistics& default_instance() {
    return *internal_default_instance();
  }
  static inline const CNStatistics* internal_default_instance() {
    return reinterpret_cast<const CNStatistics*>(
               &_CNStatistics_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    73;

  friend void swap(CNStatistics& a, CNStatistics& b) {
    a.Swap(&b);
  }
  inline void Swap(CNStatistics* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CNStatistics* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CNStatistics* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CNStatistics>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CNStatistics& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CNStatistics& from) {
    CNStatistics::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CNStatistics* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "data.CNStatistics";
  }
  protected:
  explicit CNStatistics(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSecurityCodeFieldNumber = 1,
    kSharesTradedFieldNumber = 2,
    kTurnoverFieldNumber = 3,
    kHighPriceFieldNumber = 4,
    kLowPriceFieldNumber = 5,
    kLastPriceFieldNumber = 6,
    kOpeningPriceFieldNumber = 7,
  };
  // optional int64 securityCode = 1;
  bool has_securitycode() const;
  private:
  bool _internal_has_securitycode() const;
  public:
  void clear_securitycode();
  int64_t securitycode() const;
  void set_securitycode(int64_t value);
  private:
  int64_t _internal_securitycode() const;
  void _internal_set_securitycode(int64_t value);
  public:

  // optional int64 sharesTraded = 2;
  bool has_sharestraded() const;
  private:
  bool _internal_has_sharestraded() const;
  public:
  void clear_sharestraded();
  int64_t sharestraded() const;
  void set_sharestraded(int64_t value);
  private:
  int64_t _internal_sharestraded() const;
  void _internal_set_sharestraded(int64_t value);
  public:

  // optional double turnover = 3;
  bool has_turnover() const;
  private:
  bool _internal_has_turnover() const;
  public:
  void clear_turnover();
  double turnover() const;
  void set_turnover(double value);
  private:
  double _internal_turnover() const;
  void _internal_set_turnover(double value);
  public:

  // optional double highPrice = 4;
  bool has_highprice() const;
  private:
  bool _internal_has_highprice() const;
  public:
  void clear_highprice();
  double highprice() const;
  void set_highprice(double value);
  private:
  double _internal_highprice() const;
  void _internal_set_highprice(double value);
  public:

  // optional double lowPrice = 5;
  bool has_lowprice() const;
  private:
  bool _internal_has_lowprice() const;
  public:
  void clear_lowprice();
  double lowprice() const;
  void set_lowprice(double value);
  private:
  double _internal_lowprice() const;
  void _internal_set_lowprice(double value);
  public:

  // optional double lastPrice = 6;
  bool has_lastprice() const;
  private:
  bool _internal_has_lastprice() const;
  public:
  void clear_lastprice();
  double lastprice() const;
  void set_lastprice(double value);
  private:
  double _internal_lastprice() const;
  void _internal_set_lastprice(double value);
  public:

  // optional double openingPrice = 7;
  bool has_openingprice() const;
  private:
  bool _internal_has_openingprice() const;
  public:
  void clear_openingprice();
  double openingprice() const;
  void set_openingprice(double value);
  private:
  double _internal_openingprice() const;
  void _internal_set_openingprice(double value);
  public:

  // @@protoc_insertion_point(class_scope:data.CNStatistics)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int64_t securitycode_;
    int64_t sharestraded_;
    double turnover_;
    double highprice_;
    double lowprice_;
    double lastprice_;
    double openingprice_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_data_2eproto;
};
// -------------------------------------------------------------------

class CNTopBook final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:data.CNTopBook) */ {
 public:
  inline CNTopBook() : CNTopBook(nullptr) {}
  ~CNTopBook() override;
  explicit PROTOBUF_CONSTEXPR CNTopBook(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CNTopBook(const CNTopBook& from);
  CNTopBook(CNTopBook&& from) noexcept
    : CNTopBook() {
    *this = ::std::move(from);
  }

  inline CNTopBook& operator=(const CNTopBook& from) {
    CopyFrom(from);
    return *this;
  }
  inline CNTopBook& operator=(CNTopBook&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CNTopBook& default_instance() {
    return *internal_default_instance();
  }
  static inline const CNTopBook* internal_default_instance() {
    return reinterpret_cast<const CNTopBook*>(
               &_CNTopBook_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    74;

  friend void swap(CNTopBook& a, CNTopBook& b) {
    a.Swap(&b);
  }
  inline void Swap(CNTopBook* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CNTopBook* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CNTopBook* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CNTopBook>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CNTopBook& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CNTopBook& from) {
    CNTopBook::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CNTopBook* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "data.CNTopBook";
  }
  protected:
  explicit CNTopBook(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSecurityCodeFieldNumber = 1,
    kAggregateBidQuantityFieldNumber = 2,
    kAggregateAskQuantityFieldNumber = 3,
    kBidPriceFieldNumber = 4,
    kAskPriceFieldNumber = 5,
  };
  // optional int64 securityCode = 1;
  bool has_securitycode() const;
  private:
  bool _internal_has_securitycode() const;
  public:
  void clear_securitycode();
  int64_t securitycode() const;
  void set_securitycode(int64_t value);
  private:
  int64_t _internal_securitycode() const;
  void _internal_set_securitycode(int64_t value);
  public:

  // optional int64 aggregateBidQuantity = 2;
  bool has_aggregatebidquantity() const;
  private:
  bool _internal_has_aggregatebidquantity() const;
  public:
  void clear_aggregatebidquantity();
  int64_t aggregatebidquantity() const;
  void set_aggregatebidquantity(int64_t value);
  private:
  int64_t _internal_aggregatebidquantity() const;
  void _internal_set_aggregatebidquantity(int64_t value);
  public:

  // optional int64 aggregateAskQuantity = 3;
  bool has_aggregateaskquantity() const;
  private:
  bool _internal_has_aggregateaskquantity() const;
  public:
  void clear_aggregateaskquantity();
  int64_t aggregateaskquantity() const;
  void set_aggregateaskquantity(int64_t value);
  private:
  int64_t _internal_aggregateaskquantity() const;
  void _internal_set_aggregateaskquantity(int64_t value);
  public:

  // optional double bidPrice = 4;
  bool has_bidprice() const;
  private:
  bool _internal_has_bidprice() const;
  public:
  void clear_bidprice();
  double bidprice() const;
  void set_bidprice(double value);
  private:
  double _internal_bidprice() const;
  void _internal_set_bidprice(double value);
  public:

  // optional double askPrice = 5;
  bool has_askprice() const;
  private:
  bool _internal_has_askprice() const;
  public:
  void clear_askprice();
  double askprice() const;
  void set_askprice(double value);
  private:
  double _internal_askprice() const;
  void _internal_set_askprice(double value);
  public:

  // @@protoc_insertion_point(class_scope:data.CNTopBook)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int64_t securitycode_;
    int64_t aggregatebidquantity_;
    int64_t aggregateaskquantity_;
    double bidprice_;
    double askprice_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_data_2eproto;
};
// -------------------------------------------------------------------

class CertificationMsg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:data.CertificationMsg) */ {
 public:
  inline CertificationMsg() : CertificationMsg(nullptr) {}
  ~CertificationMsg() override;
  explicit PROTOBUF_CONSTEXPR CertificationMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CertificationMsg(const CertificationMsg& from);
  CertificationMsg(CertificationMsg&& from) noexcept
    : CertificationMsg() {
    *this = ::std::move(from);
  }

  inline CertificationMsg& operator=(const CertificationMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline CertificationMsg& operator=(CertificationMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CertificationMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const CertificationMsg* internal_default_instance() {
    return reinterpret_cast<const CertificationMsg*>(
               &_CertificationMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    75;

  friend void swap(CertificationMsg& a, CertificationMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(CertificationMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CertificationMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CertificationMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CertificationMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CertificationMsg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CertificationMsg& from) {
    CertificationMsg::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CertificationMsg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "data.CertificationMsg";
  }
  protected:
  explicit CertificationMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAuthFieldNumber = 2,
    kResponseFieldNumber = 3,
    kActionTypeFieldNumber = 1,
  };
  // optional string auth = 2;
  bool has_auth() const;
  private:
  bool _internal_has_auth() const;
  public:
  void clear_auth();
  const std::string& auth() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_auth(ArgT0&& arg0, ArgT... args);
  std::string* mutable_auth();
  PROTOBUF_NODISCARD std::string* release_auth();
  void set_allocated_auth(std::string* auth);
  private:
  const std::string& _internal_auth() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_auth(const std::string& value);
  std::string* _internal_mutable_auth();
  public:

  // optional .data.Resp response = 3;
  bool has_response() const;
  private:
  bool _internal_has_response() const;
  public:
  void clear_response();
  const ::data::Resp& response() const;
  PROTOBUF_NODISCARD ::data::Resp* release_response();
  ::data::Resp* mutable_response();
  void set_allocated_response(::data::Resp* response);
  private:
  const ::data::Resp& _internal_response() const;
  ::data::Resp* _internal_mutable_response();
  public:
  void unsafe_arena_set_allocated_response(
      ::data::Resp* response);
  ::data::Resp* unsafe_arena_release_response();

  // optional .data.ActionType actionType = 1;
  bool has_actiontype() const;
  private:
  bool _internal_has_actiontype() const;
  public:
  void clear_actiontype();
  ::data::ActionType actiontype() const;
  void set_actiontype(::data::ActionType value);
  private:
  ::data::ActionType _internal_actiontype() const;
  void _internal_set_actiontype(::data::ActionType value);
  public:

  // @@protoc_insertion_point(class_scope:data.CertificationMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr auth_;
    ::data::Resp* response_;
    int actiontype_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_data_2eproto;
};
// -------------------------------------------------------------------

class Resp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:data.Resp) */ {
 public:
  inline Resp() : Resp(nullptr) {}
  ~Resp() override;
  explicit PROTOBUF_CONSTEXPR Resp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Resp(const Resp& from);
  Resp(Resp&& from) noexcept
    : Resp() {
    *this = ::std::move(from);
  }

  inline Resp& operator=(const Resp& from) {
    CopyFrom(from);
    return *this;
  }
  inline Resp& operator=(Resp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Resp& default_instance() {
    return *internal_default_instance();
  }
  static inline const Resp* internal_default_instance() {
    return reinterpret_cast<const Resp*>(
               &_Resp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    76;

  friend void swap(Resp& a, Resp& b) {
    a.Swap(&b);
  }
  inline void Swap(Resp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Resp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Resp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Resp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Resp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Resp& from) {
    Resp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Resp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "data.Resp";
  }
  protected:
  explicit Resp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorMsgFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // optional string errorMsg = 2;
  bool has_errormsg() const;
  private:
  bool _internal_has_errormsg() const;
  public:
  void clear_errormsg();
  const std::string& errormsg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_errormsg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_errormsg();
  PROTOBUF_NODISCARD std::string* release_errormsg();
  void set_allocated_errormsg(std::string* errormsg);
  private:
  const std::string& _internal_errormsg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_errormsg(const std::string& value);
  std::string* _internal_mutable_errormsg();
  public:

  // optional .data.ResponseType type = 1;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::data::ResponseType type() const;
  void set_type(::data::ResponseType value);
  private:
  ::data::ResponseType _internal_type() const;
  void _internal_set_type(::data::ResponseType value);
  public:

  // @@protoc_insertion_point(class_scope:data.Resp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr errormsg_;
    int type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_data_2eproto;
};
// -------------------------------------------------------------------

class Message final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:data.Message) */ {
 public:
  inline Message() : Message(nullptr) {}
  ~Message() override;
  explicit PROTOBUF_CONSTEXPR Message(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Message(const Message& from);
  Message(Message&& from) noexcept
    : Message() {
    *this = ::std::move(from);
  }

  inline Message& operator=(const Message& from) {
    CopyFrom(from);
    return *this;
  }
  inline Message& operator=(Message&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Message& default_instance() {
    return *internal_default_instance();
  }
  enum DataBodyCase {
    kAddOddLotOrder = 2,
    kAggregateOrderBookUpdate = 3,
    kBrokerQueue = 4,
    kClosingPrice = 5,
    kCurrencyRate = 6,
    kDeleteOddLotOrder = 7,
    kIndexData = 8,
    kIndexDefinition = 9,
    kIndicativeEquilibriumPrice = 10,
    kLiquidityProvider = 11,
    kMarketDefinition = 12,
    kMarketTurnover = 13,
    kNews = 14,
    kNominalPrice = 15,
    kOrderImbalance = 16,
    kReferencePrice = 17,
    kSecurityDefinition = 18,
    kSecurityStatus = 19,
    kStatistics = 20,
    kStockConnectDailyQuotaBalance = 21,
    kStockConnectMarketTurnover = 22,
    kTrade = 23,
    kTradeCancel = 24,
    kTradingSessionStatus = 25,
    kVCMTrigger = 26,
    kYield = 27,
    kAdjustedClosingPrice = 28,
    kDayTradeSummary = 29,
    kDayTradeSummaryNextShares = 30,
    kIPOInformation = 31,
    kIPOQuotingPeriodUpdate = 32,
    kLongAdjustedClosingPrice = 33,
    kLongDayTradeSummary = 34,
    kLongTradeCancelForNonNextSharesTrades = 35,
    kLongTradeCorrectionForNonNextsharesTrades = 36,
    kLongTradeReportForNonNextshares = 37,
    kMWCBStatusMessage = 38,
    kMarketWideCircuitBreaker = 39,
    kOperationalHalt = 40,
    kSaleConditionModifier = 41,
    kShortSaleRestrictionIndicatorMessage = 42,
    kStockDirectory = 43,
    kStockTradingAction = 44,
    kSystemEventMessage = 45,
    kTradeCancelForNextsharesTrades = 46,
    kTradeCancelForNonNextSharesTrades = 47,
    kTradeCorrectionForNextsharesTrades = 48,
    kTradeCorrectionForNonNextsharesTrades = 49,
    kTradeReportForNextshares = 50,
    kTradeReportForNonNextshares = 51,
    kQBBOMWCBBreachMessage = 52,
    kQBBOMWCBDeclineLevelMessage = 53,
    kQBBONextSharesQuotationMessage = 54,
    kQBBOOperationalHalt = 55,
    kQBBOQuotationMessage = 56,
    kQBBORegShoRestriction = 57,
    kQBBOStockDirectory = 58,
    kQBBOStockTradingAction = 59,
    kQBBOSystemEventMessage = 60,
    kQBBOIPOQuotingPeriodUpdate = 61,
    kCertificationMsg = 62,
    kCNMarketDefinition = 63,
    kCNSecurityDefinition = 64,
    kCNSecurityStatus = 65,
    kCNStatistics = 66,
    kCNTopBook = 67,
    DATABODY_NOT_SET = 0,
  };

  static inline const Message* internal_default_instance() {
    return reinterpret_cast<const Message*>(
               &_Message_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    77;

  friend void swap(Message& a, Message& b) {
    a.Swap(&b);
  }
  inline void Swap(Message* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Message* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Message* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Message>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Message& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Message& from) {
    Message::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Message* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "data.Message";
  }
  protected:
  explicit Message(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Message_DataType DataType;
  static constexpr DataType AddOddLotOrderType =
    Message_DataType_AddOddLotOrderType;
  static constexpr DataType AggregateOrderBookUpdateType =
    Message_DataType_AggregateOrderBookUpdateType;
  static constexpr DataType BrokerQueueType =
    Message_DataType_BrokerQueueType;
  static constexpr DataType ClosingPriceType =
    Message_DataType_ClosingPriceType;
  static constexpr DataType CurrencyRateType =
    Message_DataType_CurrencyRateType;
  static constexpr DataType DeleteOddLotOrderType =
    Message_DataType_DeleteOddLotOrderType;
  static constexpr DataType IndexDataType =
    Message_DataType_IndexDataType;
  static constexpr DataType IndexDefinitionType =
    Message_DataType_IndexDefinitionType;
  static constexpr DataType IndicativeEquilibriumPriceType =
    Message_DataType_IndicativeEquilibriumPriceType;
  static constexpr DataType LiquidityProviderType =
    Message_DataType_LiquidityProviderType;
  static constexpr DataType MarketDefinitionType =
    Message_DataType_MarketDefinitionType;
  static constexpr DataType MarketTurnoverType =
    Message_DataType_MarketTurnoverType;
  static constexpr DataType NewsType =
    Message_DataType_NewsType;
  static constexpr DataType NominalPriceType =
    Message_DataType_NominalPriceType;
  static constexpr DataType OrderImbalanceType =
    Message_DataType_OrderImbalanceType;
  static constexpr DataType ReferencePriceType =
    Message_DataType_ReferencePriceType;
  static constexpr DataType SecurityDefinitionType =
    Message_DataType_SecurityDefinitionType;
  static constexpr DataType SecurityStatusType =
    Message_DataType_SecurityStatusType;
  static constexpr DataType StatisticsType =
    Message_DataType_StatisticsType;
  static constexpr DataType StockConnectDailyQuotaBalanceType =
    Message_DataType_StockConnectDailyQuotaBalanceType;
  static constexpr DataType StockConnectMarketTurnoverType =
    Message_DataType_StockConnectMarketTurnoverType;
  static constexpr DataType TradeType =
    Message_DataType_TradeType;
  static constexpr DataType TradeCancelType =
    Message_DataType_TradeCancelType;
  static constexpr DataType TradingSessionStatusType =
    Message_DataType_TradingSessionStatusType;
  static constexpr DataType VCMTriggerType =
    Message_DataType_VCMTriggerType;
  static constexpr DataType YieldType =
    Message_DataType_YieldType;
  static constexpr DataType AdjustedClosingPriceType =
    Message_DataType_AdjustedClosingPriceType;
  static constexpr DataType DayTradeSummaryType =
    Message_DataType_DayTradeSummaryType;
  static constexpr DataType DayTradeSummaryNextSharesType =
    Message_DataType_DayTradeSummaryNextSharesType;
  static constexpr DataType IPOInformationType =
    Message_DataType_IPOInformationType;
  static constexpr DataType IPOQuotingPeriodUpdateType =
    Message_DataType_IPOQuotingPeriodUpdateType;
  static constexpr DataType LongAdjustedClosingPriceType =
    Message_DataType_LongAdjustedClosingPriceType;
  static constexpr DataType LongDayTradeSummaryType =
    Message_DataType_LongDayTradeSummaryType;
  static constexpr DataType LongTradeCancelForNonNextSharesTradesType =
    Message_DataType_LongTradeCancelForNonNextSharesTradesType;
  static constexpr DataType LongTradeCorrectionForNonNextsharesTradesType =
    Message_DataType_LongTradeCorrectionForNonNextsharesTradesType;
  static constexpr DataType LongTradeReportForNonNextsharesType =
    Message_DataType_LongTradeReportForNonNextsharesType;
  static constexpr DataType MWCBStatusMessageType =
    Message_DataType_MWCBStatusMessageType;
  static constexpr DataType MarketWideCircuitBreakerType =
    Message_DataType_MarketWideCircuitBreakerType;
  static constexpr DataType OperationalHaltType =
    Message_DataType_OperationalHaltType;
  static constexpr DataType SaleConditionModifierType =
    Message_DataType_SaleConditionModifierType;
  static constexpr DataType ShortSaleRestrictionIndicatorMessageType =
    Message_DataType_ShortSaleRestrictionIndicatorMessageType;
  static constexpr DataType StockDirectoryType =
    Message_DataType_StockDirectoryType;
  static constexpr DataType StockTradingActionType =
    Message_DataType_StockTradingActionType;
  static constexpr DataType SystemEventMessageType =
    Message_DataType_SystemEventMessageType;
  static constexpr DataType TradeCancelForNextsharesTradesType =
    Message_DataType_TradeCancelForNextsharesTradesType;
  static constexpr DataType TradeCancelForNonNextSharesTradesType =
    Message_DataType_TradeCancelForNonNextSharesTradesType;
  static constexpr DataType TradeCorrectionForNextsharesTradesType =
    Message_DataType_TradeCorrectionForNextsharesTradesType;
  static constexpr DataType TradeCorrectionForNonNextsharesTradesType =
    Message_DataType_TradeCorrectionForNonNextsharesTradesType;
  static constexpr DataType TradeReportForNextsharesType =
    Message_DataType_TradeReportForNextsharesType;
  static constexpr DataType TradeReportForNonNextsharesType =
    Message_DataType_TradeReportForNonNextsharesType;
  static constexpr DataType QBBOMWCBBreachMessageType =
    Message_DataType_QBBOMWCBBreachMessageType;
  static constexpr DataType QBBOMWCBDeclineLevelMessageType =
    Message_DataType_QBBOMWCBDeclineLevelMessageType;
  static constexpr DataType QBBONextSharesQuotationMessageType =
    Message_DataType_QBBONextSharesQuotationMessageType;
  static constexpr DataType QBBOOperationalHaltType =
    Message_DataType_QBBOOperationalHaltType;
  static constexpr DataType QBBOQuotationMessageType =
    Message_DataType_QBBOQuotationMessageType;
  static constexpr DataType QBBORegShoRestrictionType =
    Message_DataType_QBBORegShoRestrictionType;
  static constexpr DataType QBBOStockDirectoryType =
    Message_DataType_QBBOStockDirectoryType;
  static constexpr DataType QBBOStockTradingActionType =
    Message_DataType_QBBOStockTradingActionType;
  static constexpr DataType QBBOSystemEventMessageType =
    Message_DataType_QBBOSystemEventMessageType;
  static constexpr DataType QBBOIPOQuotingPeriodUpdateType =
    Message_DataType_QBBOIPOQuotingPeriodUpdateType;
  static constexpr DataType CertificationMsgType =
    Message_DataType_CertificationMsgType;
  static constexpr DataType CNMarketDefinitionType =
    Message_DataType_CNMarketDefinitionType;
  static constexpr DataType CNSecurityDefinitionType =
    Message_DataType_CNSecurityDefinitionType;
  static constexpr DataType CNSecurityStatusType =
    Message_DataType_CNSecurityStatusType;
  static constexpr DataType CNStatisticsType =
    Message_DataType_CNStatisticsType;
  static constexpr DataType CNTopBookType =
    Message_DataType_CNTopBookType;
  static inline bool DataType_IsValid(int value) {
    return Message_DataType_IsValid(value);
  }
  static constexpr DataType DataType_MIN =
    Message_DataType_DataType_MIN;
  static constexpr DataType DataType_MAX =
    Message_DataType_DataType_MAX;
  static constexpr int DataType_ARRAYSIZE =
    Message_DataType_DataType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  DataType_descriptor() {
    return Message_DataType_descriptor();
  }
  template<typename T>
  static inline const std::string& DataType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, DataType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function DataType_Name.");
    return Message_DataType_Name(enum_t_value);
  }
  static inline bool DataType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      DataType* value) {
    return Message_DataType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTimestampFieldNumber = 68,
    kDataTypeFieldNumber = 1,
    kAddOddLotOrderFieldNumber = 2,
    kAggregateOrderBookUpdateFieldNumber = 3,
    kBrokerQueueFieldNumber = 4,
    kClosingPriceFieldNumber = 5,
    kCurrencyRateFieldNumber = 6,
    kDeleteOddLotOrderFieldNumber = 7,
    kIndexDataFieldNumber = 8,
    kIndexDefinitionFieldNumber = 9,
    kIndicativeEquilibriumPriceFieldNumber = 10,
    kLiquidityProviderFieldNumber = 11,
    kMarketDefinitionFieldNumber = 12,
    kMarketTurnoverFieldNumber = 13,
    kNewsFieldNumber = 14,
    kNominalPriceFieldNumber = 15,
    kOrderImbalanceFieldNumber = 16,
    kReferencePriceFieldNumber = 17,
    kSecurityDefinitionFieldNumber = 18,
    kSecurityStatusFieldNumber = 19,
    kStatisticsFieldNumber = 20,
    kStockConnectDailyQuotaBalanceFieldNumber = 21,
    kStockConnectMarketTurnoverFieldNumber = 22,
    kTradeFieldNumber = 23,
    kTradeCancelFieldNumber = 24,
    kTradingSessionStatusFieldNumber = 25,
    kVCMTriggerFieldNumber = 26,
    kYieldFieldNumber = 27,
    kAdjustedClosingPriceFieldNumber = 28,
    kDayTradeSummaryFieldNumber = 29,
    kDayTradeSummaryNextSharesFieldNumber = 30,
    kIPOInformationFieldNumber = 31,
    kIPOQuotingPeriodUpdateFieldNumber = 32,
    kLongAdjustedClosingPriceFieldNumber = 33,
    kLongDayTradeSummaryFieldNumber = 34,
    kLongTradeCancelForNonNextSharesTradesFieldNumber = 35,
    kLongTradeCorrectionForNonNextsharesTradesFieldNumber = 36,
    kLongTradeReportForNonNextsharesFieldNumber = 37,
    kMWCBStatusMessageFieldNumber = 38,
    kMarketWideCircuitBreakerFieldNumber = 39,
    kOperationalHaltFieldNumber = 40,
    kSaleConditionModifierFieldNumber = 41,
    kShortSaleRestrictionIndicatorMessageFieldNumber = 42,
    kStockDirectoryFieldNumber = 43,
    kStockTradingActionFieldNumber = 44,
    kSystemEventMessageFieldNumber = 45,
    kTradeCancelForNextsharesTradesFieldNumber = 46,
    kTradeCancelForNonNextSharesTradesFieldNumber = 47,
    kTradeCorrectionForNextsharesTradesFieldNumber = 48,
    kTradeCorrectionForNonNextsharesTradesFieldNumber = 49,
    kTradeReportForNextsharesFieldNumber = 50,
    kTradeReportForNonNextsharesFieldNumber = 51,
    kQBBOMWCBBreachMessageFieldNumber = 52,
    kQBBOMWCBDeclineLevelMessageFieldNumber = 53,
    kQBBONextSharesQuotationMessageFieldNumber = 54,
    kQBBOOperationalHaltFieldNumber = 55,
    kQBBOQuotationMessageFieldNumber = 56,
    kQBBORegShoRestrictionFieldNumber = 57,
    kQBBOStockDirectoryFieldNumber = 58,
    kQBBOStockTradingActionFieldNumber = 59,
    kQBBOSystemEventMessageFieldNumber = 60,
    kQBBOIPOQuotingPeriodUpdateFieldNumber = 61,
    kCertificationMsgFieldNumber = 62,
    kCNMarketDefinitionFieldNumber = 63,
    kCNSecurityDefinitionFieldNumber = 64,
    kCNSecurityStatusFieldNumber = 65,
    kCNStatisticsFieldNumber = 66,
    kCNTopBookFieldNumber = 67,
  };
  // optional int64 timestamp = 68;
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  int64_t timestamp() const;
  void set_timestamp(int64_t value);
  private:
  int64_t _internal_timestamp() const;
  void _internal_set_timestamp(int64_t value);
  public:

  // optional .data.Message.DataType data_type = 1;
  bool has_data_type() const;
  private:
  bool _internal_has_data_type() const;
  public:
  void clear_data_type();
  ::data::Message_DataType data_type() const;
  void set_data_type(::data::Message_DataType value);
  private:
  ::data::Message_DataType _internal_data_type() const;
  void _internal_set_data_type(::data::Message_DataType value);
  public:

  // .data.AddOddLotOrder addOddLotOrder = 2;
  bool has_addoddlotorder() const;
  private:
  bool _internal_has_addoddlotorder() const;
  public:
  void clear_addoddlotorder();
  const ::data::AddOddLotOrder& addoddlotorder() const;
  PROTOBUF_NODISCARD ::data::AddOddLotOrder* release_addoddlotorder();
  ::data::AddOddLotOrder* mutable_addoddlotorder();
  void set_allocated_addoddlotorder(::data::AddOddLotOrder* addoddlotorder);
  private:
  const ::data::AddOddLotOrder& _internal_addoddlotorder() const;
  ::data::AddOddLotOrder* _internal_mutable_addoddlotorder();
  public:
  void unsafe_arena_set_allocated_addoddlotorder(
      ::data::AddOddLotOrder* addoddlotorder);
  ::data::AddOddLotOrder* unsafe_arena_release_addoddlotorder();

  // .data.AggregateOrderBookUpdate aggregateOrderBookUpdate = 3;
  bool has_aggregateorderbookupdate() const;
  private:
  bool _internal_has_aggregateorderbookupdate() const;
  public:
  void clear_aggregateorderbookupdate();
  const ::data::AggregateOrderBookUpdate& aggregateorderbookupdate() const;
  PROTOBUF_NODISCARD ::data::AggregateOrderBookUpdate* release_aggregateorderbookupdate();
  ::data::AggregateOrderBookUpdate* mutable_aggregateorderbookupdate();
  void set_allocated_aggregateorderbookupdate(::data::AggregateOrderBookUpdate* aggregateorderbookupdate);
  private:
  const ::data::AggregateOrderBookUpdate& _internal_aggregateorderbookupdate() const;
  ::data::AggregateOrderBookUpdate* _internal_mutable_aggregateorderbookupdate();
  public:
  void unsafe_arena_set_allocated_aggregateorderbookupdate(
      ::data::AggregateOrderBookUpdate* aggregateorderbookupdate);
  ::data::AggregateOrderBookUpdate* unsafe_arena_release_aggregateorderbookupdate();

  // .data.BrokerQueue brokerQueue = 4;
  bool has_brokerqueue() const;
  private:
  bool _internal_has_brokerqueue() const;
  public:
  void clear_brokerqueue();
  const ::data::BrokerQueue& brokerqueue() const;
  PROTOBUF_NODISCARD ::data::BrokerQueue* release_brokerqueue();
  ::data::BrokerQueue* mutable_brokerqueue();
  void set_allocated_brokerqueue(::data::BrokerQueue* brokerqueue);
  private:
  const ::data::BrokerQueue& _internal_brokerqueue() const;
  ::data::BrokerQueue* _internal_mutable_brokerqueue();
  public:
  void unsafe_arena_set_allocated_brokerqueue(
      ::data::BrokerQueue* brokerqueue);
  ::data::BrokerQueue* unsafe_arena_release_brokerqueue();

  // .data.ClosingPrice closingPrice = 5;
  bool has_closingprice() const;
  private:
  bool _internal_has_closingprice() const;
  public:
  void clear_closingprice();
  const ::data::ClosingPrice& closingprice() const;
  PROTOBUF_NODISCARD ::data::ClosingPrice* release_closingprice();
  ::data::ClosingPrice* mutable_closingprice();
  void set_allocated_closingprice(::data::ClosingPrice* closingprice);
  private:
  const ::data::ClosingPrice& _internal_closingprice() const;
  ::data::ClosingPrice* _internal_mutable_closingprice();
  public:
  void unsafe_arena_set_allocated_closingprice(
      ::data::ClosingPrice* closingprice);
  ::data::ClosingPrice* unsafe_arena_release_closingprice();

  // .data.CurrencyRate currencyRate = 6;
  bool has_currencyrate() const;
  private:
  bool _internal_has_currencyrate() const;
  public:
  void clear_currencyrate();
  const ::data::CurrencyRate& currencyrate() const;
  PROTOBUF_NODISCARD ::data::CurrencyRate* release_currencyrate();
  ::data::CurrencyRate* mutable_currencyrate();
  void set_allocated_currencyrate(::data::CurrencyRate* currencyrate);
  private:
  const ::data::CurrencyRate& _internal_currencyrate() const;
  ::data::CurrencyRate* _internal_mutable_currencyrate();
  public:
  void unsafe_arena_set_allocated_currencyrate(
      ::data::CurrencyRate* currencyrate);
  ::data::CurrencyRate* unsafe_arena_release_currencyrate();

  // .data.DeleteOddLotOrder deleteOddLotOrder = 7;
  bool has_deleteoddlotorder() const;
  private:
  bool _internal_has_deleteoddlotorder() const;
  public:
  void clear_deleteoddlotorder();
  const ::data::DeleteOddLotOrder& deleteoddlotorder() const;
  PROTOBUF_NODISCARD ::data::DeleteOddLotOrder* release_deleteoddlotorder();
  ::data::DeleteOddLotOrder* mutable_deleteoddlotorder();
  void set_allocated_deleteoddlotorder(::data::DeleteOddLotOrder* deleteoddlotorder);
  private:
  const ::data::DeleteOddLotOrder& _internal_deleteoddlotorder() const;
  ::data::DeleteOddLotOrder* _internal_mutable_deleteoddlotorder();
  public:
  void unsafe_arena_set_allocated_deleteoddlotorder(
      ::data::DeleteOddLotOrder* deleteoddlotorder);
  ::data::DeleteOddLotOrder* unsafe_arena_release_deleteoddlotorder();

  // .data.IndexData indexData = 8;
  bool has_indexdata() const;
  private:
  bool _internal_has_indexdata() const;
  public:
  void clear_indexdata();
  const ::data::IndexData& indexdata() const;
  PROTOBUF_NODISCARD ::data::IndexData* release_indexdata();
  ::data::IndexData* mutable_indexdata();
  void set_allocated_indexdata(::data::IndexData* indexdata);
  private:
  const ::data::IndexData& _internal_indexdata() const;
  ::data::IndexData* _internal_mutable_indexdata();
  public:
  void unsafe_arena_set_allocated_indexdata(
      ::data::IndexData* indexdata);
  ::data::IndexData* unsafe_arena_release_indexdata();

  // .data.IndexDefinition indexDefinition = 9;
  bool has_indexdefinition() const;
  private:
  bool _internal_has_indexdefinition() const;
  public:
  void clear_indexdefinition();
  const ::data::IndexDefinition& indexdefinition() const;
  PROTOBUF_NODISCARD ::data::IndexDefinition* release_indexdefinition();
  ::data::IndexDefinition* mutable_indexdefinition();
  void set_allocated_indexdefinition(::data::IndexDefinition* indexdefinition);
  private:
  const ::data::IndexDefinition& _internal_indexdefinition() const;
  ::data::IndexDefinition* _internal_mutable_indexdefinition();
  public:
  void unsafe_arena_set_allocated_indexdefinition(
      ::data::IndexDefinition* indexdefinition);
  ::data::IndexDefinition* unsafe_arena_release_indexdefinition();

  // .data.IndicativeEquilibriumPrice indicativeEquilibriumPrice = 10;
  bool has_indicativeequilibriumprice() const;
  private:
  bool _internal_has_indicativeequilibriumprice() const;
  public:
  void clear_indicativeequilibriumprice();
  const ::data::IndicativeEquilibriumPrice& indicativeequilibriumprice() const;
  PROTOBUF_NODISCARD ::data::IndicativeEquilibriumPrice* release_indicativeequilibriumprice();
  ::data::IndicativeEquilibriumPrice* mutable_indicativeequilibriumprice();
  void set_allocated_indicativeequilibriumprice(::data::IndicativeEquilibriumPrice* indicativeequilibriumprice);
  private:
  const ::data::IndicativeEquilibriumPrice& _internal_indicativeequilibriumprice() const;
  ::data::IndicativeEquilibriumPrice* _internal_mutable_indicativeequilibriumprice();
  public:
  void unsafe_arena_set_allocated_indicativeequilibriumprice(
      ::data::IndicativeEquilibriumPrice* indicativeequilibriumprice);
  ::data::IndicativeEquilibriumPrice* unsafe_arena_release_indicativeequilibriumprice();

  // .data.LiquidityProvider liquidityProvider = 11;
  bool has_liquidityprovider() const;
  private:
  bool _internal_has_liquidityprovider() const;
  public:
  void clear_liquidityprovider();
  const ::data::LiquidityProvider& liquidityprovider() const;
  PROTOBUF_NODISCARD ::data::LiquidityProvider* release_liquidityprovider();
  ::data::LiquidityProvider* mutable_liquidityprovider();
  void set_allocated_liquidityprovider(::data::LiquidityProvider* liquidityprovider);
  private:
  const ::data::LiquidityProvider& _internal_liquidityprovider() const;
  ::data::LiquidityProvider* _internal_mutable_liquidityprovider();
  public:
  void unsafe_arena_set_allocated_liquidityprovider(
      ::data::LiquidityProvider* liquidityprovider);
  ::data::LiquidityProvider* unsafe_arena_release_liquidityprovider();

  // .data.MarketDefinition marketDefinition = 12;
  bool has_marketdefinition() const;
  private:
  bool _internal_has_marketdefinition() const;
  public:
  void clear_marketdefinition();
  const ::data::MarketDefinition& marketdefinition() const;
  PROTOBUF_NODISCARD ::data::MarketDefinition* release_marketdefinition();
  ::data::MarketDefinition* mutable_marketdefinition();
  void set_allocated_marketdefinition(::data::MarketDefinition* marketdefinition);
  private:
  const ::data::MarketDefinition& _internal_marketdefinition() const;
  ::data::MarketDefinition* _internal_mutable_marketdefinition();
  public:
  void unsafe_arena_set_allocated_marketdefinition(
      ::data::MarketDefinition* marketdefinition);
  ::data::MarketDefinition* unsafe_arena_release_marketdefinition();

  // .data.MarketTurnover marketTurnover = 13;
  bool has_marketturnover() const;
  private:
  bool _internal_has_marketturnover() const;
  public:
  void clear_marketturnover();
  const ::data::MarketTurnover& marketturnover() const;
  PROTOBUF_NODISCARD ::data::MarketTurnover* release_marketturnover();
  ::data::MarketTurnover* mutable_marketturnover();
  void set_allocated_marketturnover(::data::MarketTurnover* marketturnover);
  private:
  const ::data::MarketTurnover& _internal_marketturnover() const;
  ::data::MarketTurnover* _internal_mutable_marketturnover();
  public:
  void unsafe_arena_set_allocated_marketturnover(
      ::data::MarketTurnover* marketturnover);
  ::data::MarketTurnover* unsafe_arena_release_marketturnover();

  // .data.News news = 14;
  bool has_news() const;
  private:
  bool _internal_has_news() const;
  public:
  void clear_news();
  const ::data::News& news() const;
  PROTOBUF_NODISCARD ::data::News* release_news();
  ::data::News* mutable_news();
  void set_allocated_news(::data::News* news);
  private:
  const ::data::News& _internal_news() const;
  ::data::News* _internal_mutable_news();
  public:
  void unsafe_arena_set_allocated_news(
      ::data::News* news);
  ::data::News* unsafe_arena_release_news();

  // .data.NominalPrice nominalPrice = 15;
  bool has_nominalprice() const;
  private:
  bool _internal_has_nominalprice() const;
  public:
  void clear_nominalprice();
  const ::data::NominalPrice& nominalprice() const;
  PROTOBUF_NODISCARD ::data::NominalPrice* release_nominalprice();
  ::data::NominalPrice* mutable_nominalprice();
  void set_allocated_nominalprice(::data::NominalPrice* nominalprice);
  private:
  const ::data::NominalPrice& _internal_nominalprice() const;
  ::data::NominalPrice* _internal_mutable_nominalprice();
  public:
  void unsafe_arena_set_allocated_nominalprice(
      ::data::NominalPrice* nominalprice);
  ::data::NominalPrice* unsafe_arena_release_nominalprice();

  // .data.OrderImbalance orderImbalance = 16;
  bool has_orderimbalance() const;
  private:
  bool _internal_has_orderimbalance() const;
  public:
  void clear_orderimbalance();
  const ::data::OrderImbalance& orderimbalance() const;
  PROTOBUF_NODISCARD ::data::OrderImbalance* release_orderimbalance();
  ::data::OrderImbalance* mutable_orderimbalance();
  void set_allocated_orderimbalance(::data::OrderImbalance* orderimbalance);
  private:
  const ::data::OrderImbalance& _internal_orderimbalance() const;
  ::data::OrderImbalance* _internal_mutable_orderimbalance();
  public:
  void unsafe_arena_set_allocated_orderimbalance(
      ::data::OrderImbalance* orderimbalance);
  ::data::OrderImbalance* unsafe_arena_release_orderimbalance();

  // .data.ReferencePrice referencePrice = 17;
  bool has_referenceprice() const;
  private:
  bool _internal_has_referenceprice() const;
  public:
  void clear_referenceprice();
  const ::data::ReferencePrice& referenceprice() const;
  PROTOBUF_NODISCARD ::data::ReferencePrice* release_referenceprice();
  ::data::ReferencePrice* mutable_referenceprice();
  void set_allocated_referenceprice(::data::ReferencePrice* referenceprice);
  private:
  const ::data::ReferencePrice& _internal_referenceprice() const;
  ::data::ReferencePrice* _internal_mutable_referenceprice();
  public:
  void unsafe_arena_set_allocated_referenceprice(
      ::data::ReferencePrice* referenceprice);
  ::data::ReferencePrice* unsafe_arena_release_referenceprice();

  // .data.SecurityDefinition securityDefinition = 18;
  bool has_securitydefinition() const;
  private:
  bool _internal_has_securitydefinition() const;
  public:
  void clear_securitydefinition();
  const ::data::SecurityDefinition& securitydefinition() const;
  PROTOBUF_NODISCARD ::data::SecurityDefinition* release_securitydefinition();
  ::data::SecurityDefinition* mutable_securitydefinition();
  void set_allocated_securitydefinition(::data::SecurityDefinition* securitydefinition);
  private:
  const ::data::SecurityDefinition& _internal_securitydefinition() const;
  ::data::SecurityDefinition* _internal_mutable_securitydefinition();
  public:
  void unsafe_arena_set_allocated_securitydefinition(
      ::data::SecurityDefinition* securitydefinition);
  ::data::SecurityDefinition* unsafe_arena_release_securitydefinition();

  // .data.SecurityStatus securityStatus = 19;
  bool has_securitystatus() const;
  private:
  bool _internal_has_securitystatus() const;
  public:
  void clear_securitystatus();
  const ::data::SecurityStatus& securitystatus() const;
  PROTOBUF_NODISCARD ::data::SecurityStatus* release_securitystatus();
  ::data::SecurityStatus* mutable_securitystatus();
  void set_allocated_securitystatus(::data::SecurityStatus* securitystatus);
  private:
  const ::data::SecurityStatus& _internal_securitystatus() const;
  ::data::SecurityStatus* _internal_mutable_securitystatus();
  public:
  void unsafe_arena_set_allocated_securitystatus(
      ::data::SecurityStatus* securitystatus);
  ::data::SecurityStatus* unsafe_arena_release_securitystatus();

  // .data.Statistics statistics = 20;
  bool has_statistics() const;
  private:
  bool _internal_has_statistics() const;
  public:
  void clear_statistics();
  const ::data::Statistics& statistics() const;
  PROTOBUF_NODISCARD ::data::Statistics* release_statistics();
  ::data::Statistics* mutable_statistics();
  void set_allocated_statistics(::data::Statistics* statistics);
  private:
  const ::data::Statistics& _internal_statistics() const;
  ::data::Statistics* _internal_mutable_statistics();
  public:
  void unsafe_arena_set_allocated_statistics(
      ::data::Statistics* statistics);
  ::data::Statistics* unsafe_arena_release_statistics();

  // .data.StockConnectDailyQuotaBalance stockConnectDailyQuotaBalance = 21;
  bool has_stockconnectdailyquotabalance() const;
  private:
  bool _internal_has_stockconnectdailyquotabalance() const;
  public:
  void clear_stockconnectdailyquotabalance();
  const ::data::StockConnectDailyQuotaBalance& stockconnectdailyquotabalance() const;
  PROTOBUF_NODISCARD ::data::StockConnectDailyQuotaBalance* release_stockconnectdailyquotabalance();
  ::data::StockConnectDailyQuotaBalance* mutable_stockconnectdailyquotabalance();
  void set_allocated_stockconnectdailyquotabalance(::data::StockConnectDailyQuotaBalance* stockconnectdailyquotabalance);
  private:
  const ::data::StockConnectDailyQuotaBalance& _internal_stockconnectdailyquotabalance() const;
  ::data::StockConnectDailyQuotaBalance* _internal_mutable_stockconnectdailyquotabalance();
  public:
  void unsafe_arena_set_allocated_stockconnectdailyquotabalance(
      ::data::StockConnectDailyQuotaBalance* stockconnectdailyquotabalance);
  ::data::StockConnectDailyQuotaBalance* unsafe_arena_release_stockconnectdailyquotabalance();

  // .data.StockConnectMarketTurnover stockConnectMarketTurnover = 22;
  bool has_stockconnectmarketturnover() const;
  private:
  bool _internal_has_stockconnectmarketturnover() const;
  public:
  void clear_stockconnectmarketturnover();
  const ::data::StockConnectMarketTurnover& stockconnectmarketturnover() const;
  PROTOBUF_NODISCARD ::data::StockConnectMarketTurnover* release_stockconnectmarketturnover();
  ::data::StockConnectMarketTurnover* mutable_stockconnectmarketturnover();
  void set_allocated_stockconnectmarketturnover(::data::StockConnectMarketTurnover* stockconnectmarketturnover);
  private:
  const ::data::StockConnectMarketTurnover& _internal_stockconnectmarketturnover() const;
  ::data::StockConnectMarketTurnover* _internal_mutable_stockconnectmarketturnover();
  public:
  void unsafe_arena_set_allocated_stockconnectmarketturnover(
      ::data::StockConnectMarketTurnover* stockconnectmarketturnover);
  ::data::StockConnectMarketTurnover* unsafe_arena_release_stockconnectmarketturnover();

  // .data.Trade trade = 23;
  bool has_trade() const;
  private:
  bool _internal_has_trade() const;
  public:
  void clear_trade();
  const ::data::Trade& trade() const;
  PROTOBUF_NODISCARD ::data::Trade* release_trade();
  ::data::Trade* mutable_trade();
  void set_allocated_trade(::data::Trade* trade);
  private:
  const ::data::Trade& _internal_trade() const;
  ::data::Trade* _internal_mutable_trade();
  public:
  void unsafe_arena_set_allocated_trade(
      ::data::Trade* trade);
  ::data::Trade* unsafe_arena_release_trade();

  // .data.TradeCancel tradeCancel = 24;
  bool has_tradecancel() const;
  private:
  bool _internal_has_tradecancel() const;
  public:
  void clear_tradecancel();
  const ::data::TradeCancel& tradecancel() const;
  PROTOBUF_NODISCARD ::data::TradeCancel* release_tradecancel();
  ::data::TradeCancel* mutable_tradecancel();
  void set_allocated_tradecancel(::data::TradeCancel* tradecancel);
  private:
  const ::data::TradeCancel& _internal_tradecancel() const;
  ::data::TradeCancel* _internal_mutable_tradecancel();
  public:
  void unsafe_arena_set_allocated_tradecancel(
      ::data::TradeCancel* tradecancel);
  ::data::TradeCancel* unsafe_arena_release_tradecancel();

  // .data.TradingSessionStatus tradingSessionStatus = 25;
  bool has_tradingsessionstatus() const;
  private:
  bool _internal_has_tradingsessionstatus() const;
  public:
  void clear_tradingsessionstatus();
  const ::data::TradingSessionStatus& tradingsessionstatus() const;
  PROTOBUF_NODISCARD ::data::TradingSessionStatus* release_tradingsessionstatus();
  ::data::TradingSessionStatus* mutable_tradingsessionstatus();
  void set_allocated_tradingsessionstatus(::data::TradingSessionStatus* tradingsessionstatus);
  private:
  const ::data::TradingSessionStatus& _internal_tradingsessionstatus() const;
  ::data::TradingSessionStatus* _internal_mutable_tradingsessionstatus();
  public:
  void unsafe_arena_set_allocated_tradingsessionstatus(
      ::data::TradingSessionStatus* tradingsessionstatus);
  ::data::TradingSessionStatus* unsafe_arena_release_tradingsessionstatus();

  // .data.VCMTrigger vCMTrigger = 26;
  bool has_vcmtrigger() const;
  private:
  bool _internal_has_vcmtrigger() const;
  public:
  void clear_vcmtrigger();
  const ::data::VCMTrigger& vcmtrigger() const;
  PROTOBUF_NODISCARD ::data::VCMTrigger* release_vcmtrigger();
  ::data::VCMTrigger* mutable_vcmtrigger();
  void set_allocated_vcmtrigger(::data::VCMTrigger* vcmtrigger);
  private:
  const ::data::VCMTrigger& _internal_vcmtrigger() const;
  ::data::VCMTrigger* _internal_mutable_vcmtrigger();
  public:
  void unsafe_arena_set_allocated_vcmtrigger(
      ::data::VCMTrigger* vcmtrigger);
  ::data::VCMTrigger* unsafe_arena_release_vcmtrigger();

  // .data.Yield yield = 27;
  bool has_yield() const;
  private:
  bool _internal_has_yield() const;
  public:
  void clear_yield();
  const ::data::Yield& yield() const;
  PROTOBUF_NODISCARD ::data::Yield* release_yield();
  ::data::Yield* mutable_yield();
  void set_allocated_yield(::data::Yield* yield);
  private:
  const ::data::Yield& _internal_yield() const;
  ::data::Yield* _internal_mutable_yield();
  public:
  void unsafe_arena_set_allocated_yield(
      ::data::Yield* yield);
  ::data::Yield* unsafe_arena_release_yield();

  // .data.AdjustedClosingPrice adjustedClosingPrice = 28;
  bool has_adjustedclosingprice() const;
  private:
  bool _internal_has_adjustedclosingprice() const;
  public:
  void clear_adjustedclosingprice();
  const ::data::AdjustedClosingPrice& adjustedclosingprice() const;
  PROTOBUF_NODISCARD ::data::AdjustedClosingPrice* release_adjustedclosingprice();
  ::data::AdjustedClosingPrice* mutable_adjustedclosingprice();
  void set_allocated_adjustedclosingprice(::data::AdjustedClosingPrice* adjustedclosingprice);
  private:
  const ::data::AdjustedClosingPrice& _internal_adjustedclosingprice() const;
  ::data::AdjustedClosingPrice* _internal_mutable_adjustedclosingprice();
  public:
  void unsafe_arena_set_allocated_adjustedclosingprice(
      ::data::AdjustedClosingPrice* adjustedclosingprice);
  ::data::AdjustedClosingPrice* unsafe_arena_release_adjustedclosingprice();

  // .data.DayTradeSummary dayTradeSummary = 29;
  bool has_daytradesummary() const;
  private:
  bool _internal_has_daytradesummary() const;
  public:
  void clear_daytradesummary();
  const ::data::DayTradeSummary& daytradesummary() const;
  PROTOBUF_NODISCARD ::data::DayTradeSummary* release_daytradesummary();
  ::data::DayTradeSummary* mutable_daytradesummary();
  void set_allocated_daytradesummary(::data::DayTradeSummary* daytradesummary);
  private:
  const ::data::DayTradeSummary& _internal_daytradesummary() const;
  ::data::DayTradeSummary* _internal_mutable_daytradesummary();
  public:
  void unsafe_arena_set_allocated_daytradesummary(
      ::data::DayTradeSummary* daytradesummary);
  ::data::DayTradeSummary* unsafe_arena_release_daytradesummary();

  // .data.DayTradeSummaryNextShares dayTradeSummaryNextShares = 30;
  bool has_daytradesummarynextshares() const;
  private:
  bool _internal_has_daytradesummarynextshares() const;
  public:
  void clear_daytradesummarynextshares();
  const ::data::DayTradeSummaryNextShares& daytradesummarynextshares() const;
  PROTOBUF_NODISCARD ::data::DayTradeSummaryNextShares* release_daytradesummarynextshares();
  ::data::DayTradeSummaryNextShares* mutable_daytradesummarynextshares();
  void set_allocated_daytradesummarynextshares(::data::DayTradeSummaryNextShares* daytradesummarynextshares);
  private:
  const ::data::DayTradeSummaryNextShares& _internal_daytradesummarynextshares() const;
  ::data::DayTradeSummaryNextShares* _internal_mutable_daytradesummarynextshares();
  public:
  void unsafe_arena_set_allocated_daytradesummarynextshares(
      ::data::DayTradeSummaryNextShares* daytradesummarynextshares);
  ::data::DayTradeSummaryNextShares* unsafe_arena_release_daytradesummarynextshares();

  // .data.IPOInformation iPOInformation = 31;
  bool has_ipoinformation() const;
  private:
  bool _internal_has_ipoinformation() const;
  public:
  void clear_ipoinformation();
  const ::data::IPOInformation& ipoinformation() const;
  PROTOBUF_NODISCARD ::data::IPOInformation* release_ipoinformation();
  ::data::IPOInformation* mutable_ipoinformation();
  void set_allocated_ipoinformation(::data::IPOInformation* ipoinformation);
  private:
  const ::data::IPOInformation& _internal_ipoinformation() const;
  ::data::IPOInformation* _internal_mutable_ipoinformation();
  public:
  void unsafe_arena_set_allocated_ipoinformation(
      ::data::IPOInformation* ipoinformation);
  ::data::IPOInformation* unsafe_arena_release_ipoinformation();

  // .data.IPOQuotingPeriodUpdate iPOQuotingPeriodUpdate = 32;
  bool has_ipoquotingperiodupdate() const;
  private:
  bool _internal_has_ipoquotingperiodupdate() const;
  public:
  void clear_ipoquotingperiodupdate();
  const ::data::IPOQuotingPeriodUpdate& ipoquotingperiodupdate() const;
  PROTOBUF_NODISCARD ::data::IPOQuotingPeriodUpdate* release_ipoquotingperiodupdate();
  ::data::IPOQuotingPeriodUpdate* mutable_ipoquotingperiodupdate();
  void set_allocated_ipoquotingperiodupdate(::data::IPOQuotingPeriodUpdate* ipoquotingperiodupdate);
  private:
  const ::data::IPOQuotingPeriodUpdate& _internal_ipoquotingperiodupdate() const;
  ::data::IPOQuotingPeriodUpdate* _internal_mutable_ipoquotingperiodupdate();
  public:
  void unsafe_arena_set_allocated_ipoquotingperiodupdate(
      ::data::IPOQuotingPeriodUpdate* ipoquotingperiodupdate);
  ::data::IPOQuotingPeriodUpdate* unsafe_arena_release_ipoquotingperiodupdate();

  // .data.LongAdjustedClosingPrice longAdjustedClosingPrice = 33;
  bool has_longadjustedclosingprice() const;
  private:
  bool _internal_has_longadjustedclosingprice() const;
  public:
  void clear_longadjustedclosingprice();
  const ::data::LongAdjustedClosingPrice& longadjustedclosingprice() const;
  PROTOBUF_NODISCARD ::data::LongAdjustedClosingPrice* release_longadjustedclosingprice();
  ::data::LongAdjustedClosingPrice* mutable_longadjustedclosingprice();
  void set_allocated_longadjustedclosingprice(::data::LongAdjustedClosingPrice* longadjustedclosingprice);
  private:
  const ::data::LongAdjustedClosingPrice& _internal_longadjustedclosingprice() const;
  ::data::LongAdjustedClosingPrice* _internal_mutable_longadjustedclosingprice();
  public:
  void unsafe_arena_set_allocated_longadjustedclosingprice(
      ::data::LongAdjustedClosingPrice* longadjustedclosingprice);
  ::data::LongAdjustedClosingPrice* unsafe_arena_release_longadjustedclosingprice();

  // .data.LongDayTradeSummary longDayTradeSummary = 34;
  bool has_longdaytradesummary() const;
  private:
  bool _internal_has_longdaytradesummary() const;
  public:
  void clear_longdaytradesummary();
  const ::data::LongDayTradeSummary& longdaytradesummary() const;
  PROTOBUF_NODISCARD ::data::LongDayTradeSummary* release_longdaytradesummary();
  ::data::LongDayTradeSummary* mutable_longdaytradesummary();
  void set_allocated_longdaytradesummary(::data::LongDayTradeSummary* longdaytradesummary);
  private:
  const ::data::LongDayTradeSummary& _internal_longdaytradesummary() const;
  ::data::LongDayTradeSummary* _internal_mutable_longdaytradesummary();
  public:
  void unsafe_arena_set_allocated_longdaytradesummary(
      ::data::LongDayTradeSummary* longdaytradesummary);
  ::data::LongDayTradeSummary* unsafe_arena_release_longdaytradesummary();

  // .data.LongTradeCancelForNonNextSharesTrades longTradeCancelForNonNextSharesTrades = 35;
  bool has_longtradecancelfornonnextsharestrades() const;
  private:
  bool _internal_has_longtradecancelfornonnextsharestrades() const;
  public:
  void clear_longtradecancelfornonnextsharestrades();
  const ::data::LongTradeCancelForNonNextSharesTrades& longtradecancelfornonnextsharestrades() const;
  PROTOBUF_NODISCARD ::data::LongTradeCancelForNonNextSharesTrades* release_longtradecancelfornonnextsharestrades();
  ::data::LongTradeCancelForNonNextSharesTrades* mutable_longtradecancelfornonnextsharestrades();
  void set_allocated_longtradecancelfornonnextsharestrades(::data::LongTradeCancelForNonNextSharesTrades* longtradecancelfornonnextsharestrades);
  private:
  const ::data::LongTradeCancelForNonNextSharesTrades& _internal_longtradecancelfornonnextsharestrades() const;
  ::data::LongTradeCancelForNonNextSharesTrades* _internal_mutable_longtradecancelfornonnextsharestrades();
  public:
  void unsafe_arena_set_allocated_longtradecancelfornonnextsharestrades(
      ::data::LongTradeCancelForNonNextSharesTrades* longtradecancelfornonnextsharestrades);
  ::data::LongTradeCancelForNonNextSharesTrades* unsafe_arena_release_longtradecancelfornonnextsharestrades();

  // .data.LongTradeCorrectionForNonNextsharesTrades longTradeCorrectionForNonNextsharesTrades = 36;
  bool has_longtradecorrectionfornonnextsharestrades() const;
  private:
  bool _internal_has_longtradecorrectionfornonnextsharestrades() const;
  public:
  void clear_longtradecorrectionfornonnextsharestrades();
  const ::data::LongTradeCorrectionForNonNextsharesTrades& longtradecorrectionfornonnextsharestrades() const;
  PROTOBUF_NODISCARD ::data::LongTradeCorrectionForNonNextsharesTrades* release_longtradecorrectionfornonnextsharestrades();
  ::data::LongTradeCorrectionForNonNextsharesTrades* mutable_longtradecorrectionfornonnextsharestrades();
  void set_allocated_longtradecorrectionfornonnextsharestrades(::data::LongTradeCorrectionForNonNextsharesTrades* longtradecorrectionfornonnextsharestrades);
  private:
  const ::data::LongTradeCorrectionForNonNextsharesTrades& _internal_longtradecorrectionfornonnextsharestrades() const;
  ::data::LongTradeCorrectionForNonNextsharesTrades* _internal_mutable_longtradecorrectionfornonnextsharestrades();
  public:
  void unsafe_arena_set_allocated_longtradecorrectionfornonnextsharestrades(
      ::data::LongTradeCorrectionForNonNextsharesTrades* longtradecorrectionfornonnextsharestrades);
  ::data::LongTradeCorrectionForNonNextsharesTrades* unsafe_arena_release_longtradecorrectionfornonnextsharestrades();

  // .data.LongTradeReportForNonNextshares longTradeReportForNonNextshares = 37;
  bool has_longtradereportfornonnextshares() const;
  private:
  bool _internal_has_longtradereportfornonnextshares() const;
  public:
  void clear_longtradereportfornonnextshares();
  const ::data::LongTradeReportForNonNextshares& longtradereportfornonnextshares() const;
  PROTOBUF_NODISCARD ::data::LongTradeReportForNonNextshares* release_longtradereportfornonnextshares();
  ::data::LongTradeReportForNonNextshares* mutable_longtradereportfornonnextshares();
  void set_allocated_longtradereportfornonnextshares(::data::LongTradeReportForNonNextshares* longtradereportfornonnextshares);
  private:
  const ::data::LongTradeReportForNonNextshares& _internal_longtradereportfornonnextshares() const;
  ::data::LongTradeReportForNonNextshares* _internal_mutable_longtradereportfornonnextshares();
  public:
  void unsafe_arena_set_allocated_longtradereportfornonnextshares(
      ::data::LongTradeReportForNonNextshares* longtradereportfornonnextshares);
  ::data::LongTradeReportForNonNextshares* unsafe_arena_release_longtradereportfornonnextshares();

  // .data.MWCBStatusMessage mWCBStatusMessage = 38;
  bool has_mwcbstatusmessage() const;
  private:
  bool _internal_has_mwcbstatusmessage() const;
  public:
  void clear_mwcbstatusmessage();
  const ::data::MWCBStatusMessage& mwcbstatusmessage() const;
  PROTOBUF_NODISCARD ::data::MWCBStatusMessage* release_mwcbstatusmessage();
  ::data::MWCBStatusMessage* mutable_mwcbstatusmessage();
  void set_allocated_mwcbstatusmessage(::data::MWCBStatusMessage* mwcbstatusmessage);
  private:
  const ::data::MWCBStatusMessage& _internal_mwcbstatusmessage() const;
  ::data::MWCBStatusMessage* _internal_mutable_mwcbstatusmessage();
  public:
  void unsafe_arena_set_allocated_mwcbstatusmessage(
      ::data::MWCBStatusMessage* mwcbstatusmessage);
  ::data::MWCBStatusMessage* unsafe_arena_release_mwcbstatusmessage();

  // .data.MarketWideCircuitBreaker marketWideCircuitBreaker = 39;
  bool has_marketwidecircuitbreaker() const;
  private:
  bool _internal_has_marketwidecircuitbreaker() const;
  public:
  void clear_marketwidecircuitbreaker();
  const ::data::MarketWideCircuitBreaker& marketwidecircuitbreaker() const;
  PROTOBUF_NODISCARD ::data::MarketWideCircuitBreaker* release_marketwidecircuitbreaker();
  ::data::MarketWideCircuitBreaker* mutable_marketwidecircuitbreaker();
  void set_allocated_marketwidecircuitbreaker(::data::MarketWideCircuitBreaker* marketwidecircuitbreaker);
  private:
  const ::data::MarketWideCircuitBreaker& _internal_marketwidecircuitbreaker() const;
  ::data::MarketWideCircuitBreaker* _internal_mutable_marketwidecircuitbreaker();
  public:
  void unsafe_arena_set_allocated_marketwidecircuitbreaker(
      ::data::MarketWideCircuitBreaker* marketwidecircuitbreaker);
  ::data::MarketWideCircuitBreaker* unsafe_arena_release_marketwidecircuitbreaker();

  // .data.OperationalHalt operationalHalt = 40;
  bool has_operationalhalt() const;
  private:
  bool _internal_has_operationalhalt() const;
  public:
  void clear_operationalhalt();
  const ::data::OperationalHalt& operationalhalt() const;
  PROTOBUF_NODISCARD ::data::OperationalHalt* release_operationalhalt();
  ::data::OperationalHalt* mutable_operationalhalt();
  void set_allocated_operationalhalt(::data::OperationalHalt* operationalhalt);
  private:
  const ::data::OperationalHalt& _internal_operationalhalt() const;
  ::data::OperationalHalt* _internal_mutable_operationalhalt();
  public:
  void unsafe_arena_set_allocated_operationalhalt(
      ::data::OperationalHalt* operationalhalt);
  ::data::OperationalHalt* unsafe_arena_release_operationalhalt();

  // .data.SaleConditionModifier saleConditionModifier = 41;
  bool has_saleconditionmodifier() const;
  private:
  bool _internal_has_saleconditionmodifier() const;
  public:
  void clear_saleconditionmodifier();
  const ::data::SaleConditionModifier& saleconditionmodifier() const;
  PROTOBUF_NODISCARD ::data::SaleConditionModifier* release_saleconditionmodifier();
  ::data::SaleConditionModifier* mutable_saleconditionmodifier();
  void set_allocated_saleconditionmodifier(::data::SaleConditionModifier* saleconditionmodifier);
  private:
  const ::data::SaleConditionModifier& _internal_saleconditionmodifier() const;
  ::data::SaleConditionModifier* _internal_mutable_saleconditionmodifier();
  public:
  void unsafe_arena_set_allocated_saleconditionmodifier(
      ::data::SaleConditionModifier* saleconditionmodifier);
  ::data::SaleConditionModifier* unsafe_arena_release_saleconditionmodifier();

  // .data.ShortSaleRestrictionIndicatorMessage shortSaleRestrictionIndicatorMessage = 42;
  bool has_shortsalerestrictionindicatormessage() const;
  private:
  bool _internal_has_shortsalerestrictionindicatormessage() const;
  public:
  void clear_shortsalerestrictionindicatormessage();
  const ::data::ShortSaleRestrictionIndicatorMessage& shortsalerestrictionindicatormessage() const;
  PROTOBUF_NODISCARD ::data::ShortSaleRestrictionIndicatorMessage* release_shortsalerestrictionindicatormessage();
  ::data::ShortSaleRestrictionIndicatorMessage* mutable_shortsalerestrictionindicatormessage();
  void set_allocated_shortsalerestrictionindicatormessage(::data::ShortSaleRestrictionIndicatorMessage* shortsalerestrictionindicatormessage);
  private:
  const ::data::ShortSaleRestrictionIndicatorMessage& _internal_shortsalerestrictionindicatormessage() const;
  ::data::ShortSaleRestrictionIndicatorMessage* _internal_mutable_shortsalerestrictionindicatormessage();
  public:
  void unsafe_arena_set_allocated_shortsalerestrictionindicatormessage(
      ::data::ShortSaleRestrictionIndicatorMessage* shortsalerestrictionindicatormessage);
  ::data::ShortSaleRestrictionIndicatorMessage* unsafe_arena_release_shortsalerestrictionindicatormessage();

  // .data.StockDirectory stockDirectory = 43;
  bool has_stockdirectory() const;
  private:
  bool _internal_has_stockdirectory() const;
  public:
  void clear_stockdirectory();
  const ::data::StockDirectory& stockdirectory() const;
  PROTOBUF_NODISCARD ::data::StockDirectory* release_stockdirectory();
  ::data::StockDirectory* mutable_stockdirectory();
  void set_allocated_stockdirectory(::data::StockDirectory* stockdirectory);
  private:
  const ::data::StockDirectory& _internal_stockdirectory() const;
  ::data::StockDirectory* _internal_mutable_stockdirectory();
  public:
  void unsafe_arena_set_allocated_stockdirectory(
      ::data::StockDirectory* stockdirectory);
  ::data::StockDirectory* unsafe_arena_release_stockdirectory();

  // .data.StockTradingAction stockTradingAction = 44;
  bool has_stocktradingaction() const;
  private:
  bool _internal_has_stocktradingaction() const;
  public:
  void clear_stocktradingaction();
  const ::data::StockTradingAction& stocktradingaction() const;
  PROTOBUF_NODISCARD ::data::StockTradingAction* release_stocktradingaction();
  ::data::StockTradingAction* mutable_stocktradingaction();
  void set_allocated_stocktradingaction(::data::StockTradingAction* stocktradingaction);
  private:
  const ::data::StockTradingAction& _internal_stocktradingaction() const;
  ::data::StockTradingAction* _internal_mutable_stocktradingaction();
  public:
  void unsafe_arena_set_allocated_stocktradingaction(
      ::data::StockTradingAction* stocktradingaction);
  ::data::StockTradingAction* unsafe_arena_release_stocktradingaction();

  // .data.SystemEventMessage systemEventMessage = 45;
  bool has_systemeventmessage() const;
  private:
  bool _internal_has_systemeventmessage() const;
  public:
  void clear_systemeventmessage();
  const ::data::SystemEventMessage& systemeventmessage() const;
  PROTOBUF_NODISCARD ::data::SystemEventMessage* release_systemeventmessage();
  ::data::SystemEventMessage* mutable_systemeventmessage();
  void set_allocated_systemeventmessage(::data::SystemEventMessage* systemeventmessage);
  private:
  const ::data::SystemEventMessage& _internal_systemeventmessage() const;
  ::data::SystemEventMessage* _internal_mutable_systemeventmessage();
  public:
  void unsafe_arena_set_allocated_systemeventmessage(
      ::data::SystemEventMessage* systemeventmessage);
  ::data::SystemEventMessage* unsafe_arena_release_systemeventmessage();

  // .data.TradeCancelForNextsharesTrades tradeCancelForNextsharesTrades = 46;
  bool has_tradecancelfornextsharestrades() const;
  private:
  bool _internal_has_tradecancelfornextsharestrades() const;
  public:
  void clear_tradecancelfornextsharestrades();
  const ::data::TradeCancelForNextsharesTrades& tradecancelfornextsharestrades() const;
  PROTOBUF_NODISCARD ::data::TradeCancelForNextsharesTrades* release_tradecancelfornextsharestrades();
  ::data::TradeCancelForNextsharesTrades* mutable_tradecancelfornextsharestrades();
  void set_allocated_tradecancelfornextsharestrades(::data::TradeCancelForNextsharesTrades* tradecancelfornextsharestrades);
  private:
  const ::data::TradeCancelForNextsharesTrades& _internal_tradecancelfornextsharestrades() const;
  ::data::TradeCancelForNextsharesTrades* _internal_mutable_tradecancelfornextsharestrades();
  public:
  void unsafe_arena_set_allocated_tradecancelfornextsharestrades(
      ::data::TradeCancelForNextsharesTrades* tradecancelfornextsharestrades);
  ::data::TradeCancelForNextsharesTrades* unsafe_arena_release_tradecancelfornextsharestrades();

  // .data.TradeCancelForNonNextSharesTrades tradeCancelForNonNextSharesTrades = 47;
  bool has_tradecancelfornonnextsharestrades() const;
  private:
  bool _internal_has_tradecancelfornonnextsharestrades() const;
  public:
  void clear_tradecancelfornonnextsharestrades();
  const ::data::TradeCancelForNonNextSharesTrades& tradecancelfornonnextsharestrades() const;
  PROTOBUF_NODISCARD ::data::TradeCancelForNonNextSharesTrades* release_tradecancelfornonnextsharestrades();
  ::data::TradeCancelForNonNextSharesTrades* mutable_tradecancelfornonnextsharestrades();
  void set_allocated_tradecancelfornonnextsharestrades(::data::TradeCancelForNonNextSharesTrades* tradecancelfornonnextsharestrades);
  private:
  const ::data::TradeCancelForNonNextSharesTrades& _internal_tradecancelfornonnextsharestrades() const;
  ::data::TradeCancelForNonNextSharesTrades* _internal_mutable_tradecancelfornonnextsharestrades();
  public:
  void unsafe_arena_set_allocated_tradecancelfornonnextsharestrades(
      ::data::TradeCancelForNonNextSharesTrades* tradecancelfornonnextsharestrades);
  ::data::TradeCancelForNonNextSharesTrades* unsafe_arena_release_tradecancelfornonnextsharestrades();

  // .data.TradeCorrectionForNextsharesTrades tradeCorrectionForNextsharesTrades = 48;
  bool has_tradecorrectionfornextsharestrades() const;
  private:
  bool _internal_has_tradecorrectionfornextsharestrades() const;
  public:
  void clear_tradecorrectionfornextsharestrades();
  const ::data::TradeCorrectionForNextsharesTrades& tradecorrectionfornextsharestrades() const;
  PROTOBUF_NODISCARD ::data::TradeCorrectionForNextsharesTrades* release_tradecorrectionfornextsharestrades();
  ::data::TradeCorrectionForNextsharesTrades* mutable_tradecorrectionfornextsharestrades();
  void set_allocated_tradecorrectionfornextsharestrades(::data::TradeCorrectionForNextsharesTrades* tradecorrectionfornextsharestrades);
  private:
  const ::data::TradeCorrectionForNextsharesTrades& _internal_tradecorrectionfornextsharestrades() const;
  ::data::TradeCorrectionForNextsharesTrades* _internal_mutable_tradecorrectionfornextsharestrades();
  public:
  void unsafe_arena_set_allocated_tradecorrectionfornextsharestrades(
      ::data::TradeCorrectionForNextsharesTrades* tradecorrectionfornextsharestrades);
  ::data::TradeCorrectionForNextsharesTrades* unsafe_arena_release_tradecorrectionfornextsharestrades();

  // .data.TradeCorrectionForNonNextsharesTrades tradeCorrectionForNonNextsharesTrades = 49;
  bool has_tradecorrectionfornonnextsharestrades() const;
  private:
  bool _internal_has_tradecorrectionfornonnextsharestrades() const;
  public:
  void clear_tradecorrectionfornonnextsharestrades();
  const ::data::TradeCorrectionForNonNextsharesTrades& tradecorrectionfornonnextsharestrades() const;
  PROTOBUF_NODISCARD ::data::TradeCorrectionForNonNextsharesTrades* release_tradecorrectionfornonnextsharestrades();
  ::data::TradeCorrectionForNonNextsharesTrades* mutable_tradecorrectionfornonnextsharestrades();
  void set_allocated_tradecorrectionfornonnextsharestrades(::data::TradeCorrectionForNonNextsharesTrades* tradecorrectionfornonnextsharestrades);
  private:
  const ::data::TradeCorrectionForNonNextsharesTrades& _internal_tradecorrectionfornonnextsharestrades() const;
  ::data::TradeCorrectionForNonNextsharesTrades* _internal_mutable_tradecorrectionfornonnextsharestrades();
  public:
  void unsafe_arena_set_allocated_tradecorrectionfornonnextsharestrades(
      ::data::TradeCorrectionForNonNextsharesTrades* tradecorrectionfornonnextsharestrades);
  ::data::TradeCorrectionForNonNextsharesTrades* unsafe_arena_release_tradecorrectionfornonnextsharestrades();

  // .data.TradeReportForNextshares tradeReportForNextshares = 50;
  bool has_tradereportfornextshares() const;
  private:
  bool _internal_has_tradereportfornextshares() const;
  public:
  void clear_tradereportfornextshares();
  const ::data::TradeReportForNextshares& tradereportfornextshares() const;
  PROTOBUF_NODISCARD ::data::TradeReportForNextshares* release_tradereportfornextshares();
  ::data::TradeReportForNextshares* mutable_tradereportfornextshares();
  void set_allocated_tradereportfornextshares(::data::TradeReportForNextshares* tradereportfornextshares);
  private:
  const ::data::TradeReportForNextshares& _internal_tradereportfornextshares() const;
  ::data::TradeReportForNextshares* _internal_mutable_tradereportfornextshares();
  public:
  void unsafe_arena_set_allocated_tradereportfornextshares(
      ::data::TradeReportForNextshares* tradereportfornextshares);
  ::data::TradeReportForNextshares* unsafe_arena_release_tradereportfornextshares();

  // .data.TradeReportForNonNextshares tradeReportForNonNextshares = 51;
  bool has_tradereportfornonnextshares() const;
  private:
  bool _internal_has_tradereportfornonnextshares() const;
  public:
  void clear_tradereportfornonnextshares();
  const ::data::TradeReportForNonNextshares& tradereportfornonnextshares() const;
  PROTOBUF_NODISCARD ::data::TradeReportForNonNextshares* release_tradereportfornonnextshares();
  ::data::TradeReportForNonNextshares* mutable_tradereportfornonnextshares();
  void set_allocated_tradereportfornonnextshares(::data::TradeReportForNonNextshares* tradereportfornonnextshares);
  private:
  const ::data::TradeReportForNonNextshares& _internal_tradereportfornonnextshares() const;
  ::data::TradeReportForNonNextshares* _internal_mutable_tradereportfornonnextshares();
  public:
  void unsafe_arena_set_allocated_tradereportfornonnextshares(
      ::data::TradeReportForNonNextshares* tradereportfornonnextshares);
  ::data::TradeReportForNonNextshares* unsafe_arena_release_tradereportfornonnextshares();

  // .data.QBBOMWCBBreachMessage qBBOMWCBBreachMessage = 52;
  bool has_qbbomwcbbreachmessage() const;
  private:
  bool _internal_has_qbbomwcbbreachmessage() const;
  public:
  void clear_qbbomwcbbreachmessage();
  const ::data::QBBOMWCBBreachMessage& qbbomwcbbreachmessage() const;
  PROTOBUF_NODISCARD ::data::QBBOMWCBBreachMessage* release_qbbomwcbbreachmessage();
  ::data::QBBOMWCBBreachMessage* mutable_qbbomwcbbreachmessage();
  void set_allocated_qbbomwcbbreachmessage(::data::QBBOMWCBBreachMessage* qbbomwcbbreachmessage);
  private:
  const ::data::QBBOMWCBBreachMessage& _internal_qbbomwcbbreachmessage() const;
  ::data::QBBOMWCBBreachMessage* _internal_mutable_qbbomwcbbreachmessage();
  public:
  void unsafe_arena_set_allocated_qbbomwcbbreachmessage(
      ::data::QBBOMWCBBreachMessage* qbbomwcbbreachmessage);
  ::data::QBBOMWCBBreachMessage* unsafe_arena_release_qbbomwcbbreachmessage();

  // .data.QBBOMWCBDeclineLevelMessage qBBOMWCBDeclineLevelMessage = 53;
  bool has_qbbomwcbdeclinelevelmessage() const;
  private:
  bool _internal_has_qbbomwcbdeclinelevelmessage() const;
  public:
  void clear_qbbomwcbdeclinelevelmessage();
  const ::data::QBBOMWCBDeclineLevelMessage& qbbomwcbdeclinelevelmessage() const;
  PROTOBUF_NODISCARD ::data::QBBOMWCBDeclineLevelMessage* release_qbbomwcbdeclinelevelmessage();
  ::data::QBBOMWCBDeclineLevelMessage* mutable_qbbomwcbdeclinelevelmessage();
  void set_allocated_qbbomwcbdeclinelevelmessage(::data::QBBOMWCBDeclineLevelMessage* qbbomwcbdeclinelevelmessage);
  private:
  const ::data::QBBOMWCBDeclineLevelMessage& _internal_qbbomwcbdeclinelevelmessage() const;
  ::data::QBBOMWCBDeclineLevelMessage* _internal_mutable_qbbomwcbdeclinelevelmessage();
  public:
  void unsafe_arena_set_allocated_qbbomwcbdeclinelevelmessage(
      ::data::QBBOMWCBDeclineLevelMessage* qbbomwcbdeclinelevelmessage);
  ::data::QBBOMWCBDeclineLevelMessage* unsafe_arena_release_qbbomwcbdeclinelevelmessage();

  // .data.QBBONextSharesQuotationMessage qBBONextSharesQuotationMessage = 54;
  bool has_qbbonextsharesquotationmessage() const;
  private:
  bool _internal_has_qbbonextsharesquotationmessage() const;
  public:
  void clear_qbbonextsharesquotationmessage();
  const ::data::QBBONextSharesQuotationMessage& qbbonextsharesquotationmessage() const;
  PROTOBUF_NODISCARD ::data::QBBONextSharesQuotationMessage* release_qbbonextsharesquotationmessage();
  ::data::QBBONextSharesQuotationMessage* mutable_qbbonextsharesquotationmessage();
  void set_allocated_qbbonextsharesquotationmessage(::data::QBBONextSharesQuotationMessage* qbbonextsharesquotationmessage);
  private:
  const ::data::QBBONextSharesQuotationMessage& _internal_qbbonextsharesquotationmessage() const;
  ::data::QBBONextSharesQuotationMessage* _internal_mutable_qbbonextsharesquotationmessage();
  public:
  void unsafe_arena_set_allocated_qbbonextsharesquotationmessage(
      ::data::QBBONextSharesQuotationMessage* qbbonextsharesquotationmessage);
  ::data::QBBONextSharesQuotationMessage* unsafe_arena_release_qbbonextsharesquotationmessage();

  // .data.QBBOOperationalHalt qBBOOperationalHalt = 55;
  bool has_qbbooperationalhalt() const;
  private:
  bool _internal_has_qbbooperationalhalt() const;
  public:
  void clear_qbbooperationalhalt();
  const ::data::QBBOOperationalHalt& qbbooperationalhalt() const;
  PROTOBUF_NODISCARD ::data::QBBOOperationalHalt* release_qbbooperationalhalt();
  ::data::QBBOOperationalHalt* mutable_qbbooperationalhalt();
  void set_allocated_qbbooperationalhalt(::data::QBBOOperationalHalt* qbbooperationalhalt);
  private:
  const ::data::QBBOOperationalHalt& _internal_qbbooperationalhalt() const;
  ::data::QBBOOperationalHalt* _internal_mutable_qbbooperationalhalt();
  public:
  void unsafe_arena_set_allocated_qbbooperationalhalt(
      ::data::QBBOOperationalHalt* qbbooperationalhalt);
  ::data::QBBOOperationalHalt* unsafe_arena_release_qbbooperationalhalt();

  // .data.QBBOQuotationMessage qBBOQuotationMessage = 56;
  bool has_qbboquotationmessage() const;
  private:
  bool _internal_has_qbboquotationmessage() const;
  public:
  void clear_qbboquotationmessage();
  const ::data::QBBOQuotationMessage& qbboquotationmessage() const;
  PROTOBUF_NODISCARD ::data::QBBOQuotationMessage* release_qbboquotationmessage();
  ::data::QBBOQuotationMessage* mutable_qbboquotationmessage();
  void set_allocated_qbboquotationmessage(::data::QBBOQuotationMessage* qbboquotationmessage);
  private:
  const ::data::QBBOQuotationMessage& _internal_qbboquotationmessage() const;
  ::data::QBBOQuotationMessage* _internal_mutable_qbboquotationmessage();
  public:
  void unsafe_arena_set_allocated_qbboquotationmessage(
      ::data::QBBOQuotationMessage* qbboquotationmessage);
  ::data::QBBOQuotationMessage* unsafe_arena_release_qbboquotationmessage();

  // .data.QBBORegShoRestriction qBBORegShoRestriction = 57;
  bool has_qbboregshorestriction() const;
  private:
  bool _internal_has_qbboregshorestriction() const;
  public:
  void clear_qbboregshorestriction();
  const ::data::QBBORegShoRestriction& qbboregshorestriction() const;
  PROTOBUF_NODISCARD ::data::QBBORegShoRestriction* release_qbboregshorestriction();
  ::data::QBBORegShoRestriction* mutable_qbboregshorestriction();
  void set_allocated_qbboregshorestriction(::data::QBBORegShoRestriction* qbboregshorestriction);
  private:
  const ::data::QBBORegShoRestriction& _internal_qbboregshorestriction() const;
  ::data::QBBORegShoRestriction* _internal_mutable_qbboregshorestriction();
  public:
  void unsafe_arena_set_allocated_qbboregshorestriction(
      ::data::QBBORegShoRestriction* qbboregshorestriction);
  ::data::QBBORegShoRestriction* unsafe_arena_release_qbboregshorestriction();

  // .data.QBBOStockDirectory qBBOStockDirectory = 58;
  bool has_qbbostockdirectory() const;
  private:
  bool _internal_has_qbbostockdirectory() const;
  public:
  void clear_qbbostockdirectory();
  const ::data::QBBOStockDirectory& qbbostockdirectory() const;
  PROTOBUF_NODISCARD ::data::QBBOStockDirectory* release_qbbostockdirectory();
  ::data::QBBOStockDirectory* mutable_qbbostockdirectory();
  void set_allocated_qbbostockdirectory(::data::QBBOStockDirectory* qbbostockdirectory);
  private:
  const ::data::QBBOStockDirectory& _internal_qbbostockdirectory() const;
  ::data::QBBOStockDirectory* _internal_mutable_qbbostockdirectory();
  public:
  void unsafe_arena_set_allocated_qbbostockdirectory(
      ::data::QBBOStockDirectory* qbbostockdirectory);
  ::data::QBBOStockDirectory* unsafe_arena_release_qbbostockdirectory();

  // .data.QBBOStockTradingAction qBBOStockTradingAction = 59;
  bool has_qbbostocktradingaction() const;
  private:
  bool _internal_has_qbbostocktradingaction() const;
  public:
  void clear_qbbostocktradingaction();
  const ::data::QBBOStockTradingAction& qbbostocktradingaction() const;
  PROTOBUF_NODISCARD ::data::QBBOStockTradingAction* release_qbbostocktradingaction();
  ::data::QBBOStockTradingAction* mutable_qbbostocktradingaction();
  void set_allocated_qbbostocktradingaction(::data::QBBOStockTradingAction* qbbostocktradingaction);
  private:
  const ::data::QBBOStockTradingAction& _internal_qbbostocktradingaction() const;
  ::data::QBBOStockTradingAction* _internal_mutable_qbbostocktradingaction();
  public:
  void unsafe_arena_set_allocated_qbbostocktradingaction(
      ::data::QBBOStockTradingAction* qbbostocktradingaction);
  ::data::QBBOStockTradingAction* unsafe_arena_release_qbbostocktradingaction();

  // .data.QBBOSystemEventMessage qBBOSystemEventMessage = 60;
  bool has_qbbosystemeventmessage() const;
  private:
  bool _internal_has_qbbosystemeventmessage() const;
  public:
  void clear_qbbosystemeventmessage();
  const ::data::QBBOSystemEventMessage& qbbosystemeventmessage() const;
  PROTOBUF_NODISCARD ::data::QBBOSystemEventMessage* release_qbbosystemeventmessage();
  ::data::QBBOSystemEventMessage* mutable_qbbosystemeventmessage();
  void set_allocated_qbbosystemeventmessage(::data::QBBOSystemEventMessage* qbbosystemeventmessage);
  private:
  const ::data::QBBOSystemEventMessage& _internal_qbbosystemeventmessage() const;
  ::data::QBBOSystemEventMessage* _internal_mutable_qbbosystemeventmessage();
  public:
  void unsafe_arena_set_allocated_qbbosystemeventmessage(
      ::data::QBBOSystemEventMessage* qbbosystemeventmessage);
  ::data::QBBOSystemEventMessage* unsafe_arena_release_qbbosystemeventmessage();

  // .data.QBBOIPOQuotingPeriodUpdate qBBOIPOQuotingPeriodUpdate = 61;
  bool has_qbboipoquotingperiodupdate() const;
  private:
  bool _internal_has_qbboipoquotingperiodupdate() const;
  public:
  void clear_qbboipoquotingperiodupdate();
  const ::data::QBBOIPOQuotingPeriodUpdate& qbboipoquotingperiodupdate() const;
  PROTOBUF_NODISCARD ::data::QBBOIPOQuotingPeriodUpdate* release_qbboipoquotingperiodupdate();
  ::data::QBBOIPOQuotingPeriodUpdate* mutable_qbboipoquotingperiodupdate();
  void set_allocated_qbboipoquotingperiodupdate(::data::QBBOIPOQuotingPeriodUpdate* qbboipoquotingperiodupdate);
  private:
  const ::data::QBBOIPOQuotingPeriodUpdate& _internal_qbboipoquotingperiodupdate() const;
  ::data::QBBOIPOQuotingPeriodUpdate* _internal_mutable_qbboipoquotingperiodupdate();
  public:
  void unsafe_arena_set_allocated_qbboipoquotingperiodupdate(
      ::data::QBBOIPOQuotingPeriodUpdate* qbboipoquotingperiodupdate);
  ::data::QBBOIPOQuotingPeriodUpdate* unsafe_arena_release_qbboipoquotingperiodupdate();

  // .data.CertificationMsg certificationMsg = 62;
  bool has_certificationmsg() const;
  private:
  bool _internal_has_certificationmsg() const;
  public:
  void clear_certificationmsg();
  const ::data::CertificationMsg& certificationmsg() const;
  PROTOBUF_NODISCARD ::data::CertificationMsg* release_certificationmsg();
  ::data::CertificationMsg* mutable_certificationmsg();
  void set_allocated_certificationmsg(::data::CertificationMsg* certificationmsg);
  private:
  const ::data::CertificationMsg& _internal_certificationmsg() const;
  ::data::CertificationMsg* _internal_mutable_certificationmsg();
  public:
  void unsafe_arena_set_allocated_certificationmsg(
      ::data::CertificationMsg* certificationmsg);
  ::data::CertificationMsg* unsafe_arena_release_certificationmsg();

  // .data.CNMarketDefinition cNMarketDefinition = 63;
  bool has_cnmarketdefinition() const;
  private:
  bool _internal_has_cnmarketdefinition() const;
  public:
  void clear_cnmarketdefinition();
  const ::data::CNMarketDefinition& cnmarketdefinition() const;
  PROTOBUF_NODISCARD ::data::CNMarketDefinition* release_cnmarketdefinition();
  ::data::CNMarketDefinition* mutable_cnmarketdefinition();
  void set_allocated_cnmarketdefinition(::data::CNMarketDefinition* cnmarketdefinition);
  private:
  const ::data::CNMarketDefinition& _internal_cnmarketdefinition() const;
  ::data::CNMarketDefinition* _internal_mutable_cnmarketdefinition();
  public:
  void unsafe_arena_set_allocated_cnmarketdefinition(
      ::data::CNMarketDefinition* cnmarketdefinition);
  ::data::CNMarketDefinition* unsafe_arena_release_cnmarketdefinition();

  // .data.CNSecurityDefinition cNSecurityDefinition = 64;
  bool has_cnsecuritydefinition() const;
  private:
  bool _internal_has_cnsecuritydefinition() const;
  public:
  void clear_cnsecuritydefinition();
  const ::data::CNSecurityDefinition& cnsecuritydefinition() const;
  PROTOBUF_NODISCARD ::data::CNSecurityDefinition* release_cnsecuritydefinition();
  ::data::CNSecurityDefinition* mutable_cnsecuritydefinition();
  void set_allocated_cnsecuritydefinition(::data::CNSecurityDefinition* cnsecuritydefinition);
  private:
  const ::data::CNSecurityDefinition& _internal_cnsecuritydefinition() const;
  ::data::CNSecurityDefinition* _internal_mutable_cnsecuritydefinition();
  public:
  void unsafe_arena_set_allocated_cnsecuritydefinition(
      ::data::CNSecurityDefinition* cnsecuritydefinition);
  ::data::CNSecurityDefinition* unsafe_arena_release_cnsecuritydefinition();

  // .data.CNSecurityStatus cNSecurityStatus = 65;
  bool has_cnsecuritystatus() const;
  private:
  bool _internal_has_cnsecuritystatus() const;
  public:
  void clear_cnsecuritystatus();
  const ::data::CNSecurityStatus& cnsecuritystatus() const;
  PROTOBUF_NODISCARD ::data::CNSecurityStatus* release_cnsecuritystatus();
  ::data::CNSecurityStatus* mutable_cnsecuritystatus();
  void set_allocated_cnsecuritystatus(::data::CNSecurityStatus* cnsecuritystatus);
  private:
  const ::data::CNSecurityStatus& _internal_cnsecuritystatus() const;
  ::data::CNSecurityStatus* _internal_mutable_cnsecuritystatus();
  public:
  void unsafe_arena_set_allocated_cnsecuritystatus(
      ::data::CNSecurityStatus* cnsecuritystatus);
  ::data::CNSecurityStatus* unsafe_arena_release_cnsecuritystatus();

  // .data.CNStatistics cNStatistics = 66;
  bool has_cnstatistics() const;
  private:
  bool _internal_has_cnstatistics() const;
  public:
  void clear_cnstatistics();
  const ::data::CNStatistics& cnstatistics() const;
  PROTOBUF_NODISCARD ::data::CNStatistics* release_cnstatistics();
  ::data::CNStatistics* mutable_cnstatistics();
  void set_allocated_cnstatistics(::data::CNStatistics* cnstatistics);
  private:
  const ::data::CNStatistics& _internal_cnstatistics() const;
  ::data::CNStatistics* _internal_mutable_cnstatistics();
  public:
  void unsafe_arena_set_allocated_cnstatistics(
      ::data::CNStatistics* cnstatistics);
  ::data::CNStatistics* unsafe_arena_release_cnstatistics();

  // .data.CNTopBook cNTopBook = 67;
  bool has_cntopbook() const;
  private:
  bool _internal_has_cntopbook() const;
  public:
  void clear_cntopbook();
  const ::data::CNTopBook& cntopbook() const;
  PROTOBUF_NODISCARD ::data::CNTopBook* release_cntopbook();
  ::data::CNTopBook* mutable_cntopbook();
  void set_allocated_cntopbook(::data::CNTopBook* cntopbook);
  private:
  const ::data::CNTopBook& _internal_cntopbook() const;
  ::data::CNTopBook* _internal_mutable_cntopbook();
  public:
  void unsafe_arena_set_allocated_cntopbook(
      ::data::CNTopBook* cntopbook);
  ::data::CNTopBook* unsafe_arena_release_cntopbook();

  void clear_dataBody();
  DataBodyCase dataBody_case() const;
  // @@protoc_insertion_point(class_scope:data.Message)
 private:
  class _Internal;
  void set_has_addoddlotorder();
  void set_has_aggregateorderbookupdate();
  void set_has_brokerqueue();
  void set_has_closingprice();
  void set_has_currencyrate();
  void set_has_deleteoddlotorder();
  void set_has_indexdata();
  void set_has_indexdefinition();
  void set_has_indicativeequilibriumprice();
  void set_has_liquidityprovider();
  void set_has_marketdefinition();
  void set_has_marketturnover();
  void set_has_news();
  void set_has_nominalprice();
  void set_has_orderimbalance();
  void set_has_referenceprice();
  void set_has_securitydefinition();
  void set_has_securitystatus();
  void set_has_statistics();
  void set_has_stockconnectdailyquotabalance();
  void set_has_stockconnectmarketturnover();
  void set_has_trade();
  void set_has_tradecancel();
  void set_has_tradingsessionstatus();
  void set_has_vcmtrigger();
  void set_has_yield();
  void set_has_adjustedclosingprice();
  void set_has_daytradesummary();
  void set_has_daytradesummarynextshares();
  void set_has_ipoinformation();
  void set_has_ipoquotingperiodupdate();
  void set_has_longadjustedclosingprice();
  void set_has_longdaytradesummary();
  void set_has_longtradecancelfornonnextsharestrades();
  void set_has_longtradecorrectionfornonnextsharestrades();
  void set_has_longtradereportfornonnextshares();
  void set_has_mwcbstatusmessage();
  void set_has_marketwidecircuitbreaker();
  void set_has_operationalhalt();
  void set_has_saleconditionmodifier();
  void set_has_shortsalerestrictionindicatormessage();
  void set_has_stockdirectory();
  void set_has_stocktradingaction();
  void set_has_systemeventmessage();
  void set_has_tradecancelfornextsharestrades();
  void set_has_tradecancelfornonnextsharestrades();
  void set_has_tradecorrectionfornextsharestrades();
  void set_has_tradecorrectionfornonnextsharestrades();
  void set_has_tradereportfornextshares();
  void set_has_tradereportfornonnextshares();
  void set_has_qbbomwcbbreachmessage();
  void set_has_qbbomwcbdeclinelevelmessage();
  void set_has_qbbonextsharesquotationmessage();
  void set_has_qbbooperationalhalt();
  void set_has_qbboquotationmessage();
  void set_has_qbboregshorestriction();
  void set_has_qbbostockdirectory();
  void set_has_qbbostocktradingaction();
  void set_has_qbbosystemeventmessage();
  void set_has_qbboipoquotingperiodupdate();
  void set_has_certificationmsg();
  void set_has_cnmarketdefinition();
  void set_has_cnsecuritydefinition();
  void set_has_cnsecuritystatus();
  void set_has_cnstatistics();
  void set_has_cntopbook();

  inline bool has_dataBody() const;
  inline void clear_has_dataBody();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int64_t timestamp_;
    int data_type_;
    union DataBodyUnion {
      constexpr DataBodyUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::data::AddOddLotOrder* addoddlotorder_;
      ::data::AggregateOrderBookUpdate* aggregateorderbookupdate_;
      ::data::BrokerQueue* brokerqueue_;
      ::data::ClosingPrice* closingprice_;
      ::data::CurrencyRate* currencyrate_;
      ::data::DeleteOddLotOrder* deleteoddlotorder_;
      ::data::IndexData* indexdata_;
      ::data::IndexDefinition* indexdefinition_;
      ::data::IndicativeEquilibriumPrice* indicativeequilibriumprice_;
      ::data::LiquidityProvider* liquidityprovider_;
      ::data::MarketDefinition* marketdefinition_;
      ::data::MarketTurnover* marketturnover_;
      ::data::News* news_;
      ::data::NominalPrice* nominalprice_;
      ::data::OrderImbalance* orderimbalance_;
      ::data::ReferencePrice* referenceprice_;
      ::data::SecurityDefinition* securitydefinition_;
      ::data::SecurityStatus* securitystatus_;
      ::data::Statistics* statistics_;
      ::data::StockConnectDailyQuotaBalance* stockconnectdailyquotabalance_;
      ::data::StockConnectMarketTurnover* stockconnectmarketturnover_;
      ::data::Trade* trade_;
      ::data::TradeCancel* tradecancel_;
      ::data::TradingSessionStatus* tradingsessionstatus_;
      ::data::VCMTrigger* vcmtrigger_;
      ::data::Yield* yield_;
      ::data::AdjustedClosingPrice* adjustedclosingprice_;
      ::data::DayTradeSummary* daytradesummary_;
      ::data::DayTradeSummaryNextShares* daytradesummarynextshares_;
      ::data::IPOInformation* ipoinformation_;
      ::data::IPOQuotingPeriodUpdate* ipoquotingperiodupdate_;
      ::data::LongAdjustedClosingPrice* longadjustedclosingprice_;
      ::data::LongDayTradeSummary* longdaytradesummary_;
      ::data::LongTradeCancelForNonNextSharesTrades* longtradecancelfornonnextsharestrades_;
      ::data::LongTradeCorrectionForNonNextsharesTrades* longtradecorrectionfornonnextsharestrades_;
      ::data::LongTradeReportForNonNextshares* longtradereportfornonnextshares_;
      ::data::MWCBStatusMessage* mwcbstatusmessage_;
      ::data::MarketWideCircuitBreaker* marketwidecircuitbreaker_;
      ::data::OperationalHalt* operationalhalt_;
      ::data::SaleConditionModifier* saleconditionmodifier_;
      ::data::ShortSaleRestrictionIndicatorMessage* shortsalerestrictionindicatormessage_;
      ::data::StockDirectory* stockdirectory_;
      ::data::StockTradingAction* stocktradingaction_;
      ::data::SystemEventMessage* systemeventmessage_;
      ::data::TradeCancelForNextsharesTrades* tradecancelfornextsharestrades_;
      ::data::TradeCancelForNonNextSharesTrades* tradecancelfornonnextsharestrades_;
      ::data::TradeCorrectionForNextsharesTrades* tradecorrectionfornextsharestrades_;
      ::data::TradeCorrectionForNonNextsharesTrades* tradecorrectionfornonnextsharestrades_;
      ::data::TradeReportForNextshares* tradereportfornextshares_;
      ::data::TradeReportForNonNextshares* tradereportfornonnextshares_;
      ::data::QBBOMWCBBreachMessage* qbbomwcbbreachmessage_;
      ::data::QBBOMWCBDeclineLevelMessage* qbbomwcbdeclinelevelmessage_;
      ::data::QBBONextSharesQuotationMessage* qbbonextsharesquotationmessage_;
      ::data::QBBOOperationalHalt* qbbooperationalhalt_;
      ::data::QBBOQuotationMessage* qbboquotationmessage_;
      ::data::QBBORegShoRestriction* qbboregshorestriction_;
      ::data::QBBOStockDirectory* qbbostockdirectory_;
      ::data::QBBOStockTradingAction* qbbostocktradingaction_;
      ::data::QBBOSystemEventMessage* qbbosystemeventmessage_;
      ::data::QBBOIPOQuotingPeriodUpdate* qbboipoquotingperiodupdate_;
      ::data::CertificationMsg* certificationmsg_;
      ::data::CNMarketDefinition* cnmarketdefinition_;
      ::data::CNSecurityDefinition* cnsecuritydefinition_;
      ::data::CNSecurityStatus* cnsecuritystatus_;
      ::data::CNStatistics* cnstatistics_;
      ::data::CNTopBook* cntopbook_;
    } dataBody_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_data_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// AdjustedClosingPrice

// optional string issueSymbol = 1;
inline bool AdjustedClosingPrice::_internal_has_issuesymbol() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AdjustedClosingPrice::has_issuesymbol() const {
  return _internal_has_issuesymbol();
}
inline void AdjustedClosingPrice::clear_issuesymbol() {
  _impl_.issuesymbol_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AdjustedClosingPrice::issuesymbol() const {
  // @@protoc_insertion_point(field_get:data.AdjustedClosingPrice.issueSymbol)
  return _internal_issuesymbol();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AdjustedClosingPrice::set_issuesymbol(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.issuesymbol_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:data.AdjustedClosingPrice.issueSymbol)
}
inline std::string* AdjustedClosingPrice::mutable_issuesymbol() {
  std::string* _s = _internal_mutable_issuesymbol();
  // @@protoc_insertion_point(field_mutable:data.AdjustedClosingPrice.issueSymbol)
  return _s;
}
inline const std::string& AdjustedClosingPrice::_internal_issuesymbol() const {
  return _impl_.issuesymbol_.Get();
}
inline void AdjustedClosingPrice::_internal_set_issuesymbol(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.issuesymbol_.Set(value, GetArenaForAllocation());
}
inline std::string* AdjustedClosingPrice::_internal_mutable_issuesymbol() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.issuesymbol_.Mutable(GetArenaForAllocation());
}
inline std::string* AdjustedClosingPrice::release_issuesymbol() {
  // @@protoc_insertion_point(field_release:data.AdjustedClosingPrice.issueSymbol)
  if (!_internal_has_issuesymbol()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.issuesymbol_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.issuesymbol_.IsDefault()) {
    _impl_.issuesymbol_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AdjustedClosingPrice::set_allocated_issuesymbol(std::string* issuesymbol) {
  if (issuesymbol != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.issuesymbol_.SetAllocated(issuesymbol, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.issuesymbol_.IsDefault()) {
    _impl_.issuesymbol_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:data.AdjustedClosingPrice.issueSymbol)
}

// optional .data.SecurityClass securityClass = 2;
inline bool AdjustedClosingPrice::_internal_has_securityclass() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool AdjustedClosingPrice::has_securityclass() const {
  return _internal_has_securityclass();
}
inline void AdjustedClosingPrice::clear_securityclass() {
  _impl_.securityclass_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::data::SecurityClass AdjustedClosingPrice::_internal_securityclass() const {
  return static_cast< ::data::SecurityClass >(_impl_.securityclass_);
}
inline ::data::SecurityClass AdjustedClosingPrice::securityclass() const {
  // @@protoc_insertion_point(field_get:data.AdjustedClosingPrice.securityClass)
  return _internal_securityclass();
}
inline void AdjustedClosingPrice::_internal_set_securityclass(::data::SecurityClass value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.securityclass_ = value;
}
inline void AdjustedClosingPrice::set_securityclass(::data::SecurityClass value) {
  _internal_set_securityclass(value);
  // @@protoc_insertion_point(field_set:data.AdjustedClosingPrice.securityClass)
}

// optional double adjustedClosingPrice = 3;
inline bool AdjustedClosingPrice::_internal_has_adjustedclosingprice() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool AdjustedClosingPrice::has_adjustedclosingprice() const {
  return _internal_has_adjustedclosingprice();
}
inline void AdjustedClosingPrice::clear_adjustedclosingprice() {
  _impl_.adjustedclosingprice_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline double AdjustedClosingPrice::_internal_adjustedclosingprice() const {
  return _impl_.adjustedclosingprice_;
}
inline double AdjustedClosingPrice::adjustedclosingprice() const {
  // @@protoc_insertion_point(field_get:data.AdjustedClosingPrice.adjustedClosingPrice)
  return _internal_adjustedclosingprice();
}
inline void AdjustedClosingPrice::_internal_set_adjustedclosingprice(double value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.adjustedclosingprice_ = value;
}
inline void AdjustedClosingPrice::set_adjustedclosingprice(double value) {
  _internal_set_adjustedclosingprice(value);
  // @@protoc_insertion_point(field_set:data.AdjustedClosingPrice.adjustedClosingPrice)
}

// -------------------------------------------------------------------

// DayTradeSummary

// optional string issueSymbol = 1;
inline bool DayTradeSummary::_internal_has_issuesymbol() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DayTradeSummary::has_issuesymbol() const {
  return _internal_has_issuesymbol();
}
inline void DayTradeSummary::clear_issuesymbol() {
  _impl_.issuesymbol_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DayTradeSummary::issuesymbol() const {
  // @@protoc_insertion_point(field_get:data.DayTradeSummary.issueSymbol)
  return _internal_issuesymbol();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DayTradeSummary::set_issuesymbol(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.issuesymbol_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:data.DayTradeSummary.issueSymbol)
}
inline std::string* DayTradeSummary::mutable_issuesymbol() {
  std::string* _s = _internal_mutable_issuesymbol();
  // @@protoc_insertion_point(field_mutable:data.DayTradeSummary.issueSymbol)
  return _s;
}
inline const std::string& DayTradeSummary::_internal_issuesymbol() const {
  return _impl_.issuesymbol_.Get();
}
inline void DayTradeSummary::_internal_set_issuesymbol(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.issuesymbol_.Set(value, GetArenaForAllocation());
}
inline std::string* DayTradeSummary::_internal_mutable_issuesymbol() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.issuesymbol_.Mutable(GetArenaForAllocation());
}
inline std::string* DayTradeSummary::release_issuesymbol() {
  // @@protoc_insertion_point(field_release:data.DayTradeSummary.issueSymbol)
  if (!_internal_has_issuesymbol()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.issuesymbol_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.issuesymbol_.IsDefault()) {
    _impl_.issuesymbol_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DayTradeSummary::set_allocated_issuesymbol(std::string* issuesymbol) {
  if (issuesymbol != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.issuesymbol_.SetAllocated(issuesymbol, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.issuesymbol_.IsDefault()) {
    _impl_.issuesymbol_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:data.DayTradeSummary.issueSymbol)
}

// optional .data.MarketCategory marketCategory = 2;
inline bool DayTradeSummary::_internal_has_marketcategory() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool DayTradeSummary::has_marketcategory() const {
  return _internal_has_marketcategory();
}
inline void DayTradeSummary::clear_marketcategory() {
  _impl_.marketcategory_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::data::MarketCategory DayTradeSummary::_internal_marketcategory() const {
  return static_cast< ::data::MarketCategory >(_impl_.marketcategory_);
}
inline ::data::MarketCategory DayTradeSummary::marketcategory() const {
  // @@protoc_insertion_point(field_get:data.DayTradeSummary.marketCategory)
  return _internal_marketcategory();
}
inline void DayTradeSummary::_internal_set_marketcategory(::data::MarketCategory value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.marketcategory_ = value;
}
inline void DayTradeSummary::set_marketcategory(::data::MarketCategory value) {
  _internal_set_marketcategory(value);
  // @@protoc_insertion_point(field_set:data.DayTradeSummary.marketCategory)
}

// optional double nasdaqHighPrice = 3;
inline bool DayTradeSummary::_internal_has_nasdaqhighprice() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool DayTradeSummary::has_nasdaqhighprice() const {
  return _internal_has_nasdaqhighprice();
}
inline void DayTradeSummary::clear_nasdaqhighprice() {
  _impl_.nasdaqhighprice_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline double DayTradeSummary::_internal_nasdaqhighprice() const {
  return _impl_.nasdaqhighprice_;
}
inline double DayTradeSummary::nasdaqhighprice() const {
  // @@protoc_insertion_point(field_get:data.DayTradeSummary.nasdaqHighPrice)
  return _internal_nasdaqhighprice();
}
inline void DayTradeSummary::_internal_set_nasdaqhighprice(double value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.nasdaqhighprice_ = value;
}
inline void DayTradeSummary::set_nasdaqhighprice(double value) {
  _internal_set_nasdaqhighprice(value);
  // @@protoc_insertion_point(field_set:data.DayTradeSummary.nasdaqHighPrice)
}

// optional double nasdaqLowPrice = 4;
inline bool DayTradeSummary::_internal_has_nasdaqlowprice() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool DayTradeSummary::has_nasdaqlowprice() const {
  return _internal_has_nasdaqlowprice();
}
inline void DayTradeSummary::clear_nasdaqlowprice() {
  _impl_.nasdaqlowprice_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline double DayTradeSummary::_internal_nasdaqlowprice() const {
  return _impl_.nasdaqlowprice_;
}
inline double DayTradeSummary::nasdaqlowprice() const {
  // @@protoc_insertion_point(field_get:data.DayTradeSummary.nasdaqLowPrice)
  return _internal_nasdaqlowprice();
}
inline void DayTradeSummary::_internal_set_nasdaqlowprice(double value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.nasdaqlowprice_ = value;
}
inline void DayTradeSummary::set_nasdaqlowprice(double value) {
  _internal_set_nasdaqlowprice(value);
  // @@protoc_insertion_point(field_set:data.DayTradeSummary.nasdaqLowPrice)
}

// optional double nasdaqClosingPrice = 5;
inline bool DayTradeSummary::_internal_has_nasdaqclosingprice() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool DayTradeSummary::has_nasdaqclosingprice() const {
  return _internal_has_nasdaqclosingprice();
}
inline void DayTradeSummary::clear_nasdaqclosingprice() {
  _impl_.nasdaqclosingprice_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline double DayTradeSummary::_internal_nasdaqclosingprice() const {
  return _impl_.nasdaqclosingprice_;
}
inline double DayTradeSummary::nasdaqclosingprice() const {
  // @@protoc_insertion_point(field_get:data.DayTradeSummary.nasdaqClosingPrice)
  return _internal_nasdaqclosingprice();
}
inline void DayTradeSummary::_internal_set_nasdaqclosingprice(double value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.nasdaqclosingprice_ = value;
}
inline void DayTradeSummary::set_nasdaqclosingprice(double value) {
  _internal_set_nasdaqclosingprice(value);
  // @@protoc_insertion_point(field_set:data.DayTradeSummary.nasdaqClosingPrice)
}

// optional int64 consolidatedVolume = 6;
inline bool DayTradeSummary::_internal_has_consolidatedvolume() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool DayTradeSummary::has_consolidatedvolume() const {
  return _internal_has_consolidatedvolume();
}
inline void DayTradeSummary::clear_consolidatedvolume() {
  _impl_.consolidatedvolume_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline int64_t DayTradeSummary::_internal_consolidatedvolume() const {
  return _impl_.consolidatedvolume_;
}
inline int64_t DayTradeSummary::consolidatedvolume() const {
  // @@protoc_insertion_point(field_get:data.DayTradeSummary.consolidatedVolume)
  return _internal_consolidatedvolume();
}
inline void DayTradeSummary::_internal_set_consolidatedvolume(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.consolidatedvolume_ = value;
}
inline void DayTradeSummary::set_consolidatedvolume(int64_t value) {
  _internal_set_consolidatedvolume(value);
  // @@protoc_insertion_point(field_set:data.DayTradeSummary.consolidatedVolume)
}

// -------------------------------------------------------------------

// DayTradeSummaryNextShares

// optional string issueSymbol = 1;
inline bool DayTradeSummaryNextShares::_internal_has_issuesymbol() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DayTradeSummaryNextShares::has_issuesymbol() const {
  return _internal_has_issuesymbol();
}
inline void DayTradeSummaryNextShares::clear_issuesymbol() {
  _impl_.issuesymbol_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DayTradeSummaryNextShares::issuesymbol() const {
  // @@protoc_insertion_point(field_get:data.DayTradeSummaryNextShares.issueSymbol)
  return _internal_issuesymbol();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DayTradeSummaryNextShares::set_issuesymbol(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.issuesymbol_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:data.DayTradeSummaryNextShares.issueSymbol)
}
inline std::string* DayTradeSummaryNextShares::mutable_issuesymbol() {
  std::string* _s = _internal_mutable_issuesymbol();
  // @@protoc_insertion_point(field_mutable:data.DayTradeSummaryNextShares.issueSymbol)
  return _s;
}
inline const std::string& DayTradeSummaryNextShares::_internal_issuesymbol() const {
  return _impl_.issuesymbol_.Get();
}
inline void DayTradeSummaryNextShares::_internal_set_issuesymbol(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.issuesymbol_.Set(value, GetArenaForAllocation());
}
inline std::string* DayTradeSummaryNextShares::_internal_mutable_issuesymbol() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.issuesymbol_.Mutable(GetArenaForAllocation());
}
inline std::string* DayTradeSummaryNextShares::release_issuesymbol() {
  // @@protoc_insertion_point(field_release:data.DayTradeSummaryNextShares.issueSymbol)
  if (!_internal_has_issuesymbol()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.issuesymbol_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.issuesymbol_.IsDefault()) {
    _impl_.issuesymbol_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DayTradeSummaryNextShares::set_allocated_issuesymbol(std::string* issuesymbol) {
  if (issuesymbol != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.issuesymbol_.SetAllocated(issuesymbol, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.issuesymbol_.IsDefault()) {
    _impl_.issuesymbol_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:data.DayTradeSummaryNextShares.issueSymbol)
}

// optional .data.MarketCategory marketCategory = 2;
inline bool DayTradeSummaryNextShares::_internal_has_marketcategory() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool DayTradeSummaryNextShares::has_marketcategory() const {
  return _internal_has_marketcategory();
}
inline void DayTradeSummaryNextShares::clear_marketcategory() {
  _impl_.marketcategory_ = 0;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline ::data::MarketCategory DayTradeSummaryNextShares::_internal_marketcategory() const {
  return static_cast< ::data::MarketCategory >(_impl_.marketcategory_);
}
inline ::data::MarketCategory DayTradeSummaryNextShares::marketcategory() const {
  // @@protoc_insertion_point(field_get:data.DayTradeSummaryNextShares.marketCategory)
  return _internal_marketcategory();
}
inline void DayTradeSummaryNextShares::_internal_set_marketcategory(::data::MarketCategory value) {
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.marketcategory_ = value;
}
inline void DayTradeSummaryNextShares::set_marketcategory(::data::MarketCategory value) {
  _internal_set_marketcategory(value);
  // @@protoc_insertion_point(field_set:data.DayTradeSummaryNextShares.marketCategory)
}

// optional double nasdaqHighPrice = 3;
inline bool DayTradeSummaryNextShares::_internal_has_nasdaqhighprice() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool DayTradeSummaryNextShares::has_nasdaqhighprice() const {
  return _internal_has_nasdaqhighprice();
}
inline void DayTradeSummaryNextShares::clear_nasdaqhighprice() {
  _impl_.nasdaqhighprice_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline double DayTradeSummaryNextShares::_internal_nasdaqhighprice() const {
  return _impl_.nasdaqhighprice_;
}
inline double DayTradeSummaryNextShares::nasdaqhighprice() const {
  // @@protoc_insertion_point(field_get:data.DayTradeSummaryNextShares.nasdaqHighPrice)
  return _internal_nasdaqhighprice();
}
inline void DayTradeSummaryNextShares::_internal_set_nasdaqhighprice(double value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.nasdaqhighprice_ = value;
}
inline void DayTradeSummaryNextShares::set_nasdaqhighprice(double value) {
  _internal_set_nasdaqhighprice(value);
  // @@protoc_insertion_point(field_set:data.DayTradeSummaryNextShares.nasdaqHighPrice)
}

// optional double NAVOffsetAmountHigh = 4;
inline bool DayTradeSummaryNextShares::_internal_has_navoffsetamounthigh() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool DayTradeSummaryNextShares::has_navoffsetamounthigh() const {
  return _internal_has_navoffsetamounthigh();
}
inline void DayTradeSummaryNextShares::clear_navoffsetamounthigh() {
  _impl_.navoffsetamounthigh_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline double DayTradeSummaryNextShares::_internal_navoffsetamounthigh() const {
  return _impl_.navoffsetamounthigh_;
}
inline double DayTradeSummaryNextShares::navoffsetamounthigh() const {
  // @@protoc_insertion_point(field_get:data.DayTradeSummaryNextShares.NAVOffsetAmountHigh)
  return _internal_navoffsetamounthigh();
}
inline void DayTradeSummaryNextShares::_internal_set_navoffsetamounthigh(double value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.navoffsetamounthigh_ = value;
}
inline void DayTradeSummaryNextShares::set_navoffsetamounthigh(double value) {
  _internal_set_navoffsetamounthigh(value);
  // @@protoc_insertion_point(field_set:data.DayTradeSummaryNextShares.NAVOffsetAmountHigh)
}

// optional double nasdaqLowPrice = 5;
inline bool DayTradeSummaryNextShares::_internal_has_nasdaqlowprice() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool DayTradeSummaryNextShares::has_nasdaqlowprice() const {
  return _internal_has_nasdaqlowprice();
}
inline void DayTradeSummaryNextShares::clear_nasdaqlowprice() {
  _impl_.nasdaqlowprice_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline double DayTradeSummaryNextShares::_internal_nasdaqlowprice() const {
  return _impl_.nasdaqlowprice_;
}
inline double DayTradeSummaryNextShares::nasdaqlowprice() const {
  // @@protoc_insertion_point(field_get:data.DayTradeSummaryNextShares.nasdaqLowPrice)
  return _internal_nasdaqlowprice();
}
inline void DayTradeSummaryNextShares::_internal_set_nasdaqlowprice(double value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.nasdaqlowprice_ = value;
}
inline void DayTradeSummaryNextShares::set_nasdaqlowprice(double value) {
  _internal_set_nasdaqlowprice(value);
  // @@protoc_insertion_point(field_set:data.DayTradeSummaryNextShares.nasdaqLowPrice)
}

// optional double NAVOffsetAmountLow = 6;
inline bool DayTradeSummaryNextShares::_internal_has_navoffsetamountlow() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool DayTradeSummaryNextShares::has_navoffsetamountlow() const {
  return _internal_has_navoffsetamountlow();
}
inline void DayTradeSummaryNextShares::clear_navoffsetamountlow() {
  _impl_.navoffsetamountlow_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline double DayTradeSummaryNextShares::_internal_navoffsetamountlow() const {
  return _impl_.navoffsetamountlow_;
}
inline double DayTradeSummaryNextShares::navoffsetamountlow() const {
  // @@protoc_insertion_point(field_get:data.DayTradeSummaryNextShares.NAVOffsetAmountLow)
  return _internal_navoffsetamountlow();
}
inline void DayTradeSummaryNextShares::_internal_set_navoffsetamountlow(double value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.navoffsetamountlow_ = value;
}
inline void DayTradeSummaryNextShares::set_navoffsetamountlow(double value) {
  _internal_set_navoffsetamountlow(value);
  // @@protoc_insertion_point(field_set:data.DayTradeSummaryNextShares.NAVOffsetAmountLow)
}

// optional double nasdaqClosingPrice = 7;
inline bool DayTradeSummaryNextShares::_internal_has_nasdaqclosingprice() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool DayTradeSummaryNextShares::has_nasdaqclosingprice() const {
  return _internal_has_nasdaqclosingprice();
}
inline void DayTradeSummaryNextShares::clear_nasdaqclosingprice() {
  _impl_.nasdaqclosingprice_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline double DayTradeSummaryNextShares::_internal_nasdaqclosingprice() const {
  return _impl_.nasdaqclosingprice_;
}
inline double DayTradeSummaryNextShares::nasdaqclosingprice() const {
  // @@protoc_insertion_point(field_get:data.DayTradeSummaryNextShares.nasdaqClosingPrice)
  return _internal_nasdaqclosingprice();
}
inline void DayTradeSummaryNextShares::_internal_set_nasdaqclosingprice(double value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.nasdaqclosingprice_ = value;
}
inline void DayTradeSummaryNextShares::set_nasdaqclosingprice(double value) {
  _internal_set_nasdaqclosingprice(value);
  // @@protoc_insertion_point(field_set:data.DayTradeSummaryNextShares.nasdaqClosingPrice)
}

// optional double NAVOffsetAmountClose = 8;
inline bool DayTradeSummaryNextShares::_internal_has_navoffsetamountclose() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool DayTradeSummaryNextShares::has_navoffsetamountclose() const {
  return _internal_has_navoffsetamountclose();
}
inline void DayTradeSummaryNextShares::clear_navoffsetamountclose() {
  _impl_.navoffsetamountclose_ = 0;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline double DayTradeSummaryNextShares::_internal_navoffsetamountclose() const {
  return _impl_.navoffsetamountclose_;
}
inline double DayTradeSummaryNextShares::navoffsetamountclose() const {
  // @@protoc_insertion_point(field_get:data.DayTradeSummaryNextShares.NAVOffsetAmountClose)
  return _internal_navoffsetamountclose();
}
inline void DayTradeSummaryNextShares::_internal_set_navoffsetamountclose(double value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.navoffsetamountclose_ = value;
}
inline void DayTradeSummaryNextShares::set_navoffsetamountclose(double value) {
  _internal_set_navoffsetamountclose(value);
  // @@protoc_insertion_point(field_set:data.DayTradeSummaryNextShares.NAVOffsetAmountClose)
}

// optional int64 consolidatedVolume = 9;
inline bool DayTradeSummaryNextShares::_internal_has_consolidatedvolume() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool DayTradeSummaryNextShares::has_consolidatedvolume() const {
  return _internal_has_consolidatedvolume();
}
inline void DayTradeSummaryNextShares::clear_consolidatedvolume() {
  _impl_.consolidatedvolume_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline int64_t DayTradeSummaryNextShares::_internal_consolidatedvolume() const {
  return _impl_.consolidatedvolume_;
}
inline int64_t DayTradeSummaryNextShares::consolidatedvolume() const {
  // @@protoc_insertion_point(field_get:data.DayTradeSummaryNextShares.consolidatedVolume)
  return _internal_consolidatedvolume();
}
inline void DayTradeSummaryNextShares::_internal_set_consolidatedvolume(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.consolidatedvolume_ = value;
}
inline void DayTradeSummaryNextShares::set_consolidatedvolume(int64_t value) {
  _internal_set_consolidatedvolume(value);
  // @@protoc_insertion_point(field_set:data.DayTradeSummaryNextShares.consolidatedVolume)
}

// -------------------------------------------------------------------

// IPOInformation

// optional string issueSymbol = 1;
inline bool IPOInformation::_internal_has_issuesymbol() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool IPOInformation::has_issuesymbol() const {
  return _internal_has_issuesymbol();
}
inline void IPOInformation::clear_issuesymbol() {
  _impl_.issuesymbol_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& IPOInformation::issuesymbol() const {
  // @@protoc_insertion_point(field_get:data.IPOInformation.issueSymbol)
  return _internal_issuesymbol();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void IPOInformation::set_issuesymbol(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.issuesymbol_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:data.IPOInformation.issueSymbol)
}
inline std::string* IPOInformation::mutable_issuesymbol() {
  std::string* _s = _internal_mutable_issuesymbol();
  // @@protoc_insertion_point(field_mutable:data.IPOInformation.issueSymbol)
  return _s;
}
inline const std::string& IPOInformation::_internal_issuesymbol() const {
  return _impl_.issuesymbol_.Get();
}
inline void IPOInformation::_internal_set_issuesymbol(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.issuesymbol_.Set(value, GetArenaForAllocation());
}
inline std::string* IPOInformation::_internal_mutable_issuesymbol() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.issuesymbol_.Mutable(GetArenaForAllocation());
}
inline std::string* IPOInformation::release_issuesymbol() {
  // @@protoc_insertion_point(field_release:data.IPOInformation.issueSymbol)
  if (!_internal_has_issuesymbol()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.issuesymbol_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.issuesymbol_.IsDefault()) {
    _impl_.issuesymbol_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void IPOInformation::set_allocated_issuesymbol(std::string* issuesymbol) {
  if (issuesymbol != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.issuesymbol_.SetAllocated(issuesymbol, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.issuesymbol_.IsDefault()) {
    _impl_.issuesymbol_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:data.IPOInformation.issueSymbol)
}

// optional .data.SecurityClass securityClass = 2;
inline bool IPOInformation::_internal_has_securityclass() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool IPOInformation::has_securityclass() const {
  return _internal_has_securityclass();
}
inline void IPOInformation::clear_securityclass() {
  _impl_.securityclass_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::data::SecurityClass IPOInformation::_internal_securityclass() const {
  return static_cast< ::data::SecurityClass >(_impl_.securityclass_);
}
inline ::data::SecurityClass IPOInformation::securityclass() const {
  // @@protoc_insertion_point(field_get:data.IPOInformation.securityClass)
  return _internal_securityclass();
}
inline void IPOInformation::_internal_set_securityclass(::data::SecurityClass value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.securityclass_ = value;
}
inline void IPOInformation::set_securityclass(::data::SecurityClass value) {
  _internal_set_securityclass(value);
  // @@protoc_insertion_point(field_set:data.IPOInformation.securityClass)
}

// optional .data.NetChange referenceForNetChange = 3;
inline bool IPOInformation::_internal_has_referencefornetchange() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool IPOInformation::has_referencefornetchange() const {
  return _internal_has_referencefornetchange();
}
inline void IPOInformation::clear_referencefornetchange() {
  _impl_.referencefornetchange_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::data::NetChange IPOInformation::_internal_referencefornetchange() const {
  return static_cast< ::data::NetChange >(_impl_.referencefornetchange_);
}
inline ::data::NetChange IPOInformation::referencefornetchange() const {
  // @@protoc_insertion_point(field_get:data.IPOInformation.referenceForNetChange)
  return _internal_referencefornetchange();
}
inline void IPOInformation::_internal_set_referencefornetchange(::data::NetChange value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.referencefornetchange_ = value;
}
inline void IPOInformation::set_referencefornetchange(::data::NetChange value) {
  _internal_set_referencefornetchange(value);
  // @@protoc_insertion_point(field_set:data.IPOInformation.referenceForNetChange)
}

// optional double referencePrice = 4;
inline bool IPOInformation::_internal_has_referenceprice() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool IPOInformation::has_referenceprice() const {
  return _internal_has_referenceprice();
}
inline void IPOInformation::clear_referenceprice() {
  _impl_.referenceprice_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline double IPOInformation::_internal_referenceprice() const {
  return _impl_.referenceprice_;
}
inline double IPOInformation::referenceprice() const {
  // @@protoc_insertion_point(field_get:data.IPOInformation.referencePrice)
  return _internal_referenceprice();
}
inline void IPOInformation::_internal_set_referenceprice(double value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.referenceprice_ = value;
}
inline void IPOInformation::set_referenceprice(double value) {
  _internal_set_referenceprice(value);
  // @@protoc_insertion_point(field_set:data.IPOInformation.referencePrice)
}

// -------------------------------------------------------------------

// IPOQuotingPeriodUpdate

// optional string stock = 1;
inline bool IPOQuotingPeriodUpdate::_internal_has_stock() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool IPOQuotingPeriodUpdate::has_stock() const {
  return _internal_has_stock();
}
inline void IPOQuotingPeriodUpdate::clear_stock() {
  _impl_.stock_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& IPOQuotingPeriodUpdate::stock() const {
  // @@protoc_insertion_point(field_get:data.IPOQuotingPeriodUpdate.stock)
  return _internal_stock();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void IPOQuotingPeriodUpdate::set_stock(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.stock_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:data.IPOQuotingPeriodUpdate.stock)
}
inline std::string* IPOQuotingPeriodUpdate::mutable_stock() {
  std::string* _s = _internal_mutable_stock();
  // @@protoc_insertion_point(field_mutable:data.IPOQuotingPeriodUpdate.stock)
  return _s;
}
inline const std::string& IPOQuotingPeriodUpdate::_internal_stock() const {
  return _impl_.stock_.Get();
}
inline void IPOQuotingPeriodUpdate::_internal_set_stock(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.stock_.Set(value, GetArenaForAllocation());
}
inline std::string* IPOQuotingPeriodUpdate::_internal_mutable_stock() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.stock_.Mutable(GetArenaForAllocation());
}
inline std::string* IPOQuotingPeriodUpdate::release_stock() {
  // @@protoc_insertion_point(field_release:data.IPOQuotingPeriodUpdate.stock)
  if (!_internal_has_stock()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.stock_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.stock_.IsDefault()) {
    _impl_.stock_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void IPOQuotingPeriodUpdate::set_allocated_stock(std::string* stock) {
  if (stock != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.stock_.SetAllocated(stock, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.stock_.IsDefault()) {
    _impl_.stock_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:data.IPOQuotingPeriodUpdate.stock)
}

// optional int64 iPOQuotationReleaseTime = 2;
inline bool IPOQuotingPeriodUpdate::_internal_has_ipoquotationreleasetime() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool IPOQuotingPeriodUpdate::has_ipoquotationreleasetime() const {
  return _internal_has_ipoquotationreleasetime();
}
inline void IPOQuotingPeriodUpdate::clear_ipoquotationreleasetime() {
  _impl_.ipoquotationreleasetime_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int64_t IPOQuotingPeriodUpdate::_internal_ipoquotationreleasetime() const {
  return _impl_.ipoquotationreleasetime_;
}
inline int64_t IPOQuotingPeriodUpdate::ipoquotationreleasetime() const {
  // @@protoc_insertion_point(field_get:data.IPOQuotingPeriodUpdate.iPOQuotationReleaseTime)
  return _internal_ipoquotationreleasetime();
}
inline void IPOQuotingPeriodUpdate::_internal_set_ipoquotationreleasetime(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.ipoquotationreleasetime_ = value;
}
inline void IPOQuotingPeriodUpdate::set_ipoquotationreleasetime(int64_t value) {
  _internal_set_ipoquotationreleasetime(value);
  // @@protoc_insertion_point(field_set:data.IPOQuotingPeriodUpdate.iPOQuotationReleaseTime)
}

// optional .data.IPOQuotationReleaseQualifier quotationReleaseQualifier = 3;
inline bool IPOQuotingPeriodUpdate::_internal_has_quotationreleasequalifier() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool IPOQuotingPeriodUpdate::has_quotationreleasequalifier() const {
  return _internal_has_quotationreleasequalifier();
}
inline void IPOQuotingPeriodUpdate::clear_quotationreleasequalifier() {
  _impl_.quotationreleasequalifier_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::data::IPOQuotationReleaseQualifier IPOQuotingPeriodUpdate::_internal_quotationreleasequalifier() const {
  return static_cast< ::data::IPOQuotationReleaseQualifier >(_impl_.quotationreleasequalifier_);
}
inline ::data::IPOQuotationReleaseQualifier IPOQuotingPeriodUpdate::quotationreleasequalifier() const {
  // @@protoc_insertion_point(field_get:data.IPOQuotingPeriodUpdate.quotationReleaseQualifier)
  return _internal_quotationreleasequalifier();
}
inline void IPOQuotingPeriodUpdate::_internal_set_quotationreleasequalifier(::data::IPOQuotationReleaseQualifier value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.quotationreleasequalifier_ = value;
}
inline void IPOQuotingPeriodUpdate::set_quotationreleasequalifier(::data::IPOQuotationReleaseQualifier value) {
  _internal_set_quotationreleasequalifier(value);
  // @@protoc_insertion_point(field_set:data.IPOQuotingPeriodUpdate.quotationReleaseQualifier)
}

// optional double iPOPrice = 4;
inline bool IPOQuotingPeriodUpdate::_internal_has_ipoprice() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool IPOQuotingPeriodUpdate::has_ipoprice() const {
  return _internal_has_ipoprice();
}
inline void IPOQuotingPeriodUpdate::clear_ipoprice() {
  _impl_.ipoprice_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline double IPOQuotingPeriodUpdate::_internal_ipoprice() const {
  return _impl_.ipoprice_;
}
inline double IPOQuotingPeriodUpdate::ipoprice() const {
  // @@protoc_insertion_point(field_get:data.IPOQuotingPeriodUpdate.iPOPrice)
  return _internal_ipoprice();
}
inline void IPOQuotingPeriodUpdate::_internal_set_ipoprice(double value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.ipoprice_ = value;
}
inline void IPOQuotingPeriodUpdate::set_ipoprice(double value) {
  _internal_set_ipoprice(value);
  // @@protoc_insertion_point(field_set:data.IPOQuotingPeriodUpdate.iPOPrice)
}

// -------------------------------------------------------------------

// MWCBStatusMessage

// optional .data.BreachedLevel breachedLevel = 1;
inline bool MWCBStatusMessage::_internal_has_breachedlevel() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MWCBStatusMessage::has_breachedlevel() const {
  return _internal_has_breachedlevel();
}
inline void MWCBStatusMessage::clear_breachedlevel() {
  _impl_.breachedlevel_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::data::BreachedLevel MWCBStatusMessage::_internal_breachedlevel() const {
  return static_cast< ::data::BreachedLevel >(_impl_.breachedlevel_);
}
inline ::data::BreachedLevel MWCBStatusMessage::breachedlevel() const {
  // @@protoc_insertion_point(field_get:data.MWCBStatusMessage.breachedLevel)
  return _internal_breachedlevel();
}
inline void MWCBStatusMessage::_internal_set_breachedlevel(::data::BreachedLevel value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.breachedlevel_ = value;
}
inline void MWCBStatusMessage::set_breachedlevel(::data::BreachedLevel value) {
  _internal_set_breachedlevel(value);
  // @@protoc_insertion_point(field_set:data.MWCBStatusMessage.breachedLevel)
}

// -------------------------------------------------------------------

// MarketWideCircuitBreaker

// optional double Level1 = 1;
inline bool MarketWideCircuitBreaker::_internal_has_level1() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MarketWideCircuitBreaker::has_level1() const {
  return _internal_has_level1();
}
inline void MarketWideCircuitBreaker::clear_level1() {
  _impl_.level1_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline double MarketWideCircuitBreaker::_internal_level1() const {
  return _impl_.level1_;
}
inline double MarketWideCircuitBreaker::level1() const {
  // @@protoc_insertion_point(field_get:data.MarketWideCircuitBreaker.Level1)
  return _internal_level1();
}
inline void MarketWideCircuitBreaker::_internal_set_level1(double value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.level1_ = value;
}
inline void MarketWideCircuitBreaker::set_level1(double value) {
  _internal_set_level1(value);
  // @@protoc_insertion_point(field_set:data.MarketWideCircuitBreaker.Level1)
}

// optional double Level2 = 2;
inline bool MarketWideCircuitBreaker::_internal_has_level2() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool MarketWideCircuitBreaker::has_level2() const {
  return _internal_has_level2();
}
inline void MarketWideCircuitBreaker::clear_level2() {
  _impl_.level2_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline double MarketWideCircuitBreaker::_internal_level2() const {
  return _impl_.level2_;
}
inline double MarketWideCircuitBreaker::level2() const {
  // @@protoc_insertion_point(field_get:data.MarketWideCircuitBreaker.Level2)
  return _internal_level2();
}
inline void MarketWideCircuitBreaker::_internal_set_level2(double value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.level2_ = value;
}
inline void MarketWideCircuitBreaker::set_level2(double value) {
  _internal_set_level2(value);
  // @@protoc_insertion_point(field_set:data.MarketWideCircuitBreaker.Level2)
}

// optional double Level3 = 3;
inline bool MarketWideCircuitBreaker::_internal_has_level3() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool MarketWideCircuitBreaker::has_level3() const {
  return _internal_has_level3();
}
inline void MarketWideCircuitBreaker::clear_level3() {
  _impl_.level3_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline double MarketWideCircuitBreaker::_internal_level3() const {
  return _impl_.level3_;
}
inline double MarketWideCircuitBreaker::level3() const {
  // @@protoc_insertion_point(field_get:data.MarketWideCircuitBreaker.Level3)
  return _internal_level3();
}
inline void MarketWideCircuitBreaker::_internal_set_level3(double value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.level3_ = value;
}
inline void MarketWideCircuitBreaker::set_level3(double value) {
  _internal_set_level3(value);
  // @@protoc_insertion_point(field_set:data.MarketWideCircuitBreaker.Level3)
}

// -------------------------------------------------------------------

// MessageHeader

// optional int32 trackingNumber = 1;
inline bool MessageHeader::_internal_has_trackingnumber() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool MessageHeader::has_trackingnumber() const {
  return _internal_has_trackingnumber();
}
inline void MessageHeader::clear_trackingnumber() {
  _impl_.trackingnumber_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t MessageHeader::_internal_trackingnumber() const {
  return _impl_.trackingnumber_;
}
inline int32_t MessageHeader::trackingnumber() const {
  // @@protoc_insertion_point(field_get:data.MessageHeader.trackingNumber)
  return _internal_trackingnumber();
}
inline void MessageHeader::_internal_set_trackingnumber(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.trackingnumber_ = value;
}
inline void MessageHeader::set_trackingnumber(int32_t value) {
  _internal_set_trackingnumber(value);
  // @@protoc_insertion_point(field_set:data.MessageHeader.trackingNumber)
}

// optional int64 timestamp = 2;
inline bool MessageHeader::_internal_has_timestamp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MessageHeader::has_timestamp() const {
  return _internal_has_timestamp();
}
inline void MessageHeader::clear_timestamp() {
  _impl_.timestamp_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int64_t MessageHeader::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline int64_t MessageHeader::timestamp() const {
  // @@protoc_insertion_point(field_get:data.MessageHeader.timestamp)
  return _internal_timestamp();
}
inline void MessageHeader::_internal_set_timestamp(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.timestamp_ = value;
}
inline void MessageHeader::set_timestamp(int64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:data.MessageHeader.timestamp)
}

// optional .data.MessageType messageType = 3;
inline bool MessageHeader::_internal_has_messagetype() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool MessageHeader::has_messagetype() const {
  return _internal_has_messagetype();
}
inline void MessageHeader::clear_messagetype() {
  _impl_.messagetype_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::data::MessageType MessageHeader::_internal_messagetype() const {
  return static_cast< ::data::MessageType >(_impl_.messagetype_);
}
inline ::data::MessageType MessageHeader::messagetype() const {
  // @@protoc_insertion_point(field_get:data.MessageHeader.messageType)
  return _internal_messagetype();
}
inline void MessageHeader::_internal_set_messagetype(::data::MessageType value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.messagetype_ = value;
}
inline void MessageHeader::set_messagetype(::data::MessageType value) {
  _internal_set_messagetype(value);
  // @@protoc_insertion_point(field_set:data.MessageHeader.messageType)
}

// -------------------------------------------------------------------

// OperationalHalt

// optional string stock = 1;
inline bool OperationalHalt::_internal_has_stock() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool OperationalHalt::has_stock() const {
  return _internal_has_stock();
}
inline void OperationalHalt::clear_stock() {
  _impl_.stock_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& OperationalHalt::stock() const {
  // @@protoc_insertion_point(field_get:data.OperationalHalt.stock)
  return _internal_stock();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OperationalHalt::set_stock(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.stock_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:data.OperationalHalt.stock)
}
inline std::string* OperationalHalt::mutable_stock() {
  std::string* _s = _internal_mutable_stock();
  // @@protoc_insertion_point(field_mutable:data.OperationalHalt.stock)
  return _s;
}
inline const std::string& OperationalHalt::_internal_stock() const {
  return _impl_.stock_.Get();
}
inline void OperationalHalt::_internal_set_stock(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.stock_.Set(value, GetArenaForAllocation());
}
inline std::string* OperationalHalt::_internal_mutable_stock() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.stock_.Mutable(GetArenaForAllocation());
}
inline std::string* OperationalHalt::release_stock() {
  // @@protoc_insertion_point(field_release:data.OperationalHalt.stock)
  if (!_internal_has_stock()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.stock_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.stock_.IsDefault()) {
    _impl_.stock_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void OperationalHalt::set_allocated_stock(std::string* stock) {
  if (stock != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.stock_.SetAllocated(stock, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.stock_.IsDefault()) {
    _impl_.stock_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:data.OperationalHalt.stock)
}

// optional .data.MarketCode marketCode = 2;
inline bool OperationalHalt::_internal_has_marketcode() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool OperationalHalt::has_marketcode() const {
  return _internal_has_marketcode();
}
inline void OperationalHalt::clear_marketcode() {
  _impl_.marketcode_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::data::MarketCode OperationalHalt::_internal_marketcode() const {
  return static_cast< ::data::MarketCode >(_impl_.marketcode_);
}
inline ::data::MarketCode OperationalHalt::marketcode() const {
  // @@protoc_insertion_point(field_get:data.OperationalHalt.marketCode)
  return _internal_marketcode();
}
inline void OperationalHalt::_internal_set_marketcode(::data::MarketCode value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.marketcode_ = value;
}
inline void OperationalHalt::set_marketcode(::data::MarketCode value) {
  _internal_set_marketcode(value);
  // @@protoc_insertion_point(field_set:data.OperationalHalt.marketCode)
}

// optional .data.OperationalHaltAction operationalHaltAction = 3;
inline bool OperationalHalt::_internal_has_operationalhaltaction() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool OperationalHalt::has_operationalhaltaction() const {
  return _internal_has_operationalhaltaction();
}
inline void OperationalHalt::clear_operationalhaltaction() {
  _impl_.operationalhaltaction_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::data::OperationalHaltAction OperationalHalt::_internal_operationalhaltaction() const {
  return static_cast< ::data::OperationalHaltAction >(_impl_.operationalhaltaction_);
}
inline ::data::OperationalHaltAction OperationalHalt::operationalhaltaction() const {
  // @@protoc_insertion_point(field_get:data.OperationalHalt.operationalHaltAction)
  return _internal_operationalhaltaction();
}
inline void OperationalHalt::_internal_set_operationalhaltaction(::data::OperationalHaltAction value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.operationalhaltaction_ = value;
}
inline void OperationalHalt::set_operationalhaltaction(::data::OperationalHaltAction value) {
  _internal_set_operationalhaltaction(value);
  // @@protoc_insertion_point(field_set:data.OperationalHalt.operationalHaltAction)
}

// -------------------------------------------------------------------

// SaleConditionModifier

// optional .data.LevelOne level1 = 1;
inline bool SaleConditionModifier::_internal_has_level1() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SaleConditionModifier::has_level1() const {
  return _internal_has_level1();
}
inline void SaleConditionModifier::clear_level1() {
  _impl_.level1_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::data::LevelOne SaleConditionModifier::_internal_level1() const {
  return static_cast< ::data::LevelOne >(_impl_.level1_);
}
inline ::data::LevelOne SaleConditionModifier::level1() const {
  // @@protoc_insertion_point(field_get:data.SaleConditionModifier.level1)
  return _internal_level1();
}
inline void SaleConditionModifier::_internal_set_level1(::data::LevelOne value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.level1_ = value;
}
inline void SaleConditionModifier::set_level1(::data::LevelOne value) {
  _internal_set_level1(value);
  // @@protoc_insertion_point(field_set:data.SaleConditionModifier.level1)
}

// optional .data.LevelTwo level2 = 2;
inline bool SaleConditionModifier::_internal_has_level2() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SaleConditionModifier::has_level2() const {
  return _internal_has_level2();
}
inline void SaleConditionModifier::clear_level2() {
  _impl_.level2_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::data::LevelTwo SaleConditionModifier::_internal_level2() const {
  return static_cast< ::data::LevelTwo >(_impl_.level2_);
}
inline ::data::LevelTwo SaleConditionModifier::level2() const {
  // @@protoc_insertion_point(field_get:data.SaleConditionModifier.level2)
  return _internal_level2();
}
inline void SaleConditionModifier::_internal_set_level2(::data::LevelTwo value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.level2_ = value;
}
inline void SaleConditionModifier::set_level2(::data::LevelTwo value) {
  _internal_set_level2(value);
  // @@protoc_insertion_point(field_set:data.SaleConditionModifier.level2)
}

// optional .data.LevelThree level3 = 3;
inline bool SaleConditionModifier::_internal_has_level3() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool SaleConditionModifier::has_level3() const {
  return _internal_has_level3();
}
inline void SaleConditionModifier::clear_level3() {
  _impl_.level3_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::data::LevelThree SaleConditionModifier::_internal_level3() const {
  return static_cast< ::data::LevelThree >(_impl_.level3_);
}
inline ::data::LevelThree SaleConditionModifier::level3() const {
  // @@protoc_insertion_point(field_get:data.SaleConditionModifier.level3)
  return _internal_level3();
}
inline void SaleConditionModifier::_internal_set_level3(::data::LevelThree value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.level3_ = value;
}
inline void SaleConditionModifier::set_level3(::data::LevelThree value) {
  _internal_set_level3(value);
  // @@protoc_insertion_point(field_set:data.SaleConditionModifier.level3)
}

// optional .data.LevelFour level4 = 4;
inline bool SaleConditionModifier::_internal_has_level4() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool SaleConditionModifier::has_level4() const {
  return _internal_has_level4();
}
inline void SaleConditionModifier::clear_level4() {
  _impl_.level4_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::data::LevelFour SaleConditionModifier::_internal_level4() const {
  return static_cast< ::data::LevelFour >(_impl_.level4_);
}
inline ::data::LevelFour SaleConditionModifier::level4() const {
  // @@protoc_insertion_point(field_get:data.SaleConditionModifier.level4)
  return _internal_level4();
}
inline void SaleConditionModifier::_internal_set_level4(::data::LevelFour value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.level4_ = value;
}
inline void SaleConditionModifier::set_level4(::data::LevelFour value) {
  _internal_set_level4(value);
  // @@protoc_insertion_point(field_set:data.SaleConditionModifier.level4)
}

// -------------------------------------------------------------------

// ShortSaleRestrictionIndicatorMessage

// optional string issueSymbol = 1;
inline bool ShortSaleRestrictionIndicatorMessage::_internal_has_issuesymbol() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ShortSaleRestrictionIndicatorMessage::has_issuesymbol() const {
  return _internal_has_issuesymbol();
}
inline void ShortSaleRestrictionIndicatorMessage::clear_issuesymbol() {
  _impl_.issuesymbol_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ShortSaleRestrictionIndicatorMessage::issuesymbol() const {
  // @@protoc_insertion_point(field_get:data.ShortSaleRestrictionIndicatorMessage.issueSymbol)
  return _internal_issuesymbol();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ShortSaleRestrictionIndicatorMessage::set_issuesymbol(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.issuesymbol_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:data.ShortSaleRestrictionIndicatorMessage.issueSymbol)
}
inline std::string* ShortSaleRestrictionIndicatorMessage::mutable_issuesymbol() {
  std::string* _s = _internal_mutable_issuesymbol();
  // @@protoc_insertion_point(field_mutable:data.ShortSaleRestrictionIndicatorMessage.issueSymbol)
  return _s;
}
inline const std::string& ShortSaleRestrictionIndicatorMessage::_internal_issuesymbol() const {
  return _impl_.issuesymbol_.Get();
}
inline void ShortSaleRestrictionIndicatorMessage::_internal_set_issuesymbol(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.issuesymbol_.Set(value, GetArenaForAllocation());
}
inline std::string* ShortSaleRestrictionIndicatorMessage::_internal_mutable_issuesymbol() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.issuesymbol_.Mutable(GetArenaForAllocation());
}
inline std::string* ShortSaleRestrictionIndicatorMessage::release_issuesymbol() {
  // @@protoc_insertion_point(field_release:data.ShortSaleRestrictionIndicatorMessage.issueSymbol)
  if (!_internal_has_issuesymbol()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.issuesymbol_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.issuesymbol_.IsDefault()) {
    _impl_.issuesymbol_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ShortSaleRestrictionIndicatorMessage::set_allocated_issuesymbol(std::string* issuesymbol) {
  if (issuesymbol != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.issuesymbol_.SetAllocated(issuesymbol, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.issuesymbol_.IsDefault()) {
    _impl_.issuesymbol_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:data.ShortSaleRestrictionIndicatorMessage.issueSymbol)
}

// optional .data.RegSHOAction regSHOAction = 2;
inline bool ShortSaleRestrictionIndicatorMessage::_internal_has_regshoaction() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ShortSaleRestrictionIndicatorMessage::has_regshoaction() const {
  return _internal_has_regshoaction();
}
inline void ShortSaleRestrictionIndicatorMessage::clear_regshoaction() {
  _impl_.regshoaction_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::data::RegSHOAction ShortSaleRestrictionIndicatorMessage::_internal_regshoaction() const {
  return static_cast< ::data::RegSHOAction >(_impl_.regshoaction_);
}
inline ::data::RegSHOAction ShortSaleRestrictionIndicatorMessage::regshoaction() const {
  // @@protoc_insertion_point(field_get:data.ShortSaleRestrictionIndicatorMessage.regSHOAction)
  return _internal_regshoaction();
}
inline void ShortSaleRestrictionIndicatorMessage::_internal_set_regshoaction(::data::RegSHOAction value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.regshoaction_ = value;
}
inline void ShortSaleRestrictionIndicatorMessage::set_regshoaction(::data::RegSHOAction value) {
  _internal_set_regshoaction(value);
  // @@protoc_insertion_point(field_set:data.ShortSaleRestrictionIndicatorMessage.regSHOAction)
}

// -------------------------------------------------------------------

// StockDirectory

// optional string stock = 1;
inline bool StockDirectory::_internal_has_stock() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool StockDirectory::has_stock() const {
  return _internal_has_stock();
}
inline void StockDirectory::clear_stock() {
  _impl_.stock_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& StockDirectory::stock() const {
  // @@protoc_insertion_point(field_get:data.StockDirectory.stock)
  return _internal_stock();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StockDirectory::set_stock(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.stock_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:data.StockDirectory.stock)
}
inline std::string* StockDirectory::mutable_stock() {
  std::string* _s = _internal_mutable_stock();
  // @@protoc_insertion_point(field_mutable:data.StockDirectory.stock)
  return _s;
}
inline const std::string& StockDirectory::_internal_stock() const {
  return _impl_.stock_.Get();
}
inline void StockDirectory::_internal_set_stock(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.stock_.Set(value, GetArenaForAllocation());
}
inline std::string* StockDirectory::_internal_mutable_stock() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.stock_.Mutable(GetArenaForAllocation());
}
inline std::string* StockDirectory::release_stock() {
  // @@protoc_insertion_point(field_release:data.StockDirectory.stock)
  if (!_internal_has_stock()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.stock_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.stock_.IsDefault()) {
    _impl_.stock_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void StockDirectory::set_allocated_stock(std::string* stock) {
  if (stock != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.stock_.SetAllocated(stock, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.stock_.IsDefault()) {
    _impl_.stock_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:data.StockDirectory.stock)
}

// optional .data.MarketCategory marketCategory = 2;
inline bool StockDirectory::_internal_has_marketcategory() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool StockDirectory::has_marketcategory() const {
  return _internal_has_marketcategory();
}
inline void StockDirectory::clear_marketcategory() {
  _impl_.marketcategory_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::data::MarketCategory StockDirectory::_internal_marketcategory() const {
  return static_cast< ::data::MarketCategory >(_impl_.marketcategory_);
}
inline ::data::MarketCategory StockDirectory::marketcategory() const {
  // @@protoc_insertion_point(field_get:data.StockDirectory.marketCategory)
  return _internal_marketcategory();
}
inline void StockDirectory::_internal_set_marketcategory(::data::MarketCategory value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.marketcategory_ = value;
}
inline void StockDirectory::set_marketcategory(::data::MarketCategory value) {
  _internal_set_marketcategory(value);
  // @@protoc_insertion_point(field_set:data.StockDirectory.marketCategory)
}

// optional .data.FinancialStatusIndicator financialStatusIndicator = 3;
inline bool StockDirectory::_internal_has_financialstatusindicator() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool StockDirectory::has_financialstatusindicator() const {
  return _internal_has_financialstatusindicator();
}
inline void StockDirectory::clear_financialstatusindicator() {
  _impl_.financialstatusindicator_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::data::FinancialStatusIndicator StockDirectory::_internal_financialstatusindicator() const {
  return static_cast< ::data::FinancialStatusIndicator >(_impl_.financialstatusindicator_);
}
inline ::data::FinancialStatusIndicator StockDirectory::financialstatusindicator() const {
  // @@protoc_insertion_point(field_get:data.StockDirectory.financialStatusIndicator)
  return _internal_financialstatusindicator();
}
inline void StockDirectory::_internal_set_financialstatusindicator(::data::FinancialStatusIndicator value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.financialstatusindicator_ = value;
}
inline void StockDirectory::set_financialstatusindicator(::data::FinancialStatusIndicator value) {
  _internal_set_financialstatusindicator(value);
  // @@protoc_insertion_point(field_set:data.StockDirectory.financialStatusIndicator)
}

// optional int64 roundLotsize = 4;
inline bool StockDirectory::_internal_has_roundlotsize() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool StockDirectory::has_roundlotsize() const {
  return _internal_has_roundlotsize();
}
inline void StockDirectory::clear_roundlotsize() {
  _impl_.roundlotsize_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline int64_t StockDirectory::_internal_roundlotsize() const {
  return _impl_.roundlotsize_;
}
inline int64_t StockDirectory::roundlotsize() const {
  // @@protoc_insertion_point(field_get:data.StockDirectory.roundLotsize)
  return _internal_roundlotsize();
}
inline void StockDirectory::_internal_set_roundlotsize(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.roundlotsize_ = value;
}
inline void StockDirectory::set_roundlotsize(int64_t value) {
  _internal_set_roundlotsize(value);
  // @@protoc_insertion_point(field_set:data.StockDirectory.roundLotsize)
}

// optional .data.IndicatesIf roundLotOnly = 5;
inline bool StockDirectory::_internal_has_roundlotonly() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool StockDirectory::has_roundlotonly() const {
  return _internal_has_roundlotonly();
}
inline void StockDirectory::clear_roundlotonly() {
  _impl_.roundlotonly_ = 0;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline ::data::IndicatesIf StockDirectory::_internal_roundlotonly() const {
  return static_cast< ::data::IndicatesIf >(_impl_.roundlotonly_);
}
inline ::data::IndicatesIf StockDirectory::roundlotonly() const {
  // @@protoc_insertion_point(field_get:data.StockDirectory.roundLotOnly)
  return _internal_roundlotonly();
}
inline void StockDirectory::_internal_set_roundlotonly(::data::IndicatesIf value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.roundlotonly_ = value;
}
inline void StockDirectory::set_roundlotonly(::data::IndicatesIf value) {
  _internal_set_roundlotonly(value);
  // @@protoc_insertion_point(field_set:data.StockDirectory.roundLotOnly)
}

// optional string issueClassification = 6;
inline bool StockDirectory::_internal_has_issueclassification() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool StockDirectory::has_issueclassification() const {
  return _internal_has_issueclassification();
}
inline void StockDirectory::clear_issueclassification() {
  _impl_.issueclassification_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& StockDirectory::issueclassification() const {
  // @@protoc_insertion_point(field_get:data.StockDirectory.issueClassification)
  return _internal_issueclassification();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StockDirectory::set_issueclassification(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.issueclassification_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:data.StockDirectory.issueClassification)
}
inline std::string* StockDirectory::mutable_issueclassification() {
  std::string* _s = _internal_mutable_issueclassification();
  // @@protoc_insertion_point(field_mutable:data.StockDirectory.issueClassification)
  return _s;
}
inline const std::string& StockDirectory::_internal_issueclassification() const {
  return _impl_.issueclassification_.Get();
}
inline void StockDirectory::_internal_set_issueclassification(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.issueclassification_.Set(value, GetArenaForAllocation());
}
inline std::string* StockDirectory::_internal_mutable_issueclassification() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.issueclassification_.Mutable(GetArenaForAllocation());
}
inline std::string* StockDirectory::release_issueclassification() {
  // @@protoc_insertion_point(field_release:data.StockDirectory.issueClassification)
  if (!_internal_has_issueclassification()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.issueclassification_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.issueclassification_.IsDefault()) {
    _impl_.issueclassification_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void StockDirectory::set_allocated_issueclassification(std::string* issueclassification) {
  if (issueclassification != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.issueclassification_.SetAllocated(issueclassification, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.issueclassification_.IsDefault()) {
    _impl_.issueclassification_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:data.StockDirectory.issueClassification)
}

// optional string issueSubType = 7;
inline bool StockDirectory::_internal_has_issuesubtype() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool StockDirectory::has_issuesubtype() const {
  return _internal_has_issuesubtype();
}
inline void StockDirectory::clear_issuesubtype() {
  _impl_.issuesubtype_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& StockDirectory::issuesubtype() const {
  // @@protoc_insertion_point(field_get:data.StockDirectory.issueSubType)
  return _internal_issuesubtype();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StockDirectory::set_issuesubtype(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.issuesubtype_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:data.StockDirectory.issueSubType)
}
inline std::string* StockDirectory::mutable_issuesubtype() {
  std::string* _s = _internal_mutable_issuesubtype();
  // @@protoc_insertion_point(field_mutable:data.StockDirectory.issueSubType)
  return _s;
}
inline const std::string& StockDirectory::_internal_issuesubtype() const {
  return _impl_.issuesubtype_.Get();
}
inline void StockDirectory::_internal_set_issuesubtype(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.issuesubtype_.Set(value, GetArenaForAllocation());
}
inline std::string* StockDirectory::_internal_mutable_issuesubtype() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.issuesubtype_.Mutable(GetArenaForAllocation());
}
inline std::string* StockDirectory::release_issuesubtype() {
  // @@protoc_insertion_point(field_release:data.StockDirectory.issueSubType)
  if (!_internal_has_issuesubtype()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.issuesubtype_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.issuesubtype_.IsDefault()) {
    _impl_.issuesubtype_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void StockDirectory::set_allocated_issuesubtype(std::string* issuesubtype) {
  if (issuesubtype != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.issuesubtype_.SetAllocated(issuesubtype, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.issuesubtype_.IsDefault()) {
    _impl_.issuesubtype_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:data.StockDirectory.issueSubType)
}

// optional .data.Authenticity authenticity = 8;
inline bool StockDirectory::_internal_has_authenticity() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool StockDirectory::has_authenticity() const {
  return _internal_has_authenticity();
}
inline void StockDirectory::clear_authenticity() {
  _impl_.authenticity_ = 0;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline ::data::Authenticity StockDirectory::_internal_authenticity() const {
  return static_cast< ::data::Authenticity >(_impl_.authenticity_);
}
inline ::data::Authenticity StockDirectory::authenticity() const {
  // @@protoc_insertion_point(field_get:data.StockDirectory.authenticity)
  return _internal_authenticity();
}
inline void StockDirectory::_internal_set_authenticity(::data::Authenticity value) {
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.authenticity_ = value;
}
inline void StockDirectory::set_authenticity(::data::Authenticity value) {
  _internal_set_authenticity(value);
  // @@protoc_insertion_point(field_set:data.StockDirectory.authenticity)
}

// optional .data.IndicatesIf shortSaleThresholdIndicator = 9;
inline bool StockDirectory::_internal_has_shortsalethresholdindicator() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool StockDirectory::has_shortsalethresholdindicator() const {
  return _internal_has_shortsalethresholdindicator();
}
inline void StockDirectory::clear_shortsalethresholdindicator() {
  _impl_.shortsalethresholdindicator_ = 0;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline ::data::IndicatesIf StockDirectory::_internal_shortsalethresholdindicator() const {
  return static_cast< ::data::IndicatesIf >(_impl_.shortsalethresholdindicator_);
}
inline ::data::IndicatesIf StockDirectory::shortsalethresholdindicator() const {
  // @@protoc_insertion_point(field_get:data.StockDirectory.shortSaleThresholdIndicator)
  return _internal_shortsalethresholdindicator();
}
inline void StockDirectory::_internal_set_shortsalethresholdindicator(::data::IndicatesIf value) {
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.shortsalethresholdindicator_ = value;
}
inline void StockDirectory::set_shortsalethresholdindicator(::data::IndicatesIf value) {
  _internal_set_shortsalethresholdindicator(value);
  // @@protoc_insertion_point(field_set:data.StockDirectory.shortSaleThresholdIndicator)
}

// optional .data.IndicatesIf IPOFlag = 10;
inline bool StockDirectory::_internal_has_ipoflag() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool StockDirectory::has_ipoflag() const {
  return _internal_has_ipoflag();
}
inline void StockDirectory::clear_ipoflag() {
  _impl_.ipoflag_ = 0;
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline ::data::IndicatesIf StockDirectory::_internal_ipoflag() const {
  return static_cast< ::data::IndicatesIf >(_impl_.ipoflag_);
}
inline ::data::IndicatesIf StockDirectory::ipoflag() const {
  // @@protoc_insertion_point(field_get:data.StockDirectory.IPOFlag)
  return _internal_ipoflag();
}
inline void StockDirectory::_internal_set_ipoflag(::data::IndicatesIf value) {
  _impl_._has_bits_[0] |= 0x00000400u;
  _impl_.ipoflag_ = value;
}
inline void StockDirectory::set_ipoflag(::data::IndicatesIf value) {
  _internal_set_ipoflag(value);
  // @@protoc_insertion_point(field_set:data.StockDirectory.IPOFlag)
}

// optional .data.LULDRule lULDReferencePriceTier = 11;
inline bool StockDirectory::_internal_has_luldreferencepricetier() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool StockDirectory::has_luldreferencepricetier() const {
  return _internal_has_luldreferencepricetier();
}
inline void StockDirectory::clear_luldreferencepricetier() {
  _impl_.luldreferencepricetier_ = 0;
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline ::data::LULDRule StockDirectory::_internal_luldreferencepricetier() const {
  return static_cast< ::data::LULDRule >(_impl_.luldreferencepricetier_);
}
inline ::data::LULDRule StockDirectory::luldreferencepricetier() const {
  // @@protoc_insertion_point(field_get:data.StockDirectory.lULDReferencePriceTier)
  return _internal_luldreferencepricetier();
}
inline void StockDirectory::_internal_set_luldreferencepricetier(::data::LULDRule value) {
  _impl_._has_bits_[0] |= 0x00000800u;
  _impl_.luldreferencepricetier_ = value;
}
inline void StockDirectory::set_luldreferencepricetier(::data::LULDRule value) {
  _internal_set_luldreferencepricetier(value);
  // @@protoc_insertion_point(field_set:data.StockDirectory.lULDReferencePriceTier)
}

// optional .data.IndicatesIf ETPlag = 12;
inline bool StockDirectory::_internal_has_etplag() const {
  bool value = (_impl_._has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool StockDirectory::has_etplag() const {
  return _internal_has_etplag();
}
inline void StockDirectory::clear_etplag() {
  _impl_.etplag_ = 0;
  _impl_._has_bits_[0] &= ~0x00001000u;
}
inline ::data::IndicatesIf StockDirectory::_internal_etplag() const {
  return static_cast< ::data::IndicatesIf >(_impl_.etplag_);
}
inline ::data::IndicatesIf StockDirectory::etplag() const {
  // @@protoc_insertion_point(field_get:data.StockDirectory.ETPlag)
  return _internal_etplag();
}
inline void StockDirectory::_internal_set_etplag(::data::IndicatesIf value) {
  _impl_._has_bits_[0] |= 0x00001000u;
  _impl_.etplag_ = value;
}
inline void StockDirectory::set_etplag(::data::IndicatesIf value) {
  _internal_set_etplag(value);
  // @@protoc_insertion_point(field_set:data.StockDirectory.ETPlag)
}

// optional int64 ETPLeverageFactor = 13;
inline bool StockDirectory::_internal_has_etpleveragefactor() const {
  bool value = (_impl_._has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool StockDirectory::has_etpleveragefactor() const {
  return _internal_has_etpleveragefactor();
}
inline void StockDirectory::clear_etpleveragefactor() {
  _impl_.etpleveragefactor_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00002000u;
}
inline int64_t StockDirectory::_internal_etpleveragefactor() const {
  return _impl_.etpleveragefactor_;
}
inline int64_t StockDirectory::etpleveragefactor() const {
  // @@protoc_insertion_point(field_get:data.StockDirectory.ETPLeverageFactor)
  return _internal_etpleveragefactor();
}
inline void StockDirectory::_internal_set_etpleveragefactor(int64_t value) {
  _impl_._has_bits_[0] |= 0x00002000u;
  _impl_.etpleveragefactor_ = value;
}
inline void StockDirectory::set_etpleveragefactor(int64_t value) {
  _internal_set_etpleveragefactor(value);
  // @@protoc_insertion_point(field_set:data.StockDirectory.ETPLeverageFactor)
}

// optional .data.IndicatesIf inverseIndicator = 14;
inline bool StockDirectory::_internal_has_inverseindicator() const {
  bool value = (_impl_._has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline bool StockDirectory::has_inverseindicator() const {
  return _internal_has_inverseindicator();
}
inline void StockDirectory::clear_inverseindicator() {
  _impl_.inverseindicator_ = 0;
  _impl_._has_bits_[0] &= ~0x00004000u;
}
inline ::data::IndicatesIf StockDirectory::_internal_inverseindicator() const {
  return static_cast< ::data::IndicatesIf >(_impl_.inverseindicator_);
}
inline ::data::IndicatesIf StockDirectory::inverseindicator() const {
  // @@protoc_insertion_point(field_get:data.StockDirectory.inverseIndicator)
  return _internal_inverseindicator();
}
inline void StockDirectory::_internal_set_inverseindicator(::data::IndicatesIf value) {
  _impl_._has_bits_[0] |= 0x00004000u;
  _impl_.inverseindicator_ = value;
}
inline void StockDirectory::set_inverseindicator(::data::IndicatesIf value) {
  _internal_set_inverseindicator(value);
  // @@protoc_insertion_point(field_set:data.StockDirectory.inverseIndicator)
}

// optional string bloombergID = 15;
inline bool StockDirectory::_internal_has_bloombergid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool StockDirectory::has_bloombergid() const {
  return _internal_has_bloombergid();
}
inline void StockDirectory::clear_bloombergid() {
  _impl_.bloombergid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& StockDirectory::bloombergid() const {
  // @@protoc_insertion_point(field_get:data.StockDirectory.bloombergID)
  return _internal_bloombergid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StockDirectory::set_bloombergid(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000008u;
 _impl_.bloombergid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:data.StockDirectory.bloombergID)
}
inline std::string* StockDirectory::mutable_bloombergid() {
  std::string* _s = _internal_mutable_bloombergid();
  // @@protoc_insertion_point(field_mutable:data.StockDirectory.bloombergID)
  return _s;
}
inline const std::string& StockDirectory::_internal_bloombergid() const {
  return _impl_.bloombergid_.Get();
}
inline void StockDirectory::_internal_set_bloombergid(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.bloombergid_.Set(value, GetArenaForAllocation());
}
inline std::string* StockDirectory::_internal_mutable_bloombergid() {
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.bloombergid_.Mutable(GetArenaForAllocation());
}
inline std::string* StockDirectory::release_bloombergid() {
  // @@protoc_insertion_point(field_release:data.StockDirectory.bloombergID)
  if (!_internal_has_bloombergid()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* p = _impl_.bloombergid_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.bloombergid_.IsDefault()) {
    _impl_.bloombergid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void StockDirectory::set_allocated_bloombergid(std::string* bloombergid) {
  if (bloombergid != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.bloombergid_.SetAllocated(bloombergid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.bloombergid_.IsDefault()) {
    _impl_.bloombergid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:data.StockDirectory.bloombergID)
}

// -------------------------------------------------------------------

// StockTradingAction

// optional string reserved = 1;
inline bool StockTradingAction::_internal_has_reserved() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool StockTradingAction::has_reserved() const {
  return _internal_has_reserved();
}
inline void StockTradingAction::clear_reserved() {
  _impl_.reserved_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& StockTradingAction::reserved() const {
  // @@protoc_insertion_point(field_get:data.StockTradingAction.reserved)
  return _internal_reserved();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StockTradingAction::set_reserved(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.reserved_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:data.StockTradingAction.reserved)
}
inline std::string* StockTradingAction::mutable_reserved() {
  std::string* _s = _internal_mutable_reserved();
  // @@protoc_insertion_point(field_mutable:data.StockTradingAction.reserved)
  return _s;
}
inline const std::string& StockTradingAction::_internal_reserved() const {
  return _impl_.reserved_.Get();
}
inline void StockTradingAction::_internal_set_reserved(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.reserved_.Set(value, GetArenaForAllocation());
}
inline std::string* StockTradingAction::_internal_mutable_reserved() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.reserved_.Mutable(GetArenaForAllocation());
}
inline std::string* StockTradingAction::release_reserved() {
  // @@protoc_insertion_point(field_release:data.StockTradingAction.reserved)
  if (!_internal_has_reserved()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.reserved_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.reserved_.IsDefault()) {
    _impl_.reserved_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void StockTradingAction::set_allocated_reserved(std::string* reserved) {
  if (reserved != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.reserved_.SetAllocated(reserved, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.reserved_.IsDefault()) {
    _impl_.reserved_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:data.StockTradingAction.reserved)
}

// optional string issueSymbol = 2;
inline bool StockTradingAction::_internal_has_issuesymbol() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool StockTradingAction::has_issuesymbol() const {
  return _internal_has_issuesymbol();
}
inline void StockTradingAction::clear_issuesymbol() {
  _impl_.issuesymbol_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& StockTradingAction::issuesymbol() const {
  // @@protoc_insertion_point(field_get:data.StockTradingAction.issueSymbol)
  return _internal_issuesymbol();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StockTradingAction::set_issuesymbol(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.issuesymbol_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:data.StockTradingAction.issueSymbol)
}
inline std::string* StockTradingAction::mutable_issuesymbol() {
  std::string* _s = _internal_mutable_issuesymbol();
  // @@protoc_insertion_point(field_mutable:data.StockTradingAction.issueSymbol)
  return _s;
}
inline const std::string& StockTradingAction::_internal_issuesymbol() const {
  return _impl_.issuesymbol_.Get();
}
inline void StockTradingAction::_internal_set_issuesymbol(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.issuesymbol_.Set(value, GetArenaForAllocation());
}
inline std::string* StockTradingAction::_internal_mutable_issuesymbol() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.issuesymbol_.Mutable(GetArenaForAllocation());
}
inline std::string* StockTradingAction::release_issuesymbol() {
  // @@protoc_insertion_point(field_release:data.StockTradingAction.issueSymbol)
  if (!_internal_has_issuesymbol()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.issuesymbol_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.issuesymbol_.IsDefault()) {
    _impl_.issuesymbol_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void StockTradingAction::set_allocated_issuesymbol(std::string* issuesymbol) {
  if (issuesymbol != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.issuesymbol_.SetAllocated(issuesymbol, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.issuesymbol_.IsDefault()) {
    _impl_.issuesymbol_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:data.StockTradingAction.issueSymbol)
}

// optional .data.SecurityClass securityClass = 3;
inline bool StockTradingAction::_internal_has_securityclass() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool StockTradingAction::has_securityclass() const {
  return _internal_has_securityclass();
}
inline void StockTradingAction::clear_securityclass() {
  _impl_.securityclass_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::data::SecurityClass StockTradingAction::_internal_securityclass() const {
  return static_cast< ::data::SecurityClass >(_impl_.securityclass_);
}
inline ::data::SecurityClass StockTradingAction::securityclass() const {
  // @@protoc_insertion_point(field_get:data.StockTradingAction.securityClass)
  return _internal_securityclass();
}
inline void StockTradingAction::_internal_set_securityclass(::data::SecurityClass value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.securityclass_ = value;
}
inline void StockTradingAction::set_securityclass(::data::SecurityClass value) {
  _internal_set_securityclass(value);
  // @@protoc_insertion_point(field_set:data.StockTradingAction.securityClass)
}

// optional .data.CurrentTradingState currentTradingState = 4;
inline bool StockTradingAction::_internal_has_currenttradingstate() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool StockTradingAction::has_currenttradingstate() const {
  return _internal_has_currenttradingstate();
}
inline void StockTradingAction::clear_currenttradingstate() {
  _impl_.currenttradingstate_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::data::CurrentTradingState StockTradingAction::_internal_currenttradingstate() const {
  return static_cast< ::data::CurrentTradingState >(_impl_.currenttradingstate_);
}
inline ::data::CurrentTradingState StockTradingAction::currenttradingstate() const {
  // @@protoc_insertion_point(field_get:data.StockTradingAction.currentTradingState)
  return _internal_currenttradingstate();
}
inline void StockTradingAction::_internal_set_currenttradingstate(::data::CurrentTradingState value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.currenttradingstate_ = value;
}
inline void StockTradingAction::set_currenttradingstate(::data::CurrentTradingState value) {
  _internal_set_currenttradingstate(value);
  // @@protoc_insertion_point(field_set:data.StockTradingAction.currentTradingState)
}

// optional string reason = 5;
inline bool StockTradingAction::_internal_has_reason() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool StockTradingAction::has_reason() const {
  return _internal_has_reason();
}
inline void StockTradingAction::clear_reason() {
  _impl_.reason_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& StockTradingAction::reason() const {
  // @@protoc_insertion_point(field_get:data.StockTradingAction.reason)
  return _internal_reason();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StockTradingAction::set_reason(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.reason_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:data.StockTradingAction.reason)
}
inline std::string* StockTradingAction::mutable_reason() {
  std::string* _s = _internal_mutable_reason();
  // @@protoc_insertion_point(field_mutable:data.StockTradingAction.reason)
  return _s;
}
inline const std::string& StockTradingAction::_internal_reason() const {
  return _impl_.reason_.Get();
}
inline void StockTradingAction::_internal_set_reason(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.reason_.Set(value, GetArenaForAllocation());
}
inline std::string* StockTradingAction::_internal_mutable_reason() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.reason_.Mutable(GetArenaForAllocation());
}
inline std::string* StockTradingAction::release_reason() {
  // @@protoc_insertion_point(field_release:data.StockTradingAction.reason)
  if (!_internal_has_reason()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.reason_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.reason_.IsDefault()) {
    _impl_.reason_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void StockTradingAction::set_allocated_reason(std::string* reason) {
  if (reason != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.reason_.SetAllocated(reason, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.reason_.IsDefault()) {
    _impl_.reason_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:data.StockTradingAction.reason)
}

// -------------------------------------------------------------------

// SystemEventMessage

// optional .data.EventCode eventCode = 1;
inline bool SystemEventMessage::_internal_has_eventcode() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SystemEventMessage::has_eventcode() const {
  return _internal_has_eventcode();
}
inline void SystemEventMessage::clear_eventcode() {
  _impl_.eventcode_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::data::EventCode SystemEventMessage::_internal_eventcode() const {
  return static_cast< ::data::EventCode >(_impl_.eventcode_);
}
inline ::data::EventCode SystemEventMessage::eventcode() const {
  // @@protoc_insertion_point(field_get:data.SystemEventMessage.eventCode)
  return _internal_eventcode();
}
inline void SystemEventMessage::_internal_set_eventcode(::data::EventCode value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.eventcode_ = value;
}
inline void SystemEventMessage::set_eventcode(::data::EventCode value) {
  _internal_set_eventcode(value);
  // @@protoc_insertion_point(field_set:data.SystemEventMessage.eventCode)
}

// -------------------------------------------------------------------

// TradeCancelForNextsharesTrades

// optional .data.OriginatingMarketCenterIdentifier marketCenterIdentifier = 1;
inline bool TradeCancelForNextsharesTrades::_internal_has_marketcenteridentifier() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool TradeCancelForNextsharesTrades::has_marketcenteridentifier() const {
  return _internal_has_marketcenteridentifier();
}
inline void TradeCancelForNextsharesTrades::clear_marketcenteridentifier() {
  _impl_.marketcenteridentifier_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::data::OriginatingMarketCenterIdentifier TradeCancelForNextsharesTrades::_internal_marketcenteridentifier() const {
  return static_cast< ::data::OriginatingMarketCenterIdentifier >(_impl_.marketcenteridentifier_);
}
inline ::data::OriginatingMarketCenterIdentifier TradeCancelForNextsharesTrades::marketcenteridentifier() const {
  // @@protoc_insertion_point(field_get:data.TradeCancelForNextsharesTrades.marketCenterIdentifier)
  return _internal_marketcenteridentifier();
}
inline void TradeCancelForNextsharesTrades::_internal_set_marketcenteridentifier(::data::OriginatingMarketCenterIdentifier value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.marketcenteridentifier_ = value;
}
inline void TradeCancelForNextsharesTrades::set_marketcenteridentifier(::data::OriginatingMarketCenterIdentifier value) {
  _internal_set_marketcenteridentifier(value);
  // @@protoc_insertion_point(field_set:data.TradeCancelForNextsharesTrades.marketCenterIdentifier)
}

// optional string issueSymbol = 2;
inline bool TradeCancelForNextsharesTrades::_internal_has_issuesymbol() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TradeCancelForNextsharesTrades::has_issuesymbol() const {
  return _internal_has_issuesymbol();
}
inline void TradeCancelForNextsharesTrades::clear_issuesymbol() {
  _impl_.issuesymbol_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TradeCancelForNextsharesTrades::issuesymbol() const {
  // @@protoc_insertion_point(field_get:data.TradeCancelForNextsharesTrades.issueSymbol)
  return _internal_issuesymbol();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TradeCancelForNextsharesTrades::set_issuesymbol(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.issuesymbol_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:data.TradeCancelForNextsharesTrades.issueSymbol)
}
inline std::string* TradeCancelForNextsharesTrades::mutable_issuesymbol() {
  std::string* _s = _internal_mutable_issuesymbol();
  // @@protoc_insertion_point(field_mutable:data.TradeCancelForNextsharesTrades.issueSymbol)
  return _s;
}
inline const std::string& TradeCancelForNextsharesTrades::_internal_issuesymbol() const {
  return _impl_.issuesymbol_.Get();
}
inline void TradeCancelForNextsharesTrades::_internal_set_issuesymbol(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.issuesymbol_.Set(value, GetArenaForAllocation());
}
inline std::string* TradeCancelForNextsharesTrades::_internal_mutable_issuesymbol() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.issuesymbol_.Mutable(GetArenaForAllocation());
}
inline std::string* TradeCancelForNextsharesTrades::release_issuesymbol() {
  // @@protoc_insertion_point(field_release:data.TradeCancelForNextsharesTrades.issueSymbol)
  if (!_internal_has_issuesymbol()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.issuesymbol_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.issuesymbol_.IsDefault()) {
    _impl_.issuesymbol_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TradeCancelForNextsharesTrades::set_allocated_issuesymbol(std::string* issuesymbol) {
  if (issuesymbol != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.issuesymbol_.SetAllocated(issuesymbol, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.issuesymbol_.IsDefault()) {
    _impl_.issuesymbol_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:data.TradeCancelForNextsharesTrades.issueSymbol)
}

// optional .data.SecurityClass securityClass = 3;
inline bool TradeCancelForNextsharesTrades::_internal_has_securityclass() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool TradeCancelForNextsharesTrades::has_securityclass() const {
  return _internal_has_securityclass();
}
inline void TradeCancelForNextsharesTrades::clear_securityclass() {
  _impl_.securityclass_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::data::SecurityClass TradeCancelForNextsharesTrades::_internal_securityclass() const {
  return static_cast< ::data::SecurityClass >(_impl_.securityclass_);
}
inline ::data::SecurityClass TradeCancelForNextsharesTrades::securityclass() const {
  // @@protoc_insertion_point(field_get:data.TradeCancelForNextsharesTrades.securityClass)
  return _internal_securityclass();
}
inline void TradeCancelForNextsharesTrades::_internal_set_securityclass(::data::SecurityClass value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.securityclass_ = value;
}
inline void TradeCancelForNextsharesTrades::set_securityclass(::data::SecurityClass value) {
  _internal_set_securityclass(value);
  // @@protoc_insertion_point(field_set:data.TradeCancelForNextsharesTrades.securityClass)
}

// optional string originalTradeControlNumber = 4;
inline bool TradeCancelForNextsharesTrades::_internal_has_originaltradecontrolnumber() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TradeCancelForNextsharesTrades::has_originaltradecontrolnumber() const {
  return _internal_has_originaltradecontrolnumber();
}
inline void TradeCancelForNextsharesTrades::clear_originaltradecontrolnumber() {
  _impl_.originaltradecontrolnumber_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& TradeCancelForNextsharesTrades::originaltradecontrolnumber() const {
  // @@protoc_insertion_point(field_get:data.TradeCancelForNextsharesTrades.originalTradeControlNumber)
  return _internal_originaltradecontrolnumber();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TradeCancelForNextsharesTrades::set_originaltradecontrolnumber(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.originaltradecontrolnumber_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:data.TradeCancelForNextsharesTrades.originalTradeControlNumber)
}
inline std::string* TradeCancelForNextsharesTrades::mutable_originaltradecontrolnumber() {
  std::string* _s = _internal_mutable_originaltradecontrolnumber();
  // @@protoc_insertion_point(field_mutable:data.TradeCancelForNextsharesTrades.originalTradeControlNumber)
  return _s;
}
inline const std::string& TradeCancelForNextsharesTrades::_internal_originaltradecontrolnumber() const {
  return _impl_.originaltradecontrolnumber_.Get();
}
inline void TradeCancelForNextsharesTrades::_internal_set_originaltradecontrolnumber(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.originaltradecontrolnumber_.Set(value, GetArenaForAllocation());
}
inline std::string* TradeCancelForNextsharesTrades::_internal_mutable_originaltradecontrolnumber() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.originaltradecontrolnumber_.Mutable(GetArenaForAllocation());
}
inline std::string* TradeCancelForNextsharesTrades::release_originaltradecontrolnumber() {
  // @@protoc_insertion_point(field_release:data.TradeCancelForNextsharesTrades.originalTradeControlNumber)
  if (!_internal_has_originaltradecontrolnumber()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.originaltradecontrolnumber_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.originaltradecontrolnumber_.IsDefault()) {
    _impl_.originaltradecontrolnumber_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TradeCancelForNextsharesTrades::set_allocated_originaltradecontrolnumber(std::string* originaltradecontrolnumber) {
  if (originaltradecontrolnumber != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.originaltradecontrolnumber_.SetAllocated(originaltradecontrolnumber, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.originaltradecontrolnumber_.IsDefault()) {
    _impl_.originaltradecontrolnumber_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:data.TradeCancelForNextsharesTrades.originalTradeControlNumber)
}

// optional double originalProxyPrice = 5;
inline bool TradeCancelForNextsharesTrades::_internal_has_originalproxyprice() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool TradeCancelForNextsharesTrades::has_originalproxyprice() const {
  return _internal_has_originalproxyprice();
}
inline void TradeCancelForNextsharesTrades::clear_originalproxyprice() {
  _impl_.originalproxyprice_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline double TradeCancelForNextsharesTrades::_internal_originalproxyprice() const {
  return _impl_.originalproxyprice_;
}
inline double TradeCancelForNextsharesTrades::originalproxyprice() const {
  // @@protoc_insertion_point(field_get:data.TradeCancelForNextsharesTrades.originalProxyPrice)
  return _internal_originalproxyprice();
}
inline void TradeCancelForNextsharesTrades::_internal_set_originalproxyprice(double value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.originalproxyprice_ = value;
}
inline void TradeCancelForNextsharesTrades::set_originalproxyprice(double value) {
  _internal_set_originalproxyprice(value);
  // @@protoc_insertion_point(field_set:data.TradeCancelForNextsharesTrades.originalProxyPrice)
}

// optional double originalNAVOffsetAmount = 6;
inline bool TradeCancelForNextsharesTrades::_internal_has_originalnavoffsetamount() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool TradeCancelForNextsharesTrades::has_originalnavoffsetamount() const {
  return _internal_has_originalnavoffsetamount();
}
inline void TradeCancelForNextsharesTrades::clear_originalnavoffsetamount() {
  _impl_.originalnavoffsetamount_ = 0;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline double TradeCancelForNextsharesTrades::_internal_originalnavoffsetamount() const {
  return _impl_.originalnavoffsetamount_;
}
inline double TradeCancelForNextsharesTrades::originalnavoffsetamount() const {
  // @@protoc_insertion_point(field_get:data.TradeCancelForNextsharesTrades.originalNAVOffsetAmount)
  return _internal_originalnavoffsetamount();
}
inline void TradeCancelForNextsharesTrades::_internal_set_originalnavoffsetamount(double value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.originalnavoffsetamount_ = value;
}
inline void TradeCancelForNextsharesTrades::set_originalnavoffsetamount(double value) {
  _internal_set_originalnavoffsetamount(value);
  // @@protoc_insertion_point(field_set:data.TradeCancelForNextsharesTrades.originalNAVOffsetAmount)
}

// optional int64 originalTradeSize = 7;
inline bool TradeCancelForNextsharesTrades::_internal_has_originaltradesize() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool TradeCancelForNextsharesTrades::has_originaltradesize() const {
  return _internal_has_originaltradesize();
}
inline void TradeCancelForNextsharesTrades::clear_originaltradesize() {
  _impl_.originaltradesize_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline int64_t TradeCancelForNextsharesTrades::_internal_originaltradesize() const {
  return _impl_.originaltradesize_;
}
inline int64_t TradeCancelForNextsharesTrades::originaltradesize() const {
  // @@protoc_insertion_point(field_get:data.TradeCancelForNextsharesTrades.originalTradeSize)
  return _internal_originaltradesize();
}
inline void TradeCancelForNextsharesTrades::_internal_set_originaltradesize(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.originaltradesize_ = value;
}
inline void TradeCancelForNextsharesTrades::set_originaltradesize(int64_t value) {
  _internal_set_originaltradesize(value);
  // @@protoc_insertion_point(field_set:data.TradeCancelForNextsharesTrades.originalTradeSize)
}

// optional string originalSaleConditionModifier = 8;
inline bool TradeCancelForNextsharesTrades::_internal_has_originalsaleconditionmodifier() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool TradeCancelForNextsharesTrades::has_originalsaleconditionmodifier() const {
  return _internal_has_originalsaleconditionmodifier();
}
inline void TradeCancelForNextsharesTrades::clear_originalsaleconditionmodifier() {
  _impl_.originalsaleconditionmodifier_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& TradeCancelForNextsharesTrades::originalsaleconditionmodifier() const {
  // @@protoc_insertion_point(field_get:data.TradeCancelForNextsharesTrades.originalSaleConditionModifier)
  return _internal_originalsaleconditionmodifier();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TradeCancelForNextsharesTrades::set_originalsaleconditionmodifier(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.originalsaleconditionmodifier_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:data.TradeCancelForNextsharesTrades.originalSaleConditionModifier)
}
inline std::string* TradeCancelForNextsharesTrades::mutable_originalsaleconditionmodifier() {
  std::string* _s = _internal_mutable_originalsaleconditionmodifier();
  // @@protoc_insertion_point(field_mutable:data.TradeCancelForNextsharesTrades.originalSaleConditionModifier)
  return _s;
}
inline const std::string& TradeCancelForNextsharesTrades::_internal_originalsaleconditionmodifier() const {
  return _impl_.originalsaleconditionmodifier_.Get();
}
inline void TradeCancelForNextsharesTrades::_internal_set_originalsaleconditionmodifier(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.originalsaleconditionmodifier_.Set(value, GetArenaForAllocation());
}
inline std::string* TradeCancelForNextsharesTrades::_internal_mutable_originalsaleconditionmodifier() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.originalsaleconditionmodifier_.Mutable(GetArenaForAllocation());
}
inline std::string* TradeCancelForNextsharesTrades::release_originalsaleconditionmodifier() {
  // @@protoc_insertion_point(field_release:data.TradeCancelForNextsharesTrades.originalSaleConditionModifier)
  if (!_internal_has_originalsaleconditionmodifier()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.originalsaleconditionmodifier_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.originalsaleconditionmodifier_.IsDefault()) {
    _impl_.originalsaleconditionmodifier_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TradeCancelForNextsharesTrades::set_allocated_originalsaleconditionmodifier(std::string* originalsaleconditionmodifier) {
  if (originalsaleconditionmodifier != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.originalsaleconditionmodifier_.SetAllocated(originalsaleconditionmodifier, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.originalsaleconditionmodifier_.IsDefault()) {
    _impl_.originalsaleconditionmodifier_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:data.TradeCancelForNextsharesTrades.originalSaleConditionModifier)
}

// optional int64 consolidatedVolume = 9;
inline bool TradeCancelForNextsharesTrades::_internal_has_consolidatedvolume() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool TradeCancelForNextsharesTrades::has_consolidatedvolume() const {
  return _internal_has_consolidatedvolume();
}
inline void TradeCancelForNextsharesTrades::clear_consolidatedvolume() {
  _impl_.consolidatedvolume_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline int64_t TradeCancelForNextsharesTrades::_internal_consolidatedvolume() const {
  return _impl_.consolidatedvolume_;
}
inline int64_t TradeCancelForNextsharesTrades::consolidatedvolume() const {
  // @@protoc_insertion_point(field_get:data.TradeCancelForNextsharesTrades.consolidatedVolume)
  return _internal_consolidatedvolume();
}
inline void TradeCancelForNextsharesTrades::_internal_set_consolidatedvolume(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.consolidatedvolume_ = value;
}
inline void TradeCancelForNextsharesTrades::set_consolidatedvolume(int64_t value) {
  _internal_set_consolidatedvolume(value);
  // @@protoc_insertion_point(field_set:data.TradeCancelForNextsharesTrades.consolidatedVolume)
}

// -------------------------------------------------------------------

// TradeCancelForNonNextSharesTrades

// optional .data.OriginatingMarketCenterIdentifier marketCenterIdentifier = 1;
inline bool TradeCancelForNonNextSharesTrades::_internal_has_marketcenteridentifier() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool TradeCancelForNonNextSharesTrades::has_marketcenteridentifier() const {
  return _internal_has_marketcenteridentifier();
}
inline void TradeCancelForNonNextSharesTrades::clear_marketcenteridentifier() {
  _impl_.marketcenteridentifier_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::data::OriginatingMarketCenterIdentifier TradeCancelForNonNextSharesTrades::_internal_marketcenteridentifier() const {
  return static_cast< ::data::OriginatingMarketCenterIdentifier >(_impl_.marketcenteridentifier_);
}
inline ::data::OriginatingMarketCenterIdentifier TradeCancelForNonNextSharesTrades::marketcenteridentifier() const {
  // @@protoc_insertion_point(field_get:data.TradeCancelForNonNextSharesTrades.marketCenterIdentifier)
  return _internal_marketcenteridentifier();
}
inline void TradeCancelForNonNextSharesTrades::_internal_set_marketcenteridentifier(::data::OriginatingMarketCenterIdentifier value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.marketcenteridentifier_ = value;
}
inline void TradeCancelForNonNextSharesTrades::set_marketcenteridentifier(::data::OriginatingMarketCenterIdentifier value) {
  _internal_set_marketcenteridentifier(value);
  // @@protoc_insertion_point(field_set:data.TradeCancelForNonNextSharesTrades.marketCenterIdentifier)
}

// optional string issueSymbol = 2;
inline bool TradeCancelForNonNextSharesTrades::_internal_has_issuesymbol() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TradeCancelForNonNextSharesTrades::has_issuesymbol() const {
  return _internal_has_issuesymbol();
}
inline void TradeCancelForNonNextSharesTrades::clear_issuesymbol() {
  _impl_.issuesymbol_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TradeCancelForNonNextSharesTrades::issuesymbol() const {
  // @@protoc_insertion_point(field_get:data.TradeCancelForNonNextSharesTrades.issueSymbol)
  return _internal_issuesymbol();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TradeCancelForNonNextSharesTrades::set_issuesymbol(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.issuesymbol_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:data.TradeCancelForNonNextSharesTrades.issueSymbol)
}
inline std::string* TradeCancelForNonNextSharesTrades::mutable_issuesymbol() {
  std::string* _s = _internal_mutable_issuesymbol();
  // @@protoc_insertion_point(field_mutable:data.TradeCancelForNonNextSharesTrades.issueSymbol)
  return _s;
}
inline const std::string& TradeCancelForNonNextSharesTrades::_internal_issuesymbol() const {
  return _impl_.issuesymbol_.Get();
}
inline void TradeCancelForNonNextSharesTrades::_internal_set_issuesymbol(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.issuesymbol_.Set(value, GetArenaForAllocation());
}
inline std::string* TradeCancelForNonNextSharesTrades::_internal_mutable_issuesymbol() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.issuesymbol_.Mutable(GetArenaForAllocation());
}
inline std::string* TradeCancelForNonNextSharesTrades::release_issuesymbol() {
  // @@protoc_insertion_point(field_release:data.TradeCancelForNonNextSharesTrades.issueSymbol)
  if (!_internal_has_issuesymbol()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.issuesymbol_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.issuesymbol_.IsDefault()) {
    _impl_.issuesymbol_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TradeCancelForNonNextSharesTrades::set_allocated_issuesymbol(std::string* issuesymbol) {
  if (issuesymbol != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.issuesymbol_.SetAllocated(issuesymbol, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.issuesymbol_.IsDefault()) {
    _impl_.issuesymbol_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:data.TradeCancelForNonNextSharesTrades.issueSymbol)
}

// optional .data.SecurityClass securityClass = 3;
inline bool TradeCancelForNonNextSharesTrades::_internal_has_securityclass() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool TradeCancelForNonNextSharesTrades::has_securityclass() const {
  return _internal_has_securityclass();
}
inline void TradeCancelForNonNextSharesTrades::clear_securityclass() {
  _impl_.securityclass_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::data::SecurityClass TradeCancelForNonNextSharesTrades::_internal_securityclass() const {
  return static_cast< ::data::SecurityClass >(_impl_.securityclass_);
}
inline ::data::SecurityClass TradeCancelForNonNextSharesTrades::securityclass() const {
  // @@protoc_insertion_point(field_get:data.TradeCancelForNonNextSharesTrades.securityClass)
  return _internal_securityclass();
}
inline void TradeCancelForNonNextSharesTrades::_internal_set_securityclass(::data::SecurityClass value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.securityclass_ = value;
}
inline void TradeCancelForNonNextSharesTrades::set_securityclass(::data::SecurityClass value) {
  _internal_set_securityclass(value);
  // @@protoc_insertion_point(field_set:data.TradeCancelForNonNextSharesTrades.securityClass)
}

// optional string originalControlNumber = 4;
inline bool TradeCancelForNonNextSharesTrades::_internal_has_originalcontrolnumber() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TradeCancelForNonNextSharesTrades::has_originalcontrolnumber() const {
  return _internal_has_originalcontrolnumber();
}
inline void TradeCancelForNonNextSharesTrades::clear_originalcontrolnumber() {
  _impl_.originalcontrolnumber_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& TradeCancelForNonNextSharesTrades::originalcontrolnumber() const {
  // @@protoc_insertion_point(field_get:data.TradeCancelForNonNextSharesTrades.originalControlNumber)
  return _internal_originalcontrolnumber();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TradeCancelForNonNextSharesTrades::set_originalcontrolnumber(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.originalcontrolnumber_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:data.TradeCancelForNonNextSharesTrades.originalControlNumber)
}
inline std::string* TradeCancelForNonNextSharesTrades::mutable_originalcontrolnumber() {
  std::string* _s = _internal_mutable_originalcontrolnumber();
  // @@protoc_insertion_point(field_mutable:data.TradeCancelForNonNextSharesTrades.originalControlNumber)
  return _s;
}
inline const std::string& TradeCancelForNonNextSharesTrades::_internal_originalcontrolnumber() const {
  return _impl_.originalcontrolnumber_.Get();
}
inline void TradeCancelForNonNextSharesTrades::_internal_set_originalcontrolnumber(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.originalcontrolnumber_.Set(value, GetArenaForAllocation());
}
inline std::string* TradeCancelForNonNextSharesTrades::_internal_mutable_originalcontrolnumber() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.originalcontrolnumber_.Mutable(GetArenaForAllocation());
}
inline std::string* TradeCancelForNonNextSharesTrades::release_originalcontrolnumber() {
  // @@protoc_insertion_point(field_release:data.TradeCancelForNonNextSharesTrades.originalControlNumber)
  if (!_internal_has_originalcontrolnumber()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.originalcontrolnumber_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.originalcontrolnumber_.IsDefault()) {
    _impl_.originalcontrolnumber_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TradeCancelForNonNextSharesTrades::set_allocated_originalcontrolnumber(std::string* originalcontrolnumber) {
  if (originalcontrolnumber != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.originalcontrolnumber_.SetAllocated(originalcontrolnumber, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.originalcontrolnumber_.IsDefault()) {
    _impl_.originalcontrolnumber_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:data.TradeCancelForNonNextSharesTrades.originalControlNumber)
}

// optional double originalTradePrice = 5;
inline bool TradeCancelForNonNextSharesTrades::_internal_has_originaltradeprice() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool TradeCancelForNonNextSharesTrades::has_originaltradeprice() const {
  return _internal_has_originaltradeprice();
}
inline void TradeCancelForNonNextSharesTrades::clear_originaltradeprice() {
  _impl_.originaltradeprice_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline double TradeCancelForNonNextSharesTrades::_internal_originaltradeprice() const {
  return _impl_.originaltradeprice_;
}
inline double TradeCancelForNonNextSharesTrades::originaltradeprice() const {
  // @@protoc_insertion_point(field_get:data.TradeCancelForNonNextSharesTrades.originalTradePrice)
  return _internal_originaltradeprice();
}
inline void TradeCancelForNonNextSharesTrades::_internal_set_originaltradeprice(double value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.originaltradeprice_ = value;
}
inline void TradeCancelForNonNextSharesTrades::set_originaltradeprice(double value) {
  _internal_set_originaltradeprice(value);
  // @@protoc_insertion_point(field_set:data.TradeCancelForNonNextSharesTrades.originalTradePrice)
}

// optional int64 originalTradeSize = 6;
inline bool TradeCancelForNonNextSharesTrades::_internal_has_originaltradesize() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool TradeCancelForNonNextSharesTrades::has_originaltradesize() const {
  return _internal_has_originaltradesize();
}
inline void TradeCancelForNonNextSharesTrades::clear_originaltradesize() {
  _impl_.originaltradesize_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline int64_t TradeCancelForNonNextSharesTrades::_internal_originaltradesize() const {
  return _impl_.originaltradesize_;
}
inline int64_t TradeCancelForNonNextSharesTrades::originaltradesize() const {
  // @@protoc_insertion_point(field_get:data.TradeCancelForNonNextSharesTrades.originalTradeSize)
  return _internal_originaltradesize();
}
inline void TradeCancelForNonNextSharesTrades::_internal_set_originaltradesize(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.originaltradesize_ = value;
}
inline void TradeCancelForNonNextSharesTrades::set_originaltradesize(int64_t value) {
  _internal_set_originaltradesize(value);
  // @@protoc_insertion_point(field_set:data.TradeCancelForNonNextSharesTrades.originalTradeSize)
}

// optional .data.SaleConditionModifier originalSaleConditionModifier = 7;
inline bool TradeCancelForNonNextSharesTrades::_internal_has_originalsaleconditionmodifier() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.originalsaleconditionmodifier_ != nullptr);
  return value;
}
inline bool TradeCancelForNonNextSharesTrades::has_originalsaleconditionmodifier() const {
  return _internal_has_originalsaleconditionmodifier();
}
inline void TradeCancelForNonNextSharesTrades::clear_originalsaleconditionmodifier() {
  if (_impl_.originalsaleconditionmodifier_ != nullptr) _impl_.originalsaleconditionmodifier_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::data::SaleConditionModifier& TradeCancelForNonNextSharesTrades::_internal_originalsaleconditionmodifier() const {
  const ::data::SaleConditionModifier* p = _impl_.originalsaleconditionmodifier_;
  return p != nullptr ? *p : reinterpret_cast<const ::data::SaleConditionModifier&>(
      ::data::_SaleConditionModifier_default_instance_);
}
inline const ::data::SaleConditionModifier& TradeCancelForNonNextSharesTrades::originalsaleconditionmodifier() const {
  // @@protoc_insertion_point(field_get:data.TradeCancelForNonNextSharesTrades.originalSaleConditionModifier)
  return _internal_originalsaleconditionmodifier();
}
inline void TradeCancelForNonNextSharesTrades::unsafe_arena_set_allocated_originalsaleconditionmodifier(
    ::data::SaleConditionModifier* originalsaleconditionmodifier) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.originalsaleconditionmodifier_);
  }
  _impl_.originalsaleconditionmodifier_ = originalsaleconditionmodifier;
  if (originalsaleconditionmodifier) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:data.TradeCancelForNonNextSharesTrades.originalSaleConditionModifier)
}
inline ::data::SaleConditionModifier* TradeCancelForNonNextSharesTrades::release_originalsaleconditionmodifier() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::data::SaleConditionModifier* temp = _impl_.originalsaleconditionmodifier_;
  _impl_.originalsaleconditionmodifier_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::data::SaleConditionModifier* TradeCancelForNonNextSharesTrades::unsafe_arena_release_originalsaleconditionmodifier() {
  // @@protoc_insertion_point(field_release:data.TradeCancelForNonNextSharesTrades.originalSaleConditionModifier)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::data::SaleConditionModifier* temp = _impl_.originalsaleconditionmodifier_;
  _impl_.originalsaleconditionmodifier_ = nullptr;
  return temp;
}
inline ::data::SaleConditionModifier* TradeCancelForNonNextSharesTrades::_internal_mutable_originalsaleconditionmodifier() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.originalsaleconditionmodifier_ == nullptr) {
    auto* p = CreateMaybeMessage<::data::SaleConditionModifier>(GetArenaForAllocation());
    _impl_.originalsaleconditionmodifier_ = p;
  }
  return _impl_.originalsaleconditionmodifier_;
}
inline ::data::SaleConditionModifier* TradeCancelForNonNextSharesTrades::mutable_originalsaleconditionmodifier() {
  ::data::SaleConditionModifier* _msg = _internal_mutable_originalsaleconditionmodifier();
  // @@protoc_insertion_point(field_mutable:data.TradeCancelForNonNextSharesTrades.originalSaleConditionModifier)
  return _msg;
}
inline void TradeCancelForNonNextSharesTrades::set_allocated_originalsaleconditionmodifier(::data::SaleConditionModifier* originalsaleconditionmodifier) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.originalsaleconditionmodifier_;
  }
  if (originalsaleconditionmodifier) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(originalsaleconditionmodifier);
    if (message_arena != submessage_arena) {
      originalsaleconditionmodifier = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, originalsaleconditionmodifier, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.originalsaleconditionmodifier_ = originalsaleconditionmodifier;
  // @@protoc_insertion_point(field_set_allocated:data.TradeCancelForNonNextSharesTrades.originalSaleConditionModifier)
}

// optional int64 consolidatedVolume = 8;
inline bool TradeCancelForNonNextSharesTrades::_internal_has_consolidatedvolume() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool TradeCancelForNonNextSharesTrades::has_consolidatedvolume() const {
  return _internal_has_consolidatedvolume();
}
inline void TradeCancelForNonNextSharesTrades::clear_consolidatedvolume() {
  _impl_.consolidatedvolume_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline int64_t TradeCancelForNonNextSharesTrades::_internal_consolidatedvolume() const {
  return _impl_.consolidatedvolume_;
}
inline int64_t TradeCancelForNonNextSharesTrades::consolidatedvolume() const {
  // @@protoc_insertion_point(field_get:data.TradeCancelForNonNextSharesTrades.consolidatedVolume)
  return _internal_consolidatedvolume();
}
inline void TradeCancelForNonNextSharesTrades::_internal_set_consolidatedvolume(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.consolidatedvolume_ = value;
}
inline void TradeCancelForNonNextSharesTrades::set_consolidatedvolume(int64_t value) {
  _internal_set_consolidatedvolume(value);
  // @@protoc_insertion_point(field_set:data.TradeCancelForNonNextSharesTrades.consolidatedVolume)
}

// -------------------------------------------------------------------

// TradeCorrectionForNextsharesTrades

// optional .data.OriginatingMarketCenterIdentifier marketCenterIdentifier = 1;
inline bool TradeCorrectionForNextsharesTrades::_internal_has_marketcenteridentifier() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool TradeCorrectionForNextsharesTrades::has_marketcenteridentifier() const {
  return _internal_has_marketcenteridentifier();
}
inline void TradeCorrectionForNextsharesTrades::clear_marketcenteridentifier() {
  _impl_.marketcenteridentifier_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::data::OriginatingMarketCenterIdentifier TradeCorrectionForNextsharesTrades::_internal_marketcenteridentifier() const {
  return static_cast< ::data::OriginatingMarketCenterIdentifier >(_impl_.marketcenteridentifier_);
}
inline ::data::OriginatingMarketCenterIdentifier TradeCorrectionForNextsharesTrades::marketcenteridentifier() const {
  // @@protoc_insertion_point(field_get:data.TradeCorrectionForNextsharesTrades.marketCenterIdentifier)
  return _internal_marketcenteridentifier();
}
inline void TradeCorrectionForNextsharesTrades::_internal_set_marketcenteridentifier(::data::OriginatingMarketCenterIdentifier value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.marketcenteridentifier_ = value;
}
inline void TradeCorrectionForNextsharesTrades::set_marketcenteridentifier(::data::OriginatingMarketCenterIdentifier value) {
  _internal_set_marketcenteridentifier(value);
  // @@protoc_insertion_point(field_set:data.TradeCorrectionForNextsharesTrades.marketCenterIdentifier)
}

// optional string issueSymbol = 2;
inline bool TradeCorrectionForNextsharesTrades::_internal_has_issuesymbol() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TradeCorrectionForNextsharesTrades::has_issuesymbol() const {
  return _internal_has_issuesymbol();
}
inline void TradeCorrectionForNextsharesTrades::clear_issuesymbol() {
  _impl_.issuesymbol_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TradeCorrectionForNextsharesTrades::issuesymbol() const {
  // @@protoc_insertion_point(field_get:data.TradeCorrectionForNextsharesTrades.issueSymbol)
  return _internal_issuesymbol();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TradeCorrectionForNextsharesTrades::set_issuesymbol(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.issuesymbol_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:data.TradeCorrectionForNextsharesTrades.issueSymbol)
}
inline std::string* TradeCorrectionForNextsharesTrades::mutable_issuesymbol() {
  std::string* _s = _internal_mutable_issuesymbol();
  // @@protoc_insertion_point(field_mutable:data.TradeCorrectionForNextsharesTrades.issueSymbol)
  return _s;
}
inline const std::string& TradeCorrectionForNextsharesTrades::_internal_issuesymbol() const {
  return _impl_.issuesymbol_.Get();
}
inline void TradeCorrectionForNextsharesTrades::_internal_set_issuesymbol(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.issuesymbol_.Set(value, GetArenaForAllocation());
}
inline std::string* TradeCorrectionForNextsharesTrades::_internal_mutable_issuesymbol() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.issuesymbol_.Mutable(GetArenaForAllocation());
}
inline std::string* TradeCorrectionForNextsharesTrades::release_issuesymbol() {
  // @@protoc_insertion_point(field_release:data.TradeCorrectionForNextsharesTrades.issueSymbol)
  if (!_internal_has_issuesymbol()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.issuesymbol_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.issuesymbol_.IsDefault()) {
    _impl_.issuesymbol_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TradeCorrectionForNextsharesTrades::set_allocated_issuesymbol(std::string* issuesymbol) {
  if (issuesymbol != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.issuesymbol_.SetAllocated(issuesymbol, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.issuesymbol_.IsDefault()) {
    _impl_.issuesymbol_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:data.TradeCorrectionForNextsharesTrades.issueSymbol)
}

// optional .data.SecurityClass securityClass = 3;
inline bool TradeCorrectionForNextsharesTrades::_internal_has_securityclass() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool TradeCorrectionForNextsharesTrades::has_securityclass() const {
  return _internal_has_securityclass();
}
inline void TradeCorrectionForNextsharesTrades::clear_securityclass() {
  _impl_.securityclass_ = 0;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::data::SecurityClass TradeCorrectionForNextsharesTrades::_internal_securityclass() const {
  return static_cast< ::data::SecurityClass >(_impl_.securityclass_);
}
inline ::data::SecurityClass TradeCorrectionForNextsharesTrades::securityclass() const {
  // @@protoc_insertion_point(field_get:data.TradeCorrectionForNextsharesTrades.securityClass)
  return _internal_securityclass();
}
inline void TradeCorrectionForNextsharesTrades::_internal_set_securityclass(::data::SecurityClass value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.securityclass_ = value;
}
inline void TradeCorrectionForNextsharesTrades::set_securityclass(::data::SecurityClass value) {
  _internal_set_securityclass(value);
  // @@protoc_insertion_point(field_set:data.TradeCorrectionForNextsharesTrades.securityClass)
}

// optional string originalControlNumber = 4;
inline bool TradeCorrectionForNextsharesTrades::_internal_has_originalcontrolnumber() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TradeCorrectionForNextsharesTrades::has_originalcontrolnumber() const {
  return _internal_has_originalcontrolnumber();
}
inline void TradeCorrectionForNextsharesTrades::clear_originalcontrolnumber() {
  _impl_.originalcontrolnumber_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& TradeCorrectionForNextsharesTrades::originalcontrolnumber() const {
  // @@protoc_insertion_point(field_get:data.TradeCorrectionForNextsharesTrades.originalControlNumber)
  return _internal_originalcontrolnumber();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TradeCorrectionForNextsharesTrades::set_originalcontrolnumber(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.originalcontrolnumber_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:data.TradeCorrectionForNextsharesTrades.originalControlNumber)
}
inline std::string* TradeCorrectionForNextsharesTrades::mutable_originalcontrolnumber() {
  std::string* _s = _internal_mutable_originalcontrolnumber();
  // @@protoc_insertion_point(field_mutable:data.TradeCorrectionForNextsharesTrades.originalControlNumber)
  return _s;
}
inline const std::string& TradeCorrectionForNextsharesTrades::_internal_originalcontrolnumber() const {
  return _impl_.originalcontrolnumber_.Get();
}
inline void TradeCorrectionForNextsharesTrades::_internal_set_originalcontrolnumber(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.originalcontrolnumber_.Set(value, GetArenaForAllocation());
}
inline std::string* TradeCorrectionForNextsharesTrades::_internal_mutable_originalcontrolnumber() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.originalcontrolnumber_.Mutable(GetArenaForAllocation());
}
inline std::string* TradeCorrectionForNextsharesTrades::release_originalcontrolnumber() {
  // @@protoc_insertion_point(field_release:data.TradeCorrectionForNextsharesTrades.originalControlNumber)
  if (!_internal_has_originalcontrolnumber()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.originalcontrolnumber_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.originalcontrolnumber_.IsDefault()) {
    _impl_.originalcontrolnumber_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TradeCorrectionForNextsharesTrades::set_allocated_originalcontrolnumber(std::string* originalcontrolnumber) {
  if (originalcontrolnumber != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.originalcontrolnumber_.SetAllocated(originalcontrolnumber, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.originalcontrolnumber_.IsDefault()) {
    _impl_.originalcontrolnumber_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:data.TradeCorrectionForNextsharesTrades.originalControlNumber)
}

// optional double originalProxyPrice = 5;
inline bool TradeCorrectionForNextsharesTrades::_internal_has_originalproxyprice() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool TradeCorrectionForNextsharesTrades::has_originalproxyprice() const {
  return _internal_has_originalproxyprice();
}
inline void TradeCorrectionForNextsharesTrades::clear_originalproxyprice() {
  _impl_.originalproxyprice_ = 0;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline double TradeCorrectionForNextsharesTrades::_internal_originalproxyprice() const {
  return _impl_.originalproxyprice_;
}
inline double TradeCorrectionForNextsharesTrades::originalproxyprice() const {
  // @@protoc_insertion_point(field_get:data.TradeCorrectionForNextsharesTrades.originalProxyPrice)
  return _internal_originalproxyprice();
}
inline void TradeCorrectionForNextsharesTrades::_internal_set_originalproxyprice(double value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.originalproxyprice_ = value;
}
inline void TradeCorrectionForNextsharesTrades::set_originalproxyprice(double value) {
  _internal_set_originalproxyprice(value);
  // @@protoc_insertion_point(field_set:data.TradeCorrectionForNextsharesTrades.originalProxyPrice)
}

// optional double originalNAVOffsetAmount = 6;
inline bool TradeCorrectionForNextsharesTrades::_internal_has_originalnavoffsetamount() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool TradeCorrectionForNextsharesTrades::has_originalnavoffsetamount() const {
  return _internal_has_originalnavoffsetamount();
}
inline void TradeCorrectionForNextsharesTrades::clear_originalnavoffsetamount() {
  _impl_.originalnavoffsetamount_ = 0;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline double TradeCorrectionForNextsharesTrades::_internal_originalnavoffsetamount() const {
  return _impl_.originalnavoffsetamount_;
}
inline double TradeCorrectionForNextsharesTrades::originalnavoffsetamount() const {
  // @@protoc_insertion_point(field_get:data.TradeCorrectionForNextsharesTrades.originalNAVOffsetAmount)
  return _internal_originalnavoffsetamount();
}
inline void TradeCorrectionForNextsharesTrades::_internal_set_originalnavoffsetamount(double value) {
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.originalnavoffsetamount_ = value;
}
inline void TradeCorrectionForNextsharesTrades::set_originalnavoffsetamount(double value) {
  _internal_set_originalnavoffsetamount(value);
  // @@protoc_insertion_point(field_set:data.TradeCorrectionForNextsharesTrades.originalNAVOffsetAmount)
}

// optional int64 originalTradeSize = 7;
inline bool TradeCorrectionForNextsharesTrades::_internal_has_originaltradesize() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool TradeCorrectionForNextsharesTrades::has_originaltradesize() const {
  return _internal_has_originaltradesize();
}
inline void TradeCorrectionForNextsharesTrades::clear_originaltradesize() {
  _impl_.originaltradesize_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline int64_t TradeCorrectionForNextsharesTrades::_internal_originaltradesize() const {
  return _impl_.originaltradesize_;
}
inline int64_t TradeCorrectionForNextsharesTrades::originaltradesize() const {
  // @@protoc_insertion_point(field_get:data.TradeCorrectionForNextsharesTrades.originalTradeSize)
  return _internal_originaltradesize();
}
inline void TradeCorrectionForNextsharesTrades::_internal_set_originaltradesize(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.originaltradesize_ = value;
}
inline void TradeCorrectionForNextsharesTrades::set_originaltradesize(int64_t value) {
  _internal_set_originaltradesize(value);
  // @@protoc_insertion_point(field_set:data.TradeCorrectionForNextsharesTrades.originalTradeSize)
}

// optional string originalConditionModifier = 8;
inline bool TradeCorrectionForNextsharesTrades::_internal_has_originalconditionmodifier() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool TradeCorrectionForNextsharesTrades::has_originalconditionmodifier() const {
  return _internal_has_originalconditionmodifier();
}
inline void TradeCorrectionForNextsharesTrades::clear_originalconditionmodifier() {
  _impl_.originalconditionmodifier_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& TradeCorrectionForNextsharesTrades::originalconditionmodifier() const {
  // @@protoc_insertion_point(field_get:data.TradeCorrectionForNextsharesTrades.originalConditionModifier)
  return _internal_originalconditionmodifier();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TradeCorrectionForNextsharesTrades::set_originalconditionmodifier(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.originalconditionmodifier_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:data.TradeCorrectionForNextsharesTrades.originalConditionModifier)
}
inline std::string* TradeCorrectionForNextsharesTrades::mutable_originalconditionmodifier() {
  std::string* _s = _internal_mutable_originalconditionmodifier();
  // @@protoc_insertion_point(field_mutable:data.TradeCorrectionForNextsharesTrades.originalConditionModifier)
  return _s;
}
inline const std::string& TradeCorrectionForNextsharesTrades::_internal_originalconditionmodifier() const {
  return _impl_.originalconditionmodifier_.Get();
}
inline void TradeCorrectionForNextsharesTrades::_internal_set_originalconditionmodifier(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.originalconditionmodifier_.Set(value, GetArenaForAllocation());
}
inline std::string* TradeCorrectionForNextsharesTrades::_internal_mutable_originalconditionmodifier() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.originalconditionmodifier_.Mutable(GetArenaForAllocation());
}
inline std::string* TradeCorrectionForNextsharesTrades::release_originalconditionmodifier() {
  // @@protoc_insertion_point(field_release:data.TradeCorrectionForNextsharesTrades.originalConditionModifier)
  if (!_internal_has_originalconditionmodifier()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.originalconditionmodifier_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.originalconditionmodifier_.IsDefault()) {
    _impl_.originalconditionmodifier_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TradeCorrectionForNextsharesTrades::set_allocated_originalconditionmodifier(std::string* originalconditionmodifier) {
  if (originalconditionmodifier != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.originalconditionmodifier_.SetAllocated(originalconditionmodifier, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.originalconditionmodifier_.IsDefault()) {
    _impl_.originalconditionmodifier_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:data.TradeCorrectionForNextsharesTrades.originalConditionModifier)
}

// optional string correctedTradeControlNumber = 9;
inline bool TradeCorrectionForNextsharesTrades::_internal_has_correctedtradecontrolnumber() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool TradeCorrectionForNextsharesTrades::has_correctedtradecontrolnumber() const {
  return _internal_has_correctedtradecontrolnumber();
}
inline void TradeCorrectionForNextsharesTrades::clear_correctedtradecontrolnumber() {
  _impl_.correctedtradecontrolnumber_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& TradeCorrectionForNextsharesTrades::correctedtradecontrolnumber() const {
  // @@protoc_insertion_point(field_get:data.TradeCorrectionForNextsharesTrades.correctedTradeControlNumber)
  return _internal_correctedtradecontrolnumber();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TradeCorrectionForNextsharesTrades::set_correctedtradecontrolnumber(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000008u;
 _impl_.correctedtradecontrolnumber_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:data.TradeCorrectionForNextsharesTrades.correctedTradeControlNumber)
}
inline std::string* TradeCorrectionForNextsharesTrades::mutable_correctedtradecontrolnumber() {
  std::string* _s = _internal_mutable_correctedtradecontrolnumber();
  // @@protoc_insertion_point(field_mutable:data.TradeCorrectionForNextsharesTrades.correctedTradeControlNumber)
  return _s;
}
inline const std::string& TradeCorrectionForNextsharesTrades::_internal_correctedtradecontrolnumber() const {
  return _impl_.correctedtradecontrolnumber_.Get();
}
inline void TradeCorrectionForNextsharesTrades::_internal_set_correctedtradecontrolnumber(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.correctedtradecontrolnumber_.Set(value, GetArenaForAllocation());
}
inline std::string* TradeCorrectionForNextsharesTrades::_internal_mutable_correctedtradecontrolnumber() {
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.correctedtradecontrolnumber_.Mutable(GetArenaForAllocation());
}
inline std::string* TradeCorrectionForNextsharesTrades::release_correctedtradecontrolnumber() {
  // @@protoc_insertion_point(field_release:data.TradeCorrectionForNextsharesTrades.correctedTradeControlNumber)
  if (!_internal_has_correctedtradecontrolnumber()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* p = _impl_.correctedtradecontrolnumber_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.correctedtradecontrolnumber_.IsDefault()) {
    _impl_.correctedtradecontrolnumber_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TradeCorrectionForNextsharesTrades::set_allocated_correctedtradecontrolnumber(std::string* correctedtradecontrolnumber) {
  if (correctedtradecontrolnumber != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.correctedtradecontrolnumber_.SetAllocated(correctedtradecontrolnumber, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.correctedtradecontrolnumber_.IsDefault()) {
    _impl_.correctedtradecontrolnumber_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:data.TradeCorrectionForNextsharesTrades.correctedTradeControlNumber)
}

// optional double correctedTradePrice = 10;
inline bool TradeCorrectionForNextsharesTrades::_internal_has_correctedtradeprice() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool TradeCorrectionForNextsharesTrades::has_correctedtradeprice() const {
  return _internal_has_correctedtradeprice();
}
inline void TradeCorrectionForNextsharesTrades::clear_correctedtradeprice() {
  _impl_.correctedtradeprice_ = 0;
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline double TradeCorrectionForNextsharesTrades::_internal_correctedtradeprice() const {
  return _impl_.correctedtradeprice_;
}
inline double TradeCorrectionForNextsharesTrades::correctedtradeprice() const {
  // @@protoc_insertion_point(field_get:data.TradeCorrectionForNextsharesTrades.correctedTradePrice)
  return _internal_correctedtradeprice();
}
inline void TradeCorrectionForNextsharesTrades::_internal_set_correctedtradeprice(double value) {
  _impl_._has_bits_[0] |= 0x00000400u;
  _impl_.correctedtradeprice_ = value;
}
inline void TradeCorrectionForNextsharesTrades::set_correctedtradeprice(double value) {
  _internal_set_correctedtradeprice(value);
  // @@protoc_insertion_point(field_set:data.TradeCorrectionForNextsharesTrades.correctedTradePrice)
}

// optional double correctedNAVOffsetAmount = 11;
inline bool TradeCorrectionForNextsharesTrades::_internal_has_correctednavoffsetamount() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool TradeCorrectionForNextsharesTrades::has_correctednavoffsetamount() const {
  return _internal_has_correctednavoffsetamount();
}
inline void TradeCorrectionForNextsharesTrades::clear_correctednavoffsetamount() {
  _impl_.correctednavoffsetamount_ = 0;
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline double TradeCorrectionForNextsharesTrades::_internal_correctednavoffsetamount() const {
  return _impl_.correctednavoffsetamount_;
}
inline double TradeCorrectionForNextsharesTrades::correctednavoffsetamount() const {
  // @@protoc_insertion_point(field_get:data.TradeCorrectionForNextsharesTrades.correctedNAVOffsetAmount)
  return _internal_correctednavoffsetamount();
}
inline void TradeCorrectionForNextsharesTrades::_internal_set_correctednavoffsetamount(double value) {
  _impl_._has_bits_[0] |= 0x00000800u;
  _impl_.correctednavoffsetamount_ = value;
}
inline void TradeCorrectionForNextsharesTrades::set_correctednavoffsetamount(double value) {
  _internal_set_correctednavoffsetamount(value);
  // @@protoc_insertion_point(field_set:data.TradeCorrectionForNextsharesTrades.correctedNAVOffsetAmount)
}

// optional int64 CorrectedTradeSize = 12;
inline bool TradeCorrectionForNextsharesTrades::_internal_has_correctedtradesize() const {
  bool value = (_impl_._has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool TradeCorrectionForNextsharesTrades::has_correctedtradesize() const {
  return _internal_has_correctedtradesize();
}
inline void TradeCorrectionForNextsharesTrades::clear_correctedtradesize() {
  _impl_.correctedtradesize_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00001000u;
}
inline int64_t TradeCorrectionForNextsharesTrades::_internal_correctedtradesize() const {
  return _impl_.correctedtradesize_;
}
inline int64_t TradeCorrectionForNextsharesTrades::correctedtradesize() const {
  // @@protoc_insertion_point(field_get:data.TradeCorrectionForNextsharesTrades.CorrectedTradeSize)
  return _internal_correctedtradesize();
}
inline void TradeCorrectionForNextsharesTrades::_internal_set_correctedtradesize(int64_t value) {
  _impl_._has_bits_[0] |= 0x00001000u;
  _impl_.correctedtradesize_ = value;
}
inline void TradeCorrectionForNextsharesTrades::set_correctedtradesize(int64_t value) {
  _internal_set_correctedtradesize(value);
  // @@protoc_insertion_point(field_set:data.TradeCorrectionForNextsharesTrades.CorrectedTradeSize)
}

// optional string CorrectedSaleConditionModifier = 13;
inline bool TradeCorrectionForNextsharesTrades::_internal_has_correctedsaleconditionmodifier() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool TradeCorrectionForNextsharesTrades::has_correctedsaleconditionmodifier() const {
  return _internal_has_correctedsaleconditionmodifier();
}
inline void TradeCorrectionForNextsharesTrades::clear_correctedsaleconditionmodifier() {
  _impl_.correctedsaleconditionmodifier_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const std::string& TradeCorrectionForNextsharesTrades::correctedsaleconditionmodifier() const {
  // @@protoc_insertion_point(field_get:data.TradeCorrectionForNextsharesTrades.CorrectedSaleConditionModifier)
  return _internal_correctedsaleconditionmodifier();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TradeCorrectionForNextsharesTrades::set_correctedsaleconditionmodifier(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000010u;
 _impl_.correctedsaleconditionmodifier_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:data.TradeCorrectionForNextsharesTrades.CorrectedSaleConditionModifier)
}
inline std::string* TradeCorrectionForNextsharesTrades::mutable_correctedsaleconditionmodifier() {
  std::string* _s = _internal_mutable_correctedsaleconditionmodifier();
  // @@protoc_insertion_point(field_mutable:data.TradeCorrectionForNextsharesTrades.CorrectedSaleConditionModifier)
  return _s;
}
inline const std::string& TradeCorrectionForNextsharesTrades::_internal_correctedsaleconditionmodifier() const {
  return _impl_.correctedsaleconditionmodifier_.Get();
}
inline void TradeCorrectionForNextsharesTrades::_internal_set_correctedsaleconditionmodifier(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.correctedsaleconditionmodifier_.Set(value, GetArenaForAllocation());
}
inline std::string* TradeCorrectionForNextsharesTrades::_internal_mutable_correctedsaleconditionmodifier() {
  _impl_._has_bits_[0] |= 0x00000010u;
  return _impl_.correctedsaleconditionmodifier_.Mutable(GetArenaForAllocation());
}
inline std::string* TradeCorrectionForNextsharesTrades::release_correctedsaleconditionmodifier() {
  // @@protoc_insertion_point(field_release:data.TradeCorrectionForNextsharesTrades.CorrectedSaleConditionModifier)
  if (!_internal_has_correctedsaleconditionmodifier()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000010u;
  auto* p = _impl_.correctedsaleconditionmodifier_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.correctedsaleconditionmodifier_.IsDefault()) {
    _impl_.correctedsaleconditionmodifier_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TradeCorrectionForNextsharesTrades::set_allocated_correctedsaleconditionmodifier(std::string* correctedsaleconditionmodifier) {
  if (correctedsaleconditionmodifier != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.correctedsaleconditionmodifier_.SetAllocated(correctedsaleconditionmodifier, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.correctedsaleconditionmodifier_.IsDefault()) {
    _impl_.correctedsaleconditionmodifier_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:data.TradeCorrectionForNextsharesTrades.CorrectedSaleConditionModifier)
}

// optional int64 consolidatedVolume = 14;
inline bool TradeCorrectionForNextsharesTrades::_internal_has_consolidatedvolume() const {
  bool value = (_impl_._has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool TradeCorrectionForNextsharesTrades::has_consolidatedvolume() const {
  return _internal_has_consolidatedvolume();
}
inline void TradeCorrectionForNextsharesTrades::clear_consolidatedvolume() {
  _impl_.consolidatedvolume_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00002000u;
}
inline int64_t TradeCorrectionForNextsharesTrades::_internal_consolidatedvolume() const {
  return _impl_.consolidatedvolume_;
}
inline int64_t TradeCorrectionForNextsharesTrades::consolidatedvolume() const {
  // @@protoc_insertion_point(field_get:data.TradeCorrectionForNextsharesTrades.consolidatedVolume)
  return _internal_consolidatedvolume();
}
inline void TradeCorrectionForNextsharesTrades::_internal_set_consolidatedvolume(int64_t value) {
  _impl_._has_bits_[0] |= 0x00002000u;
  _impl_.consolidatedvolume_ = value;
}
inline void TradeCorrectionForNextsharesTrades::set_consolidatedvolume(int64_t value) {
  _internal_set_consolidatedvolume(value);
  // @@protoc_insertion_point(field_set:data.TradeCorrectionForNextsharesTrades.consolidatedVolume)
}

// -------------------------------------------------------------------

// TradeCorrectionForNonNextsharesTrades

// optional .data.OriginatingMarketCenterIdentifier marketCenterIdentifier = 1;
inline bool TradeCorrectionForNonNextsharesTrades::_internal_has_marketcenteridentifier() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool TradeCorrectionForNonNextsharesTrades::has_marketcenteridentifier() const {
  return _internal_has_marketcenteridentifier();
}
inline void TradeCorrectionForNonNextsharesTrades::clear_marketcenteridentifier() {
  _impl_.marketcenteridentifier_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::data::OriginatingMarketCenterIdentifier TradeCorrectionForNonNextsharesTrades::_internal_marketcenteridentifier() const {
  return static_cast< ::data::OriginatingMarketCenterIdentifier >(_impl_.marketcenteridentifier_);
}
inline ::data::OriginatingMarketCenterIdentifier TradeCorrectionForNonNextsharesTrades::marketcenteridentifier() const {
  // @@protoc_insertion_point(field_get:data.TradeCorrectionForNonNextsharesTrades.marketCenterIdentifier)
  return _internal_marketcenteridentifier();
}
inline void TradeCorrectionForNonNextsharesTrades::_internal_set_marketcenteridentifier(::data::OriginatingMarketCenterIdentifier value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.marketcenteridentifier_ = value;
}
inline void TradeCorrectionForNonNextsharesTrades::set_marketcenteridentifier(::data::OriginatingMarketCenterIdentifier value) {
  _internal_set_marketcenteridentifier(value);
  // @@protoc_insertion_point(field_set:data.TradeCorrectionForNonNextsharesTrades.marketCenterIdentifier)
}

// optional string issueSymbol = 2;
inline bool TradeCorrectionForNonNextsharesTrades::_internal_has_issuesymbol() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TradeCorrectionForNonNextsharesTrades::has_issuesymbol() const {
  return _internal_has_issuesymbol();
}
inline void TradeCorrectionForNonNextsharesTrades::clear_issuesymbol() {
  _impl_.issuesymbol_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TradeCorrectionForNonNextsharesTrades::issuesymbol() const {
  // @@protoc_insertion_point(field_get:data.TradeCorrectionForNonNextsharesTrades.issueSymbol)
  return _internal_issuesymbol();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TradeCorrectionForNonNextsharesTrades::set_issuesymbol(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.issuesymbol_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:data.TradeCorrectionForNonNextsharesTrades.issueSymbol)
}
inline std::string* TradeCorrectionForNonNextsharesTrades::mutable_issuesymbol() {
  std::string* _s = _internal_mutable_issuesymbol();
  // @@protoc_insertion_point(field_mutable:data.TradeCorrectionForNonNextsharesTrades.issueSymbol)
  return _s;
}
inline const std::string& TradeCorrectionForNonNextsharesTrades::_internal_issuesymbol() const {
  return _impl_.issuesymbol_.Get();
}
inline void TradeCorrectionForNonNextsharesTrades::_internal_set_issuesymbol(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.issuesymbol_.Set(value, GetArenaForAllocation());
}
inline std::string* TradeCorrectionForNonNextsharesTrades::_internal_mutable_issuesymbol() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.issuesymbol_.Mutable(GetArenaForAllocation());
}
inline std::string* TradeCorrectionForNonNextsharesTrades::release_issuesymbol() {
  // @@protoc_insertion_point(field_release:data.TradeCorrectionForNonNextsharesTrades.issueSymbol)
  if (!_internal_has_issuesymbol()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.issuesymbol_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.issuesymbol_.IsDefault()) {
    _impl_.issuesymbol_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TradeCorrectionForNonNextsharesTrades::set_allocated_issuesymbol(std::string* issuesymbol) {
  if (issuesymbol != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.issuesymbol_.SetAllocated(issuesymbol, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.issuesymbol_.IsDefault()) {
    _impl_.issuesymbol_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:data.TradeCorrectionForNonNextsharesTrades.issueSymbol)
}

// optional .data.SecurityClass securityClass = 3;
inline bool TradeCorrectionForNonNextsharesTrades::_internal_has_securityclass() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool TradeCorrectionForNonNextsharesTrades::has_securityclass() const {
  return _internal_has_securityclass();
}
inline void TradeCorrectionForNonNextsharesTrades::clear_securityclass() {
  _impl_.securityclass_ = 0;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::data::SecurityClass TradeCorrectionForNonNextsharesTrades::_internal_securityclass() const {
  return static_cast< ::data::SecurityClass >(_impl_.securityclass_);
}
inline ::data::SecurityClass TradeCorrectionForNonNextsharesTrades::securityclass() const {
  // @@protoc_insertion_point(field_get:data.TradeCorrectionForNonNextsharesTrades.securityClass)
  return _internal_securityclass();
}
inline void TradeCorrectionForNonNextsharesTrades::_internal_set_securityclass(::data::SecurityClass value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.securityclass_ = value;
}
inline void TradeCorrectionForNonNextsharesTrades::set_securityclass(::data::SecurityClass value) {
  _internal_set_securityclass(value);
  // @@protoc_insertion_point(field_set:data.TradeCorrectionForNonNextsharesTrades.securityClass)
}

// optional string originalControlNumber = 4;
inline bool TradeCorrectionForNonNextsharesTrades::_internal_has_originalcontrolnumber() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TradeCorrectionForNonNextsharesTrades::has_originalcontrolnumber() const {
  return _internal_has_originalcontrolnumber();
}
inline void TradeCorrectionForNonNextsharesTrades::clear_originalcontrolnumber() {
  _impl_.originalcontrolnumber_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& TradeCorrectionForNonNextsharesTrades::originalcontrolnumber() const {
  // @@protoc_insertion_point(field_get:data.TradeCorrectionForNonNextsharesTrades.originalControlNumber)
  return _internal_originalcontrolnumber();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TradeCorrectionForNonNextsharesTrades::set_originalcontrolnumber(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.originalcontrolnumber_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:data.TradeCorrectionForNonNextsharesTrades.originalControlNumber)
}
inline std::string* TradeCorrectionForNonNextsharesTrades::mutable_originalcontrolnumber() {
  std::string* _s = _internal_mutable_originalcontrolnumber();
  // @@protoc_insertion_point(field_mutable:data.TradeCorrectionForNonNextsharesTrades.originalControlNumber)
  return _s;
}
inline const std::string& TradeCorrectionForNonNextsharesTrades::_internal_originalcontrolnumber() const {
  return _impl_.originalcontrolnumber_.Get();
}
inline void TradeCorrectionForNonNextsharesTrades::_internal_set_originalcontrolnumber(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.originalcontrolnumber_.Set(value, GetArenaForAllocation());
}
inline std::string* TradeCorrectionForNonNextsharesTrades::_internal_mutable_originalcontrolnumber() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.originalcontrolnumber_.Mutable(GetArenaForAllocation());
}
inline std::string* TradeCorrectionForNonNextsharesTrades::release_originalcontrolnumber() {
  // @@protoc_insertion_point(field_release:data.TradeCorrectionForNonNextsharesTrades.originalControlNumber)
  if (!_internal_has_originalcontrolnumber()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.originalcontrolnumber_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.originalcontrolnumber_.IsDefault()) {
    _impl_.originalcontrolnumber_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TradeCorrectionForNonNextsharesTrades::set_allocated_originalcontrolnumber(std::string* originalcontrolnumber) {
  if (originalcontrolnumber != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.originalcontrolnumber_.SetAllocated(originalcontrolnumber, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.originalcontrolnumber_.IsDefault()) {
    _impl_.originalcontrolnumber_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:data.TradeCorrectionForNonNextsharesTrades.originalControlNumber)
}

// optional double originalTradePrice = 5;
inline bool TradeCorrectionForNonNextsharesTrades::_internal_has_originaltradeprice() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool TradeCorrectionForNonNextsharesTrades::has_originaltradeprice() const {
  return _internal_has_originaltradeprice();
}
inline void TradeCorrectionForNonNextsharesTrades::clear_originaltradeprice() {
  _impl_.originaltradeprice_ = 0;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline double TradeCorrectionForNonNextsharesTrades::_internal_originaltradeprice() const {
  return _impl_.originaltradeprice_;
}
inline double TradeCorrectionForNonNextsharesTrades::originaltradeprice() const {
  // @@protoc_insertion_point(field_get:data.TradeCorrectionForNonNextsharesTrades.originalTradePrice)
  return _internal_originaltradeprice();
}
inline void TradeCorrectionForNonNextsharesTrades::_internal_set_originaltradeprice(double value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.originaltradeprice_ = value;
}
inline void TradeCorrectionForNonNextsharesTrades::set_originaltradeprice(double value) {
  _internal_set_originaltradeprice(value);
  // @@protoc_insertion_point(field_set:data.TradeCorrectionForNonNextsharesTrades.originalTradePrice)
}

// optional int64 originalTradeSize = 6;
inline bool TradeCorrectionForNonNextsharesTrades::_internal_has_originaltradesize() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool TradeCorrectionForNonNextsharesTrades::has_originaltradesize() const {
  return _internal_has_originaltradesize();
}
inline void TradeCorrectionForNonNextsharesTrades::clear_originaltradesize() {
  _impl_.originaltradesize_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline int64_t TradeCorrectionForNonNextsharesTrades::_internal_originaltradesize() const {
  return _impl_.originaltradesize_;
}
inline int64_t TradeCorrectionForNonNextsharesTrades::originaltradesize() const {
  // @@protoc_insertion_point(field_get:data.TradeCorrectionForNonNextsharesTrades.originalTradeSize)
  return _internal_originaltradesize();
}
inline void TradeCorrectionForNonNextsharesTrades::_internal_set_originaltradesize(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.originaltradesize_ = value;
}
inline void TradeCorrectionForNonNextsharesTrades::set_originaltradesize(int64_t value) {
  _internal_set_originaltradesize(value);
  // @@protoc_insertion_point(field_set:data.TradeCorrectionForNonNextsharesTrades.originalTradeSize)
}

// optional string originalConditionModifier = 7;
inline bool TradeCorrectionForNonNextsharesTrades::_internal_has_originalconditionmodifier() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool TradeCorrectionForNonNextsharesTrades::has_originalconditionmodifier() const {
  return _internal_has_originalconditionmodifier();
}
inline void TradeCorrectionForNonNextsharesTrades::clear_originalconditionmodifier() {
  _impl_.originalconditionmodifier_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& TradeCorrectionForNonNextsharesTrades::originalconditionmodifier() const {
  // @@protoc_insertion_point(field_get:data.TradeCorrectionForNonNextsharesTrades.originalConditionModifier)
  return _internal_originalconditionmodifier();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TradeCorrectionForNonNextsharesTrades::set_originalconditionmodifier(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.originalconditionmodifier_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:data.TradeCorrectionForNonNextsharesTrades.originalConditionModifier)
}
inline std::string* TradeCorrectionForNonNextsharesTrades::mutable_originalconditionmodifier() {
  std::string* _s = _internal_mutable_originalconditionmodifier();
  // @@protoc_insertion_point(field_mutable:data.TradeCorrectionForNonNextsharesTrades.originalConditionModifier)
  return _s;
}
inline const std::string& TradeCorrectionForNonNextsharesTrades::_internal_originalconditionmodifier() const {
  return _impl_.originalconditionmodifier_.Get();
}
inline void TradeCorrectionForNonNextsharesTrades::_internal_set_originalconditionmodifier(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.originalconditionmodifier_.Set(value, GetArenaForAllocation());
}
inline std::string* TradeCorrectionForNonNextsharesTrades::_internal_mutable_originalconditionmodifier() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.originalconditionmodifier_.Mutable(GetArenaForAllocation());
}
inline std::string* TradeCorrectionForNonNextsharesTrades::release_originalconditionmodifier() {
  // @@protoc_insertion_point(field_release:data.TradeCorrectionForNonNextsharesTrades.originalConditionModifier)
  if (!_internal_has_originalconditionmodifier()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.originalconditionmodifier_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.originalconditionmodifier_.IsDefault()) {
    _impl_.originalconditionmodifier_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TradeCorrectionForNonNextsharesTrades::set_allocated_originalconditionmodifier(std::string* originalconditionmodifier) {
  if (originalconditionmodifier != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.originalconditionmodifier_.SetAllocated(originalconditionmodifier, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.originalconditionmodifier_.IsDefault()) {
    _impl_.originalconditionmodifier_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:data.TradeCorrectionForNonNextsharesTrades.originalConditionModifier)
}

// optional string correctedTradeControlNumber = 8;
inline bool TradeCorrectionForNonNextsharesTrades::_internal_has_correctedtradecontrolnumber() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool TradeCorrectionForNonNextsharesTrades::has_correctedtradecontrolnumber() const {
  return _internal_has_correctedtradecontrolnumber();
}
inline void TradeCorrectionForNonNextsharesTrades::clear_correctedtradecontrolnumber() {
  _impl_.correctedtradecontrolnumber_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& TradeCorrectionForNonNextsharesTrades::correctedtradecontrolnumber() const {
  // @@protoc_insertion_point(field_get:data.TradeCorrectionForNonNextsharesTrades.correctedTradeControlNumber)
  return _internal_correctedtradecontrolnumber();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TradeCorrectionForNonNextsharesTrades::set_correctedtradecontrolnumber(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000008u;
 _impl_.correctedtradecontrolnumber_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:data.TradeCorrectionForNonNextsharesTrades.correctedTradeControlNumber)
}
inline std::string* TradeCorrectionForNonNextsharesTrades::mutable_correctedtradecontrolnumber() {
  std::string* _s = _internal_mutable_correctedtradecontrolnumber();
  // @@protoc_insertion_point(field_mutable:data.TradeCorrectionForNonNextsharesTrades.correctedTradeControlNumber)
  return _s;
}
inline const std::string& TradeCorrectionForNonNextsharesTrades::_internal_correctedtradecontrolnumber() const {
  return _impl_.correctedtradecontrolnumber_.Get();
}
inline void TradeCorrectionForNonNextsharesTrades::_internal_set_correctedtradecontrolnumber(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.correctedtradecontrolnumber_.Set(value, GetArenaForAllocation());
}
inline std::string* TradeCorrectionForNonNextsharesTrades::_internal_mutable_correctedtradecontrolnumber() {
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.correctedtradecontrolnumber_.Mutable(GetArenaForAllocation());
}
inline std::string* TradeCorrectionForNonNextsharesTrades::release_correctedtradecontrolnumber() {
  // @@protoc_insertion_point(field_release:data.TradeCorrectionForNonNextsharesTrades.correctedTradeControlNumber)
  if (!_internal_has_correctedtradecontrolnumber()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* p = _impl_.correctedtradecontrolnumber_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.correctedtradecontrolnumber_.IsDefault()) {
    _impl_.correctedtradecontrolnumber_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TradeCorrectionForNonNextsharesTrades::set_allocated_correctedtradecontrolnumber(std::string* correctedtradecontrolnumber) {
  if (correctedtradecontrolnumber != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.correctedtradecontrolnumber_.SetAllocated(correctedtradecontrolnumber, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.correctedtradecontrolnumber_.IsDefault()) {
    _impl_.correctedtradecontrolnumber_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:data.TradeCorrectionForNonNextsharesTrades.correctedTradeControlNumber)
}

// optional double correctedTradePrice = 9;
inline bool TradeCorrectionForNonNextsharesTrades::_internal_has_correctedtradeprice() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool TradeCorrectionForNonNextsharesTrades::has_correctedtradeprice() const {
  return _internal_has_correctedtradeprice();
}
inline void TradeCorrectionForNonNextsharesTrades::clear_correctedtradeprice() {
  _impl_.correctedtradeprice_ = 0;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline double TradeCorrectionForNonNextsharesTrades::_internal_correctedtradeprice() const {
  return _impl_.correctedtradeprice_;
}
inline double TradeCorrectionForNonNextsharesTrades::correctedtradeprice() const {
  // @@protoc_insertion_point(field_get:data.TradeCorrectionForNonNextsharesTrades.correctedTradePrice)
  return _internal_correctedtradeprice();
}
inline void TradeCorrectionForNonNextsharesTrades::_internal_set_correctedtradeprice(double value) {
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.correctedtradeprice_ = value;
}
inline void TradeCorrectionForNonNextsharesTrades::set_correctedtradeprice(double value) {
  _internal_set_correctedtradeprice(value);
  // @@protoc_insertion_point(field_set:data.TradeCorrectionForNonNextsharesTrades.correctedTradePrice)
}

// optional int64 CorrectedTradeSize = 10;
inline bool TradeCorrectionForNonNextsharesTrades::_internal_has_correctedtradesize() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool TradeCorrectionForNonNextsharesTrades::has_correctedtradesize() const {
  return _internal_has_correctedtradesize();
}
inline void TradeCorrectionForNonNextsharesTrades::clear_correctedtradesize() {
  _impl_.correctedtradesize_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline int64_t TradeCorrectionForNonNextsharesTrades::_internal_correctedtradesize() const {
  return _impl_.correctedtradesize_;
}
inline int64_t TradeCorrectionForNonNextsharesTrades::correctedtradesize() const {
  // @@protoc_insertion_point(field_get:data.TradeCorrectionForNonNextsharesTrades.CorrectedTradeSize)
  return _internal_correctedtradesize();
}
inline void TradeCorrectionForNonNextsharesTrades::_internal_set_correctedtradesize(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000400u;
  _impl_.correctedtradesize_ = value;
}
inline void TradeCorrectionForNonNextsharesTrades::set_correctedtradesize(int64_t value) {
  _internal_set_correctedtradesize(value);
  // @@protoc_insertion_point(field_set:data.TradeCorrectionForNonNextsharesTrades.CorrectedTradeSize)
}

// optional string CorrectedSaleConditionModifier = 11;
inline bool TradeCorrectionForNonNextsharesTrades::_internal_has_correctedsaleconditionmodifier() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool TradeCorrectionForNonNextsharesTrades::has_correctedsaleconditionmodifier() const {
  return _internal_has_correctedsaleconditionmodifier();
}
inline void TradeCorrectionForNonNextsharesTrades::clear_correctedsaleconditionmodifier() {
  _impl_.correctedsaleconditionmodifier_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const std::string& TradeCorrectionForNonNextsharesTrades::correctedsaleconditionmodifier() const {
  // @@protoc_insertion_point(field_get:data.TradeCorrectionForNonNextsharesTrades.CorrectedSaleConditionModifier)
  return _internal_correctedsaleconditionmodifier();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TradeCorrectionForNonNextsharesTrades::set_correctedsaleconditionmodifier(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000010u;
 _impl_.correctedsaleconditionmodifier_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:data.TradeCorrectionForNonNextsharesTrades.CorrectedSaleConditionModifier)
}
inline std::string* TradeCorrectionForNonNextsharesTrades::mutable_correctedsaleconditionmodifier() {
  std::string* _s = _internal_mutable_correctedsaleconditionmodifier();
  // @@protoc_insertion_point(field_mutable:data.TradeCorrectionForNonNextsharesTrades.CorrectedSaleConditionModifier)
  return _s;
}
inline const std::string& TradeCorrectionForNonNextsharesTrades::_internal_correctedsaleconditionmodifier() const {
  return _impl_.correctedsaleconditionmodifier_.Get();
}
inline void TradeCorrectionForNonNextsharesTrades::_internal_set_correctedsaleconditionmodifier(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.correctedsaleconditionmodifier_.Set(value, GetArenaForAllocation());
}
inline std::string* TradeCorrectionForNonNextsharesTrades::_internal_mutable_correctedsaleconditionmodifier() {
  _impl_._has_bits_[0] |= 0x00000010u;
  return _impl_.correctedsaleconditionmodifier_.Mutable(GetArenaForAllocation());
}
inline std::string* TradeCorrectionForNonNextsharesTrades::release_correctedsaleconditionmodifier() {
  // @@protoc_insertion_point(field_release:data.TradeCorrectionForNonNextsharesTrades.CorrectedSaleConditionModifier)
  if (!_internal_has_correctedsaleconditionmodifier()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000010u;
  auto* p = _impl_.correctedsaleconditionmodifier_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.correctedsaleconditionmodifier_.IsDefault()) {
    _impl_.correctedsaleconditionmodifier_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TradeCorrectionForNonNextsharesTrades::set_allocated_correctedsaleconditionmodifier(std::string* correctedsaleconditionmodifier) {
  if (correctedsaleconditionmodifier != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.correctedsaleconditionmodifier_.SetAllocated(correctedsaleconditionmodifier, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.correctedsaleconditionmodifier_.IsDefault()) {
    _impl_.correctedsaleconditionmodifier_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:data.TradeCorrectionForNonNextsharesTrades.CorrectedSaleConditionModifier)
}

// optional int64 consolidatedVolume = 12;
inline bool TradeCorrectionForNonNextsharesTrades::_internal_has_consolidatedvolume() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool TradeCorrectionForNonNextsharesTrades::has_consolidatedvolume() const {
  return _internal_has_consolidatedvolume();
}
inline void TradeCorrectionForNonNextsharesTrades::clear_consolidatedvolume() {
  _impl_.consolidatedvolume_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline int64_t TradeCorrectionForNonNextsharesTrades::_internal_consolidatedvolume() const {
  return _impl_.consolidatedvolume_;
}
inline int64_t TradeCorrectionForNonNextsharesTrades::consolidatedvolume() const {
  // @@protoc_insertion_point(field_get:data.TradeCorrectionForNonNextsharesTrades.consolidatedVolume)
  return _internal_consolidatedvolume();
}
inline void TradeCorrectionForNonNextsharesTrades::_internal_set_consolidatedvolume(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000800u;
  _impl_.consolidatedvolume_ = value;
}
inline void TradeCorrectionForNonNextsharesTrades::set_consolidatedvolume(int64_t value) {
  _internal_set_consolidatedvolume(value);
  // @@protoc_insertion_point(field_set:data.TradeCorrectionForNonNextsharesTrades.consolidatedVolume)
}

// -------------------------------------------------------------------

// TradeReportForNextshares

// optional .data.OriginatingMarketCenterIdentifier originatingMarketCenterIdentifier = 1;
inline bool TradeReportForNextshares::_internal_has_originatingmarketcenteridentifier() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool TradeReportForNextshares::has_originatingmarketcenteridentifier() const {
  return _internal_has_originatingmarketcenteridentifier();
}
inline void TradeReportForNextshares::clear_originatingmarketcenteridentifier() {
  _impl_.originatingmarketcenteridentifier_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::data::OriginatingMarketCenterIdentifier TradeReportForNextshares::_internal_originatingmarketcenteridentifier() const {
  return static_cast< ::data::OriginatingMarketCenterIdentifier >(_impl_.originatingmarketcenteridentifier_);
}
inline ::data::OriginatingMarketCenterIdentifier TradeReportForNextshares::originatingmarketcenteridentifier() const {
  // @@protoc_insertion_point(field_get:data.TradeReportForNextshares.originatingMarketCenterIdentifier)
  return _internal_originatingmarketcenteridentifier();
}
inline void TradeReportForNextshares::_internal_set_originatingmarketcenteridentifier(::data::OriginatingMarketCenterIdentifier value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.originatingmarketcenteridentifier_ = value;
}
inline void TradeReportForNextshares::set_originatingmarketcenteridentifier(::data::OriginatingMarketCenterIdentifier value) {
  _internal_set_originatingmarketcenteridentifier(value);
  // @@protoc_insertion_point(field_set:data.TradeReportForNextshares.originatingMarketCenterIdentifier)
}

// optional string nextsharesSymbol = 2;
inline bool TradeReportForNextshares::_internal_has_nextsharessymbol() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TradeReportForNextshares::has_nextsharessymbol() const {
  return _internal_has_nextsharessymbol();
}
inline void TradeReportForNextshares::clear_nextsharessymbol() {
  _impl_.nextsharessymbol_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TradeReportForNextshares::nextsharessymbol() const {
  // @@protoc_insertion_point(field_get:data.TradeReportForNextshares.nextsharesSymbol)
  return _internal_nextsharessymbol();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TradeReportForNextshares::set_nextsharessymbol(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.nextsharessymbol_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:data.TradeReportForNextshares.nextsharesSymbol)
}
inline std::string* TradeReportForNextshares::mutable_nextsharessymbol() {
  std::string* _s = _internal_mutable_nextsharessymbol();
  // @@protoc_insertion_point(field_mutable:data.TradeReportForNextshares.nextsharesSymbol)
  return _s;
}
inline const std::string& TradeReportForNextshares::_internal_nextsharessymbol() const {
  return _impl_.nextsharessymbol_.Get();
}
inline void TradeReportForNextshares::_internal_set_nextsharessymbol(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.nextsharessymbol_.Set(value, GetArenaForAllocation());
}
inline std::string* TradeReportForNextshares::_internal_mutable_nextsharessymbol() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.nextsharessymbol_.Mutable(GetArenaForAllocation());
}
inline std::string* TradeReportForNextshares::release_nextsharessymbol() {
  // @@protoc_insertion_point(field_release:data.TradeReportForNextshares.nextsharesSymbol)
  if (!_internal_has_nextsharessymbol()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.nextsharessymbol_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.nextsharessymbol_.IsDefault()) {
    _impl_.nextsharessymbol_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TradeReportForNextshares::set_allocated_nextsharessymbol(std::string* nextsharessymbol) {
  if (nextsharessymbol != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.nextsharessymbol_.SetAllocated(nextsharessymbol, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.nextsharessymbol_.IsDefault()) {
    _impl_.nextsharessymbol_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:data.TradeReportForNextshares.nextsharesSymbol)
}

// optional .data.SecurityClass securityClass = 3;
inline bool TradeReportForNextshares::_internal_has_securityclass() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool TradeReportForNextshares::has_securityclass() const {
  return _internal_has_securityclass();
}
inline void TradeReportForNextshares::clear_securityclass() {
  _impl_.securityclass_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::data::SecurityClass TradeReportForNextshares::_internal_securityclass() const {
  return static_cast< ::data::SecurityClass >(_impl_.securityclass_);
}
inline ::data::SecurityClass TradeReportForNextshares::securityclass() const {
  // @@protoc_insertion_point(field_get:data.TradeReportForNextshares.securityClass)
  return _internal_securityclass();
}
inline void TradeReportForNextshares::_internal_set_securityclass(::data::SecurityClass value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.securityclass_ = value;
}
inline void TradeReportForNextshares::set_securityclass(::data::SecurityClass value) {
  _internal_set_securityclass(value);
  // @@protoc_insertion_point(field_set:data.TradeReportForNextshares.securityClass)
}

// optional string tradeControlNumber = 4;
inline bool TradeReportForNextshares::_internal_has_tradecontrolnumber() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TradeReportForNextshares::has_tradecontrolnumber() const {
  return _internal_has_tradecontrolnumber();
}
inline void TradeReportForNextshares::clear_tradecontrolnumber() {
  _impl_.tradecontrolnumber_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& TradeReportForNextshares::tradecontrolnumber() const {
  // @@protoc_insertion_point(field_get:data.TradeReportForNextshares.tradeControlNumber)
  return _internal_tradecontrolnumber();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TradeReportForNextshares::set_tradecontrolnumber(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.tradecontrolnumber_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:data.TradeReportForNextshares.tradeControlNumber)
}
inline std::string* TradeReportForNextshares::mutable_tradecontrolnumber() {
  std::string* _s = _internal_mutable_tradecontrolnumber();
  // @@protoc_insertion_point(field_mutable:data.TradeReportForNextshares.tradeControlNumber)
  return _s;
}
inline const std::string& TradeReportForNextshares::_internal_tradecontrolnumber() const {
  return _impl_.tradecontrolnumber_.Get();
}
inline void TradeReportForNextshares::_internal_set_tradecontrolnumber(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.tradecontrolnumber_.Set(value, GetArenaForAllocation());
}
inline std::string* TradeReportForNextshares::_internal_mutable_tradecontrolnumber() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.tradecontrolnumber_.Mutable(GetArenaForAllocation());
}
inline std::string* TradeReportForNextshares::release_tradecontrolnumber() {
  // @@protoc_insertion_point(field_release:data.TradeReportForNextshares.tradeControlNumber)
  if (!_internal_has_tradecontrolnumber()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.tradecontrolnumber_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.tradecontrolnumber_.IsDefault()) {
    _impl_.tradecontrolnumber_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TradeReportForNextshares::set_allocated_tradecontrolnumber(std::string* tradecontrolnumber) {
  if (tradecontrolnumber != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.tradecontrolnumber_.SetAllocated(tradecontrolnumber, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.tradecontrolnumber_.IsDefault()) {
    _impl_.tradecontrolnumber_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:data.TradeReportForNextshares.tradeControlNumber)
}

// optional double proxyPrice = 5;
inline bool TradeReportForNextshares::_internal_has_proxyprice() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool TradeReportForNextshares::has_proxyprice() const {
  return _internal_has_proxyprice();
}
inline void TradeReportForNextshares::clear_proxyprice() {
  _impl_.proxyprice_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline double TradeReportForNextshares::_internal_proxyprice() const {
  return _impl_.proxyprice_;
}
inline double TradeReportForNextshares::proxyprice() const {
  // @@protoc_insertion_point(field_get:data.TradeReportForNextshares.proxyPrice)
  return _internal_proxyprice();
}
inline void TradeReportForNextshares::_internal_set_proxyprice(double value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.proxyprice_ = value;
}
inline void TradeReportForNextshares::set_proxyprice(double value) {
  _internal_set_proxyprice(value);
  // @@protoc_insertion_point(field_set:data.TradeReportForNextshares.proxyPrice)
}

// optional int64 tradeSize = 6;
inline bool TradeReportForNextshares::_internal_has_tradesize() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool TradeReportForNextshares::has_tradesize() const {
  return _internal_has_tradesize();
}
inline void TradeReportForNextshares::clear_tradesize() {
  _impl_.tradesize_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline int64_t TradeReportForNextshares::_internal_tradesize() const {
  return _impl_.tradesize_;
}
inline int64_t TradeReportForNextshares::tradesize() const {
  // @@protoc_insertion_point(field_get:data.TradeReportForNextshares.tradeSize)
  return _internal_tradesize();
}
inline void TradeReportForNextshares::_internal_set_tradesize(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.tradesize_ = value;
}
inline void TradeReportForNextshares::set_tradesize(int64_t value) {
  _internal_set_tradesize(value);
  // @@protoc_insertion_point(field_set:data.TradeReportForNextshares.tradeSize)
}

// optional double NAVOffsetAmount = 7;
inline bool TradeReportForNextshares::_internal_has_navoffsetamount() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool TradeReportForNextshares::has_navoffsetamount() const {
  return _internal_has_navoffsetamount();
}
inline void TradeReportForNextshares::clear_navoffsetamount() {
  _impl_.navoffsetamount_ = 0;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline double TradeReportForNextshares::_internal_navoffsetamount() const {
  return _impl_.navoffsetamount_;
}
inline double TradeReportForNextshares::navoffsetamount() const {
  // @@protoc_insertion_point(field_get:data.TradeReportForNextshares.NAVOffsetAmount)
  return _internal_navoffsetamount();
}
inline void TradeReportForNextshares::_internal_set_navoffsetamount(double value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.navoffsetamount_ = value;
}
inline void TradeReportForNextshares::set_navoffsetamount(double value) {
  _internal_set_navoffsetamount(value);
  // @@protoc_insertion_point(field_set:data.TradeReportForNextshares.NAVOffsetAmount)
}

// optional .data.SaleConditionModifier saleConditionModifier = 8;
inline bool TradeReportForNextshares::_internal_has_saleconditionmodifier() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.saleconditionmodifier_ != nullptr);
  return value;
}
inline bool TradeReportForNextshares::has_saleconditionmodifier() const {
  return _internal_has_saleconditionmodifier();
}
inline void TradeReportForNextshares::clear_saleconditionmodifier() {
  if (_impl_.saleconditionmodifier_ != nullptr) _impl_.saleconditionmodifier_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::data::SaleConditionModifier& TradeReportForNextshares::_internal_saleconditionmodifier() const {
  const ::data::SaleConditionModifier* p = _impl_.saleconditionmodifier_;
  return p != nullptr ? *p : reinterpret_cast<const ::data::SaleConditionModifier&>(
      ::data::_SaleConditionModifier_default_instance_);
}
inline const ::data::SaleConditionModifier& TradeReportForNextshares::saleconditionmodifier() const {
  // @@protoc_insertion_point(field_get:data.TradeReportForNextshares.saleConditionModifier)
  return _internal_saleconditionmodifier();
}
inline void TradeReportForNextshares::unsafe_arena_set_allocated_saleconditionmodifier(
    ::data::SaleConditionModifier* saleconditionmodifier) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.saleconditionmodifier_);
  }
  _impl_.saleconditionmodifier_ = saleconditionmodifier;
  if (saleconditionmodifier) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:data.TradeReportForNextshares.saleConditionModifier)
}
inline ::data::SaleConditionModifier* TradeReportForNextshares::release_saleconditionmodifier() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::data::SaleConditionModifier* temp = _impl_.saleconditionmodifier_;
  _impl_.saleconditionmodifier_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::data::SaleConditionModifier* TradeReportForNextshares::unsafe_arena_release_saleconditionmodifier() {
  // @@protoc_insertion_point(field_release:data.TradeReportForNextshares.saleConditionModifier)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::data::SaleConditionModifier* temp = _impl_.saleconditionmodifier_;
  _impl_.saleconditionmodifier_ = nullptr;
  return temp;
}
inline ::data::SaleConditionModifier* TradeReportForNextshares::_internal_mutable_saleconditionmodifier() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.saleconditionmodifier_ == nullptr) {
    auto* p = CreateMaybeMessage<::data::SaleConditionModifier>(GetArenaForAllocation());
    _impl_.saleconditionmodifier_ = p;
  }
  return _impl_.saleconditionmodifier_;
}
inline ::data::SaleConditionModifier* TradeReportForNextshares::mutable_saleconditionmodifier() {
  ::data::SaleConditionModifier* _msg = _internal_mutable_saleconditionmodifier();
  // @@protoc_insertion_point(field_mutable:data.TradeReportForNextshares.saleConditionModifier)
  return _msg;
}
inline void TradeReportForNextshares::set_allocated_saleconditionmodifier(::data::SaleConditionModifier* saleconditionmodifier) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.saleconditionmodifier_;
  }
  if (saleconditionmodifier) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(saleconditionmodifier);
    if (message_arena != submessage_arena) {
      saleconditionmodifier = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, saleconditionmodifier, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.saleconditionmodifier_ = saleconditionmodifier;
  // @@protoc_insertion_point(field_set_allocated:data.TradeReportForNextshares.saleConditionModifier)
}

// optional int32 consolidatedVolume = 9;
inline bool TradeReportForNextshares::_internal_has_consolidatedvolume() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool TradeReportForNextshares::has_consolidatedvolume() const {
  return _internal_has_consolidatedvolume();
}
inline void TradeReportForNextshares::clear_consolidatedvolume() {
  _impl_.consolidatedvolume_ = 0;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline int32_t TradeReportForNextshares::_internal_consolidatedvolume() const {
  return _impl_.consolidatedvolume_;
}
inline int32_t TradeReportForNextshares::consolidatedvolume() const {
  // @@protoc_insertion_point(field_get:data.TradeReportForNextshares.consolidatedVolume)
  return _internal_consolidatedvolume();
}
inline void TradeReportForNextshares::_internal_set_consolidatedvolume(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.consolidatedvolume_ = value;
}
inline void TradeReportForNextshares::set_consolidatedvolume(int32_t value) {
  _internal_set_consolidatedvolume(value);
  // @@protoc_insertion_point(field_set:data.TradeReportForNextshares.consolidatedVolume)
}

// -------------------------------------------------------------------

// TradeReportForNonNextshares

// optional .data.OriginatingMarketCenterIdentifier originatingMarketCenterIdentifier = 1;
inline bool TradeReportForNonNextshares::_internal_has_originatingmarketcenteridentifier() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool TradeReportForNonNextshares::has_originatingmarketcenteridentifier() const {
  return _internal_has_originatingmarketcenteridentifier();
}
inline void TradeReportForNonNextshares::clear_originatingmarketcenteridentifier() {
  _impl_.originatingmarketcenteridentifier_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::data::OriginatingMarketCenterIdentifier TradeReportForNonNextshares::_internal_originatingmarketcenteridentifier() const {
  return static_cast< ::data::OriginatingMarketCenterIdentifier >(_impl_.originatingmarketcenteridentifier_);
}
inline ::data::OriginatingMarketCenterIdentifier TradeReportForNonNextshares::originatingmarketcenteridentifier() const {
  // @@protoc_insertion_point(field_get:data.TradeReportForNonNextshares.originatingMarketCenterIdentifier)
  return _internal_originatingmarketcenteridentifier();
}
inline void TradeReportForNonNextshares::_internal_set_originatingmarketcenteridentifier(::data::OriginatingMarketCenterIdentifier value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.originatingmarketcenteridentifier_ = value;
}
inline void TradeReportForNonNextshares::set_originatingmarketcenteridentifier(::data::OriginatingMarketCenterIdentifier value) {
  _internal_set_originatingmarketcenteridentifier(value);
  // @@protoc_insertion_point(field_set:data.TradeReportForNonNextshares.originatingMarketCenterIdentifier)
}

// optional string issueSymbol = 2;
inline bool TradeReportForNonNextshares::_internal_has_issuesymbol() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TradeReportForNonNextshares::has_issuesymbol() const {
  return _internal_has_issuesymbol();
}
inline void TradeReportForNonNextshares::clear_issuesymbol() {
  _impl_.issuesymbol_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TradeReportForNonNextshares::issuesymbol() const {
  // @@protoc_insertion_point(field_get:data.TradeReportForNonNextshares.issueSymbol)
  return _internal_issuesymbol();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TradeReportForNonNextshares::set_issuesymbol(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.issuesymbol_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:data.TradeReportForNonNextshares.issueSymbol)
}
inline std::string* TradeReportForNonNextshares::mutable_issuesymbol() {
  std::string* _s = _internal_mutable_issuesymbol();
  // @@protoc_insertion_point(field_mutable:data.TradeReportForNonNextshares.issueSymbol)
  return _s;
}
inline const std::string& TradeReportForNonNextshares::_internal_issuesymbol() const {
  return _impl_.issuesymbol_.Get();
}
inline void TradeReportForNonNextshares::_internal_set_issuesymbol(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.issuesymbol_.Set(value, GetArenaForAllocation());
}
inline std::string* TradeReportForNonNextshares::_internal_mutable_issuesymbol() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.issuesymbol_.Mutable(GetArenaForAllocation());
}
inline std::string* TradeReportForNonNextshares::release_issuesymbol() {
  // @@protoc_insertion_point(field_release:data.TradeReportForNonNextshares.issueSymbol)
  if (!_internal_has_issuesymbol()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.issuesymbol_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.issuesymbol_.IsDefault()) {
    _impl_.issuesymbol_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TradeReportForNonNextshares::set_allocated_issuesymbol(std::string* issuesymbol) {
  if (issuesymbol != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.issuesymbol_.SetAllocated(issuesymbol, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.issuesymbol_.IsDefault()) {
    _impl_.issuesymbol_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:data.TradeReportForNonNextshares.issueSymbol)
}

// optional .data.SecurityClass securityClass = 3;
inline bool TradeReportForNonNextshares::_internal_has_securityclass() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool TradeReportForNonNextshares::has_securityclass() const {
  return _internal_has_securityclass();
}
inline void TradeReportForNonNextshares::clear_securityclass() {
  _impl_.securityclass_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::data::SecurityClass TradeReportForNonNextshares::_internal_securityclass() const {
  return static_cast< ::data::SecurityClass >(_impl_.securityclass_);
}
inline ::data::SecurityClass TradeReportForNonNextshares::securityclass() const {
  // @@protoc_insertion_point(field_get:data.TradeReportForNonNextshares.securityClass)
  return _internal_securityclass();
}
inline void TradeReportForNonNextshares::_internal_set_securityclass(::data::SecurityClass value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.securityclass_ = value;
}
inline void TradeReportForNonNextshares::set_securityclass(::data::SecurityClass value) {
  _internal_set_securityclass(value);
  // @@protoc_insertion_point(field_set:data.TradeReportForNonNextshares.securityClass)
}

// optional string tradeControlNumber = 4;
inline bool TradeReportForNonNextshares::_internal_has_tradecontrolnumber() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TradeReportForNonNextshares::has_tradecontrolnumber() const {
  return _internal_has_tradecontrolnumber();
}
inline void TradeReportForNonNextshares::clear_tradecontrolnumber() {
  _impl_.tradecontrolnumber_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& TradeReportForNonNextshares::tradecontrolnumber() const {
  // @@protoc_insertion_point(field_get:data.TradeReportForNonNextshares.tradeControlNumber)
  return _internal_tradecontrolnumber();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TradeReportForNonNextshares::set_tradecontrolnumber(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.tradecontrolnumber_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:data.TradeReportForNonNextshares.tradeControlNumber)
}
inline std::string* TradeReportForNonNextshares::mutable_tradecontrolnumber() {
  std::string* _s = _internal_mutable_tradecontrolnumber();
  // @@protoc_insertion_point(field_mutable:data.TradeReportForNonNextshares.tradeControlNumber)
  return _s;
}
inline const std::string& TradeReportForNonNextshares::_internal_tradecontrolnumber() const {
  return _impl_.tradecontrolnumber_.Get();
}
inline void TradeReportForNonNextshares::_internal_set_tradecontrolnumber(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.tradecontrolnumber_.Set(value, GetArenaForAllocation());
}
inline std::string* TradeReportForNonNextshares::_internal_mutable_tradecontrolnumber() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.tradecontrolnumber_.Mutable(GetArenaForAllocation());
}
inline std::string* TradeReportForNonNextshares::release_tradecontrolnumber() {
  // @@protoc_insertion_point(field_release:data.TradeReportForNonNextshares.tradeControlNumber)
  if (!_internal_has_tradecontrolnumber()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.tradecontrolnumber_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.tradecontrolnumber_.IsDefault()) {
    _impl_.tradecontrolnumber_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TradeReportForNonNextshares::set_allocated_tradecontrolnumber(std::string* tradecontrolnumber) {
  if (tradecontrolnumber != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.tradecontrolnumber_.SetAllocated(tradecontrolnumber, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.tradecontrolnumber_.IsDefault()) {
    _impl_.tradecontrolnumber_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:data.TradeReportForNonNextshares.tradeControlNumber)
}

// optional double tradePrice = 5;
inline bool TradeReportForNonNextshares::_internal_has_tradeprice() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool TradeReportForNonNextshares::has_tradeprice() const {
  return _internal_has_tradeprice();
}
inline void TradeReportForNonNextshares::clear_tradeprice() {
  _impl_.tradeprice_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline double TradeReportForNonNextshares::_internal_tradeprice() const {
  return _impl_.tradeprice_;
}
inline double TradeReportForNonNextshares::tradeprice() const {
  // @@protoc_insertion_point(field_get:data.TradeReportForNonNextshares.tradePrice)
  return _internal_tradeprice();
}
inline void TradeReportForNonNextshares::_internal_set_tradeprice(double value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.tradeprice_ = value;
}
inline void TradeReportForNonNextshares::set_tradeprice(double value) {
  _internal_set_tradeprice(value);
  // @@protoc_insertion_point(field_set:data.TradeReportForNonNextshares.tradePrice)
}

// optional int64 tradeSize = 6;
inline bool TradeReportForNonNextshares::_internal_has_tradesize() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool TradeReportForNonNextshares::has_tradesize() const {
  return _internal_has_tradesize();
}
inline void TradeReportForNonNextshares::clear_tradesize() {
  _impl_.tradesize_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline int64_t TradeReportForNonNextshares::_internal_tradesize() const {
  return _impl_.tradesize_;
}
inline int64_t TradeReportForNonNextshares::tradesize() const {
  // @@protoc_insertion_point(field_get:data.TradeReportForNonNextshares.tradeSize)
  return _internal_tradesize();
}
inline void TradeReportForNonNextshares::_internal_set_tradesize(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.tradesize_ = value;
}
inline void TradeReportForNonNextshares::set_tradesize(int64_t value) {
  _internal_set_tradesize(value);
  // @@protoc_insertion_point(field_set:data.TradeReportForNonNextshares.tradeSize)
}

// optional .data.SaleConditionModifier saleConditionModifier = 7;
inline bool TradeReportForNonNextshares::_internal_has_saleconditionmodifier() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.saleconditionmodifier_ != nullptr);
  return value;
}
inline bool TradeReportForNonNextshares::has_saleconditionmodifier() const {
  return _internal_has_saleconditionmodifier();
}
inline void TradeReportForNonNextshares::clear_saleconditionmodifier() {
  if (_impl_.saleconditionmodifier_ != nullptr) _impl_.saleconditionmodifier_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::data::SaleConditionModifier& TradeReportForNonNextshares::_internal_saleconditionmodifier() const {
  const ::data::SaleConditionModifier* p = _impl_.saleconditionmodifier_;
  return p != nullptr ? *p : reinterpret_cast<const ::data::SaleConditionModifier&>(
      ::data::_SaleConditionModifier_default_instance_);
}
inline const ::data::SaleConditionModifier& TradeReportForNonNextshares::saleconditionmodifier() const {
  // @@protoc_insertion_point(field_get:data.TradeReportForNonNextshares.saleConditionModifier)
  return _internal_saleconditionmodifier();
}
inline void TradeReportForNonNextshares::unsafe_arena_set_allocated_saleconditionmodifier(
    ::data::SaleConditionModifier* saleconditionmodifier) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.saleconditionmodifier_);
  }
  _impl_.saleconditionmodifier_ = saleconditionmodifier;
  if (saleconditionmodifier) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:data.TradeReportForNonNextshares.saleConditionModifier)
}
inline ::data::SaleConditionModifier* TradeReportForNonNextshares::release_saleconditionmodifier() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::data::SaleConditionModifier* temp = _impl_.saleconditionmodifier_;
  _impl_.saleconditionmodifier_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::data::SaleConditionModifier* TradeReportForNonNextshares::unsafe_arena_release_saleconditionmodifier() {
  // @@protoc_insertion_point(field_release:data.TradeReportForNonNextshares.saleConditionModifier)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::data::SaleConditionModifier* temp = _impl_.saleconditionmodifier_;
  _impl_.saleconditionmodifier_ = nullptr;
  return temp;
}
inline ::data::SaleConditionModifier* TradeReportForNonNextshares::_internal_mutable_saleconditionmodifier() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.saleconditionmodifier_ == nullptr) {
    auto* p = CreateMaybeMessage<::data::SaleConditionModifier>(GetArenaForAllocation());
    _impl_.saleconditionmodifier_ = p;
  }
  return _impl_.saleconditionmodifier_;
}
inline ::data::SaleConditionModifier* TradeReportForNonNextshares::mutable_saleconditionmodifier() {
  ::data::SaleConditionModifier* _msg = _internal_mutable_saleconditionmodifier();
  // @@protoc_insertion_point(field_mutable:data.TradeReportForNonNextshares.saleConditionModifier)
  return _msg;
}
inline void TradeReportForNonNextshares::set_allocated_saleconditionmodifier(::data::SaleConditionModifier* saleconditionmodifier) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.saleconditionmodifier_;
  }
  if (saleconditionmodifier) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(saleconditionmodifier);
    if (message_arena != submessage_arena) {
      saleconditionmodifier = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, saleconditionmodifier, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.saleconditionmodifier_ = saleconditionmodifier;
  // @@protoc_insertion_point(field_set_allocated:data.TradeReportForNonNextshares.saleConditionModifier)
}

// optional int64 consolidatedVolume = 8;
inline bool TradeReportForNonNextshares::_internal_has_consolidatedvolume() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool TradeReportForNonNextshares::has_consolidatedvolume() const {
  return _internal_has_consolidatedvolume();
}
inline void TradeReportForNonNextshares::clear_consolidatedvolume() {
  _impl_.consolidatedvolume_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline int64_t TradeReportForNonNextshares::_internal_consolidatedvolume() const {
  return _impl_.consolidatedvolume_;
}
inline int64_t TradeReportForNonNextshares::consolidatedvolume() const {
  // @@protoc_insertion_point(field_get:data.TradeReportForNonNextshares.consolidatedVolume)
  return _internal_consolidatedvolume();
}
inline void TradeReportForNonNextshares::_internal_set_consolidatedvolume(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.consolidatedvolume_ = value;
}
inline void TradeReportForNonNextshares::set_consolidatedvolume(int64_t value) {
  _internal_set_consolidatedvolume(value);
  // @@protoc_insertion_point(field_set:data.TradeReportForNonNextshares.consolidatedVolume)
}

// -------------------------------------------------------------------

// QBBOMWCBBreachMessage

// optional string breachedLevel = 1;
inline bool QBBOMWCBBreachMessage::_internal_has_breachedlevel() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool QBBOMWCBBreachMessage::has_breachedlevel() const {
  return _internal_has_breachedlevel();
}
inline void QBBOMWCBBreachMessage::clear_breachedlevel() {
  _impl_.breachedlevel_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& QBBOMWCBBreachMessage::breachedlevel() const {
  // @@protoc_insertion_point(field_get:data.QBBOMWCBBreachMessage.breachedLevel)
  return _internal_breachedlevel();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void QBBOMWCBBreachMessage::set_breachedlevel(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.breachedlevel_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:data.QBBOMWCBBreachMessage.breachedLevel)
}
inline std::string* QBBOMWCBBreachMessage::mutable_breachedlevel() {
  std::string* _s = _internal_mutable_breachedlevel();
  // @@protoc_insertion_point(field_mutable:data.QBBOMWCBBreachMessage.breachedLevel)
  return _s;
}
inline const std::string& QBBOMWCBBreachMessage::_internal_breachedlevel() const {
  return _impl_.breachedlevel_.Get();
}
inline void QBBOMWCBBreachMessage::_internal_set_breachedlevel(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.breachedlevel_.Set(value, GetArenaForAllocation());
}
inline std::string* QBBOMWCBBreachMessage::_internal_mutable_breachedlevel() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.breachedlevel_.Mutable(GetArenaForAllocation());
}
inline std::string* QBBOMWCBBreachMessage::release_breachedlevel() {
  // @@protoc_insertion_point(field_release:data.QBBOMWCBBreachMessage.breachedLevel)
  if (!_internal_has_breachedlevel()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.breachedlevel_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.breachedlevel_.IsDefault()) {
    _impl_.breachedlevel_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void QBBOMWCBBreachMessage::set_allocated_breachedlevel(std::string* breachedlevel) {
  if (breachedlevel != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.breachedlevel_.SetAllocated(breachedlevel, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.breachedlevel_.IsDefault()) {
    _impl_.breachedlevel_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:data.QBBOMWCBBreachMessage.breachedLevel)
}

// -------------------------------------------------------------------

// QBBOMWCBDeclineLevelMessage

// optional double Level1 = 1;
inline bool QBBOMWCBDeclineLevelMessage::_internal_has_level1() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool QBBOMWCBDeclineLevelMessage::has_level1() const {
  return _internal_has_level1();
}
inline void QBBOMWCBDeclineLevelMessage::clear_level1() {
  _impl_.level1_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline double QBBOMWCBDeclineLevelMessage::_internal_level1() const {
  return _impl_.level1_;
}
inline double QBBOMWCBDeclineLevelMessage::level1() const {
  // @@protoc_insertion_point(field_get:data.QBBOMWCBDeclineLevelMessage.Level1)
  return _internal_level1();
}
inline void QBBOMWCBDeclineLevelMessage::_internal_set_level1(double value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.level1_ = value;
}
inline void QBBOMWCBDeclineLevelMessage::set_level1(double value) {
  _internal_set_level1(value);
  // @@protoc_insertion_point(field_set:data.QBBOMWCBDeclineLevelMessage.Level1)
}

// optional double Level2 = 2;
inline bool QBBOMWCBDeclineLevelMessage::_internal_has_level2() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool QBBOMWCBDeclineLevelMessage::has_level2() const {
  return _internal_has_level2();
}
inline void QBBOMWCBDeclineLevelMessage::clear_level2() {
  _impl_.level2_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline double QBBOMWCBDeclineLevelMessage::_internal_level2() const {
  return _impl_.level2_;
}
inline double QBBOMWCBDeclineLevelMessage::level2() const {
  // @@protoc_insertion_point(field_get:data.QBBOMWCBDeclineLevelMessage.Level2)
  return _internal_level2();
}
inline void QBBOMWCBDeclineLevelMessage::_internal_set_level2(double value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.level2_ = value;
}
inline void QBBOMWCBDeclineLevelMessage::set_level2(double value) {
  _internal_set_level2(value);
  // @@protoc_insertion_point(field_set:data.QBBOMWCBDeclineLevelMessage.Level2)
}

// optional double Level3 = 3;
inline bool QBBOMWCBDeclineLevelMessage::_internal_has_level3() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool QBBOMWCBDeclineLevelMessage::has_level3() const {
  return _internal_has_level3();
}
inline void QBBOMWCBDeclineLevelMessage::clear_level3() {
  _impl_.level3_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline double QBBOMWCBDeclineLevelMessage::_internal_level3() const {
  return _impl_.level3_;
}
inline double QBBOMWCBDeclineLevelMessage::level3() const {
  // @@protoc_insertion_point(field_get:data.QBBOMWCBDeclineLevelMessage.Level3)
  return _internal_level3();
}
inline void QBBOMWCBDeclineLevelMessage::_internal_set_level3(double value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.level3_ = value;
}
inline void QBBOMWCBDeclineLevelMessage::set_level3(double value) {
  _internal_set_level3(value);
  // @@protoc_insertion_point(field_set:data.QBBOMWCBDeclineLevelMessage.Level3)
}

// -------------------------------------------------------------------

// QBBOMessageHeader

// optional .data.QBBOMessageType messageType = 1;
inline bool QBBOMessageHeader::_internal_has_messagetype() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool QBBOMessageHeader::has_messagetype() const {
  return _internal_has_messagetype();
}
inline void QBBOMessageHeader::clear_messagetype() {
  _impl_.messagetype_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::data::QBBOMessageType QBBOMessageHeader::_internal_messagetype() const {
  return static_cast< ::data::QBBOMessageType >(_impl_.messagetype_);
}
inline ::data::QBBOMessageType QBBOMessageHeader::messagetype() const {
  // @@protoc_insertion_point(field_get:data.QBBOMessageHeader.messageType)
  return _internal_messagetype();
}
inline void QBBOMessageHeader::_internal_set_messagetype(::data::QBBOMessageType value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.messagetype_ = value;
}
inline void QBBOMessageHeader::set_messagetype(::data::QBBOMessageType value) {
  _internal_set_messagetype(value);
  // @@protoc_insertion_point(field_set:data.QBBOMessageHeader.messageType)
}

// optional int32 trackingNumber = 2;
inline bool QBBOMessageHeader::_internal_has_trackingnumber() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool QBBOMessageHeader::has_trackingnumber() const {
  return _internal_has_trackingnumber();
}
inline void QBBOMessageHeader::clear_trackingnumber() {
  _impl_.trackingnumber_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t QBBOMessageHeader::_internal_trackingnumber() const {
  return _impl_.trackingnumber_;
}
inline int32_t QBBOMessageHeader::trackingnumber() const {
  // @@protoc_insertion_point(field_get:data.QBBOMessageHeader.trackingNumber)
  return _internal_trackingnumber();
}
inline void QBBOMessageHeader::_internal_set_trackingnumber(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.trackingnumber_ = value;
}
inline void QBBOMessageHeader::set_trackingnumber(int32_t value) {
  _internal_set_trackingnumber(value);
  // @@protoc_insertion_point(field_set:data.QBBOMessageHeader.trackingNumber)
}

// optional int64 timestamp = 3;
inline bool QBBOMessageHeader::_internal_has_timestamp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool QBBOMessageHeader::has_timestamp() const {
  return _internal_has_timestamp();
}
inline void QBBOMessageHeader::clear_timestamp() {
  _impl_.timestamp_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int64_t QBBOMessageHeader::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline int64_t QBBOMessageHeader::timestamp() const {
  // @@protoc_insertion_point(field_get:data.QBBOMessageHeader.timestamp)
  return _internal_timestamp();
}
inline void QBBOMessageHeader::_internal_set_timestamp(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.timestamp_ = value;
}
inline void QBBOMessageHeader::set_timestamp(int64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:data.QBBOMessageHeader.timestamp)
}

// -------------------------------------------------------------------

// QBBONextSharesQuotationMessage

// optional string nextsharesSymbol = 1;
inline bool QBBONextSharesQuotationMessage::_internal_has_nextsharessymbol() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool QBBONextSharesQuotationMessage::has_nextsharessymbol() const {
  return _internal_has_nextsharessymbol();
}
inline void QBBONextSharesQuotationMessage::clear_nextsharessymbol() {
  _impl_.nextsharessymbol_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& QBBONextSharesQuotationMessage::nextsharessymbol() const {
  // @@protoc_insertion_point(field_get:data.QBBONextSharesQuotationMessage.nextsharesSymbol)
  return _internal_nextsharessymbol();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void QBBONextSharesQuotationMessage::set_nextsharessymbol(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.nextsharessymbol_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:data.QBBONextSharesQuotationMessage.nextsharesSymbol)
}
inline std::string* QBBONextSharesQuotationMessage::mutable_nextsharessymbol() {
  std::string* _s = _internal_mutable_nextsharessymbol();
  // @@protoc_insertion_point(field_mutable:data.QBBONextSharesQuotationMessage.nextsharesSymbol)
  return _s;
}
inline const std::string& QBBONextSharesQuotationMessage::_internal_nextsharessymbol() const {
  return _impl_.nextsharessymbol_.Get();
}
inline void QBBONextSharesQuotationMessage::_internal_set_nextsharessymbol(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.nextsharessymbol_.Set(value, GetArenaForAllocation());
}
inline std::string* QBBONextSharesQuotationMessage::_internal_mutable_nextsharessymbol() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.nextsharessymbol_.Mutable(GetArenaForAllocation());
}
inline std::string* QBBONextSharesQuotationMessage::release_nextsharessymbol() {
  // @@protoc_insertion_point(field_release:data.QBBONextSharesQuotationMessage.nextsharesSymbol)
  if (!_internal_has_nextsharessymbol()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.nextsharessymbol_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.nextsharessymbol_.IsDefault()) {
    _impl_.nextsharessymbol_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void QBBONextSharesQuotationMessage::set_allocated_nextsharessymbol(std::string* nextsharessymbol) {
  if (nextsharessymbol != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.nextsharessymbol_.SetAllocated(nextsharessymbol, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.nextsharessymbol_.IsDefault()) {
    _impl_.nextsharessymbol_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:data.QBBONextSharesQuotationMessage.nextsharesSymbol)
}

// optional .data.SecurityClass securityClass = 2;
inline bool QBBONextSharesQuotationMessage::_internal_has_securityclass() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool QBBONextSharesQuotationMessage::has_securityclass() const {
  return _internal_has_securityclass();
}
inline void QBBONextSharesQuotationMessage::clear_securityclass() {
  _impl_.securityclass_ = 0;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline ::data::SecurityClass QBBONextSharesQuotationMessage::_internal_securityclass() const {
  return static_cast< ::data::SecurityClass >(_impl_.securityclass_);
}
inline ::data::SecurityClass QBBONextSharesQuotationMessage::securityclass() const {
  // @@protoc_insertion_point(field_get:data.QBBONextSharesQuotationMessage.securityClass)
  return _internal_securityclass();
}
inline void QBBONextSharesQuotationMessage::_internal_set_securityclass(::data::SecurityClass value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.securityclass_ = value;
}
inline void QBBONextSharesQuotationMessage::set_securityclass(::data::SecurityClass value) {
  _internal_set_securityclass(value);
  // @@protoc_insertion_point(field_set:data.QBBONextSharesQuotationMessage.securityClass)
}

// optional double nasdaqBestBid = 3;
inline bool QBBONextSharesQuotationMessage::_internal_has_nasdaqbestbid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool QBBONextSharesQuotationMessage::has_nasdaqbestbid() const {
  return _internal_has_nasdaqbestbid();
}
inline void QBBONextSharesQuotationMessage::clear_nasdaqbestbid() {
  _impl_.nasdaqbestbid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline double QBBONextSharesQuotationMessage::_internal_nasdaqbestbid() const {
  return _impl_.nasdaqbestbid_;
}
inline double QBBONextSharesQuotationMessage::nasdaqbestbid() const {
  // @@protoc_insertion_point(field_get:data.QBBONextSharesQuotationMessage.nasdaqBestBid)
  return _internal_nasdaqbestbid();
}
inline void QBBONextSharesQuotationMessage::_internal_set_nasdaqbestbid(double value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.nasdaqbestbid_ = value;
}
inline void QBBONextSharesQuotationMessage::set_nasdaqbestbid(double value) {
  _internal_set_nasdaqbestbid(value);
  // @@protoc_insertion_point(field_set:data.QBBONextSharesQuotationMessage.nasdaqBestBid)
}

// optional int64 nasdaqBestBidSize = 4;
inline bool QBBONextSharesQuotationMessage::_internal_has_nasdaqbestbidsize() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool QBBONextSharesQuotationMessage::has_nasdaqbestbidsize() const {
  return _internal_has_nasdaqbestbidsize();
}
inline void QBBONextSharesQuotationMessage::clear_nasdaqbestbidsize() {
  _impl_.nasdaqbestbidsize_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int64_t QBBONextSharesQuotationMessage::_internal_nasdaqbestbidsize() const {
  return _impl_.nasdaqbestbidsize_;
}
inline int64_t QBBONextSharesQuotationMessage::nasdaqbestbidsize() const {
  // @@protoc_insertion_point(field_get:data.QBBONextSharesQuotationMessage.nasdaqBestBidSize)
  return _internal_nasdaqbestbidsize();
}
inline void QBBONextSharesQuotationMessage::_internal_set_nasdaqbestbidsize(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.nasdaqbestbidsize_ = value;
}
inline void QBBONextSharesQuotationMessage::set_nasdaqbestbidsize(int64_t value) {
  _internal_set_nasdaqbestbidsize(value);
  // @@protoc_insertion_point(field_set:data.QBBONextSharesQuotationMessage.nasdaqBestBidSize)
}

// optional double nasdaqBestBidDiscountAmount = 5;
inline bool QBBONextSharesQuotationMessage::_internal_has_nasdaqbestbiddiscountamount() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool QBBONextSharesQuotationMessage::has_nasdaqbestbiddiscountamount() const {
  return _internal_has_nasdaqbestbiddiscountamount();
}
inline void QBBONextSharesQuotationMessage::clear_nasdaqbestbiddiscountamount() {
  _impl_.nasdaqbestbiddiscountamount_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline double QBBONextSharesQuotationMessage::_internal_nasdaqbestbiddiscountamount() const {
  return _impl_.nasdaqbestbiddiscountamount_;
}
inline double QBBONextSharesQuotationMessage::nasdaqbestbiddiscountamount() const {
  // @@protoc_insertion_point(field_get:data.QBBONextSharesQuotationMessage.nasdaqBestBidDiscountAmount)
  return _internal_nasdaqbestbiddiscountamount();
}
inline void QBBONextSharesQuotationMessage::_internal_set_nasdaqbestbiddiscountamount(double value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.nasdaqbestbiddiscountamount_ = value;
}
inline void QBBONextSharesQuotationMessage::set_nasdaqbestbiddiscountamount(double value) {
  _internal_set_nasdaqbestbiddiscountamount(value);
  // @@protoc_insertion_point(field_set:data.QBBONextSharesQuotationMessage.nasdaqBestBidDiscountAmount)
}

// optional double nasdaqBestOfferProxyPrice = 6;
inline bool QBBONextSharesQuotationMessage::_internal_has_nasdaqbestofferproxyprice() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool QBBONextSharesQuotationMessage::has_nasdaqbestofferproxyprice() const {
  return _internal_has_nasdaqbestofferproxyprice();
}
inline void QBBONextSharesQuotationMessage::clear_nasdaqbestofferproxyprice() {
  _impl_.nasdaqbestofferproxyprice_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline double QBBONextSharesQuotationMessage::_internal_nasdaqbestofferproxyprice() const {
  return _impl_.nasdaqbestofferproxyprice_;
}
inline double QBBONextSharesQuotationMessage::nasdaqbestofferproxyprice() const {
  // @@protoc_insertion_point(field_get:data.QBBONextSharesQuotationMessage.nasdaqBestOfferProxyPrice)
  return _internal_nasdaqbestofferproxyprice();
}
inline void QBBONextSharesQuotationMessage::_internal_set_nasdaqbestofferproxyprice(double value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.nasdaqbestofferproxyprice_ = value;
}
inline void QBBONextSharesQuotationMessage::set_nasdaqbestofferproxyprice(double value) {
  _internal_set_nasdaqbestofferproxyprice(value);
  // @@protoc_insertion_point(field_set:data.QBBONextSharesQuotationMessage.nasdaqBestOfferProxyPrice)
}

// optional int64 nasdaqBestOfferSize = 7;
inline bool QBBONextSharesQuotationMessage::_internal_has_nasdaqbestoffersize() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool QBBONextSharesQuotationMessage::has_nasdaqbestoffersize() const {
  return _internal_has_nasdaqbestoffersize();
}
inline void QBBONextSharesQuotationMessage::clear_nasdaqbestoffersize() {
  _impl_.nasdaqbestoffersize_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline int64_t QBBONextSharesQuotationMessage::_internal_nasdaqbestoffersize() const {
  return _impl_.nasdaqbestoffersize_;
}
inline int64_t QBBONextSharesQuotationMessage::nasdaqbestoffersize() const {
  // @@protoc_insertion_point(field_get:data.QBBONextSharesQuotationMessage.nasdaqBestOfferSize)
  return _internal_nasdaqbestoffersize();
}
inline void QBBONextSharesQuotationMessage::_internal_set_nasdaqbestoffersize(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.nasdaqbestoffersize_ = value;
}
inline void QBBONextSharesQuotationMessage::set_nasdaqbestoffersize(int64_t value) {
  _internal_set_nasdaqbestoffersize(value);
  // @@protoc_insertion_point(field_set:data.QBBONextSharesQuotationMessage.nasdaqBestOfferSize)
}

// optional double nasdaqBestOfferDiscountAmount = 8;
inline bool QBBONextSharesQuotationMessage::_internal_has_nasdaqbestofferdiscountamount() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool QBBONextSharesQuotationMessage::has_nasdaqbestofferdiscountamount() const {
  return _internal_has_nasdaqbestofferdiscountamount();
}
inline void QBBONextSharesQuotationMessage::clear_nasdaqbestofferdiscountamount() {
  _impl_.nasdaqbestofferdiscountamount_ = 0;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline double QBBONextSharesQuotationMessage::_internal_nasdaqbestofferdiscountamount() const {
  return _impl_.nasdaqbestofferdiscountamount_;
}
inline double QBBONextSharesQuotationMessage::nasdaqbestofferdiscountamount() const {
  // @@protoc_insertion_point(field_get:data.QBBONextSharesQuotationMessage.nasdaqBestOfferDiscountAmount)
  return _internal_nasdaqbestofferdiscountamount();
}
inline void QBBONextSharesQuotationMessage::_internal_set_nasdaqbestofferdiscountamount(double value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.nasdaqbestofferdiscountamount_ = value;
}
inline void QBBONextSharesQuotationMessage::set_nasdaqbestofferdiscountamount(double value) {
  _internal_set_nasdaqbestofferdiscountamount(value);
  // @@protoc_insertion_point(field_set:data.QBBONextSharesQuotationMessage.nasdaqBestOfferDiscountAmount)
}

// -------------------------------------------------------------------

// QBBOOperationalHalt

// optional string stock = 1;
inline bool QBBOOperationalHalt::_internal_has_stock() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool QBBOOperationalHalt::has_stock() const {
  return _internal_has_stock();
}
inline void QBBOOperationalHalt::clear_stock() {
  _impl_.stock_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& QBBOOperationalHalt::stock() const {
  // @@protoc_insertion_point(field_get:data.QBBOOperationalHalt.stock)
  return _internal_stock();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void QBBOOperationalHalt::set_stock(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.stock_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:data.QBBOOperationalHalt.stock)
}
inline std::string* QBBOOperationalHalt::mutable_stock() {
  std::string* _s = _internal_mutable_stock();
  // @@protoc_insertion_point(field_mutable:data.QBBOOperationalHalt.stock)
  return _s;
}
inline const std::string& QBBOOperationalHalt::_internal_stock() const {
  return _impl_.stock_.Get();
}
inline void QBBOOperationalHalt::_internal_set_stock(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.stock_.Set(value, GetArenaForAllocation());
}
inline std::string* QBBOOperationalHalt::_internal_mutable_stock() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.stock_.Mutable(GetArenaForAllocation());
}
inline std::string* QBBOOperationalHalt::release_stock() {
  // @@protoc_insertion_point(field_release:data.QBBOOperationalHalt.stock)
  if (!_internal_has_stock()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.stock_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.stock_.IsDefault()) {
    _impl_.stock_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void QBBOOperationalHalt::set_allocated_stock(std::string* stock) {
  if (stock != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.stock_.SetAllocated(stock, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.stock_.IsDefault()) {
    _impl_.stock_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:data.QBBOOperationalHalt.stock)
}

// optional .data.MarketCode marketCode = 2;
inline bool QBBOOperationalHalt::_internal_has_marketcode() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool QBBOOperationalHalt::has_marketcode() const {
  return _internal_has_marketcode();
}
inline void QBBOOperationalHalt::clear_marketcode() {
  _impl_.marketcode_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::data::MarketCode QBBOOperationalHalt::_internal_marketcode() const {
  return static_cast< ::data::MarketCode >(_impl_.marketcode_);
}
inline ::data::MarketCode QBBOOperationalHalt::marketcode() const {
  // @@protoc_insertion_point(field_get:data.QBBOOperationalHalt.marketCode)
  return _internal_marketcode();
}
inline void QBBOOperationalHalt::_internal_set_marketcode(::data::MarketCode value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.marketcode_ = value;
}
inline void QBBOOperationalHalt::set_marketcode(::data::MarketCode value) {
  _internal_set_marketcode(value);
  // @@protoc_insertion_point(field_set:data.QBBOOperationalHalt.marketCode)
}

// optional .data.HaltAction operationalHaltAction = 3;
inline bool QBBOOperationalHalt::_internal_has_operationalhaltaction() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool QBBOOperationalHalt::has_operationalhaltaction() const {
  return _internal_has_operationalhaltaction();
}
inline void QBBOOperationalHalt::clear_operationalhaltaction() {
  _impl_.operationalhaltaction_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::data::HaltAction QBBOOperationalHalt::_internal_operationalhaltaction() const {
  return static_cast< ::data::HaltAction >(_impl_.operationalhaltaction_);
}
inline ::data::HaltAction QBBOOperationalHalt::operationalhaltaction() const {
  // @@protoc_insertion_point(field_get:data.QBBOOperationalHalt.operationalHaltAction)
  return _internal_operationalhaltaction();
}
inline void QBBOOperationalHalt::_internal_set_operationalhaltaction(::data::HaltAction value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.operationalhaltaction_ = value;
}
inline void QBBOOperationalHalt::set_operationalhaltaction(::data::HaltAction value) {
  _internal_set_operationalhaltaction(value);
  // @@protoc_insertion_point(field_set:data.QBBOOperationalHalt.operationalHaltAction)
}

// -------------------------------------------------------------------

// QBBOQuotationMessage

// optional string stock = 1;
inline bool QBBOQuotationMessage::_internal_has_stock() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool QBBOQuotationMessage::has_stock() const {
  return _internal_has_stock();
}
inline void QBBOQuotationMessage::clear_stock() {
  _impl_.stock_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& QBBOQuotationMessage::stock() const {
  // @@protoc_insertion_point(field_get:data.QBBOQuotationMessage.stock)
  return _internal_stock();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void QBBOQuotationMessage::set_stock(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.stock_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:data.QBBOQuotationMessage.stock)
}
inline std::string* QBBOQuotationMessage::mutable_stock() {
  std::string* _s = _internal_mutable_stock();
  // @@protoc_insertion_point(field_mutable:data.QBBOQuotationMessage.stock)
  return _s;
}
inline const std::string& QBBOQuotationMessage::_internal_stock() const {
  return _impl_.stock_.Get();
}
inline void QBBOQuotationMessage::_internal_set_stock(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.stock_.Set(value, GetArenaForAllocation());
}
inline std::string* QBBOQuotationMessage::_internal_mutable_stock() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.stock_.Mutable(GetArenaForAllocation());
}
inline std::string* QBBOQuotationMessage::release_stock() {
  // @@protoc_insertion_point(field_release:data.QBBOQuotationMessage.stock)
  if (!_internal_has_stock()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.stock_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.stock_.IsDefault()) {
    _impl_.stock_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void QBBOQuotationMessage::set_allocated_stock(std::string* stock) {
  if (stock != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.stock_.SetAllocated(stock, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.stock_.IsDefault()) {
    _impl_.stock_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:data.QBBOQuotationMessage.stock)
}

// optional .data.SecurityClass securityClass = 2;
inline bool QBBOQuotationMessage::_internal_has_securityclass() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool QBBOQuotationMessage::has_securityclass() const {
  return _internal_has_securityclass();
}
inline void QBBOQuotationMessage::clear_securityclass() {
  _impl_.securityclass_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::data::SecurityClass QBBOQuotationMessage::_internal_securityclass() const {
  return static_cast< ::data::SecurityClass >(_impl_.securityclass_);
}
inline ::data::SecurityClass QBBOQuotationMessage::securityclass() const {
  // @@protoc_insertion_point(field_get:data.QBBOQuotationMessage.securityClass)
  return _internal_securityclass();
}
inline void QBBOQuotationMessage::_internal_set_securityclass(::data::SecurityClass value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.securityclass_ = value;
}
inline void QBBOQuotationMessage::set_securityclass(::data::SecurityClass value) {
  _internal_set_securityclass(value);
  // @@protoc_insertion_point(field_set:data.QBBOQuotationMessage.securityClass)
}

// optional double nasdaqBestBidPrice = 3;
inline bool QBBOQuotationMessage::_internal_has_nasdaqbestbidprice() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool QBBOQuotationMessage::has_nasdaqbestbidprice() const {
  return _internal_has_nasdaqbestbidprice();
}
inline void QBBOQuotationMessage::clear_nasdaqbestbidprice() {
  _impl_.nasdaqbestbidprice_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline double QBBOQuotationMessage::_internal_nasdaqbestbidprice() const {
  return _impl_.nasdaqbestbidprice_;
}
inline double QBBOQuotationMessage::nasdaqbestbidprice() const {
  // @@protoc_insertion_point(field_get:data.QBBOQuotationMessage.nasdaqBestBidPrice)
  return _internal_nasdaqbestbidprice();
}
inline void QBBOQuotationMessage::_internal_set_nasdaqbestbidprice(double value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.nasdaqbestbidprice_ = value;
}
inline void QBBOQuotationMessage::set_nasdaqbestbidprice(double value) {
  _internal_set_nasdaqbestbidprice(value);
  // @@protoc_insertion_point(field_set:data.QBBOQuotationMessage.nasdaqBestBidPrice)
}

// optional int64 nasdaqBestBidSize = 4;
inline bool QBBOQuotationMessage::_internal_has_nasdaqbestbidsize() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool QBBOQuotationMessage::has_nasdaqbestbidsize() const {
  return _internal_has_nasdaqbestbidsize();
}
inline void QBBOQuotationMessage::clear_nasdaqbestbidsize() {
  _impl_.nasdaqbestbidsize_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int64_t QBBOQuotationMessage::_internal_nasdaqbestbidsize() const {
  return _impl_.nasdaqbestbidsize_;
}
inline int64_t QBBOQuotationMessage::nasdaqbestbidsize() const {
  // @@protoc_insertion_point(field_get:data.QBBOQuotationMessage.nasdaqBestBidSize)
  return _internal_nasdaqbestbidsize();
}
inline void QBBOQuotationMessage::_internal_set_nasdaqbestbidsize(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.nasdaqbestbidsize_ = value;
}
inline void QBBOQuotationMessage::set_nasdaqbestbidsize(int64_t value) {
  _internal_set_nasdaqbestbidsize(value);
  // @@protoc_insertion_point(field_set:data.QBBOQuotationMessage.nasdaqBestBidSize)
}

// optional double nasdaqBestOfferPrice = 5;
inline bool QBBOQuotationMessage::_internal_has_nasdaqbestofferprice() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool QBBOQuotationMessage::has_nasdaqbestofferprice() const {
  return _internal_has_nasdaqbestofferprice();
}
inline void QBBOQuotationMessage::clear_nasdaqbestofferprice() {
  _impl_.nasdaqbestofferprice_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline double QBBOQuotationMessage::_internal_nasdaqbestofferprice() const {
  return _impl_.nasdaqbestofferprice_;
}
inline double QBBOQuotationMessage::nasdaqbestofferprice() const {
  // @@protoc_insertion_point(field_get:data.QBBOQuotationMessage.nasdaqBestOfferPrice)
  return _internal_nasdaqbestofferprice();
}
inline void QBBOQuotationMessage::_internal_set_nasdaqbestofferprice(double value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.nasdaqbestofferprice_ = value;
}
inline void QBBOQuotationMessage::set_nasdaqbestofferprice(double value) {
  _internal_set_nasdaqbestofferprice(value);
  // @@protoc_insertion_point(field_set:data.QBBOQuotationMessage.nasdaqBestOfferPrice)
}

// optional int64 nasdaqBestOfferSize = 6;
inline bool QBBOQuotationMessage::_internal_has_nasdaqbestoffersize() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool QBBOQuotationMessage::has_nasdaqbestoffersize() const {
  return _internal_has_nasdaqbestoffersize();
}
inline void QBBOQuotationMessage::clear_nasdaqbestoffersize() {
  _impl_.nasdaqbestoffersize_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline int64_t QBBOQuotationMessage::_internal_nasdaqbestoffersize() const {
  return _impl_.nasdaqbestoffersize_;
}
inline int64_t QBBOQuotationMessage::nasdaqbestoffersize() const {
  // @@protoc_insertion_point(field_get:data.QBBOQuotationMessage.nasdaqBestOfferSize)
  return _internal_nasdaqbestoffersize();
}
inline void QBBOQuotationMessage::_internal_set_nasdaqbestoffersize(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.nasdaqbestoffersize_ = value;
}
inline void QBBOQuotationMessage::set_nasdaqbestoffersize(int64_t value) {
  _internal_set_nasdaqbestoffersize(value);
  // @@protoc_insertion_point(field_set:data.QBBOQuotationMessage.nasdaqBestOfferSize)
}

// -------------------------------------------------------------------

// QBBORegShoRestriction

// optional string stock = 1;
inline bool QBBORegShoRestriction::_internal_has_stock() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool QBBORegShoRestriction::has_stock() const {
  return _internal_has_stock();
}
inline void QBBORegShoRestriction::clear_stock() {
  _impl_.stock_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& QBBORegShoRestriction::stock() const {
  // @@protoc_insertion_point(field_get:data.QBBORegShoRestriction.stock)
  return _internal_stock();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void QBBORegShoRestriction::set_stock(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.stock_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:data.QBBORegShoRestriction.stock)
}
inline std::string* QBBORegShoRestriction::mutable_stock() {
  std::string* _s = _internal_mutable_stock();
  // @@protoc_insertion_point(field_mutable:data.QBBORegShoRestriction.stock)
  return _s;
}
inline const std::string& QBBORegShoRestriction::_internal_stock() const {
  return _impl_.stock_.Get();
}
inline void QBBORegShoRestriction::_internal_set_stock(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.stock_.Set(value, GetArenaForAllocation());
}
inline std::string* QBBORegShoRestriction::_internal_mutable_stock() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.stock_.Mutable(GetArenaForAllocation());
}
inline std::string* QBBORegShoRestriction::release_stock() {
  // @@protoc_insertion_point(field_release:data.QBBORegShoRestriction.stock)
  if (!_internal_has_stock()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.stock_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.stock_.IsDefault()) {
    _impl_.stock_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void QBBORegShoRestriction::set_allocated_stock(std::string* stock) {
  if (stock != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.stock_.SetAllocated(stock, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.stock_.IsDefault()) {
    _impl_.stock_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:data.QBBORegShoRestriction.stock)
}

// optional .data.RegSHOAction regSHOAction = 2;
inline bool QBBORegShoRestriction::_internal_has_regshoaction() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool QBBORegShoRestriction::has_regshoaction() const {
  return _internal_has_regshoaction();
}
inline void QBBORegShoRestriction::clear_regshoaction() {
  _impl_.regshoaction_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::data::RegSHOAction QBBORegShoRestriction::_internal_regshoaction() const {
  return static_cast< ::data::RegSHOAction >(_impl_.regshoaction_);
}
inline ::data::RegSHOAction QBBORegShoRestriction::regshoaction() const {
  // @@protoc_insertion_point(field_get:data.QBBORegShoRestriction.regSHOAction)
  return _internal_regshoaction();
}
inline void QBBORegShoRestriction::_internal_set_regshoaction(::data::RegSHOAction value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.regshoaction_ = value;
}
inline void QBBORegShoRestriction::set_regshoaction(::data::RegSHOAction value) {
  _internal_set_regshoaction(value);
  // @@protoc_insertion_point(field_set:data.QBBORegShoRestriction.regSHOAction)
}

// -------------------------------------------------------------------

// QBBOStockDirectory

// optional string stock = 1;
inline bool QBBOStockDirectory::_internal_has_stock() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool QBBOStockDirectory::has_stock() const {
  return _internal_has_stock();
}
inline void QBBOStockDirectory::clear_stock() {
  _impl_.stock_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& QBBOStockDirectory::stock() const {
  // @@protoc_insertion_point(field_get:data.QBBOStockDirectory.stock)
  return _internal_stock();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void QBBOStockDirectory::set_stock(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.stock_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:data.QBBOStockDirectory.stock)
}
inline std::string* QBBOStockDirectory::mutable_stock() {
  std::string* _s = _internal_mutable_stock();
  // @@protoc_insertion_point(field_mutable:data.QBBOStockDirectory.stock)
  return _s;
}
inline const std::string& QBBOStockDirectory::_internal_stock() const {
  return _impl_.stock_.Get();
}
inline void QBBOStockDirectory::_internal_set_stock(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.stock_.Set(value, GetArenaForAllocation());
}
inline std::string* QBBOStockDirectory::_internal_mutable_stock() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.stock_.Mutable(GetArenaForAllocation());
}
inline std::string* QBBOStockDirectory::release_stock() {
  // @@protoc_insertion_point(field_release:data.QBBOStockDirectory.stock)
  if (!_internal_has_stock()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.stock_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.stock_.IsDefault()) {
    _impl_.stock_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void QBBOStockDirectory::set_allocated_stock(std::string* stock) {
  if (stock != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.stock_.SetAllocated(stock, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.stock_.IsDefault()) {
    _impl_.stock_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:data.QBBOStockDirectory.stock)
}

// optional .data.MarketCategory marketCategory = 2;
inline bool QBBOStockDirectory::_internal_has_marketcategory() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool QBBOStockDirectory::has_marketcategory() const {
  return _internal_has_marketcategory();
}
inline void QBBOStockDirectory::clear_marketcategory() {
  _impl_.marketcategory_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::data::MarketCategory QBBOStockDirectory::_internal_marketcategory() const {
  return static_cast< ::data::MarketCategory >(_impl_.marketcategory_);
}
inline ::data::MarketCategory QBBOStockDirectory::marketcategory() const {
  // @@protoc_insertion_point(field_get:data.QBBOStockDirectory.marketCategory)
  return _internal_marketcategory();
}
inline void QBBOStockDirectory::_internal_set_marketcategory(::data::MarketCategory value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.marketcategory_ = value;
}
inline void QBBOStockDirectory::set_marketcategory(::data::MarketCategory value) {
  _internal_set_marketcategory(value);
  // @@protoc_insertion_point(field_set:data.QBBOStockDirectory.marketCategory)
}

// optional .data.FinancialStatusIndicator financialStatusIndicator = 3;
inline bool QBBOStockDirectory::_internal_has_financialstatusindicator() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool QBBOStockDirectory::has_financialstatusindicator() const {
  return _internal_has_financialstatusindicator();
}
inline void QBBOStockDirectory::clear_financialstatusindicator() {
  _impl_.financialstatusindicator_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::data::FinancialStatusIndicator QBBOStockDirectory::_internal_financialstatusindicator() const {
  return static_cast< ::data::FinancialStatusIndicator >(_impl_.financialstatusindicator_);
}
inline ::data::FinancialStatusIndicator QBBOStockDirectory::financialstatusindicator() const {
  // @@protoc_insertion_point(field_get:data.QBBOStockDirectory.financialStatusIndicator)
  return _internal_financialstatusindicator();
}
inline void QBBOStockDirectory::_internal_set_financialstatusindicator(::data::FinancialStatusIndicator value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.financialstatusindicator_ = value;
}
inline void QBBOStockDirectory::set_financialstatusindicator(::data::FinancialStatusIndicator value) {
  _internal_set_financialstatusindicator(value);
  // @@protoc_insertion_point(field_set:data.QBBOStockDirectory.financialStatusIndicator)
}

// optional int64 roundLotsize = 4;
inline bool QBBOStockDirectory::_internal_has_roundlotsize() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool QBBOStockDirectory::has_roundlotsize() const {
  return _internal_has_roundlotsize();
}
inline void QBBOStockDirectory::clear_roundlotsize() {
  _impl_.roundlotsize_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline int64_t QBBOStockDirectory::_internal_roundlotsize() const {
  return _impl_.roundlotsize_;
}
inline int64_t QBBOStockDirectory::roundlotsize() const {
  // @@protoc_insertion_point(field_get:data.QBBOStockDirectory.roundLotsize)
  return _internal_roundlotsize();
}
inline void QBBOStockDirectory::_internal_set_roundlotsize(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.roundlotsize_ = value;
}
inline void QBBOStockDirectory::set_roundlotsize(int64_t value) {
  _internal_set_roundlotsize(value);
  // @@protoc_insertion_point(field_set:data.QBBOStockDirectory.roundLotsize)
}

// optional .data.IndicatesIf roundLotOnly = 5;
inline bool QBBOStockDirectory::_internal_has_roundlotonly() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool QBBOStockDirectory::has_roundlotonly() const {
  return _internal_has_roundlotonly();
}
inline void QBBOStockDirectory::clear_roundlotonly() {
  _impl_.roundlotonly_ = 0;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::data::IndicatesIf QBBOStockDirectory::_internal_roundlotonly() const {
  return static_cast< ::data::IndicatesIf >(_impl_.roundlotonly_);
}
inline ::data::IndicatesIf QBBOStockDirectory::roundlotonly() const {
  // @@protoc_insertion_point(field_get:data.QBBOStockDirectory.roundLotOnly)
  return _internal_roundlotonly();
}
inline void QBBOStockDirectory::_internal_set_roundlotonly(::data::IndicatesIf value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.roundlotonly_ = value;
}
inline void QBBOStockDirectory::set_roundlotonly(::data::IndicatesIf value) {
  _internal_set_roundlotonly(value);
  // @@protoc_insertion_point(field_set:data.QBBOStockDirectory.roundLotOnly)
}

// optional string issueClassification = 6;
inline bool QBBOStockDirectory::_internal_has_issueclassification() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool QBBOStockDirectory::has_issueclassification() const {
  return _internal_has_issueclassification();
}
inline void QBBOStockDirectory::clear_issueclassification() {
  _impl_.issueclassification_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& QBBOStockDirectory::issueclassification() const {
  // @@protoc_insertion_point(field_get:data.QBBOStockDirectory.issueClassification)
  return _internal_issueclassification();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void QBBOStockDirectory::set_issueclassification(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.issueclassification_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:data.QBBOStockDirectory.issueClassification)
}
inline std::string* QBBOStockDirectory::mutable_issueclassification() {
  std::string* _s = _internal_mutable_issueclassification();
  // @@protoc_insertion_point(field_mutable:data.QBBOStockDirectory.issueClassification)
  return _s;
}
inline const std::string& QBBOStockDirectory::_internal_issueclassification() const {
  return _impl_.issueclassification_.Get();
}
inline void QBBOStockDirectory::_internal_set_issueclassification(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.issueclassification_.Set(value, GetArenaForAllocation());
}
inline std::string* QBBOStockDirectory::_internal_mutable_issueclassification() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.issueclassification_.Mutable(GetArenaForAllocation());
}
inline std::string* QBBOStockDirectory::release_issueclassification() {
  // @@protoc_insertion_point(field_release:data.QBBOStockDirectory.issueClassification)
  if (!_internal_has_issueclassification()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.issueclassification_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.issueclassification_.IsDefault()) {
    _impl_.issueclassification_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void QBBOStockDirectory::set_allocated_issueclassification(std::string* issueclassification) {
  if (issueclassification != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.issueclassification_.SetAllocated(issueclassification, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.issueclassification_.IsDefault()) {
    _impl_.issueclassification_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:data.QBBOStockDirectory.issueClassification)
}

// optional string issueSubType = 7;
inline bool QBBOStockDirectory::_internal_has_issuesubtype() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool QBBOStockDirectory::has_issuesubtype() const {
  return _internal_has_issuesubtype();
}
inline void QBBOStockDirectory::clear_issuesubtype() {
  _impl_.issuesubtype_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& QBBOStockDirectory::issuesubtype() const {
  // @@protoc_insertion_point(field_get:data.QBBOStockDirectory.issueSubType)
  return _internal_issuesubtype();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void QBBOStockDirectory::set_issuesubtype(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.issuesubtype_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:data.QBBOStockDirectory.issueSubType)
}
inline std::string* QBBOStockDirectory::mutable_issuesubtype() {
  std::string* _s = _internal_mutable_issuesubtype();
  // @@protoc_insertion_point(field_mutable:data.QBBOStockDirectory.issueSubType)
  return _s;
}
inline const std::string& QBBOStockDirectory::_internal_issuesubtype() const {
  return _impl_.issuesubtype_.Get();
}
inline void QBBOStockDirectory::_internal_set_issuesubtype(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.issuesubtype_.Set(value, GetArenaForAllocation());
}
inline std::string* QBBOStockDirectory::_internal_mutable_issuesubtype() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.issuesubtype_.Mutable(GetArenaForAllocation());
}
inline std::string* QBBOStockDirectory::release_issuesubtype() {
  // @@protoc_insertion_point(field_release:data.QBBOStockDirectory.issueSubType)
  if (!_internal_has_issuesubtype()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.issuesubtype_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.issuesubtype_.IsDefault()) {
    _impl_.issuesubtype_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void QBBOStockDirectory::set_allocated_issuesubtype(std::string* issuesubtype) {
  if (issuesubtype != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.issuesubtype_.SetAllocated(issuesubtype, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.issuesubtype_.IsDefault()) {
    _impl_.issuesubtype_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:data.QBBOStockDirectory.issueSubType)
}

// optional .data.Authenticity authenticity = 8;
inline bool QBBOStockDirectory::_internal_has_authenticity() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool QBBOStockDirectory::has_authenticity() const {
  return _internal_has_authenticity();
}
inline void QBBOStockDirectory::clear_authenticity() {
  _impl_.authenticity_ = 0;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline ::data::Authenticity QBBOStockDirectory::_internal_authenticity() const {
  return static_cast< ::data::Authenticity >(_impl_.authenticity_);
}
inline ::data::Authenticity QBBOStockDirectory::authenticity() const {
  // @@protoc_insertion_point(field_get:data.QBBOStockDirectory.authenticity)
  return _internal_authenticity();
}
inline void QBBOStockDirectory::_internal_set_authenticity(::data::Authenticity value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.authenticity_ = value;
}
inline void QBBOStockDirectory::set_authenticity(::data::Authenticity value) {
  _internal_set_authenticity(value);
  // @@protoc_insertion_point(field_set:data.QBBOStockDirectory.authenticity)
}

// optional .data.IndicatesIf shortSaleThresholdIndicator = 9;
inline bool QBBOStockDirectory::_internal_has_shortsalethresholdindicator() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool QBBOStockDirectory::has_shortsalethresholdindicator() const {
  return _internal_has_shortsalethresholdindicator();
}
inline void QBBOStockDirectory::clear_shortsalethresholdindicator() {
  _impl_.shortsalethresholdindicator_ = 0;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline ::data::IndicatesIf QBBOStockDirectory::_internal_shortsalethresholdindicator() const {
  return static_cast< ::data::IndicatesIf >(_impl_.shortsalethresholdindicator_);
}
inline ::data::IndicatesIf QBBOStockDirectory::shortsalethresholdindicator() const {
  // @@protoc_insertion_point(field_get:data.QBBOStockDirectory.shortSaleThresholdIndicator)
  return _internal_shortsalethresholdindicator();
}
inline void QBBOStockDirectory::_internal_set_shortsalethresholdindicator(::data::IndicatesIf value) {
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.shortsalethresholdindicator_ = value;
}
inline void QBBOStockDirectory::set_shortsalethresholdindicator(::data::IndicatesIf value) {
  _internal_set_shortsalethresholdindicator(value);
  // @@protoc_insertion_point(field_set:data.QBBOStockDirectory.shortSaleThresholdIndicator)
}

// optional .data.IndicatesIf IPOFlag = 10;
inline bool QBBOStockDirectory::_internal_has_ipoflag() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool QBBOStockDirectory::has_ipoflag() const {
  return _internal_has_ipoflag();
}
inline void QBBOStockDirectory::clear_ipoflag() {
  _impl_.ipoflag_ = 0;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline ::data::IndicatesIf QBBOStockDirectory::_internal_ipoflag() const {
  return static_cast< ::data::IndicatesIf >(_impl_.ipoflag_);
}
inline ::data::IndicatesIf QBBOStockDirectory::ipoflag() const {
  // @@protoc_insertion_point(field_get:data.QBBOStockDirectory.IPOFlag)
  return _internal_ipoflag();
}
inline void QBBOStockDirectory::_internal_set_ipoflag(::data::IndicatesIf value) {
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.ipoflag_ = value;
}
inline void QBBOStockDirectory::set_ipoflag(::data::IndicatesIf value) {
  _internal_set_ipoflag(value);
  // @@protoc_insertion_point(field_set:data.QBBOStockDirectory.IPOFlag)
}

// optional .data.LULDRule lULDReferencePriceTier = 11;
inline bool QBBOStockDirectory::_internal_has_luldreferencepricetier() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool QBBOStockDirectory::has_luldreferencepricetier() const {
  return _internal_has_luldreferencepricetier();
}
inline void QBBOStockDirectory::clear_luldreferencepricetier() {
  _impl_.luldreferencepricetier_ = 0;
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline ::data::LULDRule QBBOStockDirectory::_internal_luldreferencepricetier() const {
  return static_cast< ::data::LULDRule >(_impl_.luldreferencepricetier_);
}
inline ::data::LULDRule QBBOStockDirectory::luldreferencepricetier() const {
  // @@protoc_insertion_point(field_get:data.QBBOStockDirectory.lULDReferencePriceTier)
  return _internal_luldreferencepricetier();
}
inline void QBBOStockDirectory::_internal_set_luldreferencepricetier(::data::LULDRule value) {
  _impl_._has_bits_[0] |= 0x00000400u;
  _impl_.luldreferencepricetier_ = value;
}
inline void QBBOStockDirectory::set_luldreferencepricetier(::data::LULDRule value) {
  _internal_set_luldreferencepricetier(value);
  // @@protoc_insertion_point(field_set:data.QBBOStockDirectory.lULDReferencePriceTier)
}

// optional .data.IndicatesIf ETPlag = 12;
inline bool QBBOStockDirectory::_internal_has_etplag() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool QBBOStockDirectory::has_etplag() const {
  return _internal_has_etplag();
}
inline void QBBOStockDirectory::clear_etplag() {
  _impl_.etplag_ = 0;
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline ::data::IndicatesIf QBBOStockDirectory::_internal_etplag() const {
  return static_cast< ::data::IndicatesIf >(_impl_.etplag_);
}
inline ::data::IndicatesIf QBBOStockDirectory::etplag() const {
  // @@protoc_insertion_point(field_get:data.QBBOStockDirectory.ETPlag)
  return _internal_etplag();
}
inline void QBBOStockDirectory::_internal_set_etplag(::data::IndicatesIf value) {
  _impl_._has_bits_[0] |= 0x00000800u;
  _impl_.etplag_ = value;
}
inline void QBBOStockDirectory::set_etplag(::data::IndicatesIf value) {
  _internal_set_etplag(value);
  // @@protoc_insertion_point(field_set:data.QBBOStockDirectory.ETPlag)
}

// optional int64 ETPLeverageFactor = 13;
inline bool QBBOStockDirectory::_internal_has_etpleveragefactor() const {
  bool value = (_impl_._has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool QBBOStockDirectory::has_etpleveragefactor() const {
  return _internal_has_etpleveragefactor();
}
inline void QBBOStockDirectory::clear_etpleveragefactor() {
  _impl_.etpleveragefactor_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00001000u;
}
inline int64_t QBBOStockDirectory::_internal_etpleveragefactor() const {
  return _impl_.etpleveragefactor_;
}
inline int64_t QBBOStockDirectory::etpleveragefactor() const {
  // @@protoc_insertion_point(field_get:data.QBBOStockDirectory.ETPLeverageFactor)
  return _internal_etpleveragefactor();
}
inline void QBBOStockDirectory::_internal_set_etpleveragefactor(int64_t value) {
  _impl_._has_bits_[0] |= 0x00001000u;
  _impl_.etpleveragefactor_ = value;
}
inline void QBBOStockDirectory::set_etpleveragefactor(int64_t value) {
  _internal_set_etpleveragefactor(value);
  // @@protoc_insertion_point(field_set:data.QBBOStockDirectory.ETPLeverageFactor)
}

// optional .data.IndicatesIf inverseIndicator = 14;
inline bool QBBOStockDirectory::_internal_has_inverseindicator() const {
  bool value = (_impl_._has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool QBBOStockDirectory::has_inverseindicator() const {
  return _internal_has_inverseindicator();
}
inline void QBBOStockDirectory::clear_inverseindicator() {
  _impl_.inverseindicator_ = 0;
  _impl_._has_bits_[0] &= ~0x00002000u;
}
inline ::data::IndicatesIf QBBOStockDirectory::_internal_inverseindicator() const {
  return static_cast< ::data::IndicatesIf >(_impl_.inverseindicator_);
}
inline ::data::IndicatesIf QBBOStockDirectory::inverseindicator() const {
  // @@protoc_insertion_point(field_get:data.QBBOStockDirectory.inverseIndicator)
  return _internal_inverseindicator();
}
inline void QBBOStockDirectory::_internal_set_inverseindicator(::data::IndicatesIf value) {
  _impl_._has_bits_[0] |= 0x00002000u;
  _impl_.inverseindicator_ = value;
}
inline void QBBOStockDirectory::set_inverseindicator(::data::IndicatesIf value) {
  _internal_set_inverseindicator(value);
  // @@protoc_insertion_point(field_set:data.QBBOStockDirectory.inverseIndicator)
}

// -------------------------------------------------------------------

// QBBOStockTradingAction

// optional string stock = 1;
inline bool QBBOStockTradingAction::_internal_has_stock() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool QBBOStockTradingAction::has_stock() const {
  return _internal_has_stock();
}
inline void QBBOStockTradingAction::clear_stock() {
  _impl_.stock_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& QBBOStockTradingAction::stock() const {
  // @@protoc_insertion_point(field_get:data.QBBOStockTradingAction.stock)
  return _internal_stock();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void QBBOStockTradingAction::set_stock(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.stock_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:data.QBBOStockTradingAction.stock)
}
inline std::string* QBBOStockTradingAction::mutable_stock() {
  std::string* _s = _internal_mutable_stock();
  // @@protoc_insertion_point(field_mutable:data.QBBOStockTradingAction.stock)
  return _s;
}
inline const std::string& QBBOStockTradingAction::_internal_stock() const {
  return _impl_.stock_.Get();
}
inline void QBBOStockTradingAction::_internal_set_stock(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.stock_.Set(value, GetArenaForAllocation());
}
inline std::string* QBBOStockTradingAction::_internal_mutable_stock() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.stock_.Mutable(GetArenaForAllocation());
}
inline std::string* QBBOStockTradingAction::release_stock() {
  // @@protoc_insertion_point(field_release:data.QBBOStockTradingAction.stock)
  if (!_internal_has_stock()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.stock_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.stock_.IsDefault()) {
    _impl_.stock_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void QBBOStockTradingAction::set_allocated_stock(std::string* stock) {
  if (stock != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.stock_.SetAllocated(stock, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.stock_.IsDefault()) {
    _impl_.stock_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:data.QBBOStockTradingAction.stock)
}

// optional .data.SecurityClass securityClass = 2;
inline bool QBBOStockTradingAction::_internal_has_securityclass() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool QBBOStockTradingAction::has_securityclass() const {
  return _internal_has_securityclass();
}
inline void QBBOStockTradingAction::clear_securityclass() {
  _impl_.securityclass_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::data::SecurityClass QBBOStockTradingAction::_internal_securityclass() const {
  return static_cast< ::data::SecurityClass >(_impl_.securityclass_);
}
inline ::data::SecurityClass QBBOStockTradingAction::securityclass() const {
  // @@protoc_insertion_point(field_get:data.QBBOStockTradingAction.securityClass)
  return _internal_securityclass();
}
inline void QBBOStockTradingAction::_internal_set_securityclass(::data::SecurityClass value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.securityclass_ = value;
}
inline void QBBOStockTradingAction::set_securityclass(::data::SecurityClass value) {
  _internal_set_securityclass(value);
  // @@protoc_insertion_point(field_set:data.QBBOStockTradingAction.securityClass)
}

// optional .data.CurrentTradingState currentTradingState = 3;
inline bool QBBOStockTradingAction::_internal_has_currenttradingstate() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool QBBOStockTradingAction::has_currenttradingstate() const {
  return _internal_has_currenttradingstate();
}
inline void QBBOStockTradingAction::clear_currenttradingstate() {
  _impl_.currenttradingstate_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::data::CurrentTradingState QBBOStockTradingAction::_internal_currenttradingstate() const {
  return static_cast< ::data::CurrentTradingState >(_impl_.currenttradingstate_);
}
inline ::data::CurrentTradingState QBBOStockTradingAction::currenttradingstate() const {
  // @@protoc_insertion_point(field_get:data.QBBOStockTradingAction.currentTradingState)
  return _internal_currenttradingstate();
}
inline void QBBOStockTradingAction::_internal_set_currenttradingstate(::data::CurrentTradingState value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.currenttradingstate_ = value;
}
inline void QBBOStockTradingAction::set_currenttradingstate(::data::CurrentTradingState value) {
  _internal_set_currenttradingstate(value);
  // @@protoc_insertion_point(field_set:data.QBBOStockTradingAction.currentTradingState)
}

// optional string reason = 4;
inline bool QBBOStockTradingAction::_internal_has_reason() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool QBBOStockTradingAction::has_reason() const {
  return _internal_has_reason();
}
inline void QBBOStockTradingAction::clear_reason() {
  _impl_.reason_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& QBBOStockTradingAction::reason() const {
  // @@protoc_insertion_point(field_get:data.QBBOStockTradingAction.reason)
  return _internal_reason();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void QBBOStockTradingAction::set_reason(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.reason_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:data.QBBOStockTradingAction.reason)
}
inline std::string* QBBOStockTradingAction::mutable_reason() {
  std::string* _s = _internal_mutable_reason();
  // @@protoc_insertion_point(field_mutable:data.QBBOStockTradingAction.reason)
  return _s;
}
inline const std::string& QBBOStockTradingAction::_internal_reason() const {
  return _impl_.reason_.Get();
}
inline void QBBOStockTradingAction::_internal_set_reason(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.reason_.Set(value, GetArenaForAllocation());
}
inline std::string* QBBOStockTradingAction::_internal_mutable_reason() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.reason_.Mutable(GetArenaForAllocation());
}
inline std::string* QBBOStockTradingAction::release_reason() {
  // @@protoc_insertion_point(field_release:data.QBBOStockTradingAction.reason)
  if (!_internal_has_reason()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.reason_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.reason_.IsDefault()) {
    _impl_.reason_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void QBBOStockTradingAction::set_allocated_reason(std::string* reason) {
  if (reason != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.reason_.SetAllocated(reason, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.reason_.IsDefault()) {
    _impl_.reason_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:data.QBBOStockTradingAction.reason)
}

// -------------------------------------------------------------------

// QBBOSystemEventMessage

// optional .data.EventCode eventCode = 1;
inline bool QBBOSystemEventMessage::_internal_has_eventcode() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool QBBOSystemEventMessage::has_eventcode() const {
  return _internal_has_eventcode();
}
inline void QBBOSystemEventMessage::clear_eventcode() {
  _impl_.eventcode_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::data::EventCode QBBOSystemEventMessage::_internal_eventcode() const {
  return static_cast< ::data::EventCode >(_impl_.eventcode_);
}
inline ::data::EventCode QBBOSystemEventMessage::eventcode() const {
  // @@protoc_insertion_point(field_get:data.QBBOSystemEventMessage.eventCode)
  return _internal_eventcode();
}
inline void QBBOSystemEventMessage::_internal_set_eventcode(::data::EventCode value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.eventcode_ = value;
}
inline void QBBOSystemEventMessage::set_eventcode(::data::EventCode value) {
  _internal_set_eventcode(value);
  // @@protoc_insertion_point(field_set:data.QBBOSystemEventMessage.eventCode)
}

// -------------------------------------------------------------------

// AddOddLotOrder

// optional int64 securityCode = 1;
inline bool AddOddLotOrder::_internal_has_securitycode() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AddOddLotOrder::has_securitycode() const {
  return _internal_has_securitycode();
}
inline void AddOddLotOrder::clear_securitycode() {
  _impl_.securitycode_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int64_t AddOddLotOrder::_internal_securitycode() const {
  return _impl_.securitycode_;
}
inline int64_t AddOddLotOrder::securitycode() const {
  // @@protoc_insertion_point(field_get:data.AddOddLotOrder.securityCode)
  return _internal_securitycode();
}
inline void AddOddLotOrder::_internal_set_securitycode(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.securitycode_ = value;
}
inline void AddOddLotOrder::set_securitycode(int64_t value) {
  _internal_set_securitycode(value);
  // @@protoc_insertion_point(field_set:data.AddOddLotOrder.securityCode)
}

// optional int64 orderId = 2;
inline bool AddOddLotOrder::_internal_has_orderid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool AddOddLotOrder::has_orderid() const {
  return _internal_has_orderid();
}
inline void AddOddLotOrder::clear_orderid() {
  _impl_.orderid_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int64_t AddOddLotOrder::_internal_orderid() const {
  return _impl_.orderid_;
}
inline int64_t AddOddLotOrder::orderid() const {
  // @@protoc_insertion_point(field_get:data.AddOddLotOrder.orderId)
  return _internal_orderid();
}
inline void AddOddLotOrder::_internal_set_orderid(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.orderid_ = value;
}
inline void AddOddLotOrder::set_orderid(int64_t value) {
  _internal_set_orderid(value);
  // @@protoc_insertion_point(field_set:data.AddOddLotOrder.orderId)
}

// optional double price = 3;
inline bool AddOddLotOrder::_internal_has_price() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool AddOddLotOrder::has_price() const {
  return _internal_has_price();
}
inline void AddOddLotOrder::clear_price() {
  _impl_.price_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline double AddOddLotOrder::_internal_price() const {
  return _impl_.price_;
}
inline double AddOddLotOrder::price() const {
  // @@protoc_insertion_point(field_get:data.AddOddLotOrder.price)
  return _internal_price();
}
inline void AddOddLotOrder::_internal_set_price(double value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.price_ = value;
}
inline void AddOddLotOrder::set_price(double value) {
  _internal_set_price(value);
  // @@protoc_insertion_point(field_set:data.AddOddLotOrder.price)
}

// optional int64 quantity = 4;
inline bool AddOddLotOrder::_internal_has_quantity() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool AddOddLotOrder::has_quantity() const {
  return _internal_has_quantity();
}
inline void AddOddLotOrder::clear_quantity() {
  _impl_.quantity_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline int64_t AddOddLotOrder::_internal_quantity() const {
  return _impl_.quantity_;
}
inline int64_t AddOddLotOrder::quantity() const {
  // @@protoc_insertion_point(field_get:data.AddOddLotOrder.quantity)
  return _internal_quantity();
}
inline void AddOddLotOrder::_internal_set_quantity(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.quantity_ = value;
}
inline void AddOddLotOrder::set_quantity(int64_t value) {
  _internal_set_quantity(value);
  // @@protoc_insertion_point(field_set:data.AddOddLotOrder.quantity)
}

// optional int32 brokerID = 5;
inline bool AddOddLotOrder::_internal_has_brokerid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool AddOddLotOrder::has_brokerid() const {
  return _internal_has_brokerid();
}
inline void AddOddLotOrder::clear_brokerid() {
  _impl_.brokerid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline int32_t AddOddLotOrder::_internal_brokerid() const {
  return _impl_.brokerid_;
}
inline int32_t AddOddLotOrder::brokerid() const {
  // @@protoc_insertion_point(field_get:data.AddOddLotOrder.brokerID)
  return _internal_brokerid();
}
inline void AddOddLotOrder::_internal_set_brokerid(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.brokerid_ = value;
}
inline void AddOddLotOrder::set_brokerid(int32_t value) {
  _internal_set_brokerid(value);
  // @@protoc_insertion_point(field_set:data.AddOddLotOrder.brokerID)
}

// optional .data.Side side = 6;
inline bool AddOddLotOrder::_internal_has_side() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool AddOddLotOrder::has_side() const {
  return _internal_has_side();
}
inline void AddOddLotOrder::clear_side() {
  _impl_.side_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::data::Side AddOddLotOrder::_internal_side() const {
  return static_cast< ::data::Side >(_impl_.side_);
}
inline ::data::Side AddOddLotOrder::side() const {
  // @@protoc_insertion_point(field_get:data.AddOddLotOrder.side)
  return _internal_side();
}
inline void AddOddLotOrder::_internal_set_side(::data::Side value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.side_ = value;
}
inline void AddOddLotOrder::set_side(::data::Side value) {
  _internal_set_side(value);
  // @@protoc_insertion_point(field_set:data.AddOddLotOrder.side)
}

// -------------------------------------------------------------------

// AggregateOrderBookUpdate

// optional int64 securityCode = 1;
inline bool AggregateOrderBookUpdate::_internal_has_securitycode() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AggregateOrderBookUpdate::has_securitycode() const {
  return _internal_has_securitycode();
}
inline void AggregateOrderBookUpdate::clear_securitycode() {
  _impl_.securitycode_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int64_t AggregateOrderBookUpdate::_internal_securitycode() const {
  return _impl_.securitycode_;
}
inline int64_t AggregateOrderBookUpdate::securitycode() const {
  // @@protoc_insertion_point(field_get:data.AggregateOrderBookUpdate.securityCode)
  return _internal_securitycode();
}
inline void AggregateOrderBookUpdate::_internal_set_securitycode(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.securitycode_ = value;
}
inline void AggregateOrderBookUpdate::set_securitycode(int64_t value) {
  _internal_set_securitycode(value);
  // @@protoc_insertion_point(field_set:data.AggregateOrderBookUpdate.securityCode)
}

// repeated .data.NoEntry noEntries = 2;
inline int AggregateOrderBookUpdate::_internal_noentries_size() const {
  return _impl_.noentries_.size();
}
inline int AggregateOrderBookUpdate::noentries_size() const {
  return _internal_noentries_size();
}
inline void AggregateOrderBookUpdate::clear_noentries() {
  _impl_.noentries_.Clear();
}
inline ::data::NoEntry* AggregateOrderBookUpdate::mutable_noentries(int index) {
  // @@protoc_insertion_point(field_mutable:data.AggregateOrderBookUpdate.noEntries)
  return _impl_.noentries_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::data::NoEntry >*
AggregateOrderBookUpdate::mutable_noentries() {
  // @@protoc_insertion_point(field_mutable_list:data.AggregateOrderBookUpdate.noEntries)
  return &_impl_.noentries_;
}
inline const ::data::NoEntry& AggregateOrderBookUpdate::_internal_noentries(int index) const {
  return _impl_.noentries_.Get(index);
}
inline const ::data::NoEntry& AggregateOrderBookUpdate::noentries(int index) const {
  // @@protoc_insertion_point(field_get:data.AggregateOrderBookUpdate.noEntries)
  return _internal_noentries(index);
}
inline ::data::NoEntry* AggregateOrderBookUpdate::_internal_add_noentries() {
  return _impl_.noentries_.Add();
}
inline ::data::NoEntry* AggregateOrderBookUpdate::add_noentries() {
  ::data::NoEntry* _add = _internal_add_noentries();
  // @@protoc_insertion_point(field_add:data.AggregateOrderBookUpdate.noEntries)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::data::NoEntry >&
AggregateOrderBookUpdate::noentries() const {
  // @@protoc_insertion_point(field_list:data.AggregateOrderBookUpdate.noEntries)
  return _impl_.noentries_;
}

// -------------------------------------------------------------------

// BQMoreItem

// optional int32 item = 1;
inline bool BQMoreItem::_internal_has_item() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool BQMoreItem::has_item() const {
  return _internal_has_item();
}
inline void BQMoreItem::clear_item() {
  _impl_.item_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int32_t BQMoreItem::_internal_item() const {
  return _impl_.item_;
}
inline int32_t BQMoreItem::item() const {
  // @@protoc_insertion_point(field_get:data.BQMoreItem.item)
  return _internal_item();
}
inline void BQMoreItem::_internal_set_item(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.item_ = value;
}
inline void BQMoreItem::set_item(int32_t value) {
  _internal_set_item(value);
  // @@protoc_insertion_point(field_set:data.BQMoreItem.item)
}

// optional .data.IndicatesType type = 2;
inline bool BQMoreItem::_internal_has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool BQMoreItem::has_type() const {
  return _internal_has_type();
}
inline void BQMoreItem::clear_type() {
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::data::IndicatesType BQMoreItem::_internal_type() const {
  return static_cast< ::data::IndicatesType >(_impl_.type_);
}
inline ::data::IndicatesType BQMoreItem::type() const {
  // @@protoc_insertion_point(field_get:data.BQMoreItem.type)
  return _internal_type();
}
inline void BQMoreItem::_internal_set_type(::data::IndicatesType value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.type_ = value;
}
inline void BQMoreItem::set_type(::data::IndicatesType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:data.BQMoreItem.type)
}

// -------------------------------------------------------------------

// BrokerQueue

// optional int64 securityCode = 1;
inline bool BrokerQueue::_internal_has_securitycode() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool BrokerQueue::has_securitycode() const {
  return _internal_has_securitycode();
}
inline void BrokerQueue::clear_securitycode() {
  _impl_.securitycode_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int64_t BrokerQueue::_internal_securitycode() const {
  return _impl_.securitycode_;
}
inline int64_t BrokerQueue::securitycode() const {
  // @@protoc_insertion_point(field_get:data.BrokerQueue.securityCode)
  return _internal_securitycode();
}
inline void BrokerQueue::_internal_set_securitycode(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.securitycode_ = value;
}
inline void BrokerQueue::set_securitycode(int64_t value) {
  _internal_set_securitycode(value);
  // @@protoc_insertion_point(field_set:data.BrokerQueue.securityCode)
}

// optional int32 itemCount = 2;
inline bool BrokerQueue::_internal_has_itemcount() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool BrokerQueue::has_itemcount() const {
  return _internal_has_itemcount();
}
inline void BrokerQueue::clear_itemcount() {
  _impl_.itemcount_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t BrokerQueue::_internal_itemcount() const {
  return _impl_.itemcount_;
}
inline int32_t BrokerQueue::itemcount() const {
  // @@protoc_insertion_point(field_get:data.BrokerQueue.itemCount)
  return _internal_itemcount();
}
inline void BrokerQueue::_internal_set_itemcount(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.itemcount_ = value;
}
inline void BrokerQueue::set_itemcount(int32_t value) {
  _internal_set_itemcount(value);
  // @@protoc_insertion_point(field_set:data.BrokerQueue.itemCount)
}

// optional .data.BrokerSide side = 3;
inline bool BrokerQueue::_internal_has_side() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool BrokerQueue::has_side() const {
  return _internal_has_side();
}
inline void BrokerQueue::clear_side() {
  _impl_.side_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::data::BrokerSide BrokerQueue::_internal_side() const {
  return static_cast< ::data::BrokerSide >(_impl_.side_);
}
inline ::data::BrokerSide BrokerQueue::side() const {
  // @@protoc_insertion_point(field_get:data.BrokerQueue.side)
  return _internal_side();
}
inline void BrokerQueue::_internal_set_side(::data::BrokerSide value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.side_ = value;
}
inline void BrokerQueue::set_side(::data::BrokerSide value) {
  _internal_set_side(value);
  // @@protoc_insertion_point(field_set:data.BrokerQueue.side)
}

// optional .data.BQMoreFlag bQMoreFlag = 4;
inline bool BrokerQueue::_internal_has_bqmoreflag() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool BrokerQueue::has_bqmoreflag() const {
  return _internal_has_bqmoreflag();
}
inline void BrokerQueue::clear_bqmoreflag() {
  _impl_.bqmoreflag_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::data::BQMoreFlag BrokerQueue::_internal_bqmoreflag() const {
  return static_cast< ::data::BQMoreFlag >(_impl_.bqmoreflag_);
}
inline ::data::BQMoreFlag BrokerQueue::bqmoreflag() const {
  // @@protoc_insertion_point(field_get:data.BrokerQueue.bQMoreFlag)
  return _internal_bqmoreflag();
}
inline void BrokerQueue::_internal_set_bqmoreflag(::data::BQMoreFlag value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.bqmoreflag_ = value;
}
inline void BrokerQueue::set_bqmoreflag(::data::BQMoreFlag value) {
  _internal_set_bqmoreflag(value);
  // @@protoc_insertion_point(field_set:data.BrokerQueue.bQMoreFlag)
}

// repeated .data.BQMoreItem items = 5;
inline int BrokerQueue::_internal_items_size() const {
  return _impl_.items_.size();
}
inline int BrokerQueue::items_size() const {
  return _internal_items_size();
}
inline void BrokerQueue::clear_items() {
  _impl_.items_.Clear();
}
inline ::data::BQMoreItem* BrokerQueue::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:data.BrokerQueue.items)
  return _impl_.items_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::data::BQMoreItem >*
BrokerQueue::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:data.BrokerQueue.items)
  return &_impl_.items_;
}
inline const ::data::BQMoreItem& BrokerQueue::_internal_items(int index) const {
  return _impl_.items_.Get(index);
}
inline const ::data::BQMoreItem& BrokerQueue::items(int index) const {
  // @@protoc_insertion_point(field_get:data.BrokerQueue.items)
  return _internal_items(index);
}
inline ::data::BQMoreItem* BrokerQueue::_internal_add_items() {
  return _impl_.items_.Add();
}
inline ::data::BQMoreItem* BrokerQueue::add_items() {
  ::data::BQMoreItem* _add = _internal_add_items();
  // @@protoc_insertion_point(field_add:data.BrokerQueue.items)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::data::BQMoreItem >&
BrokerQueue::items() const {
  // @@protoc_insertion_point(field_list:data.BrokerQueue.items)
  return _impl_.items_;
}

// -------------------------------------------------------------------

// ClosingPrice

// optional int64 securityCode = 1;
inline bool ClosingPrice::_internal_has_securitycode() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ClosingPrice::has_securitycode() const {
  return _internal_has_securitycode();
}
inline void ClosingPrice::clear_securitycode() {
  _impl_.securitycode_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int64_t ClosingPrice::_internal_securitycode() const {
  return _impl_.securitycode_;
}
inline int64_t ClosingPrice::securitycode() const {
  // @@protoc_insertion_point(field_get:data.ClosingPrice.securityCode)
  return _internal_securitycode();
}
inline void ClosingPrice::_internal_set_securitycode(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.securitycode_ = value;
}
inline void ClosingPrice::set_securitycode(int64_t value) {
  _internal_set_securitycode(value);
  // @@protoc_insertion_point(field_set:data.ClosingPrice.securityCode)
}

// optional double closingPrice = 2;
inline bool ClosingPrice::_internal_has_closingprice() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ClosingPrice::has_closingprice() const {
  return _internal_has_closingprice();
}
inline void ClosingPrice::clear_closingprice() {
  _impl_.closingprice_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline double ClosingPrice::_internal_closingprice() const {
  return _impl_.closingprice_;
}
inline double ClosingPrice::closingprice() const {
  // @@protoc_insertion_point(field_get:data.ClosingPrice.closingPrice)
  return _internal_closingprice();
}
inline void ClosingPrice::_internal_set_closingprice(double value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.closingprice_ = value;
}
inline void ClosingPrice::set_closingprice(double value) {
  _internal_set_closingprice(value);
  // @@protoc_insertion_point(field_set:data.ClosingPrice.closingPrice)
}

// optional int64 numberOfTrades = 3;
inline bool ClosingPrice::_internal_has_numberoftrades() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ClosingPrice::has_numberoftrades() const {
  return _internal_has_numberoftrades();
}
inline void ClosingPrice::clear_numberoftrades() {
  _impl_.numberoftrades_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int64_t ClosingPrice::_internal_numberoftrades() const {
  return _impl_.numberoftrades_;
}
inline int64_t ClosingPrice::numberoftrades() const {
  // @@protoc_insertion_point(field_get:data.ClosingPrice.numberOfTrades)
  return _internal_numberoftrades();
}
inline void ClosingPrice::_internal_set_numberoftrades(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.numberoftrades_ = value;
}
inline void ClosingPrice::set_numberoftrades(int64_t value) {
  _internal_set_numberoftrades(value);
  // @@protoc_insertion_point(field_set:data.ClosingPrice.numberOfTrades)
}

// -------------------------------------------------------------------

// CurrencyRate

// optional .data.CurrencyType currencyCode = 1;
inline bool CurrencyRate::_internal_has_currencycode() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CurrencyRate::has_currencycode() const {
  return _internal_has_currencycode();
}
inline void CurrencyRate::clear_currencycode() {
  _impl_.currencycode_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::data::CurrencyType CurrencyRate::_internal_currencycode() const {
  return static_cast< ::data::CurrencyType >(_impl_.currencycode_);
}
inline ::data::CurrencyType CurrencyRate::currencycode() const {
  // @@protoc_insertion_point(field_get:data.CurrencyRate.currencyCode)
  return _internal_currencycode();
}
inline void CurrencyRate::_internal_set_currencycode(::data::CurrencyType value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.currencycode_ = value;
}
inline void CurrencyRate::set_currencycode(::data::CurrencyType value) {
  _internal_set_currencycode(value);
  // @@protoc_insertion_point(field_set:data.CurrencyRate.currencyCode)
}

// optional int32 currencyFactor = 2;
inline bool CurrencyRate::_internal_has_currencyfactor() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CurrencyRate::has_currencyfactor() const {
  return _internal_has_currencyfactor();
}
inline void CurrencyRate::clear_currencyfactor() {
  _impl_.currencyfactor_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t CurrencyRate::_internal_currencyfactor() const {
  return _impl_.currencyfactor_;
}
inline int32_t CurrencyRate::currencyfactor() const {
  // @@protoc_insertion_point(field_get:data.CurrencyRate.currencyFactor)
  return _internal_currencyfactor();
}
inline void CurrencyRate::_internal_set_currencyfactor(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.currencyfactor_ = value;
}
inline void CurrencyRate::set_currencyfactor(int32_t value) {
  _internal_set_currencyfactor(value);
  // @@protoc_insertion_point(field_set:data.CurrencyRate.currencyFactor)
}

// optional double currencyRate = 3;
inline bool CurrencyRate::_internal_has_currencyrate() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CurrencyRate::has_currencyrate() const {
  return _internal_has_currencyrate();
}
inline void CurrencyRate::clear_currencyrate() {
  _impl_.currencyrate_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline double CurrencyRate::_internal_currencyrate() const {
  return _impl_.currencyrate_;
}
inline double CurrencyRate::currencyrate() const {
  // @@protoc_insertion_point(field_get:data.CurrencyRate.currencyRate)
  return _internal_currencyrate();
}
inline void CurrencyRate::_internal_set_currencyrate(double value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.currencyrate_ = value;
}
inline void CurrencyRate::set_currencyrate(double value) {
  _internal_set_currencyrate(value);
  // @@protoc_insertion_point(field_set:data.CurrencyRate.currencyRate)
}

// -------------------------------------------------------------------

// DeleteOddLotOrder

// optional int64 securityCode = 1;
inline bool DeleteOddLotOrder::_internal_has_securitycode() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DeleteOddLotOrder::has_securitycode() const {
  return _internal_has_securitycode();
}
inline void DeleteOddLotOrder::clear_securitycode() {
  _impl_.securitycode_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int64_t DeleteOddLotOrder::_internal_securitycode() const {
  return _impl_.securitycode_;
}
inline int64_t DeleteOddLotOrder::securitycode() const {
  // @@protoc_insertion_point(field_get:data.DeleteOddLotOrder.securityCode)
  return _internal_securitycode();
}
inline void DeleteOddLotOrder::_internal_set_securitycode(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.securitycode_ = value;
}
inline void DeleteOddLotOrder::set_securitycode(int64_t value) {
  _internal_set_securitycode(value);
  // @@protoc_insertion_point(field_set:data.DeleteOddLotOrder.securityCode)
}

// optional int64 orderId = 2;
inline bool DeleteOddLotOrder::_internal_has_orderid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool DeleteOddLotOrder::has_orderid() const {
  return _internal_has_orderid();
}
inline void DeleteOddLotOrder::clear_orderid() {
  _impl_.orderid_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int64_t DeleteOddLotOrder::_internal_orderid() const {
  return _impl_.orderid_;
}
inline int64_t DeleteOddLotOrder::orderid() const {
  // @@protoc_insertion_point(field_get:data.DeleteOddLotOrder.orderId)
  return _internal_orderid();
}
inline void DeleteOddLotOrder::_internal_set_orderid(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.orderid_ = value;
}
inline void DeleteOddLotOrder::set_orderid(int64_t value) {
  _internal_set_orderid(value);
  // @@protoc_insertion_point(field_set:data.DeleteOddLotOrder.orderId)
}

// optional int32 brokerID = 3;
inline bool DeleteOddLotOrder::_internal_has_brokerid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool DeleteOddLotOrder::has_brokerid() const {
  return _internal_has_brokerid();
}
inline void DeleteOddLotOrder::clear_brokerid() {
  _impl_.brokerid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int32_t DeleteOddLotOrder::_internal_brokerid() const {
  return _impl_.brokerid_;
}
inline int32_t DeleteOddLotOrder::brokerid() const {
  // @@protoc_insertion_point(field_get:data.DeleteOddLotOrder.brokerID)
  return _internal_brokerid();
}
inline void DeleteOddLotOrder::_internal_set_brokerid(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.brokerid_ = value;
}
inline void DeleteOddLotOrder::set_brokerid(int32_t value) {
  _internal_set_brokerid(value);
  // @@protoc_insertion_point(field_set:data.DeleteOddLotOrder.brokerID)
}

// optional .data.Side side = 4;
inline bool DeleteOddLotOrder::_internal_has_side() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool DeleteOddLotOrder::has_side() const {
  return _internal_has_side();
}
inline void DeleteOddLotOrder::clear_side() {
  _impl_.side_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::data::Side DeleteOddLotOrder::_internal_side() const {
  return static_cast< ::data::Side >(_impl_.side_);
}
inline ::data::Side DeleteOddLotOrder::side() const {
  // @@protoc_insertion_point(field_get:data.DeleteOddLotOrder.side)
  return _internal_side();
}
inline void DeleteOddLotOrder::_internal_set_side(::data::Side value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.side_ = value;
}
inline void DeleteOddLotOrder::set_side(::data::Side value) {
  _internal_set_side(value);
  // @@protoc_insertion_point(field_set:data.DeleteOddLotOrder.side)
}

// -------------------------------------------------------------------

// IndexData

// optional string indexCode = 1;
inline bool IndexData::_internal_has_indexcode() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool IndexData::has_indexcode() const {
  return _internal_has_indexcode();
}
inline void IndexData::clear_indexcode() {
  _impl_.indexcode_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& IndexData::indexcode() const {
  // @@protoc_insertion_point(field_get:data.IndexData.indexCode)
  return _internal_indexcode();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void IndexData::set_indexcode(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.indexcode_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:data.IndexData.indexCode)
}
inline std::string* IndexData::mutable_indexcode() {
  std::string* _s = _internal_mutable_indexcode();
  // @@protoc_insertion_point(field_mutable:data.IndexData.indexCode)
  return _s;
}
inline const std::string& IndexData::_internal_indexcode() const {
  return _impl_.indexcode_.Get();
}
inline void IndexData::_internal_set_indexcode(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.indexcode_.Set(value, GetArenaForAllocation());
}
inline std::string* IndexData::_internal_mutable_indexcode() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.indexcode_.Mutable(GetArenaForAllocation());
}
inline std::string* IndexData::release_indexcode() {
  // @@protoc_insertion_point(field_release:data.IndexData.indexCode)
  if (!_internal_has_indexcode()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.indexcode_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.indexcode_.IsDefault()) {
    _impl_.indexcode_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void IndexData::set_allocated_indexcode(std::string* indexcode) {
  if (indexcode != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.indexcode_.SetAllocated(indexcode, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.indexcode_.IsDefault()) {
    _impl_.indexcode_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:data.IndexData.indexCode)
}

// optional .data.IndexStatus indexStatus = 2;
inline bool IndexData::_internal_has_indexstatus() const {
  bool value = (_impl_._has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline bool IndexData::has_indexstatus() const {
  return _internal_has_indexstatus();
}
inline void IndexData::clear_indexstatus() {
  _impl_.indexstatus_ = 0;
  _impl_._has_bits_[0] &= ~0x00004000u;
}
inline ::data::IndexStatus IndexData::_internal_indexstatus() const {
  return static_cast< ::data::IndexStatus >(_impl_.indexstatus_);
}
inline ::data::IndexStatus IndexData::indexstatus() const {
  // @@protoc_insertion_point(field_get:data.IndexData.indexStatus)
  return _internal_indexstatus();
}
inline void IndexData::_internal_set_indexstatus(::data::IndexStatus value) {
  _impl_._has_bits_[0] |= 0x00004000u;
  _impl_.indexstatus_ = value;
}
inline void IndexData::set_indexstatus(::data::IndexStatus value) {
  _internal_set_indexstatus(value);
  // @@protoc_insertion_point(field_set:data.IndexData.indexStatus)
}

// optional int64 indexTime = 3;
inline bool IndexData::_internal_has_indextime() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool IndexData::has_indextime() const {
  return _internal_has_indextime();
}
inline void IndexData::clear_indextime() {
  _impl_.indextime_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int64_t IndexData::_internal_indextime() const {
  return _impl_.indextime_;
}
inline int64_t IndexData::indextime() const {
  // @@protoc_insertion_point(field_get:data.IndexData.indexTime)
  return _internal_indextime();
}
inline void IndexData::_internal_set_indextime(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.indextime_ = value;
}
inline void IndexData::set_indextime(int64_t value) {
  _internal_set_indextime(value);
  // @@protoc_insertion_point(field_set:data.IndexData.indexTime)
}

// optional double indexValue = 4;
inline bool IndexData::_internal_has_indexvalue() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool IndexData::has_indexvalue() const {
  return _internal_has_indexvalue();
}
inline void IndexData::clear_indexvalue() {
  _impl_.indexvalue_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline double IndexData::_internal_indexvalue() const {
  return _impl_.indexvalue_;
}
inline double IndexData::indexvalue() const {
  // @@protoc_insertion_point(field_get:data.IndexData.indexValue)
  return _internal_indexvalue();
}
inline void IndexData::_internal_set_indexvalue(double value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.indexvalue_ = value;
}
inline void IndexData::set_indexvalue(double value) {
  _internal_set_indexvalue(value);
  // @@protoc_insertion_point(field_set:data.IndexData.indexValue)
}

// optional double netChgPrevDay = 5;
inline bool IndexData::_internal_has_netchgprevday() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool IndexData::has_netchgprevday() const {
  return _internal_has_netchgprevday();
}
inline void IndexData::clear_netchgprevday() {
  _impl_.netchgprevday_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline double IndexData::_internal_netchgprevday() const {
  return _impl_.netchgprevday_;
}
inline double IndexData::netchgprevday() const {
  // @@protoc_insertion_point(field_get:data.IndexData.netChgPrevDay)
  return _internal_netchgprevday();
}
inline void IndexData::_internal_set_netchgprevday(double value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.netchgprevday_ = value;
}
inline void IndexData::set_netchgprevday(double value) {
  _internal_set_netchgprevday(value);
  // @@protoc_insertion_point(field_set:data.IndexData.netChgPrevDay)
}

// optional double highValue = 6;
inline bool IndexData::_internal_has_highvalue() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool IndexData::has_highvalue() const {
  return _internal_has_highvalue();
}
inline void IndexData::clear_highvalue() {
  _impl_.highvalue_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline double IndexData::_internal_highvalue() const {
  return _impl_.highvalue_;
}
inline double IndexData::highvalue() const {
  // @@protoc_insertion_point(field_get:data.IndexData.highValue)
  return _internal_highvalue();
}
inline void IndexData::_internal_set_highvalue(double value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.highvalue_ = value;
}
inline void IndexData::set_highvalue(double value) {
  _internal_set_highvalue(value);
  // @@protoc_insertion_point(field_set:data.IndexData.highValue)
}

// optional double lowValue = 7;
inline bool IndexData::_internal_has_lowvalue() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool IndexData::has_lowvalue() const {
  return _internal_has_lowvalue();
}
inline void IndexData::clear_lowvalue() {
  _impl_.lowvalue_ = 0;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline double IndexData::_internal_lowvalue() const {
  return _impl_.lowvalue_;
}
inline double IndexData::lowvalue() const {
  // @@protoc_insertion_point(field_get:data.IndexData.lowValue)
  return _internal_lowvalue();
}
inline void IndexData::_internal_set_lowvalue(double value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.lowvalue_ = value;
}
inline void IndexData::set_lowvalue(double value) {
  _internal_set_lowvalue(value);
  // @@protoc_insertion_point(field_set:data.IndexData.lowValue)
}

// optional double eASValue = 8;
inline bool IndexData::_internal_has_easvalue() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool IndexData::has_easvalue() const {
  return _internal_has_easvalue();
}
inline void IndexData::clear_easvalue() {
  _impl_.easvalue_ = 0;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline double IndexData::_internal_easvalue() const {
  return _impl_.easvalue_;
}
inline double IndexData::easvalue() const {
  // @@protoc_insertion_point(field_get:data.IndexData.eASValue)
  return _internal_easvalue();
}
inline void IndexData::_internal_set_easvalue(double value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.easvalue_ = value;
}
inline void IndexData::set_easvalue(double value) {
  _internal_set_easvalue(value);
  // @@protoc_insertion_point(field_set:data.IndexData.eASValue)
}

// optional double indexTurnover = 9;
inline bool IndexData::_internal_has_indexturnover() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool IndexData::has_indexturnover() const {
  return _internal_has_indexturnover();
}
inline void IndexData::clear_indexturnover() {
  _impl_.indexturnover_ = 0;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline double IndexData::_internal_indexturnover() const {
  return _impl_.indexturnover_;
}
inline double IndexData::indexturnover() const {
  // @@protoc_insertion_point(field_get:data.IndexData.indexTurnover)
  return _internal_indexturnover();
}
inline void IndexData::_internal_set_indexturnover(double value) {
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.indexturnover_ = value;
}
inline void IndexData::set_indexturnover(double value) {
  _internal_set_indexturnover(value);
  // @@protoc_insertion_point(field_set:data.IndexData.indexTurnover)
}

// optional double openingValue = 10;
inline bool IndexData::_internal_has_openingvalue() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool IndexData::has_openingvalue() const {
  return _internal_has_openingvalue();
}
inline void IndexData::clear_openingvalue() {
  _impl_.openingvalue_ = 0;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline double IndexData::_internal_openingvalue() const {
  return _impl_.openingvalue_;
}
inline double IndexData::openingvalue() const {
  // @@protoc_insertion_point(field_get:data.IndexData.openingValue)
  return _internal_openingvalue();
}
inline void IndexData::_internal_set_openingvalue(double value) {
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.openingvalue_ = value;
}
inline void IndexData::set_openingvalue(double value) {
  _internal_set_openingvalue(value);
  // @@protoc_insertion_point(field_set:data.IndexData.openingValue)
}

// optional double closingValue = 11;
inline bool IndexData::_internal_has_closingvalue() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool IndexData::has_closingvalue() const {
  return _internal_has_closingvalue();
}
inline void IndexData::clear_closingvalue() {
  _impl_.closingvalue_ = 0;
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline double IndexData::_internal_closingvalue() const {
  return _impl_.closingvalue_;
}
inline double IndexData::closingvalue() const {
  // @@protoc_insertion_point(field_get:data.IndexData.closingValue)
  return _internal_closingvalue();
}
inline void IndexData::_internal_set_closingvalue(double value) {
  _impl_._has_bits_[0] |= 0x00000400u;
  _impl_.closingvalue_ = value;
}
inline void IndexData::set_closingvalue(double value) {
  _internal_set_closingvalue(value);
  // @@protoc_insertion_point(field_set:data.IndexData.closingValue)
}

// optional double previousSesClose = 12;
inline bool IndexData::_internal_has_previoussesclose() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool IndexData::has_previoussesclose() const {
  return _internal_has_previoussesclose();
}
inline void IndexData::clear_previoussesclose() {
  _impl_.previoussesclose_ = 0;
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline double IndexData::_internal_previoussesclose() const {
  return _impl_.previoussesclose_;
}
inline double IndexData::previoussesclose() const {
  // @@protoc_insertion_point(field_get:data.IndexData.previousSesClose)
  return _internal_previoussesclose();
}
inline void IndexData::_internal_set_previoussesclose(double value) {
  _impl_._has_bits_[0] |= 0x00000800u;
  _impl_.previoussesclose_ = value;
}
inline void IndexData::set_previoussesclose(double value) {
  _internal_set_previoussesclose(value);
  // @@protoc_insertion_point(field_set:data.IndexData.previousSesClose)
}

// optional int64 indexVolume = 13;
inline bool IndexData::_internal_has_indexvolume() const {
  bool value = (_impl_._has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool IndexData::has_indexvolume() const {
  return _internal_has_indexvolume();
}
inline void IndexData::clear_indexvolume() {
  _impl_.indexvolume_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00001000u;
}
inline int64_t IndexData::_internal_indexvolume() const {
  return _impl_.indexvolume_;
}
inline int64_t IndexData::indexvolume() const {
  // @@protoc_insertion_point(field_get:data.IndexData.indexVolume)
  return _internal_indexvolume();
}
inline void IndexData::_internal_set_indexvolume(int64_t value) {
  _impl_._has_bits_[0] |= 0x00001000u;
  _impl_.indexvolume_ = value;
}
inline void IndexData::set_indexvolume(int64_t value) {
  _internal_set_indexvolume(value);
  // @@protoc_insertion_point(field_set:data.IndexData.indexVolume)
}

// optional double netChgPrevDayPct = 14;
inline bool IndexData::_internal_has_netchgprevdaypct() const {
  bool value = (_impl_._has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool IndexData::has_netchgprevdaypct() const {
  return _internal_has_netchgprevdaypct();
}
inline void IndexData::clear_netchgprevdaypct() {
  _impl_.netchgprevdaypct_ = 0;
  _impl_._has_bits_[0] &= ~0x00002000u;
}
inline double IndexData::_internal_netchgprevdaypct() const {
  return _impl_.netchgprevdaypct_;
}
inline double IndexData::netchgprevdaypct() const {
  // @@protoc_insertion_point(field_get:data.IndexData.netChgPrevDayPct)
  return _internal_netchgprevdaypct();
}
inline void IndexData::_internal_set_netchgprevdaypct(double value) {
  _impl_._has_bits_[0] |= 0x00002000u;
  _impl_.netchgprevdaypct_ = value;
}
inline void IndexData::set_netchgprevdaypct(double value) {
  _internal_set_netchgprevdaypct(value);
  // @@protoc_insertion_point(field_set:data.IndexData.netChgPrevDayPct)
}

// optional string exception = 15;
inline bool IndexData::_internal_has_exception() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool IndexData::has_exception() const {
  return _internal_has_exception();
}
inline void IndexData::clear_exception() {
  _impl_.exception_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& IndexData::exception() const {
  // @@protoc_insertion_point(field_get:data.IndexData.exception)
  return _internal_exception();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void IndexData::set_exception(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.exception_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:data.IndexData.exception)
}
inline std::string* IndexData::mutable_exception() {
  std::string* _s = _internal_mutable_exception();
  // @@protoc_insertion_point(field_mutable:data.IndexData.exception)
  return _s;
}
inline const std::string& IndexData::_internal_exception() const {
  return _impl_.exception_.Get();
}
inline void IndexData::_internal_set_exception(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.exception_.Set(value, GetArenaForAllocation());
}
inline std::string* IndexData::_internal_mutable_exception() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.exception_.Mutable(GetArenaForAllocation());
}
inline std::string* IndexData::release_exception() {
  // @@protoc_insertion_point(field_release:data.IndexData.exception)
  if (!_internal_has_exception()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.exception_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.exception_.IsDefault()) {
    _impl_.exception_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void IndexData::set_allocated_exception(std::string* exception) {
  if (exception != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.exception_.SetAllocated(exception, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.exception_.IsDefault()) {
    _impl_.exception_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:data.IndexData.exception)
}

// -------------------------------------------------------------------

// IndexDefinition

// optional string indexCode = 1;
inline bool IndexDefinition::_internal_has_indexcode() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool IndexDefinition::has_indexcode() const {
  return _internal_has_indexcode();
}
inline void IndexDefinition::clear_indexcode() {
  _impl_.indexcode_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& IndexDefinition::indexcode() const {
  // @@protoc_insertion_point(field_get:data.IndexDefinition.indexCode)
  return _internal_indexcode();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void IndexDefinition::set_indexcode(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.indexcode_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:data.IndexDefinition.indexCode)
}
inline std::string* IndexDefinition::mutable_indexcode() {
  std::string* _s = _internal_mutable_indexcode();
  // @@protoc_insertion_point(field_mutable:data.IndexDefinition.indexCode)
  return _s;
}
inline const std::string& IndexDefinition::_internal_indexcode() const {
  return _impl_.indexcode_.Get();
}
inline void IndexDefinition::_internal_set_indexcode(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.indexcode_.Set(value, GetArenaForAllocation());
}
inline std::string* IndexDefinition::_internal_mutable_indexcode() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.indexcode_.Mutable(GetArenaForAllocation());
}
inline std::string* IndexDefinition::release_indexcode() {
  // @@protoc_insertion_point(field_release:data.IndexDefinition.indexCode)
  if (!_internal_has_indexcode()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.indexcode_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.indexcode_.IsDefault()) {
    _impl_.indexcode_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void IndexDefinition::set_allocated_indexcode(std::string* indexcode) {
  if (indexcode != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.indexcode_.SetAllocated(indexcode, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.indexcode_.IsDefault()) {
    _impl_.indexcode_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:data.IndexDefinition.indexCode)
}

// optional .data.IndexSource indexSource = 2;
inline bool IndexDefinition::_internal_has_indexsource() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool IndexDefinition::has_indexsource() const {
  return _internal_has_indexsource();
}
inline void IndexDefinition::clear_indexsource() {
  _impl_.indexsource_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::data::IndexSource IndexDefinition::_internal_indexsource() const {
  return static_cast< ::data::IndexSource >(_impl_.indexsource_);
}
inline ::data::IndexSource IndexDefinition::indexsource() const {
  // @@protoc_insertion_point(field_get:data.IndexDefinition.indexSource)
  return _internal_indexsource();
}
inline void IndexDefinition::_internal_set_indexsource(::data::IndexSource value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.indexsource_ = value;
}
inline void IndexDefinition::set_indexsource(::data::IndexSource value) {
  _internal_set_indexsource(value);
  // @@protoc_insertion_point(field_set:data.IndexDefinition.indexSource)
}

// optional .data.CurrencyType currencyCode = 3;
inline bool IndexDefinition::_internal_has_currencycode() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool IndexDefinition::has_currencycode() const {
  return _internal_has_currencycode();
}
inline void IndexDefinition::clear_currencycode() {
  _impl_.currencycode_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::data::CurrencyType IndexDefinition::_internal_currencycode() const {
  return static_cast< ::data::CurrencyType >(_impl_.currencycode_);
}
inline ::data::CurrencyType IndexDefinition::currencycode() const {
  // @@protoc_insertion_point(field_get:data.IndexDefinition.currencyCode)
  return _internal_currencycode();
}
inline void IndexDefinition::_internal_set_currencycode(::data::CurrencyType value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.currencycode_ = value;
}
inline void IndexDefinition::set_currencycode(::data::CurrencyType value) {
  _internal_set_currencycode(value);
  // @@protoc_insertion_point(field_set:data.IndexDefinition.currencyCode)
}

// -------------------------------------------------------------------

// IndicativeEquilibriumPrice

// optional int64 securityCode = 1;
inline bool IndicativeEquilibriumPrice::_internal_has_securitycode() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool IndicativeEquilibriumPrice::has_securitycode() const {
  return _internal_has_securitycode();
}
inline void IndicativeEquilibriumPrice::clear_securitycode() {
  _impl_.securitycode_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int64_t IndicativeEquilibriumPrice::_internal_securitycode() const {
  return _impl_.securitycode_;
}
inline int64_t IndicativeEquilibriumPrice::securitycode() const {
  // @@protoc_insertion_point(field_get:data.IndicativeEquilibriumPrice.securityCode)
  return _internal_securitycode();
}
inline void IndicativeEquilibriumPrice::_internal_set_securitycode(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.securitycode_ = value;
}
inline void IndicativeEquilibriumPrice::set_securitycode(int64_t value) {
  _internal_set_securitycode(value);
  // @@protoc_insertion_point(field_set:data.IndicativeEquilibriumPrice.securityCode)
}

// optional double price = 2;
inline bool IndicativeEquilibriumPrice::_internal_has_price() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool IndicativeEquilibriumPrice::has_price() const {
  return _internal_has_price();
}
inline void IndicativeEquilibriumPrice::clear_price() {
  _impl_.price_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline double IndicativeEquilibriumPrice::_internal_price() const {
  return _impl_.price_;
}
inline double IndicativeEquilibriumPrice::price() const {
  // @@protoc_insertion_point(field_get:data.IndicativeEquilibriumPrice.price)
  return _internal_price();
}
inline void IndicativeEquilibriumPrice::_internal_set_price(double value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.price_ = value;
}
inline void IndicativeEquilibriumPrice::set_price(double value) {
  _internal_set_price(value);
  // @@protoc_insertion_point(field_set:data.IndicativeEquilibriumPrice.price)
}

// optional int64 aggregateQuantity = 3;
inline bool IndicativeEquilibriumPrice::_internal_has_aggregatequantity() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool IndicativeEquilibriumPrice::has_aggregatequantity() const {
  return _internal_has_aggregatequantity();
}
inline void IndicativeEquilibriumPrice::clear_aggregatequantity() {
  _impl_.aggregatequantity_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int64_t IndicativeEquilibriumPrice::_internal_aggregatequantity() const {
  return _impl_.aggregatequantity_;
}
inline int64_t IndicativeEquilibriumPrice::aggregatequantity() const {
  // @@protoc_insertion_point(field_get:data.IndicativeEquilibriumPrice.aggregateQuantity)
  return _internal_aggregatequantity();
}
inline void IndicativeEquilibriumPrice::_internal_set_aggregatequantity(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.aggregatequantity_ = value;
}
inline void IndicativeEquilibriumPrice::set_aggregatequantity(int64_t value) {
  _internal_set_aggregatequantity(value);
  // @@protoc_insertion_point(field_set:data.IndicativeEquilibriumPrice.aggregateQuantity)
}

// -------------------------------------------------------------------

// LiquidityProvider

// optional int64 securityCode = 1;
inline bool LiquidityProvider::_internal_has_securitycode() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool LiquidityProvider::has_securitycode() const {
  return _internal_has_securitycode();
}
inline void LiquidityProvider::clear_securitycode() {
  _impl_.securitycode_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int64_t LiquidityProvider::_internal_securitycode() const {
  return _impl_.securitycode_;
}
inline int64_t LiquidityProvider::securitycode() const {
  // @@protoc_insertion_point(field_get:data.LiquidityProvider.securityCode)
  return _internal_securitycode();
}
inline void LiquidityProvider::_internal_set_securitycode(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.securitycode_ = value;
}
inline void LiquidityProvider::set_securitycode(int64_t value) {
  _internal_set_securitycode(value);
  // @@protoc_insertion_point(field_set:data.LiquidityProvider.securityCode)
}

// repeated .data.NoLiquidityProvider noLiquidityProviders = 2;
inline int LiquidityProvider::_internal_noliquidityproviders_size() const {
  return _impl_.noliquidityproviders_.size();
}
inline int LiquidityProvider::noliquidityproviders_size() const {
  return _internal_noliquidityproviders_size();
}
inline void LiquidityProvider::clear_noliquidityproviders() {
  _impl_.noliquidityproviders_.Clear();
}
inline ::data::NoLiquidityProvider* LiquidityProvider::mutable_noliquidityproviders(int index) {
  // @@protoc_insertion_point(field_mutable:data.LiquidityProvider.noLiquidityProviders)
  return _impl_.noliquidityproviders_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::data::NoLiquidityProvider >*
LiquidityProvider::mutable_noliquidityproviders() {
  // @@protoc_insertion_point(field_mutable_list:data.LiquidityProvider.noLiquidityProviders)
  return &_impl_.noliquidityproviders_;
}
inline const ::data::NoLiquidityProvider& LiquidityProvider::_internal_noliquidityproviders(int index) const {
  return _impl_.noliquidityproviders_.Get(index);
}
inline const ::data::NoLiquidityProvider& LiquidityProvider::noliquidityproviders(int index) const {
  // @@protoc_insertion_point(field_get:data.LiquidityProvider.noLiquidityProviders)
  return _internal_noliquidityproviders(index);
}
inline ::data::NoLiquidityProvider* LiquidityProvider::_internal_add_noliquidityproviders() {
  return _impl_.noliquidityproviders_.Add();
}
inline ::data::NoLiquidityProvider* LiquidityProvider::add_noliquidityproviders() {
  ::data::NoLiquidityProvider* _add = _internal_add_noliquidityproviders();
  // @@protoc_insertion_point(field_add:data.LiquidityProvider.noLiquidityProviders)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::data::NoLiquidityProvider >&
LiquidityProvider::noliquidityproviders() const {
  // @@protoc_insertion_point(field_list:data.LiquidityProvider.noLiquidityProviders)
  return _impl_.noliquidityproviders_;
}

// -------------------------------------------------------------------

// MarketDefinition

// optional .data.MarketCode marketCode = 1;
inline bool MarketDefinition::_internal_has_marketcode() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool MarketDefinition::has_marketcode() const {
  return _internal_has_marketcode();
}
inline void MarketDefinition::clear_marketcode() {
  _impl_.marketcode_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::data::MarketCode MarketDefinition::_internal_marketcode() const {
  return static_cast< ::data::MarketCode >(_impl_.marketcode_);
}
inline ::data::MarketCode MarketDefinition::marketcode() const {
  // @@protoc_insertion_point(field_get:data.MarketDefinition.marketCode)
  return _internal_marketcode();
}
inline void MarketDefinition::_internal_set_marketcode(::data::MarketCode value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.marketcode_ = value;
}
inline void MarketDefinition::set_marketcode(::data::MarketCode value) {
  _internal_set_marketcode(value);
  // @@protoc_insertion_point(field_set:data.MarketDefinition.marketCode)
}

// optional string marketName = 2;
inline bool MarketDefinition::_internal_has_marketname() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MarketDefinition::has_marketname() const {
  return _internal_has_marketname();
}
inline void MarketDefinition::clear_marketname() {
  _impl_.marketname_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& MarketDefinition::marketname() const {
  // @@protoc_insertion_point(field_get:data.MarketDefinition.marketName)
  return _internal_marketname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MarketDefinition::set_marketname(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.marketname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:data.MarketDefinition.marketName)
}
inline std::string* MarketDefinition::mutable_marketname() {
  std::string* _s = _internal_mutable_marketname();
  // @@protoc_insertion_point(field_mutable:data.MarketDefinition.marketName)
  return _s;
}
inline const std::string& MarketDefinition::_internal_marketname() const {
  return _impl_.marketname_.Get();
}
inline void MarketDefinition::_internal_set_marketname(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.marketname_.Set(value, GetArenaForAllocation());
}
inline std::string* MarketDefinition::_internal_mutable_marketname() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.marketname_.Mutable(GetArenaForAllocation());
}
inline std::string* MarketDefinition::release_marketname() {
  // @@protoc_insertion_point(field_release:data.MarketDefinition.marketName)
  if (!_internal_has_marketname()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.marketname_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.marketname_.IsDefault()) {
    _impl_.marketname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MarketDefinition::set_allocated_marketname(std::string* marketname) {
  if (marketname != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.marketname_.SetAllocated(marketname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.marketname_.IsDefault()) {
    _impl_.marketname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:data.MarketDefinition.marketName)
}

// optional .data.CurrencyType currencyCode = 3;
inline bool MarketDefinition::_internal_has_currencycode() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool MarketDefinition::has_currencycode() const {
  return _internal_has_currencycode();
}
inline void MarketDefinition::clear_currencycode() {
  _impl_.currencycode_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::data::CurrencyType MarketDefinition::_internal_currencycode() const {
  return static_cast< ::data::CurrencyType >(_impl_.currencycode_);
}
inline ::data::CurrencyType MarketDefinition::currencycode() const {
  // @@protoc_insertion_point(field_get:data.MarketDefinition.currencyCode)
  return _internal_currencycode();
}
inline void MarketDefinition::_internal_set_currencycode(::data::CurrencyType value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.currencycode_ = value;
}
inline void MarketDefinition::set_currencycode(::data::CurrencyType value) {
  _internal_set_currencycode(value);
  // @@protoc_insertion_point(field_set:data.MarketDefinition.currencyCode)
}

// optional int64 numberOfSecurities = 4;
inline bool MarketDefinition::_internal_has_numberofsecurities() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool MarketDefinition::has_numberofsecurities() const {
  return _internal_has_numberofsecurities();
}
inline void MarketDefinition::clear_numberofsecurities() {
  _impl_.numberofsecurities_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline int64_t MarketDefinition::_internal_numberofsecurities() const {
  return _impl_.numberofsecurities_;
}
inline int64_t MarketDefinition::numberofsecurities() const {
  // @@protoc_insertion_point(field_get:data.MarketDefinition.numberOfSecurities)
  return _internal_numberofsecurities();
}
inline void MarketDefinition::_internal_set_numberofsecurities(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.numberofsecurities_ = value;
}
inline void MarketDefinition::set_numberofsecurities(int64_t value) {
  _internal_set_numberofsecurities(value);
  // @@protoc_insertion_point(field_set:data.MarketDefinition.numberOfSecurities)
}

// -------------------------------------------------------------------

// MarketTurnover

// optional .data.MarketCode marketCode = 1;
inline bool MarketTurnover::_internal_has_marketcode() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MarketTurnover::has_marketcode() const {
  return _internal_has_marketcode();
}
inline void MarketTurnover::clear_marketcode() {
  _impl_.marketcode_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::data::MarketCode MarketTurnover::_internal_marketcode() const {
  return static_cast< ::data::MarketCode >(_impl_.marketcode_);
}
inline ::data::MarketCode MarketTurnover::marketcode() const {
  // @@protoc_insertion_point(field_get:data.MarketTurnover.marketCode)
  return _internal_marketcode();
}
inline void MarketTurnover::_internal_set_marketcode(::data::MarketCode value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.marketcode_ = value;
}
inline void MarketTurnover::set_marketcode(::data::MarketCode value) {
  _internal_set_marketcode(value);
  // @@protoc_insertion_point(field_set:data.MarketTurnover.marketCode)
}

// optional .data.CurrencyType currencyCode = 2;
inline bool MarketTurnover::_internal_has_currencycode() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool MarketTurnover::has_currencycode() const {
  return _internal_has_currencycode();
}
inline void MarketTurnover::clear_currencycode() {
  _impl_.currencycode_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::data::CurrencyType MarketTurnover::_internal_currencycode() const {
  return static_cast< ::data::CurrencyType >(_impl_.currencycode_);
}
inline ::data::CurrencyType MarketTurnover::currencycode() const {
  // @@protoc_insertion_point(field_get:data.MarketTurnover.currencyCode)
  return _internal_currencycode();
}
inline void MarketTurnover::_internal_set_currencycode(::data::CurrencyType value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.currencycode_ = value;
}
inline void MarketTurnover::set_currencycode(::data::CurrencyType value) {
  _internal_set_currencycode(value);
  // @@protoc_insertion_point(field_set:data.MarketTurnover.currencyCode)
}

// optional double turnover = 3;
inline bool MarketTurnover::_internal_has_turnover() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool MarketTurnover::has_turnover() const {
  return _internal_has_turnover();
}
inline void MarketTurnover::clear_turnover() {
  _impl_.turnover_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline double MarketTurnover::_internal_turnover() const {
  return _impl_.turnover_;
}
inline double MarketTurnover::turnover() const {
  // @@protoc_insertion_point(field_get:data.MarketTurnover.turnover)
  return _internal_turnover();
}
inline void MarketTurnover::_internal_set_turnover(double value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.turnover_ = value;
}
inline void MarketTurnover::set_turnover(double value) {
  _internal_set_turnover(value);
  // @@protoc_insertion_point(field_set:data.MarketTurnover.turnover)
}

// -------------------------------------------------------------------

// News

// optional .data.NewsType newsType = 1;
inline bool News::_internal_has_newstype() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool News::has_newstype() const {
  return _internal_has_newstype();
}
inline void News::clear_newstype() {
  _impl_.newstype_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::data::NewsType News::_internal_newstype() const {
  return static_cast< ::data::NewsType >(_impl_.newstype_);
}
inline ::data::NewsType News::newstype() const {
  // @@protoc_insertion_point(field_get:data.News.newsType)
  return _internal_newstype();
}
inline void News::_internal_set_newstype(::data::NewsType value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.newstype_ = value;
}
inline void News::set_newstype(::data::NewsType value) {
  _internal_set_newstype(value);
  // @@protoc_insertion_point(field_set:data.News.newsType)
}

// optional string newsID = 2;
inline bool News::_internal_has_newsid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool News::has_newsid() const {
  return _internal_has_newsid();
}
inline void News::clear_newsid() {
  _impl_.newsid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& News::newsid() const {
  // @@protoc_insertion_point(field_get:data.News.newsID)
  return _internal_newsid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void News::set_newsid(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.newsid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:data.News.newsID)
}
inline std::string* News::mutable_newsid() {
  std::string* _s = _internal_mutable_newsid();
  // @@protoc_insertion_point(field_mutable:data.News.newsID)
  return _s;
}
inline const std::string& News::_internal_newsid() const {
  return _impl_.newsid_.Get();
}
inline void News::_internal_set_newsid(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.newsid_.Set(value, GetArenaForAllocation());
}
inline std::string* News::_internal_mutable_newsid() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.newsid_.Mutable(GetArenaForAllocation());
}
inline std::string* News::release_newsid() {
  // @@protoc_insertion_point(field_release:data.News.newsID)
  if (!_internal_has_newsid()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.newsid_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.newsid_.IsDefault()) {
    _impl_.newsid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void News::set_allocated_newsid(std::string* newsid) {
  if (newsid != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.newsid_.SetAllocated(newsid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.newsid_.IsDefault()) {
    _impl_.newsid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:data.News.newsID)
}

// optional string headline = 3;
inline bool News::_internal_has_headline() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool News::has_headline() const {
  return _internal_has_headline();
}
inline void News::clear_headline() {
  _impl_.headline_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& News::headline() const {
  // @@protoc_insertion_point(field_get:data.News.headline)
  return _internal_headline();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void News::set_headline(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.headline_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:data.News.headline)
}
inline std::string* News::mutable_headline() {
  std::string* _s = _internal_mutable_headline();
  // @@protoc_insertion_point(field_mutable:data.News.headline)
  return _s;
}
inline const std::string& News::_internal_headline() const {
  return _impl_.headline_.Get();
}
inline void News::_internal_set_headline(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.headline_.Set(value, GetArenaForAllocation());
}
inline std::string* News::_internal_mutable_headline() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.headline_.Mutable(GetArenaForAllocation());
}
inline std::string* News::release_headline() {
  // @@protoc_insertion_point(field_release:data.News.headline)
  if (!_internal_has_headline()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.headline_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.headline_.IsDefault()) {
    _impl_.headline_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void News::set_allocated_headline(std::string* headline) {
  if (headline != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.headline_.SetAllocated(headline, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.headline_.IsDefault()) {
    _impl_.headline_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:data.News.headline)
}

// optional .data.CancelFlag cancelFlag = 4;
inline bool News::_internal_has_cancelflag() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool News::has_cancelflag() const {
  return _internal_has_cancelflag();
}
inline void News::clear_cancelflag() {
  _impl_.cancelflag_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::data::CancelFlag News::_internal_cancelflag() const {
  return static_cast< ::data::CancelFlag >(_impl_.cancelflag_);
}
inline ::data::CancelFlag News::cancelflag() const {
  // @@protoc_insertion_point(field_get:data.News.cancelFlag)
  return _internal_cancelflag();
}
inline void News::_internal_set_cancelflag(::data::CancelFlag value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.cancelflag_ = value;
}
inline void News::set_cancelflag(::data::CancelFlag value) {
  _internal_set_cancelflag(value);
  // @@protoc_insertion_point(field_set:data.News.cancelFlag)
}

// optional .data.LastFragment lastFragment = 5;
inline bool News::_internal_has_lastfragment() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool News::has_lastfragment() const {
  return _internal_has_lastfragment();
}
inline void News::clear_lastfragment() {
  _impl_.lastfragment_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::data::LastFragment News::_internal_lastfragment() const {
  return static_cast< ::data::LastFragment >(_impl_.lastfragment_);
}
inline ::data::LastFragment News::lastfragment() const {
  // @@protoc_insertion_point(field_get:data.News.lastFragment)
  return _internal_lastfragment();
}
inline void News::_internal_set_lastfragment(::data::LastFragment value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.lastfragment_ = value;
}
inline void News::set_lastfragment(::data::LastFragment value) {
  _internal_set_lastfragment(value);
  // @@protoc_insertion_point(field_set:data.News.lastFragment)
}

// optional int64 releaseTime = 6;
inline bool News::_internal_has_releasetime() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool News::has_releasetime() const {
  return _internal_has_releasetime();
}
inline void News::clear_releasetime() {
  _impl_.releasetime_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline int64_t News::_internal_releasetime() const {
  return _impl_.releasetime_;
}
inline int64_t News::releasetime() const {
  // @@protoc_insertion_point(field_get:data.News.releaseTime)
  return _internal_releasetime();
}
inline void News::_internal_set_releasetime(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.releasetime_ = value;
}
inline void News::set_releasetime(int64_t value) {
  _internal_set_releasetime(value);
  // @@protoc_insertion_point(field_set:data.News.releaseTime)
}

// repeated .data.NoMarketCode noMarketCodes = 7;
inline int News::_internal_nomarketcodes_size() const {
  return _impl_.nomarketcodes_.size();
}
inline int News::nomarketcodes_size() const {
  return _internal_nomarketcodes_size();
}
inline void News::clear_nomarketcodes() {
  _impl_.nomarketcodes_.Clear();
}
inline ::data::NoMarketCode* News::mutable_nomarketcodes(int index) {
  // @@protoc_insertion_point(field_mutable:data.News.noMarketCodes)
  return _impl_.nomarketcodes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::data::NoMarketCode >*
News::mutable_nomarketcodes() {
  // @@protoc_insertion_point(field_mutable_list:data.News.noMarketCodes)
  return &_impl_.nomarketcodes_;
}
inline const ::data::NoMarketCode& News::_internal_nomarketcodes(int index) const {
  return _impl_.nomarketcodes_.Get(index);
}
inline const ::data::NoMarketCode& News::nomarketcodes(int index) const {
  // @@protoc_insertion_point(field_get:data.News.noMarketCodes)
  return _internal_nomarketcodes(index);
}
inline ::data::NoMarketCode* News::_internal_add_nomarketcodes() {
  return _impl_.nomarketcodes_.Add();
}
inline ::data::NoMarketCode* News::add_nomarketcodes() {
  ::data::NoMarketCode* _add = _internal_add_nomarketcodes();
  // @@protoc_insertion_point(field_add:data.News.noMarketCodes)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::data::NoMarketCode >&
News::nomarketcodes() const {
  // @@protoc_insertion_point(field_list:data.News.noMarketCodes)
  return _impl_.nomarketcodes_;
}

// repeated .data.NoSecurityCode noSecurityCodes = 8;
inline int News::_internal_nosecuritycodes_size() const {
  return _impl_.nosecuritycodes_.size();
}
inline int News::nosecuritycodes_size() const {
  return _internal_nosecuritycodes_size();
}
inline void News::clear_nosecuritycodes() {
  _impl_.nosecuritycodes_.Clear();
}
inline ::data::NoSecurityCode* News::mutable_nosecuritycodes(int index) {
  // @@protoc_insertion_point(field_mutable:data.News.noSecurityCodes)
  return _impl_.nosecuritycodes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::data::NoSecurityCode >*
News::mutable_nosecuritycodes() {
  // @@protoc_insertion_point(field_mutable_list:data.News.noSecurityCodes)
  return &_impl_.nosecuritycodes_;
}
inline const ::data::NoSecurityCode& News::_internal_nosecuritycodes(int index) const {
  return _impl_.nosecuritycodes_.Get(index);
}
inline const ::data::NoSecurityCode& News::nosecuritycodes(int index) const {
  // @@protoc_insertion_point(field_get:data.News.noSecurityCodes)
  return _internal_nosecuritycodes(index);
}
inline ::data::NoSecurityCode* News::_internal_add_nosecuritycodes() {
  return _impl_.nosecuritycodes_.Add();
}
inline ::data::NoSecurityCode* News::add_nosecuritycodes() {
  ::data::NoSecurityCode* _add = _internal_add_nosecuritycodes();
  // @@protoc_insertion_point(field_add:data.News.noSecurityCodes)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::data::NoSecurityCode >&
News::nosecuritycodes() const {
  // @@protoc_insertion_point(field_list:data.News.noSecurityCodes)
  return _impl_.nosecuritycodes_;
}

// repeated .data.NoNewsLine noNewsLines = 9;
inline int News::_internal_nonewslines_size() const {
  return _impl_.nonewslines_.size();
}
inline int News::nonewslines_size() const {
  return _internal_nonewslines_size();
}
inline void News::clear_nonewslines() {
  _impl_.nonewslines_.Clear();
}
inline ::data::NoNewsLine* News::mutable_nonewslines(int index) {
  // @@protoc_insertion_point(field_mutable:data.News.noNewsLines)
  return _impl_.nonewslines_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::data::NoNewsLine >*
News::mutable_nonewslines() {
  // @@protoc_insertion_point(field_mutable_list:data.News.noNewsLines)
  return &_impl_.nonewslines_;
}
inline const ::data::NoNewsLine& News::_internal_nonewslines(int index) const {
  return _impl_.nonewslines_.Get(index);
}
inline const ::data::NoNewsLine& News::nonewslines(int index) const {
  // @@protoc_insertion_point(field_get:data.News.noNewsLines)
  return _internal_nonewslines(index);
}
inline ::data::NoNewsLine* News::_internal_add_nonewslines() {
  return _impl_.nonewslines_.Add();
}
inline ::data::NoNewsLine* News::add_nonewslines() {
  ::data::NoNewsLine* _add = _internal_add_nonewslines();
  // @@protoc_insertion_point(field_add:data.News.noNewsLines)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::data::NoNewsLine >&
News::nonewslines() const {
  // @@protoc_insertion_point(field_list:data.News.noNewsLines)
  return _impl_.nonewslines_;
}

// -------------------------------------------------------------------

// NoEntry

// optional int64 aggregateQuantity = 1;
inline bool NoEntry::_internal_has_aggregatequantity() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool NoEntry::has_aggregatequantity() const {
  return _internal_has_aggregatequantity();
}
inline void NoEntry::clear_aggregatequantity() {
  _impl_.aggregatequantity_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int64_t NoEntry::_internal_aggregatequantity() const {
  return _impl_.aggregatequantity_;
}
inline int64_t NoEntry::aggregatequantity() const {
  // @@protoc_insertion_point(field_get:data.NoEntry.aggregateQuantity)
  return _internal_aggregatequantity();
}
inline void NoEntry::_internal_set_aggregatequantity(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.aggregatequantity_ = value;
}
inline void NoEntry::set_aggregatequantity(int64_t value) {
  _internal_set_aggregatequantity(value);
  // @@protoc_insertion_point(field_set:data.NoEntry.aggregateQuantity)
}

// optional double price = 2;
inline bool NoEntry::_internal_has_price() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool NoEntry::has_price() const {
  return _internal_has_price();
}
inline void NoEntry::clear_price() {
  _impl_.price_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline double NoEntry::_internal_price() const {
  return _impl_.price_;
}
inline double NoEntry::price() const {
  // @@protoc_insertion_point(field_get:data.NoEntry.price)
  return _internal_price();
}
inline void NoEntry::_internal_set_price(double value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.price_ = value;
}
inline void NoEntry::set_price(double value) {
  _internal_set_price(value);
  // @@protoc_insertion_point(field_set:data.NoEntry.price)
}

// optional int64 numberOfOrders = 3;
inline bool NoEntry::_internal_has_numberoforders() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool NoEntry::has_numberoforders() const {
  return _internal_has_numberoforders();
}
inline void NoEntry::clear_numberoforders() {
  _impl_.numberoforders_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int64_t NoEntry::_internal_numberoforders() const {
  return _impl_.numberoforders_;
}
inline int64_t NoEntry::numberoforders() const {
  // @@protoc_insertion_point(field_get:data.NoEntry.numberOfOrders)
  return _internal_numberoforders();
}
inline void NoEntry::_internal_set_numberoforders(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.numberoforders_ = value;
}
inline void NoEntry::set_numberoforders(int64_t value) {
  _internal_set_numberoforders(value);
  // @@protoc_insertion_point(field_set:data.NoEntry.numberOfOrders)
}

// optional .data.Side side = 4;
inline bool NoEntry::_internal_has_side() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool NoEntry::has_side() const {
  return _internal_has_side();
}
inline void NoEntry::clear_side() {
  _impl_.side_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::data::Side NoEntry::_internal_side() const {
  return static_cast< ::data::Side >(_impl_.side_);
}
inline ::data::Side NoEntry::side() const {
  // @@protoc_insertion_point(field_get:data.NoEntry.side)
  return _internal_side();
}
inline void NoEntry::_internal_set_side(::data::Side value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.side_ = value;
}
inline void NoEntry::set_side(::data::Side value) {
  _internal_set_side(value);
  // @@protoc_insertion_point(field_set:data.NoEntry.side)
}

// optional int32 priceLevel = 5;
inline bool NoEntry::_internal_has_pricelevel() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool NoEntry::has_pricelevel() const {
  return _internal_has_pricelevel();
}
inline void NoEntry::clear_pricelevel() {
  _impl_.pricelevel_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline int32_t NoEntry::_internal_pricelevel() const {
  return _impl_.pricelevel_;
}
inline int32_t NoEntry::pricelevel() const {
  // @@protoc_insertion_point(field_get:data.NoEntry.priceLevel)
  return _internal_pricelevel();
}
inline void NoEntry::_internal_set_pricelevel(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.pricelevel_ = value;
}
inline void NoEntry::set_pricelevel(int32_t value) {
  _internal_set_pricelevel(value);
  // @@protoc_insertion_point(field_set:data.NoEntry.priceLevel)
}

// optional .data.UpdateAction updateAction = 6;
inline bool NoEntry::_internal_has_updateaction() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool NoEntry::has_updateaction() const {
  return _internal_has_updateaction();
}
inline void NoEntry::clear_updateaction() {
  _impl_.updateaction_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::data::UpdateAction NoEntry::_internal_updateaction() const {
  return static_cast< ::data::UpdateAction >(_impl_.updateaction_);
}
inline ::data::UpdateAction NoEntry::updateaction() const {
  // @@protoc_insertion_point(field_get:data.NoEntry.updateAction)
  return _internal_updateaction();
}
inline void NoEntry::_internal_set_updateaction(::data::UpdateAction value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.updateaction_ = value;
}
inline void NoEntry::set_updateaction(::data::UpdateAction value) {
  _internal_set_updateaction(value);
  // @@protoc_insertion_point(field_set:data.NoEntry.updateAction)
}

// -------------------------------------------------------------------

// NoLiquidityProvider

// optional int32 lPBrokerNumber = 1;
inline bool NoLiquidityProvider::_internal_has_lpbrokernumber() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool NoLiquidityProvider::has_lpbrokernumber() const {
  return _internal_has_lpbrokernumber();
}
inline void NoLiquidityProvider::clear_lpbrokernumber() {
  _impl_.lpbrokernumber_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int32_t NoLiquidityProvider::_internal_lpbrokernumber() const {
  return _impl_.lpbrokernumber_;
}
inline int32_t NoLiquidityProvider::lpbrokernumber() const {
  // @@protoc_insertion_point(field_get:data.NoLiquidityProvider.lPBrokerNumber)
  return _internal_lpbrokernumber();
}
inline void NoLiquidityProvider::_internal_set_lpbrokernumber(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.lpbrokernumber_ = value;
}
inline void NoLiquidityProvider::set_lpbrokernumber(int32_t value) {
  _internal_set_lpbrokernumber(value);
  // @@protoc_insertion_point(field_set:data.NoLiquidityProvider.lPBrokerNumber)
}

// -------------------------------------------------------------------

// NoMarketCode

// optional .data.MarketCode marketCode = 1;
inline bool NoMarketCode::_internal_has_marketcode() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool NoMarketCode::has_marketcode() const {
  return _internal_has_marketcode();
}
inline void NoMarketCode::clear_marketcode() {
  _impl_.marketcode_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::data::MarketCode NoMarketCode::_internal_marketcode() const {
  return static_cast< ::data::MarketCode >(_impl_.marketcode_);
}
inline ::data::MarketCode NoMarketCode::marketcode() const {
  // @@protoc_insertion_point(field_get:data.NoMarketCode.marketCode)
  return _internal_marketcode();
}
inline void NoMarketCode::_internal_set_marketcode(::data::MarketCode value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.marketcode_ = value;
}
inline void NoMarketCode::set_marketcode(::data::MarketCode value) {
  _internal_set_marketcode(value);
  // @@protoc_insertion_point(field_set:data.NoMarketCode.marketCode)
}

// -------------------------------------------------------------------

// NoNewsLine

// optional string newsLine = 1;
inline bool NoNewsLine::_internal_has_newsline() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool NoNewsLine::has_newsline() const {
  return _internal_has_newsline();
}
inline void NoNewsLine::clear_newsline() {
  _impl_.newsline_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& NoNewsLine::newsline() const {
  // @@protoc_insertion_point(field_get:data.NoNewsLine.newsLine)
  return _internal_newsline();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NoNewsLine::set_newsline(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.newsline_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:data.NoNewsLine.newsLine)
}
inline std::string* NoNewsLine::mutable_newsline() {
  std::string* _s = _internal_mutable_newsline();
  // @@protoc_insertion_point(field_mutable:data.NoNewsLine.newsLine)
  return _s;
}
inline const std::string& NoNewsLine::_internal_newsline() const {
  return _impl_.newsline_.Get();
}
inline void NoNewsLine::_internal_set_newsline(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.newsline_.Set(value, GetArenaForAllocation());
}
inline std::string* NoNewsLine::_internal_mutable_newsline() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.newsline_.Mutable(GetArenaForAllocation());
}
inline std::string* NoNewsLine::release_newsline() {
  // @@protoc_insertion_point(field_release:data.NoNewsLine.newsLine)
  if (!_internal_has_newsline()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.newsline_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.newsline_.IsDefault()) {
    _impl_.newsline_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void NoNewsLine::set_allocated_newsline(std::string* newsline) {
  if (newsline != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.newsline_.SetAllocated(newsline, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.newsline_.IsDefault()) {
    _impl_.newsline_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:data.NoNewsLine.newsLine)
}

// -------------------------------------------------------------------

// NoSecurityCode

// optional int64 securityCode = 1;
inline bool NoSecurityCode::_internal_has_securitycode() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool NoSecurityCode::has_securitycode() const {
  return _internal_has_securitycode();
}
inline void NoSecurityCode::clear_securitycode() {
  _impl_.securitycode_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int64_t NoSecurityCode::_internal_securitycode() const {
  return _impl_.securitycode_;
}
inline int64_t NoSecurityCode::securitycode() const {
  // @@protoc_insertion_point(field_get:data.NoSecurityCode.securityCode)
  return _internal_securitycode();
}
inline void NoSecurityCode::_internal_set_securitycode(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.securitycode_ = value;
}
inline void NoSecurityCode::set_securitycode(int64_t value) {
  _internal_set_securitycode(value);
  // @@protoc_insertion_point(field_set:data.NoSecurityCode.securityCode)
}

// -------------------------------------------------------------------

// NoUnderlyingSecurity

// optional int64 underlyingSecurityCode = 1;
inline bool NoUnderlyingSecurity::_internal_has_underlyingsecuritycode() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool NoUnderlyingSecurity::has_underlyingsecuritycode() const {
  return _internal_has_underlyingsecuritycode();
}
inline void NoUnderlyingSecurity::clear_underlyingsecuritycode() {
  _impl_.underlyingsecuritycode_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int64_t NoUnderlyingSecurity::_internal_underlyingsecuritycode() const {
  return _impl_.underlyingsecuritycode_;
}
inline int64_t NoUnderlyingSecurity::underlyingsecuritycode() const {
  // @@protoc_insertion_point(field_get:data.NoUnderlyingSecurity.underlyingSecurityCode)
  return _internal_underlyingsecuritycode();
}
inline void NoUnderlyingSecurity::_internal_set_underlyingsecuritycode(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.underlyingsecuritycode_ = value;
}
inline void NoUnderlyingSecurity::set_underlyingsecuritycode(int64_t value) {
  _internal_set_underlyingsecuritycode(value);
  // @@protoc_insertion_point(field_set:data.NoUnderlyingSecurity.underlyingSecurityCode)
}

// -------------------------------------------------------------------

// NominalPrice

// optional int64 securityCode = 1;
inline bool NominalPrice::_internal_has_securitycode() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool NominalPrice::has_securitycode() const {
  return _internal_has_securitycode();
}
inline void NominalPrice::clear_securitycode() {
  _impl_.securitycode_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int64_t NominalPrice::_internal_securitycode() const {
  return _impl_.securitycode_;
}
inline int64_t NominalPrice::securitycode() const {
  // @@protoc_insertion_point(field_get:data.NominalPrice.securityCode)
  return _internal_securitycode();
}
inline void NominalPrice::_internal_set_securitycode(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.securitycode_ = value;
}
inline void NominalPrice::set_securitycode(int64_t value) {
  _internal_set_securitycode(value);
  // @@protoc_insertion_point(field_set:data.NominalPrice.securityCode)
}

// optional double nominalPrice = 2;
inline bool NominalPrice::_internal_has_nominalprice() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool NominalPrice::has_nominalprice() const {
  return _internal_has_nominalprice();
}
inline void NominalPrice::clear_nominalprice() {
  _impl_.nominalprice_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline double NominalPrice::_internal_nominalprice() const {
  return _impl_.nominalprice_;
}
inline double NominalPrice::nominalprice() const {
  // @@protoc_insertion_point(field_get:data.NominalPrice.nominalPrice)
  return _internal_nominalprice();
}
inline void NominalPrice::_internal_set_nominalprice(double value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.nominalprice_ = value;
}
inline void NominalPrice::set_nominalprice(double value) {
  _internal_set_nominalprice(value);
  // @@protoc_insertion_point(field_set:data.NominalPrice.nominalPrice)
}

// -------------------------------------------------------------------

// OrderImbalance

// optional int64 securityCode = 1;
inline bool OrderImbalance::_internal_has_securitycode() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool OrderImbalance::has_securitycode() const {
  return _internal_has_securitycode();
}
inline void OrderImbalance::clear_securitycode() {
  _impl_.securitycode_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int64_t OrderImbalance::_internal_securitycode() const {
  return _impl_.securitycode_;
}
inline int64_t OrderImbalance::securitycode() const {
  // @@protoc_insertion_point(field_get:data.OrderImbalance.securityCode)
  return _internal_securitycode();
}
inline void OrderImbalance::_internal_set_securitycode(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.securitycode_ = value;
}
inline void OrderImbalance::set_securitycode(int64_t value) {
  _internal_set_securitycode(value);
  // @@protoc_insertion_point(field_set:data.OrderImbalance.securityCode)
}

// optional .data.OrderImbalanceDirection orderImbalanceDirection = 2;
inline bool OrderImbalance::_internal_has_orderimbalancedirection() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool OrderImbalance::has_orderimbalancedirection() const {
  return _internal_has_orderimbalancedirection();
}
inline void OrderImbalance::clear_orderimbalancedirection() {
  _impl_.orderimbalancedirection_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::data::OrderImbalanceDirection OrderImbalance::_internal_orderimbalancedirection() const {
  return static_cast< ::data::OrderImbalanceDirection >(_impl_.orderimbalancedirection_);
}
inline ::data::OrderImbalanceDirection OrderImbalance::orderimbalancedirection() const {
  // @@protoc_insertion_point(field_get:data.OrderImbalance.orderImbalanceDirection)
  return _internal_orderimbalancedirection();
}
inline void OrderImbalance::_internal_set_orderimbalancedirection(::data::OrderImbalanceDirection value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.orderimbalancedirection_ = value;
}
inline void OrderImbalance::set_orderimbalancedirection(::data::OrderImbalanceDirection value) {
  _internal_set_orderimbalancedirection(value);
  // @@protoc_insertion_point(field_set:data.OrderImbalance.orderImbalanceDirection)
}

// optional int64 orderImbalanceQuantity = 3;
inline bool OrderImbalance::_internal_has_orderimbalancequantity() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool OrderImbalance::has_orderimbalancequantity() const {
  return _internal_has_orderimbalancequantity();
}
inline void OrderImbalance::clear_orderimbalancequantity() {
  _impl_.orderimbalancequantity_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int64_t OrderImbalance::_internal_orderimbalancequantity() const {
  return _impl_.orderimbalancequantity_;
}
inline int64_t OrderImbalance::orderimbalancequantity() const {
  // @@protoc_insertion_point(field_get:data.OrderImbalance.orderImbalanceQuantity)
  return _internal_orderimbalancequantity();
}
inline void OrderImbalance::_internal_set_orderimbalancequantity(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.orderimbalancequantity_ = value;
}
inline void OrderImbalance::set_orderimbalancequantity(int64_t value) {
  _internal_set_orderimbalancequantity(value);
  // @@protoc_insertion_point(field_set:data.OrderImbalance.orderImbalanceQuantity)
}

// -------------------------------------------------------------------

// PacketHeader

// optional int32 pktSize = 1;
inline bool PacketHeader::_internal_has_pktsize() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool PacketHeader::has_pktsize() const {
  return _internal_has_pktsize();
}
inline void PacketHeader::clear_pktsize() {
  _impl_.pktsize_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t PacketHeader::_internal_pktsize() const {
  return _impl_.pktsize_;
}
inline int32_t PacketHeader::pktsize() const {
  // @@protoc_insertion_point(field_get:data.PacketHeader.pktSize)
  return _internal_pktsize();
}
inline void PacketHeader::_internal_set_pktsize(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.pktsize_ = value;
}
inline void PacketHeader::set_pktsize(int32_t value) {
  _internal_set_pktsize(value);
  // @@protoc_insertion_point(field_set:data.PacketHeader.pktSize)
}

// optional int32 msgCount = 2;
inline bool PacketHeader::_internal_has_msgcount() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool PacketHeader::has_msgcount() const {
  return _internal_has_msgcount();
}
inline void PacketHeader::clear_msgcount() {
  _impl_.msgcount_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int32_t PacketHeader::_internal_msgcount() const {
  return _impl_.msgcount_;
}
inline int32_t PacketHeader::msgcount() const {
  // @@protoc_insertion_point(field_get:data.PacketHeader.msgCount)
  return _internal_msgcount();
}
inline void PacketHeader::_internal_set_msgcount(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.msgcount_ = value;
}
inline void PacketHeader::set_msgcount(int32_t value) {
  _internal_set_msgcount(value);
  // @@protoc_insertion_point(field_set:data.PacketHeader.msgCount)
}

// optional string filler = 3;
inline bool PacketHeader::_internal_has_filler() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PacketHeader::has_filler() const {
  return _internal_has_filler();
}
inline void PacketHeader::clear_filler() {
  _impl_.filler_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PacketHeader::filler() const {
  // @@protoc_insertion_point(field_get:data.PacketHeader.filler)
  return _internal_filler();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PacketHeader::set_filler(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.filler_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:data.PacketHeader.filler)
}
inline std::string* PacketHeader::mutable_filler() {
  std::string* _s = _internal_mutable_filler();
  // @@protoc_insertion_point(field_mutable:data.PacketHeader.filler)
  return _s;
}
inline const std::string& PacketHeader::_internal_filler() const {
  return _impl_.filler_.Get();
}
inline void PacketHeader::_internal_set_filler(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.filler_.Set(value, GetArenaForAllocation());
}
inline std::string* PacketHeader::_internal_mutable_filler() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.filler_.Mutable(GetArenaForAllocation());
}
inline std::string* PacketHeader::release_filler() {
  // @@protoc_insertion_point(field_release:data.PacketHeader.filler)
  if (!_internal_has_filler()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.filler_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.filler_.IsDefault()) {
    _impl_.filler_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PacketHeader::set_allocated_filler(std::string* filler) {
  if (filler != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.filler_.SetAllocated(filler, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.filler_.IsDefault()) {
    _impl_.filler_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:data.PacketHeader.filler)
}

// optional int64 seqNum = 4;
inline bool PacketHeader::_internal_has_seqnum() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool PacketHeader::has_seqnum() const {
  return _internal_has_seqnum();
}
inline void PacketHeader::clear_seqnum() {
  _impl_.seqnum_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline int64_t PacketHeader::_internal_seqnum() const {
  return _impl_.seqnum_;
}
inline int64_t PacketHeader::seqnum() const {
  // @@protoc_insertion_point(field_get:data.PacketHeader.seqNum)
  return _internal_seqnum();
}
inline void PacketHeader::_internal_set_seqnum(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.seqnum_ = value;
}
inline void PacketHeader::set_seqnum(int64_t value) {
  _internal_set_seqnum(value);
  // @@protoc_insertion_point(field_set:data.PacketHeader.seqNum)
}

// optional int64 sendTime = 5;
inline bool PacketHeader::_internal_has_sendtime() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool PacketHeader::has_sendtime() const {
  return _internal_has_sendtime();
}
inline void PacketHeader::clear_sendtime() {
  _impl_.sendtime_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline int64_t PacketHeader::_internal_sendtime() const {
  return _impl_.sendtime_;
}
inline int64_t PacketHeader::sendtime() const {
  // @@protoc_insertion_point(field_get:data.PacketHeader.sendTime)
  return _internal_sendtime();
}
inline void PacketHeader::_internal_set_sendtime(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.sendtime_ = value;
}
inline void PacketHeader::set_sendtime(int64_t value) {
  _internal_set_sendtime(value);
  // @@protoc_insertion_point(field_set:data.PacketHeader.sendTime)
}

// -------------------------------------------------------------------

// LongAdjustedClosingPrice

// optional string issueSymbol = 1;
inline bool LongAdjustedClosingPrice::_internal_has_issuesymbol() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool LongAdjustedClosingPrice::has_issuesymbol() const {
  return _internal_has_issuesymbol();
}
inline void LongAdjustedClosingPrice::clear_issuesymbol() {
  _impl_.issuesymbol_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& LongAdjustedClosingPrice::issuesymbol() const {
  // @@protoc_insertion_point(field_get:data.LongAdjustedClosingPrice.issueSymbol)
  return _internal_issuesymbol();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LongAdjustedClosingPrice::set_issuesymbol(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.issuesymbol_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:data.LongAdjustedClosingPrice.issueSymbol)
}
inline std::string* LongAdjustedClosingPrice::mutable_issuesymbol() {
  std::string* _s = _internal_mutable_issuesymbol();
  // @@protoc_insertion_point(field_mutable:data.LongAdjustedClosingPrice.issueSymbol)
  return _s;
}
inline const std::string& LongAdjustedClosingPrice::_internal_issuesymbol() const {
  return _impl_.issuesymbol_.Get();
}
inline void LongAdjustedClosingPrice::_internal_set_issuesymbol(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.issuesymbol_.Set(value, GetArenaForAllocation());
}
inline std::string* LongAdjustedClosingPrice::_internal_mutable_issuesymbol() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.issuesymbol_.Mutable(GetArenaForAllocation());
}
inline std::string* LongAdjustedClosingPrice::release_issuesymbol() {
  // @@protoc_insertion_point(field_release:data.LongAdjustedClosingPrice.issueSymbol)
  if (!_internal_has_issuesymbol()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.issuesymbol_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.issuesymbol_.IsDefault()) {
    _impl_.issuesymbol_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void LongAdjustedClosingPrice::set_allocated_issuesymbol(std::string* issuesymbol) {
  if (issuesymbol != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.issuesymbol_.SetAllocated(issuesymbol, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.issuesymbol_.IsDefault()) {
    _impl_.issuesymbol_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:data.LongAdjustedClosingPrice.issueSymbol)
}

// optional .data.SecurityClass securityClass = 2;
inline bool LongAdjustedClosingPrice::_internal_has_securityclass() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool LongAdjustedClosingPrice::has_securityclass() const {
  return _internal_has_securityclass();
}
inline void LongAdjustedClosingPrice::clear_securityclass() {
  _impl_.securityclass_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::data::SecurityClass LongAdjustedClosingPrice::_internal_securityclass() const {
  return static_cast< ::data::SecurityClass >(_impl_.securityclass_);
}
inline ::data::SecurityClass LongAdjustedClosingPrice::securityclass() const {
  // @@protoc_insertion_point(field_get:data.LongAdjustedClosingPrice.securityClass)
  return _internal_securityclass();
}
inline void LongAdjustedClosingPrice::_internal_set_securityclass(::data::SecurityClass value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.securityclass_ = value;
}
inline void LongAdjustedClosingPrice::set_securityclass(::data::SecurityClass value) {
  _internal_set_securityclass(value);
  // @@protoc_insertion_point(field_set:data.LongAdjustedClosingPrice.securityClass)
}

// optional double adjustedClosingPrice = 3;
inline bool LongAdjustedClosingPrice::_internal_has_adjustedclosingprice() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool LongAdjustedClosingPrice::has_adjustedclosingprice() const {
  return _internal_has_adjustedclosingprice();
}
inline void LongAdjustedClosingPrice::clear_adjustedclosingprice() {
  _impl_.adjustedclosingprice_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline double LongAdjustedClosingPrice::_internal_adjustedclosingprice() const {
  return _impl_.adjustedclosingprice_;
}
inline double LongAdjustedClosingPrice::adjustedclosingprice() const {
  // @@protoc_insertion_point(field_get:data.LongAdjustedClosingPrice.adjustedClosingPrice)
  return _internal_adjustedclosingprice();
}
inline void LongAdjustedClosingPrice::_internal_set_adjustedclosingprice(double value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.adjustedclosingprice_ = value;
}
inline void LongAdjustedClosingPrice::set_adjustedclosingprice(double value) {
  _internal_set_adjustedclosingprice(value);
  // @@protoc_insertion_point(field_set:data.LongAdjustedClosingPrice.adjustedClosingPrice)
}

// -------------------------------------------------------------------

// LongDayTradeSummary

// optional string issueSymbol = 1;
inline bool LongDayTradeSummary::_internal_has_issuesymbol() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool LongDayTradeSummary::has_issuesymbol() const {
  return _internal_has_issuesymbol();
}
inline void LongDayTradeSummary::clear_issuesymbol() {
  _impl_.issuesymbol_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& LongDayTradeSummary::issuesymbol() const {
  // @@protoc_insertion_point(field_get:data.LongDayTradeSummary.issueSymbol)
  return _internal_issuesymbol();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LongDayTradeSummary::set_issuesymbol(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.issuesymbol_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:data.LongDayTradeSummary.issueSymbol)
}
inline std::string* LongDayTradeSummary::mutable_issuesymbol() {
  std::string* _s = _internal_mutable_issuesymbol();
  // @@protoc_insertion_point(field_mutable:data.LongDayTradeSummary.issueSymbol)
  return _s;
}
inline const std::string& LongDayTradeSummary::_internal_issuesymbol() const {
  return _impl_.issuesymbol_.Get();
}
inline void LongDayTradeSummary::_internal_set_issuesymbol(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.issuesymbol_.Set(value, GetArenaForAllocation());
}
inline std::string* LongDayTradeSummary::_internal_mutable_issuesymbol() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.issuesymbol_.Mutable(GetArenaForAllocation());
}
inline std::string* LongDayTradeSummary::release_issuesymbol() {
  // @@protoc_insertion_point(field_release:data.LongDayTradeSummary.issueSymbol)
  if (!_internal_has_issuesymbol()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.issuesymbol_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.issuesymbol_.IsDefault()) {
    _impl_.issuesymbol_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void LongDayTradeSummary::set_allocated_issuesymbol(std::string* issuesymbol) {
  if (issuesymbol != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.issuesymbol_.SetAllocated(issuesymbol, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.issuesymbol_.IsDefault()) {
    _impl_.issuesymbol_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:data.LongDayTradeSummary.issueSymbol)
}

// optional .data.MarketCategory marketCategory = 2;
inline bool LongDayTradeSummary::_internal_has_marketcategory() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool LongDayTradeSummary::has_marketcategory() const {
  return _internal_has_marketcategory();
}
inline void LongDayTradeSummary::clear_marketcategory() {
  _impl_.marketcategory_ = 0;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::data::MarketCategory LongDayTradeSummary::_internal_marketcategory() const {
  return static_cast< ::data::MarketCategory >(_impl_.marketcategory_);
}
inline ::data::MarketCategory LongDayTradeSummary::marketcategory() const {
  // @@protoc_insertion_point(field_get:data.LongDayTradeSummary.marketCategory)
  return _internal_marketcategory();
}
inline void LongDayTradeSummary::_internal_set_marketcategory(::data::MarketCategory value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.marketcategory_ = value;
}
inline void LongDayTradeSummary::set_marketcategory(::data::MarketCategory value) {
  _internal_set_marketcategory(value);
  // @@protoc_insertion_point(field_set:data.LongDayTradeSummary.marketCategory)
}

// optional double nasdaqHighPrice = 3;
inline bool LongDayTradeSummary::_internal_has_nasdaqhighprice() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool LongDayTradeSummary::has_nasdaqhighprice() const {
  return _internal_has_nasdaqhighprice();
}
inline void LongDayTradeSummary::clear_nasdaqhighprice() {
  _impl_.nasdaqhighprice_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline double LongDayTradeSummary::_internal_nasdaqhighprice() const {
  return _impl_.nasdaqhighprice_;
}
inline double LongDayTradeSummary::nasdaqhighprice() const {
  // @@protoc_insertion_point(field_get:data.LongDayTradeSummary.nasdaqHighPrice)
  return _internal_nasdaqhighprice();
}
inline void LongDayTradeSummary::_internal_set_nasdaqhighprice(double value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.nasdaqhighprice_ = value;
}
inline void LongDayTradeSummary::set_nasdaqhighprice(double value) {
  _internal_set_nasdaqhighprice(value);
  // @@protoc_insertion_point(field_set:data.LongDayTradeSummary.nasdaqHighPrice)
}

// optional double nasdaqLowPrice = 4;
inline bool LongDayTradeSummary::_internal_has_nasdaqlowprice() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool LongDayTradeSummary::has_nasdaqlowprice() const {
  return _internal_has_nasdaqlowprice();
}
inline void LongDayTradeSummary::clear_nasdaqlowprice() {
  _impl_.nasdaqlowprice_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline double LongDayTradeSummary::_internal_nasdaqlowprice() const {
  return _impl_.nasdaqlowprice_;
}
inline double LongDayTradeSummary::nasdaqlowprice() const {
  // @@protoc_insertion_point(field_get:data.LongDayTradeSummary.nasdaqLowPrice)
  return _internal_nasdaqlowprice();
}
inline void LongDayTradeSummary::_internal_set_nasdaqlowprice(double value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.nasdaqlowprice_ = value;
}
inline void LongDayTradeSummary::set_nasdaqlowprice(double value) {
  _internal_set_nasdaqlowprice(value);
  // @@protoc_insertion_point(field_set:data.LongDayTradeSummary.nasdaqLowPrice)
}

// optional double nasdaqClosingPrice = 5;
inline bool LongDayTradeSummary::_internal_has_nasdaqclosingprice() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool LongDayTradeSummary::has_nasdaqclosingprice() const {
  return _internal_has_nasdaqclosingprice();
}
inline void LongDayTradeSummary::clear_nasdaqclosingprice() {
  _impl_.nasdaqclosingprice_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline double LongDayTradeSummary::_internal_nasdaqclosingprice() const {
  return _impl_.nasdaqclosingprice_;
}
inline double LongDayTradeSummary::nasdaqclosingprice() const {
  // @@protoc_insertion_point(field_get:data.LongDayTradeSummary.nasdaqClosingPrice)
  return _internal_nasdaqclosingprice();
}
inline void LongDayTradeSummary::_internal_set_nasdaqclosingprice(double value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.nasdaqclosingprice_ = value;
}
inline void LongDayTradeSummary::set_nasdaqclosingprice(double value) {
  _internal_set_nasdaqclosingprice(value);
  // @@protoc_insertion_point(field_set:data.LongDayTradeSummary.nasdaqClosingPrice)
}

// optional int64 consolidatedVolume = 6;
inline bool LongDayTradeSummary::_internal_has_consolidatedvolume() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool LongDayTradeSummary::has_consolidatedvolume() const {
  return _internal_has_consolidatedvolume();
}
inline void LongDayTradeSummary::clear_consolidatedvolume() {
  _impl_.consolidatedvolume_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline int64_t LongDayTradeSummary::_internal_consolidatedvolume() const {
  return _impl_.consolidatedvolume_;
}
inline int64_t LongDayTradeSummary::consolidatedvolume() const {
  // @@protoc_insertion_point(field_get:data.LongDayTradeSummary.consolidatedVolume)
  return _internal_consolidatedvolume();
}
inline void LongDayTradeSummary::_internal_set_consolidatedvolume(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.consolidatedvolume_ = value;
}
inline void LongDayTradeSummary::set_consolidatedvolume(int64_t value) {
  _internal_set_consolidatedvolume(value);
  // @@protoc_insertion_point(field_set:data.LongDayTradeSummary.consolidatedVolume)
}

// optional double consolidatedOpenPrice = 7;
inline bool LongDayTradeSummary::_internal_has_consolidatedopenprice() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool LongDayTradeSummary::has_consolidatedopenprice() const {
  return _internal_has_consolidatedopenprice();
}
inline void LongDayTradeSummary::clear_consolidatedopenprice() {
  _impl_.consolidatedopenprice_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline double LongDayTradeSummary::_internal_consolidatedopenprice() const {
  return _impl_.consolidatedopenprice_;
}
inline double LongDayTradeSummary::consolidatedopenprice() const {
  // @@protoc_insertion_point(field_get:data.LongDayTradeSummary.consolidatedOpenPrice)
  return _internal_consolidatedopenprice();
}
inline void LongDayTradeSummary::_internal_set_consolidatedopenprice(double value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.consolidatedopenprice_ = value;
}
inline void LongDayTradeSummary::set_consolidatedopenprice(double value) {
  _internal_set_consolidatedopenprice(value);
  // @@protoc_insertion_point(field_set:data.LongDayTradeSummary.consolidatedOpenPrice)
}

// -------------------------------------------------------------------

// LongTradeCancelForNonNextSharesTrades

// optional .data.OriginatingMarketCenterIdentifier marketCenterIdentifier = 1;
inline bool LongTradeCancelForNonNextSharesTrades::_internal_has_marketcenteridentifier() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool LongTradeCancelForNonNextSharesTrades::has_marketcenteridentifier() const {
  return _internal_has_marketcenteridentifier();
}
inline void LongTradeCancelForNonNextSharesTrades::clear_marketcenteridentifier() {
  _impl_.marketcenteridentifier_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::data::OriginatingMarketCenterIdentifier LongTradeCancelForNonNextSharesTrades::_internal_marketcenteridentifier() const {
  return static_cast< ::data::OriginatingMarketCenterIdentifier >(_impl_.marketcenteridentifier_);
}
inline ::data::OriginatingMarketCenterIdentifier LongTradeCancelForNonNextSharesTrades::marketcenteridentifier() const {
  // @@protoc_insertion_point(field_get:data.LongTradeCancelForNonNextSharesTrades.marketCenterIdentifier)
  return _internal_marketcenteridentifier();
}
inline void LongTradeCancelForNonNextSharesTrades::_internal_set_marketcenteridentifier(::data::OriginatingMarketCenterIdentifier value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.marketcenteridentifier_ = value;
}
inline void LongTradeCancelForNonNextSharesTrades::set_marketcenteridentifier(::data::OriginatingMarketCenterIdentifier value) {
  _internal_set_marketcenteridentifier(value);
  // @@protoc_insertion_point(field_set:data.LongTradeCancelForNonNextSharesTrades.marketCenterIdentifier)
}

// optional string issueSymbol = 2;
inline bool LongTradeCancelForNonNextSharesTrades::_internal_has_issuesymbol() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool LongTradeCancelForNonNextSharesTrades::has_issuesymbol() const {
  return _internal_has_issuesymbol();
}
inline void LongTradeCancelForNonNextSharesTrades::clear_issuesymbol() {
  _impl_.issuesymbol_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& LongTradeCancelForNonNextSharesTrades::issuesymbol() const {
  // @@protoc_insertion_point(field_get:data.LongTradeCancelForNonNextSharesTrades.issueSymbol)
  return _internal_issuesymbol();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LongTradeCancelForNonNextSharesTrades::set_issuesymbol(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.issuesymbol_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:data.LongTradeCancelForNonNextSharesTrades.issueSymbol)
}
inline std::string* LongTradeCancelForNonNextSharesTrades::mutable_issuesymbol() {
  std::string* _s = _internal_mutable_issuesymbol();
  // @@protoc_insertion_point(field_mutable:data.LongTradeCancelForNonNextSharesTrades.issueSymbol)
  return _s;
}
inline const std::string& LongTradeCancelForNonNextSharesTrades::_internal_issuesymbol() const {
  return _impl_.issuesymbol_.Get();
}
inline void LongTradeCancelForNonNextSharesTrades::_internal_set_issuesymbol(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.issuesymbol_.Set(value, GetArenaForAllocation());
}
inline std::string* LongTradeCancelForNonNextSharesTrades::_internal_mutable_issuesymbol() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.issuesymbol_.Mutable(GetArenaForAllocation());
}
inline std::string* LongTradeCancelForNonNextSharesTrades::release_issuesymbol() {
  // @@protoc_insertion_point(field_release:data.LongTradeCancelForNonNextSharesTrades.issueSymbol)
  if (!_internal_has_issuesymbol()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.issuesymbol_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.issuesymbol_.IsDefault()) {
    _impl_.issuesymbol_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void LongTradeCancelForNonNextSharesTrades::set_allocated_issuesymbol(std::string* issuesymbol) {
  if (issuesymbol != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.issuesymbol_.SetAllocated(issuesymbol, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.issuesymbol_.IsDefault()) {
    _impl_.issuesymbol_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:data.LongTradeCancelForNonNextSharesTrades.issueSymbol)
}

// optional .data.SecurityClass securityClass = 3;
inline bool LongTradeCancelForNonNextSharesTrades::_internal_has_securityclass() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool LongTradeCancelForNonNextSharesTrades::has_securityclass() const {
  return _internal_has_securityclass();
}
inline void LongTradeCancelForNonNextSharesTrades::clear_securityclass() {
  _impl_.securityclass_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::data::SecurityClass LongTradeCancelForNonNextSharesTrades::_internal_securityclass() const {
  return static_cast< ::data::SecurityClass >(_impl_.securityclass_);
}
inline ::data::SecurityClass LongTradeCancelForNonNextSharesTrades::securityclass() const {
  // @@protoc_insertion_point(field_get:data.LongTradeCancelForNonNextSharesTrades.securityClass)
  return _internal_securityclass();
}
inline void LongTradeCancelForNonNextSharesTrades::_internal_set_securityclass(::data::SecurityClass value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.securityclass_ = value;
}
inline void LongTradeCancelForNonNextSharesTrades::set_securityclass(::data::SecurityClass value) {
  _internal_set_securityclass(value);
  // @@protoc_insertion_point(field_set:data.LongTradeCancelForNonNextSharesTrades.securityClass)
}

// optional string originalControlNumber = 4;
inline bool LongTradeCancelForNonNextSharesTrades::_internal_has_originalcontrolnumber() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool LongTradeCancelForNonNextSharesTrades::has_originalcontrolnumber() const {
  return _internal_has_originalcontrolnumber();
}
inline void LongTradeCancelForNonNextSharesTrades::clear_originalcontrolnumber() {
  _impl_.originalcontrolnumber_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& LongTradeCancelForNonNextSharesTrades::originalcontrolnumber() const {
  // @@protoc_insertion_point(field_get:data.LongTradeCancelForNonNextSharesTrades.originalControlNumber)
  return _internal_originalcontrolnumber();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LongTradeCancelForNonNextSharesTrades::set_originalcontrolnumber(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.originalcontrolnumber_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:data.LongTradeCancelForNonNextSharesTrades.originalControlNumber)
}
inline std::string* LongTradeCancelForNonNextSharesTrades::mutable_originalcontrolnumber() {
  std::string* _s = _internal_mutable_originalcontrolnumber();
  // @@protoc_insertion_point(field_mutable:data.LongTradeCancelForNonNextSharesTrades.originalControlNumber)
  return _s;
}
inline const std::string& LongTradeCancelForNonNextSharesTrades::_internal_originalcontrolnumber() const {
  return _impl_.originalcontrolnumber_.Get();
}
inline void LongTradeCancelForNonNextSharesTrades::_internal_set_originalcontrolnumber(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.originalcontrolnumber_.Set(value, GetArenaForAllocation());
}
inline std::string* LongTradeCancelForNonNextSharesTrades::_internal_mutable_originalcontrolnumber() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.originalcontrolnumber_.Mutable(GetArenaForAllocation());
}
inline std::string* LongTradeCancelForNonNextSharesTrades::release_originalcontrolnumber() {
  // @@protoc_insertion_point(field_release:data.LongTradeCancelForNonNextSharesTrades.originalControlNumber)
  if (!_internal_has_originalcontrolnumber()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.originalcontrolnumber_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.originalcontrolnumber_.IsDefault()) {
    _impl_.originalcontrolnumber_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void LongTradeCancelForNonNextSharesTrades::set_allocated_originalcontrolnumber(std::string* originalcontrolnumber) {
  if (originalcontrolnumber != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.originalcontrolnumber_.SetAllocated(originalcontrolnumber, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.originalcontrolnumber_.IsDefault()) {
    _impl_.originalcontrolnumber_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:data.LongTradeCancelForNonNextSharesTrades.originalControlNumber)
}

// optional double originalTradePrice = 5;
inline bool LongTradeCancelForNonNextSharesTrades::_internal_has_originaltradeprice() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool LongTradeCancelForNonNextSharesTrades::has_originaltradeprice() const {
  return _internal_has_originaltradeprice();
}
inline void LongTradeCancelForNonNextSharesTrades::clear_originaltradeprice() {
  _impl_.originaltradeprice_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline double LongTradeCancelForNonNextSharesTrades::_internal_originaltradeprice() const {
  return _impl_.originaltradeprice_;
}
inline double LongTradeCancelForNonNextSharesTrades::originaltradeprice() const {
  // @@protoc_insertion_point(field_get:data.LongTradeCancelForNonNextSharesTrades.originalTradePrice)
  return _internal_originaltradeprice();
}
inline void LongTradeCancelForNonNextSharesTrades::_internal_set_originaltradeprice(double value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.originaltradeprice_ = value;
}
inline void LongTradeCancelForNonNextSharesTrades::set_originaltradeprice(double value) {
  _internal_set_originaltradeprice(value);
  // @@protoc_insertion_point(field_set:data.LongTradeCancelForNonNextSharesTrades.originalTradePrice)
}

// optional int64 originalTradeSize = 6;
inline bool LongTradeCancelForNonNextSharesTrades::_internal_has_originaltradesize() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool LongTradeCancelForNonNextSharesTrades::has_originaltradesize() const {
  return _internal_has_originaltradesize();
}
inline void LongTradeCancelForNonNextSharesTrades::clear_originaltradesize() {
  _impl_.originaltradesize_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline int64_t LongTradeCancelForNonNextSharesTrades::_internal_originaltradesize() const {
  return _impl_.originaltradesize_;
}
inline int64_t LongTradeCancelForNonNextSharesTrades::originaltradesize() const {
  // @@protoc_insertion_point(field_get:data.LongTradeCancelForNonNextSharesTrades.originalTradeSize)
  return _internal_originaltradesize();
}
inline void LongTradeCancelForNonNextSharesTrades::_internal_set_originaltradesize(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.originaltradesize_ = value;
}
inline void LongTradeCancelForNonNextSharesTrades::set_originaltradesize(int64_t value) {
  _internal_set_originaltradesize(value);
  // @@protoc_insertion_point(field_set:data.LongTradeCancelForNonNextSharesTrades.originalTradeSize)
}

// optional .data.SaleConditionModifier originalSaleConditionModifier = 7;
inline bool LongTradeCancelForNonNextSharesTrades::_internal_has_originalsaleconditionmodifier() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.originalsaleconditionmodifier_ != nullptr);
  return value;
}
inline bool LongTradeCancelForNonNextSharesTrades::has_originalsaleconditionmodifier() const {
  return _internal_has_originalsaleconditionmodifier();
}
inline void LongTradeCancelForNonNextSharesTrades::clear_originalsaleconditionmodifier() {
  if (_impl_.originalsaleconditionmodifier_ != nullptr) _impl_.originalsaleconditionmodifier_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::data::SaleConditionModifier& LongTradeCancelForNonNextSharesTrades::_internal_originalsaleconditionmodifier() const {
  const ::data::SaleConditionModifier* p = _impl_.originalsaleconditionmodifier_;
  return p != nullptr ? *p : reinterpret_cast<const ::data::SaleConditionModifier&>(
      ::data::_SaleConditionModifier_default_instance_);
}
inline const ::data::SaleConditionModifier& LongTradeCancelForNonNextSharesTrades::originalsaleconditionmodifier() const {
  // @@protoc_insertion_point(field_get:data.LongTradeCancelForNonNextSharesTrades.originalSaleConditionModifier)
  return _internal_originalsaleconditionmodifier();
}
inline void LongTradeCancelForNonNextSharesTrades::unsafe_arena_set_allocated_originalsaleconditionmodifier(
    ::data::SaleConditionModifier* originalsaleconditionmodifier) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.originalsaleconditionmodifier_);
  }
  _impl_.originalsaleconditionmodifier_ = originalsaleconditionmodifier;
  if (originalsaleconditionmodifier) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:data.LongTradeCancelForNonNextSharesTrades.originalSaleConditionModifier)
}
inline ::data::SaleConditionModifier* LongTradeCancelForNonNextSharesTrades::release_originalsaleconditionmodifier() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::data::SaleConditionModifier* temp = _impl_.originalsaleconditionmodifier_;
  _impl_.originalsaleconditionmodifier_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::data::SaleConditionModifier* LongTradeCancelForNonNextSharesTrades::unsafe_arena_release_originalsaleconditionmodifier() {
  // @@protoc_insertion_point(field_release:data.LongTradeCancelForNonNextSharesTrades.originalSaleConditionModifier)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::data::SaleConditionModifier* temp = _impl_.originalsaleconditionmodifier_;
  _impl_.originalsaleconditionmodifier_ = nullptr;
  return temp;
}
inline ::data::SaleConditionModifier* LongTradeCancelForNonNextSharesTrades::_internal_mutable_originalsaleconditionmodifier() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.originalsaleconditionmodifier_ == nullptr) {
    auto* p = CreateMaybeMessage<::data::SaleConditionModifier>(GetArenaForAllocation());
    _impl_.originalsaleconditionmodifier_ = p;
  }
  return _impl_.originalsaleconditionmodifier_;
}
inline ::data::SaleConditionModifier* LongTradeCancelForNonNextSharesTrades::mutable_originalsaleconditionmodifier() {
  ::data::SaleConditionModifier* _msg = _internal_mutable_originalsaleconditionmodifier();
  // @@protoc_insertion_point(field_mutable:data.LongTradeCancelForNonNextSharesTrades.originalSaleConditionModifier)
  return _msg;
}
inline void LongTradeCancelForNonNextSharesTrades::set_allocated_originalsaleconditionmodifier(::data::SaleConditionModifier* originalsaleconditionmodifier) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.originalsaleconditionmodifier_;
  }
  if (originalsaleconditionmodifier) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(originalsaleconditionmodifier);
    if (message_arena != submessage_arena) {
      originalsaleconditionmodifier = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, originalsaleconditionmodifier, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.originalsaleconditionmodifier_ = originalsaleconditionmodifier;
  // @@protoc_insertion_point(field_set_allocated:data.LongTradeCancelForNonNextSharesTrades.originalSaleConditionModifier)
}

// optional int64 consolidatedVolume = 8;
inline bool LongTradeCancelForNonNextSharesTrades::_internal_has_consolidatedvolume() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool LongTradeCancelForNonNextSharesTrades::has_consolidatedvolume() const {
  return _internal_has_consolidatedvolume();
}
inline void LongTradeCancelForNonNextSharesTrades::clear_consolidatedvolume() {
  _impl_.consolidatedvolume_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline int64_t LongTradeCancelForNonNextSharesTrades::_internal_consolidatedvolume() const {
  return _impl_.consolidatedvolume_;
}
inline int64_t LongTradeCancelForNonNextSharesTrades::consolidatedvolume() const {
  // @@protoc_insertion_point(field_get:data.LongTradeCancelForNonNextSharesTrades.consolidatedVolume)
  return _internal_consolidatedvolume();
}
inline void LongTradeCancelForNonNextSharesTrades::_internal_set_consolidatedvolume(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.consolidatedvolume_ = value;
}
inline void LongTradeCancelForNonNextSharesTrades::set_consolidatedvolume(int64_t value) {
  _internal_set_consolidatedvolume(value);
  // @@protoc_insertion_point(field_set:data.LongTradeCancelForNonNextSharesTrades.consolidatedVolume)
}

// -------------------------------------------------------------------

// LongTradeCorrectionForNonNextsharesTrades

// optional .data.OriginatingMarketCenterIdentifier marketCenterIdentifier = 1;
inline bool LongTradeCorrectionForNonNextsharesTrades::_internal_has_marketcenteridentifier() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool LongTradeCorrectionForNonNextsharesTrades::has_marketcenteridentifier() const {
  return _internal_has_marketcenteridentifier();
}
inline void LongTradeCorrectionForNonNextsharesTrades::clear_marketcenteridentifier() {
  _impl_.marketcenteridentifier_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::data::OriginatingMarketCenterIdentifier LongTradeCorrectionForNonNextsharesTrades::_internal_marketcenteridentifier() const {
  return static_cast< ::data::OriginatingMarketCenterIdentifier >(_impl_.marketcenteridentifier_);
}
inline ::data::OriginatingMarketCenterIdentifier LongTradeCorrectionForNonNextsharesTrades::marketcenteridentifier() const {
  // @@protoc_insertion_point(field_get:data.LongTradeCorrectionForNonNextsharesTrades.marketCenterIdentifier)
  return _internal_marketcenteridentifier();
}
inline void LongTradeCorrectionForNonNextsharesTrades::_internal_set_marketcenteridentifier(::data::OriginatingMarketCenterIdentifier value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.marketcenteridentifier_ = value;
}
inline void LongTradeCorrectionForNonNextsharesTrades::set_marketcenteridentifier(::data::OriginatingMarketCenterIdentifier value) {
  _internal_set_marketcenteridentifier(value);
  // @@protoc_insertion_point(field_set:data.LongTradeCorrectionForNonNextsharesTrades.marketCenterIdentifier)
}

// optional string issueSymbol = 2;
inline bool LongTradeCorrectionForNonNextsharesTrades::_internal_has_issuesymbol() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool LongTradeCorrectionForNonNextsharesTrades::has_issuesymbol() const {
  return _internal_has_issuesymbol();
}
inline void LongTradeCorrectionForNonNextsharesTrades::clear_issuesymbol() {
  _impl_.issuesymbol_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& LongTradeCorrectionForNonNextsharesTrades::issuesymbol() const {
  // @@protoc_insertion_point(field_get:data.LongTradeCorrectionForNonNextsharesTrades.issueSymbol)
  return _internal_issuesymbol();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LongTradeCorrectionForNonNextsharesTrades::set_issuesymbol(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.issuesymbol_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:data.LongTradeCorrectionForNonNextsharesTrades.issueSymbol)
}
inline std::string* LongTradeCorrectionForNonNextsharesTrades::mutable_issuesymbol() {
  std::string* _s = _internal_mutable_issuesymbol();
  // @@protoc_insertion_point(field_mutable:data.LongTradeCorrectionForNonNextsharesTrades.issueSymbol)
  return _s;
}
inline const std::string& LongTradeCorrectionForNonNextsharesTrades::_internal_issuesymbol() const {
  return _impl_.issuesymbol_.Get();
}
inline void LongTradeCorrectionForNonNextsharesTrades::_internal_set_issuesymbol(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.issuesymbol_.Set(value, GetArenaForAllocation());
}
inline std::string* LongTradeCorrectionForNonNextsharesTrades::_internal_mutable_issuesymbol() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.issuesymbol_.Mutable(GetArenaForAllocation());
}
inline std::string* LongTradeCorrectionForNonNextsharesTrades::release_issuesymbol() {
  // @@protoc_insertion_point(field_release:data.LongTradeCorrectionForNonNextsharesTrades.issueSymbol)
  if (!_internal_has_issuesymbol()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.issuesymbol_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.issuesymbol_.IsDefault()) {
    _impl_.issuesymbol_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void LongTradeCorrectionForNonNextsharesTrades::set_allocated_issuesymbol(std::string* issuesymbol) {
  if (issuesymbol != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.issuesymbol_.SetAllocated(issuesymbol, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.issuesymbol_.IsDefault()) {
    _impl_.issuesymbol_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:data.LongTradeCorrectionForNonNextsharesTrades.issueSymbol)
}

// optional .data.SecurityClass securityClass = 3;
inline bool LongTradeCorrectionForNonNextsharesTrades::_internal_has_securityclass() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool LongTradeCorrectionForNonNextsharesTrades::has_securityclass() const {
  return _internal_has_securityclass();
}
inline void LongTradeCorrectionForNonNextsharesTrades::clear_securityclass() {
  _impl_.securityclass_ = 0;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::data::SecurityClass LongTradeCorrectionForNonNextsharesTrades::_internal_securityclass() const {
  return static_cast< ::data::SecurityClass >(_impl_.securityclass_);
}
inline ::data::SecurityClass LongTradeCorrectionForNonNextsharesTrades::securityclass() const {
  // @@protoc_insertion_point(field_get:data.LongTradeCorrectionForNonNextsharesTrades.securityClass)
  return _internal_securityclass();
}
inline void LongTradeCorrectionForNonNextsharesTrades::_internal_set_securityclass(::data::SecurityClass value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.securityclass_ = value;
}
inline void LongTradeCorrectionForNonNextsharesTrades::set_securityclass(::data::SecurityClass value) {
  _internal_set_securityclass(value);
  // @@protoc_insertion_point(field_set:data.LongTradeCorrectionForNonNextsharesTrades.securityClass)
}

// optional string originalControlNumber = 4;
inline bool LongTradeCorrectionForNonNextsharesTrades::_internal_has_originalcontrolnumber() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool LongTradeCorrectionForNonNextsharesTrades::has_originalcontrolnumber() const {
  return _internal_has_originalcontrolnumber();
}
inline void LongTradeCorrectionForNonNextsharesTrades::clear_originalcontrolnumber() {
  _impl_.originalcontrolnumber_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& LongTradeCorrectionForNonNextsharesTrades::originalcontrolnumber() const {
  // @@protoc_insertion_point(field_get:data.LongTradeCorrectionForNonNextsharesTrades.originalControlNumber)
  return _internal_originalcontrolnumber();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LongTradeCorrectionForNonNextsharesTrades::set_originalcontrolnumber(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.originalcontrolnumber_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:data.LongTradeCorrectionForNonNextsharesTrades.originalControlNumber)
}
inline std::string* LongTradeCorrectionForNonNextsharesTrades::mutable_originalcontrolnumber() {
  std::string* _s = _internal_mutable_originalcontrolnumber();
  // @@protoc_insertion_point(field_mutable:data.LongTradeCorrectionForNonNextsharesTrades.originalControlNumber)
  return _s;
}
inline const std::string& LongTradeCorrectionForNonNextsharesTrades::_internal_originalcontrolnumber() const {
  return _impl_.originalcontrolnumber_.Get();
}
inline void LongTradeCorrectionForNonNextsharesTrades::_internal_set_originalcontrolnumber(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.originalcontrolnumber_.Set(value, GetArenaForAllocation());
}
inline std::string* LongTradeCorrectionForNonNextsharesTrades::_internal_mutable_originalcontrolnumber() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.originalcontrolnumber_.Mutable(GetArenaForAllocation());
}
inline std::string* LongTradeCorrectionForNonNextsharesTrades::release_originalcontrolnumber() {
  // @@protoc_insertion_point(field_release:data.LongTradeCorrectionForNonNextsharesTrades.originalControlNumber)
  if (!_internal_has_originalcontrolnumber()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.originalcontrolnumber_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.originalcontrolnumber_.IsDefault()) {
    _impl_.originalcontrolnumber_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void LongTradeCorrectionForNonNextsharesTrades::set_allocated_originalcontrolnumber(std::string* originalcontrolnumber) {
  if (originalcontrolnumber != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.originalcontrolnumber_.SetAllocated(originalcontrolnumber, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.originalcontrolnumber_.IsDefault()) {
    _impl_.originalcontrolnumber_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:data.LongTradeCorrectionForNonNextsharesTrades.originalControlNumber)
}

// optional double originalTradePrice = 5;
inline bool LongTradeCorrectionForNonNextsharesTrades::_internal_has_originaltradeprice() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool LongTradeCorrectionForNonNextsharesTrades::has_originaltradeprice() const {
  return _internal_has_originaltradeprice();
}
inline void LongTradeCorrectionForNonNextsharesTrades::clear_originaltradeprice() {
  _impl_.originaltradeprice_ = 0;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline double LongTradeCorrectionForNonNextsharesTrades::_internal_originaltradeprice() const {
  return _impl_.originaltradeprice_;
}
inline double LongTradeCorrectionForNonNextsharesTrades::originaltradeprice() const {
  // @@protoc_insertion_point(field_get:data.LongTradeCorrectionForNonNextsharesTrades.originalTradePrice)
  return _internal_originaltradeprice();
}
inline void LongTradeCorrectionForNonNextsharesTrades::_internal_set_originaltradeprice(double value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.originaltradeprice_ = value;
}
inline void LongTradeCorrectionForNonNextsharesTrades::set_originaltradeprice(double value) {
  _internal_set_originaltradeprice(value);
  // @@protoc_insertion_point(field_set:data.LongTradeCorrectionForNonNextsharesTrades.originalTradePrice)
}

// optional int64 originalTradeSize = 6;
inline bool LongTradeCorrectionForNonNextsharesTrades::_internal_has_originaltradesize() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool LongTradeCorrectionForNonNextsharesTrades::has_originaltradesize() const {
  return _internal_has_originaltradesize();
}
inline void LongTradeCorrectionForNonNextsharesTrades::clear_originaltradesize() {
  _impl_.originaltradesize_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline int64_t LongTradeCorrectionForNonNextsharesTrades::_internal_originaltradesize() const {
  return _impl_.originaltradesize_;
}
inline int64_t LongTradeCorrectionForNonNextsharesTrades::originaltradesize() const {
  // @@protoc_insertion_point(field_get:data.LongTradeCorrectionForNonNextsharesTrades.originalTradeSize)
  return _internal_originaltradesize();
}
inline void LongTradeCorrectionForNonNextsharesTrades::_internal_set_originaltradesize(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.originaltradesize_ = value;
}
inline void LongTradeCorrectionForNonNextsharesTrades::set_originaltradesize(int64_t value) {
  _internal_set_originaltradesize(value);
  // @@protoc_insertion_point(field_set:data.LongTradeCorrectionForNonNextsharesTrades.originalTradeSize)
}

// optional string originalConditionModifier = 7;
inline bool LongTradeCorrectionForNonNextsharesTrades::_internal_has_originalconditionmodifier() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool LongTradeCorrectionForNonNextsharesTrades::has_originalconditionmodifier() const {
  return _internal_has_originalconditionmodifier();
}
inline void LongTradeCorrectionForNonNextsharesTrades::clear_originalconditionmodifier() {
  _impl_.originalconditionmodifier_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& LongTradeCorrectionForNonNextsharesTrades::originalconditionmodifier() const {
  // @@protoc_insertion_point(field_get:data.LongTradeCorrectionForNonNextsharesTrades.originalConditionModifier)
  return _internal_originalconditionmodifier();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LongTradeCorrectionForNonNextsharesTrades::set_originalconditionmodifier(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.originalconditionmodifier_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:data.LongTradeCorrectionForNonNextsharesTrades.originalConditionModifier)
}
inline std::string* LongTradeCorrectionForNonNextsharesTrades::mutable_originalconditionmodifier() {
  std::string* _s = _internal_mutable_originalconditionmodifier();
  // @@protoc_insertion_point(field_mutable:data.LongTradeCorrectionForNonNextsharesTrades.originalConditionModifier)
  return _s;
}
inline const std::string& LongTradeCorrectionForNonNextsharesTrades::_internal_originalconditionmodifier() const {
  return _impl_.originalconditionmodifier_.Get();
}
inline void LongTradeCorrectionForNonNextsharesTrades::_internal_set_originalconditionmodifier(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.originalconditionmodifier_.Set(value, GetArenaForAllocation());
}
inline std::string* LongTradeCorrectionForNonNextsharesTrades::_internal_mutable_originalconditionmodifier() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.originalconditionmodifier_.Mutable(GetArenaForAllocation());
}
inline std::string* LongTradeCorrectionForNonNextsharesTrades::release_originalconditionmodifier() {
  // @@protoc_insertion_point(field_release:data.LongTradeCorrectionForNonNextsharesTrades.originalConditionModifier)
  if (!_internal_has_originalconditionmodifier()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.originalconditionmodifier_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.originalconditionmodifier_.IsDefault()) {
    _impl_.originalconditionmodifier_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void LongTradeCorrectionForNonNextsharesTrades::set_allocated_originalconditionmodifier(std::string* originalconditionmodifier) {
  if (originalconditionmodifier != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.originalconditionmodifier_.SetAllocated(originalconditionmodifier, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.originalconditionmodifier_.IsDefault()) {
    _impl_.originalconditionmodifier_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:data.LongTradeCorrectionForNonNextsharesTrades.originalConditionModifier)
}

// optional string correctedTradeControlNumber = 8;
inline bool LongTradeCorrectionForNonNextsharesTrades::_internal_has_correctedtradecontrolnumber() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool LongTradeCorrectionForNonNextsharesTrades::has_correctedtradecontrolnumber() const {
  return _internal_has_correctedtradecontrolnumber();
}
inline void LongTradeCorrectionForNonNextsharesTrades::clear_correctedtradecontrolnumber() {
  _impl_.correctedtradecontrolnumber_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& LongTradeCorrectionForNonNextsharesTrades::correctedtradecontrolnumber() const {
  // @@protoc_insertion_point(field_get:data.LongTradeCorrectionForNonNextsharesTrades.correctedTradeControlNumber)
  return _internal_correctedtradecontrolnumber();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LongTradeCorrectionForNonNextsharesTrades::set_correctedtradecontrolnumber(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000008u;
 _impl_.correctedtradecontrolnumber_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:data.LongTradeCorrectionForNonNextsharesTrades.correctedTradeControlNumber)
}
inline std::string* LongTradeCorrectionForNonNextsharesTrades::mutable_correctedtradecontrolnumber() {
  std::string* _s = _internal_mutable_correctedtradecontrolnumber();
  // @@protoc_insertion_point(field_mutable:data.LongTradeCorrectionForNonNextsharesTrades.correctedTradeControlNumber)
  return _s;
}
inline const std::string& LongTradeCorrectionForNonNextsharesTrades::_internal_correctedtradecontrolnumber() const {
  return _impl_.correctedtradecontrolnumber_.Get();
}
inline void LongTradeCorrectionForNonNextsharesTrades::_internal_set_correctedtradecontrolnumber(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.correctedtradecontrolnumber_.Set(value, GetArenaForAllocation());
}
inline std::string* LongTradeCorrectionForNonNextsharesTrades::_internal_mutable_correctedtradecontrolnumber() {
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.correctedtradecontrolnumber_.Mutable(GetArenaForAllocation());
}
inline std::string* LongTradeCorrectionForNonNextsharesTrades::release_correctedtradecontrolnumber() {
  // @@protoc_insertion_point(field_release:data.LongTradeCorrectionForNonNextsharesTrades.correctedTradeControlNumber)
  if (!_internal_has_correctedtradecontrolnumber()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* p = _impl_.correctedtradecontrolnumber_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.correctedtradecontrolnumber_.IsDefault()) {
    _impl_.correctedtradecontrolnumber_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void LongTradeCorrectionForNonNextsharesTrades::set_allocated_correctedtradecontrolnumber(std::string* correctedtradecontrolnumber) {
  if (correctedtradecontrolnumber != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.correctedtradecontrolnumber_.SetAllocated(correctedtradecontrolnumber, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.correctedtradecontrolnumber_.IsDefault()) {
    _impl_.correctedtradecontrolnumber_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:data.LongTradeCorrectionForNonNextsharesTrades.correctedTradeControlNumber)
}

// optional double correctedTradePrice = 9;
inline bool LongTradeCorrectionForNonNextsharesTrades::_internal_has_correctedtradeprice() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool LongTradeCorrectionForNonNextsharesTrades::has_correctedtradeprice() const {
  return _internal_has_correctedtradeprice();
}
inline void LongTradeCorrectionForNonNextsharesTrades::clear_correctedtradeprice() {
  _impl_.correctedtradeprice_ = 0;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline double LongTradeCorrectionForNonNextsharesTrades::_internal_correctedtradeprice() const {
  return _impl_.correctedtradeprice_;
}
inline double LongTradeCorrectionForNonNextsharesTrades::correctedtradeprice() const {
  // @@protoc_insertion_point(field_get:data.LongTradeCorrectionForNonNextsharesTrades.correctedTradePrice)
  return _internal_correctedtradeprice();
}
inline void LongTradeCorrectionForNonNextsharesTrades::_internal_set_correctedtradeprice(double value) {
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.correctedtradeprice_ = value;
}
inline void LongTradeCorrectionForNonNextsharesTrades::set_correctedtradeprice(double value) {
  _internal_set_correctedtradeprice(value);
  // @@protoc_insertion_point(field_set:data.LongTradeCorrectionForNonNextsharesTrades.correctedTradePrice)
}

// optional int64 CorrectedTradeSize = 10;
inline bool LongTradeCorrectionForNonNextsharesTrades::_internal_has_correctedtradesize() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool LongTradeCorrectionForNonNextsharesTrades::has_correctedtradesize() const {
  return _internal_has_correctedtradesize();
}
inline void LongTradeCorrectionForNonNextsharesTrades::clear_correctedtradesize() {
  _impl_.correctedtradesize_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline int64_t LongTradeCorrectionForNonNextsharesTrades::_internal_correctedtradesize() const {
  return _impl_.correctedtradesize_;
}
inline int64_t LongTradeCorrectionForNonNextsharesTrades::correctedtradesize() const {
  // @@protoc_insertion_point(field_get:data.LongTradeCorrectionForNonNextsharesTrades.CorrectedTradeSize)
  return _internal_correctedtradesize();
}
inline void LongTradeCorrectionForNonNextsharesTrades::_internal_set_correctedtradesize(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000400u;
  _impl_.correctedtradesize_ = value;
}
inline void LongTradeCorrectionForNonNextsharesTrades::set_correctedtradesize(int64_t value) {
  _internal_set_correctedtradesize(value);
  // @@protoc_insertion_point(field_set:data.LongTradeCorrectionForNonNextsharesTrades.CorrectedTradeSize)
}

// optional string CorrectedSaleConditionModifier = 11;
inline bool LongTradeCorrectionForNonNextsharesTrades::_internal_has_correctedsaleconditionmodifier() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool LongTradeCorrectionForNonNextsharesTrades::has_correctedsaleconditionmodifier() const {
  return _internal_has_correctedsaleconditionmodifier();
}
inline void LongTradeCorrectionForNonNextsharesTrades::clear_correctedsaleconditionmodifier() {
  _impl_.correctedsaleconditionmodifier_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const std::string& LongTradeCorrectionForNonNextsharesTrades::correctedsaleconditionmodifier() const {
  // @@protoc_insertion_point(field_get:data.LongTradeCorrectionForNonNextsharesTrades.CorrectedSaleConditionModifier)
  return _internal_correctedsaleconditionmodifier();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LongTradeCorrectionForNonNextsharesTrades::set_correctedsaleconditionmodifier(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000010u;
 _impl_.correctedsaleconditionmodifier_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:data.LongTradeCorrectionForNonNextsharesTrades.CorrectedSaleConditionModifier)
}
inline std::string* LongTradeCorrectionForNonNextsharesTrades::mutable_correctedsaleconditionmodifier() {
  std::string* _s = _internal_mutable_correctedsaleconditionmodifier();
  // @@protoc_insertion_point(field_mutable:data.LongTradeCorrectionForNonNextsharesTrades.CorrectedSaleConditionModifier)
  return _s;
}
inline const std::string& LongTradeCorrectionForNonNextsharesTrades::_internal_correctedsaleconditionmodifier() const {
  return _impl_.correctedsaleconditionmodifier_.Get();
}
inline void LongTradeCorrectionForNonNextsharesTrades::_internal_set_correctedsaleconditionmodifier(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.correctedsaleconditionmodifier_.Set(value, GetArenaForAllocation());
}
inline std::string* LongTradeCorrectionForNonNextsharesTrades::_internal_mutable_correctedsaleconditionmodifier() {
  _impl_._has_bits_[0] |= 0x00000010u;
  return _impl_.correctedsaleconditionmodifier_.Mutable(GetArenaForAllocation());
}
inline std::string* LongTradeCorrectionForNonNextsharesTrades::release_correctedsaleconditionmodifier() {
  // @@protoc_insertion_point(field_release:data.LongTradeCorrectionForNonNextsharesTrades.CorrectedSaleConditionModifier)
  if (!_internal_has_correctedsaleconditionmodifier()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000010u;
  auto* p = _impl_.correctedsaleconditionmodifier_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.correctedsaleconditionmodifier_.IsDefault()) {
    _impl_.correctedsaleconditionmodifier_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void LongTradeCorrectionForNonNextsharesTrades::set_allocated_correctedsaleconditionmodifier(std::string* correctedsaleconditionmodifier) {
  if (correctedsaleconditionmodifier != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.correctedsaleconditionmodifier_.SetAllocated(correctedsaleconditionmodifier, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.correctedsaleconditionmodifier_.IsDefault()) {
    _impl_.correctedsaleconditionmodifier_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:data.LongTradeCorrectionForNonNextsharesTrades.CorrectedSaleConditionModifier)
}

// optional int64 consolidatedVolume = 12;
inline bool LongTradeCorrectionForNonNextsharesTrades::_internal_has_consolidatedvolume() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool LongTradeCorrectionForNonNextsharesTrades::has_consolidatedvolume() const {
  return _internal_has_consolidatedvolume();
}
inline void LongTradeCorrectionForNonNextsharesTrades::clear_consolidatedvolume() {
  _impl_.consolidatedvolume_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline int64_t LongTradeCorrectionForNonNextsharesTrades::_internal_consolidatedvolume() const {
  return _impl_.consolidatedvolume_;
}
inline int64_t LongTradeCorrectionForNonNextsharesTrades::consolidatedvolume() const {
  // @@protoc_insertion_point(field_get:data.LongTradeCorrectionForNonNextsharesTrades.consolidatedVolume)
  return _internal_consolidatedvolume();
}
inline void LongTradeCorrectionForNonNextsharesTrades::_internal_set_consolidatedvolume(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000800u;
  _impl_.consolidatedvolume_ = value;
}
inline void LongTradeCorrectionForNonNextsharesTrades::set_consolidatedvolume(int64_t value) {
  _internal_set_consolidatedvolume(value);
  // @@protoc_insertion_point(field_set:data.LongTradeCorrectionForNonNextsharesTrades.consolidatedVolume)
}

// -------------------------------------------------------------------

// LongTradeReportForNonNextshares

// optional int64 consolidatedVolume = 1;
inline bool LongTradeReportForNonNextshares::_internal_has_consolidatedvolume() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool LongTradeReportForNonNextshares::has_consolidatedvolume() const {
  return _internal_has_consolidatedvolume();
}
inline void LongTradeReportForNonNextshares::clear_consolidatedvolume() {
  _impl_.consolidatedvolume_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int64_t LongTradeReportForNonNextshares::_internal_consolidatedvolume() const {
  return _impl_.consolidatedvolume_;
}
inline int64_t LongTradeReportForNonNextshares::consolidatedvolume() const {
  // @@protoc_insertion_point(field_get:data.LongTradeReportForNonNextshares.consolidatedVolume)
  return _internal_consolidatedvolume();
}
inline void LongTradeReportForNonNextshares::_internal_set_consolidatedvolume(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.consolidatedvolume_ = value;
}
inline void LongTradeReportForNonNextshares::set_consolidatedvolume(int64_t value) {
  _internal_set_consolidatedvolume(value);
  // @@protoc_insertion_point(field_set:data.LongTradeReportForNonNextshares.consolidatedVolume)
}

// -------------------------------------------------------------------

// ReferencePrice

// optional int64 securityCode = 1;
inline bool ReferencePrice::_internal_has_securitycode() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ReferencePrice::has_securitycode() const {
  return _internal_has_securitycode();
}
inline void ReferencePrice::clear_securitycode() {
  _impl_.securitycode_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int64_t ReferencePrice::_internal_securitycode() const {
  return _impl_.securitycode_;
}
inline int64_t ReferencePrice::securitycode() const {
  // @@protoc_insertion_point(field_get:data.ReferencePrice.securityCode)
  return _internal_securitycode();
}
inline void ReferencePrice::_internal_set_securitycode(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.securitycode_ = value;
}
inline void ReferencePrice::set_securitycode(int64_t value) {
  _internal_set_securitycode(value);
  // @@protoc_insertion_point(field_set:data.ReferencePrice.securityCode)
}

// optional double referencePrice = 2;
inline bool ReferencePrice::_internal_has_referenceprice() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ReferencePrice::has_referenceprice() const {
  return _internal_has_referenceprice();
}
inline void ReferencePrice::clear_referenceprice() {
  _impl_.referenceprice_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline double ReferencePrice::_internal_referenceprice() const {
  return _impl_.referenceprice_;
}
inline double ReferencePrice::referenceprice() const {
  // @@protoc_insertion_point(field_get:data.ReferencePrice.referencePrice)
  return _internal_referenceprice();
}
inline void ReferencePrice::_internal_set_referenceprice(double value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.referenceprice_ = value;
}
inline void ReferencePrice::set_referenceprice(double value) {
  _internal_set_referenceprice(value);
  // @@protoc_insertion_point(field_set:data.ReferencePrice.referencePrice)
}

// optional double lowerPrice = 3;
inline bool ReferencePrice::_internal_has_lowerprice() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ReferencePrice::has_lowerprice() const {
  return _internal_has_lowerprice();
}
inline void ReferencePrice::clear_lowerprice() {
  _impl_.lowerprice_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline double ReferencePrice::_internal_lowerprice() const {
  return _impl_.lowerprice_;
}
inline double ReferencePrice::lowerprice() const {
  // @@protoc_insertion_point(field_get:data.ReferencePrice.lowerPrice)
  return _internal_lowerprice();
}
inline void ReferencePrice::_internal_set_lowerprice(double value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.lowerprice_ = value;
}
inline void ReferencePrice::set_lowerprice(double value) {
  _internal_set_lowerprice(value);
  // @@protoc_insertion_point(field_set:data.ReferencePrice.lowerPrice)
}

// optional double upperPrice = 4;
inline bool ReferencePrice::_internal_has_upperprice() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ReferencePrice::has_upperprice() const {
  return _internal_has_upperprice();
}
inline void ReferencePrice::clear_upperprice() {
  _impl_.upperprice_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline double ReferencePrice::_internal_upperprice() const {
  return _impl_.upperprice_;
}
inline double ReferencePrice::upperprice() const {
  // @@protoc_insertion_point(field_get:data.ReferencePrice.upperPrice)
  return _internal_upperprice();
}
inline void ReferencePrice::_internal_set_upperprice(double value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.upperprice_ = value;
}
inline void ReferencePrice::set_upperprice(double value) {
  _internal_set_upperprice(value);
  // @@protoc_insertion_point(field_set:data.ReferencePrice.upperPrice)
}

// -------------------------------------------------------------------

// QBBOIPOQuotingPeriodUpdate

// optional string stock = 1;
inline bool QBBOIPOQuotingPeriodUpdate::_internal_has_stock() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool QBBOIPOQuotingPeriodUpdate::has_stock() const {
  return _internal_has_stock();
}
inline void QBBOIPOQuotingPeriodUpdate::clear_stock() {
  _impl_.stock_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& QBBOIPOQuotingPeriodUpdate::stock() const {
  // @@protoc_insertion_point(field_get:data.QBBOIPOQuotingPeriodUpdate.stock)
  return _internal_stock();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void QBBOIPOQuotingPeriodUpdate::set_stock(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.stock_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:data.QBBOIPOQuotingPeriodUpdate.stock)
}
inline std::string* QBBOIPOQuotingPeriodUpdate::mutable_stock() {
  std::string* _s = _internal_mutable_stock();
  // @@protoc_insertion_point(field_mutable:data.QBBOIPOQuotingPeriodUpdate.stock)
  return _s;
}
inline const std::string& QBBOIPOQuotingPeriodUpdate::_internal_stock() const {
  return _impl_.stock_.Get();
}
inline void QBBOIPOQuotingPeriodUpdate::_internal_set_stock(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.stock_.Set(value, GetArenaForAllocation());
}
inline std::string* QBBOIPOQuotingPeriodUpdate::_internal_mutable_stock() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.stock_.Mutable(GetArenaForAllocation());
}
inline std::string* QBBOIPOQuotingPeriodUpdate::release_stock() {
  // @@protoc_insertion_point(field_release:data.QBBOIPOQuotingPeriodUpdate.stock)
  if (!_internal_has_stock()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.stock_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.stock_.IsDefault()) {
    _impl_.stock_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void QBBOIPOQuotingPeriodUpdate::set_allocated_stock(std::string* stock) {
  if (stock != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.stock_.SetAllocated(stock, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.stock_.IsDefault()) {
    _impl_.stock_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:data.QBBOIPOQuotingPeriodUpdate.stock)
}

// optional int64 iPOQuotationReleaseTime = 2;
inline bool QBBOIPOQuotingPeriodUpdate::_internal_has_ipoquotationreleasetime() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool QBBOIPOQuotingPeriodUpdate::has_ipoquotationreleasetime() const {
  return _internal_has_ipoquotationreleasetime();
}
inline void QBBOIPOQuotingPeriodUpdate::clear_ipoquotationreleasetime() {
  _impl_.ipoquotationreleasetime_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int64_t QBBOIPOQuotingPeriodUpdate::_internal_ipoquotationreleasetime() const {
  return _impl_.ipoquotationreleasetime_;
}
inline int64_t QBBOIPOQuotingPeriodUpdate::ipoquotationreleasetime() const {
  // @@protoc_insertion_point(field_get:data.QBBOIPOQuotingPeriodUpdate.iPOQuotationReleaseTime)
  return _internal_ipoquotationreleasetime();
}
inline void QBBOIPOQuotingPeriodUpdate::_internal_set_ipoquotationreleasetime(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.ipoquotationreleasetime_ = value;
}
inline void QBBOIPOQuotingPeriodUpdate::set_ipoquotationreleasetime(int64_t value) {
  _internal_set_ipoquotationreleasetime(value);
  // @@protoc_insertion_point(field_set:data.QBBOIPOQuotingPeriodUpdate.iPOQuotationReleaseTime)
}

// optional .data.IPOQuotationReleaseQualifier quotationReleaseQualifier = 3;
inline bool QBBOIPOQuotingPeriodUpdate::_internal_has_quotationreleasequalifier() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool QBBOIPOQuotingPeriodUpdate::has_quotationreleasequalifier() const {
  return _internal_has_quotationreleasequalifier();
}
inline void QBBOIPOQuotingPeriodUpdate::clear_quotationreleasequalifier() {
  _impl_.quotationreleasequalifier_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::data::IPOQuotationReleaseQualifier QBBOIPOQuotingPeriodUpdate::_internal_quotationreleasequalifier() const {
  return static_cast< ::data::IPOQuotationReleaseQualifier >(_impl_.quotationreleasequalifier_);
}
inline ::data::IPOQuotationReleaseQualifier QBBOIPOQuotingPeriodUpdate::quotationreleasequalifier() const {
  // @@protoc_insertion_point(field_get:data.QBBOIPOQuotingPeriodUpdate.quotationReleaseQualifier)
  return _internal_quotationreleasequalifier();
}
inline void QBBOIPOQuotingPeriodUpdate::_internal_set_quotationreleasequalifier(::data::IPOQuotationReleaseQualifier value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.quotationreleasequalifier_ = value;
}
inline void QBBOIPOQuotingPeriodUpdate::set_quotationreleasequalifier(::data::IPOQuotationReleaseQualifier value) {
  _internal_set_quotationreleasequalifier(value);
  // @@protoc_insertion_point(field_set:data.QBBOIPOQuotingPeriodUpdate.quotationReleaseQualifier)
}

// optional double iPOPrice = 4;
inline bool QBBOIPOQuotingPeriodUpdate::_internal_has_ipoprice() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool QBBOIPOQuotingPeriodUpdate::has_ipoprice() const {
  return _internal_has_ipoprice();
}
inline void QBBOIPOQuotingPeriodUpdate::clear_ipoprice() {
  _impl_.ipoprice_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline double QBBOIPOQuotingPeriodUpdate::_internal_ipoprice() const {
  return _impl_.ipoprice_;
}
inline double QBBOIPOQuotingPeriodUpdate::ipoprice() const {
  // @@protoc_insertion_point(field_get:data.QBBOIPOQuotingPeriodUpdate.iPOPrice)
  return _internal_ipoprice();
}
inline void QBBOIPOQuotingPeriodUpdate::_internal_set_ipoprice(double value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.ipoprice_ = value;
}
inline void QBBOIPOQuotingPeriodUpdate::set_ipoprice(double value) {
  _internal_set_ipoprice(value);
  // @@protoc_insertion_point(field_set:data.QBBOIPOQuotingPeriodUpdate.iPOPrice)
}

// -------------------------------------------------------------------

// SecurityDefinition

// optional int64 securityCode = 1;
inline bool SecurityDefinition::_internal_has_securitycode() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool SecurityDefinition::has_securitycode() const {
  return _internal_has_securitycode();
}
inline void SecurityDefinition::clear_securitycode() {
  _impl_.securitycode_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline int64_t SecurityDefinition::_internal_securitycode() const {
  return _impl_.securitycode_;
}
inline int64_t SecurityDefinition::securitycode() const {
  // @@protoc_insertion_point(field_get:data.SecurityDefinition.securityCode)
  return _internal_securitycode();
}
inline void SecurityDefinition::_internal_set_securitycode(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.securitycode_ = value;
}
inline void SecurityDefinition::set_securitycode(int64_t value) {
  _internal_set_securitycode(value);
  // @@protoc_insertion_point(field_set:data.SecurityDefinition.securityCode)
}

// optional .data.MarketCode marketCode = 2;
inline bool SecurityDefinition::_internal_has_marketcode() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool SecurityDefinition::has_marketcode() const {
  return _internal_has_marketcode();
}
inline void SecurityDefinition::clear_marketcode() {
  _impl_.marketcode_ = 0;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline ::data::MarketCode SecurityDefinition::_internal_marketcode() const {
  return static_cast< ::data::MarketCode >(_impl_.marketcode_);
}
inline ::data::MarketCode SecurityDefinition::marketcode() const {
  // @@protoc_insertion_point(field_get:data.SecurityDefinition.marketCode)
  return _internal_marketcode();
}
inline void SecurityDefinition::_internal_set_marketcode(::data::MarketCode value) {
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.marketcode_ = value;
}
inline void SecurityDefinition::set_marketcode(::data::MarketCode value) {
  _internal_set_marketcode(value);
  // @@protoc_insertion_point(field_set:data.SecurityDefinition.marketCode)
}

// optional string isinCode = 3;
inline bool SecurityDefinition::_internal_has_isincode() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SecurityDefinition::has_isincode() const {
  return _internal_has_isincode();
}
inline void SecurityDefinition::clear_isincode() {
  _impl_.isincode_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SecurityDefinition::isincode() const {
  // @@protoc_insertion_point(field_get:data.SecurityDefinition.isinCode)
  return _internal_isincode();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SecurityDefinition::set_isincode(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.isincode_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:data.SecurityDefinition.isinCode)
}
inline std::string* SecurityDefinition::mutable_isincode() {
  std::string* _s = _internal_mutable_isincode();
  // @@protoc_insertion_point(field_mutable:data.SecurityDefinition.isinCode)
  return _s;
}
inline const std::string& SecurityDefinition::_internal_isincode() const {
  return _impl_.isincode_.Get();
}
inline void SecurityDefinition::_internal_set_isincode(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.isincode_.Set(value, GetArenaForAllocation());
}
inline std::string* SecurityDefinition::_internal_mutable_isincode() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.isincode_.Mutable(GetArenaForAllocation());
}
inline std::string* SecurityDefinition::release_isincode() {
  // @@protoc_insertion_point(field_release:data.SecurityDefinition.isinCode)
  if (!_internal_has_isincode()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.isincode_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.isincode_.IsDefault()) {
    _impl_.isincode_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SecurityDefinition::set_allocated_isincode(std::string* isincode) {
  if (isincode != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.isincode_.SetAllocated(isincode, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.isincode_.IsDefault()) {
    _impl_.isincode_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:data.SecurityDefinition.isinCode)
}

// optional .data.InstrumentType instrumentType = 4;
inline bool SecurityDefinition::_internal_has_instrumenttype() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool SecurityDefinition::has_instrumenttype() const {
  return _internal_has_instrumenttype();
}
inline void SecurityDefinition::clear_instrumenttype() {
  _impl_.instrumenttype_ = 0;
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline ::data::InstrumentType SecurityDefinition::_internal_instrumenttype() const {
  return static_cast< ::data::InstrumentType >(_impl_.instrumenttype_);
}
inline ::data::InstrumentType SecurityDefinition::instrumenttype() const {
  // @@protoc_insertion_point(field_get:data.SecurityDefinition.instrumentType)
  return _internal_instrumenttype();
}
inline void SecurityDefinition::_internal_set_instrumenttype(::data::InstrumentType value) {
  _impl_._has_bits_[0] |= 0x00000400u;
  _impl_.instrumenttype_ = value;
}
inline void SecurityDefinition::set_instrumenttype(::data::InstrumentType value) {
  _internal_set_instrumenttype(value);
  // @@protoc_insertion_point(field_set:data.SecurityDefinition.instrumentType)
}

// optional .data.ProductType productType = 5;
inline bool SecurityDefinition::_internal_has_producttype() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool SecurityDefinition::has_producttype() const {
  return _internal_has_producttype();
}
inline void SecurityDefinition::clear_producttype() {
  _impl_.producttype_ = 0;
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline ::data::ProductType SecurityDefinition::_internal_producttype() const {
  return static_cast< ::data::ProductType >(_impl_.producttype_);
}
inline ::data::ProductType SecurityDefinition::producttype() const {
  // @@protoc_insertion_point(field_get:data.SecurityDefinition.productType)
  return _internal_producttype();
}
inline void SecurityDefinition::_internal_set_producttype(::data::ProductType value) {
  _impl_._has_bits_[0] |= 0x00000800u;
  _impl_.producttype_ = value;
}
inline void SecurityDefinition::set_producttype(::data::ProductType value) {
  _internal_set_producttype(value);
  // @@protoc_insertion_point(field_set:data.SecurityDefinition.productType)
}

// optional .data.SpreadTableCode spreadTableCode = 6;
inline bool SecurityDefinition::_internal_has_spreadtablecode() const {
  bool value = (_impl_._has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool SecurityDefinition::has_spreadtablecode() const {
  return _internal_has_spreadtablecode();
}
inline void SecurityDefinition::clear_spreadtablecode() {
  _impl_.spreadtablecode_ = 0;
  _impl_._has_bits_[0] &= ~0x00001000u;
}
inline ::data::SpreadTableCode SecurityDefinition::_internal_spreadtablecode() const {
  return static_cast< ::data::SpreadTableCode >(_impl_.spreadtablecode_);
}
inline ::data::SpreadTableCode SecurityDefinition::spreadtablecode() const {
  // @@protoc_insertion_point(field_get:data.SecurityDefinition.spreadTableCode)
  return _internal_spreadtablecode();
}
inline void SecurityDefinition::_internal_set_spreadtablecode(::data::SpreadTableCode value) {
  _impl_._has_bits_[0] |= 0x00001000u;
  _impl_.spreadtablecode_ = value;
}
inline void SecurityDefinition::set_spreadtablecode(::data::SpreadTableCode value) {
  _internal_set_spreadtablecode(value);
  // @@protoc_insertion_point(field_set:data.SecurityDefinition.spreadTableCode)
}

// optional string securityShortName = 7;
inline bool SecurityDefinition::_internal_has_securityshortname() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SecurityDefinition::has_securityshortname() const {
  return _internal_has_securityshortname();
}
inline void SecurityDefinition::clear_securityshortname() {
  _impl_.securityshortname_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& SecurityDefinition::securityshortname() const {
  // @@protoc_insertion_point(field_get:data.SecurityDefinition.securityShortName)
  return _internal_securityshortname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SecurityDefinition::set_securityshortname(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.securityshortname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:data.SecurityDefinition.securityShortName)
}
inline std::string* SecurityDefinition::mutable_securityshortname() {
  std::string* _s = _internal_mutable_securityshortname();
  // @@protoc_insertion_point(field_mutable:data.SecurityDefinition.securityShortName)
  return _s;
}
inline const std::string& SecurityDefinition::_internal_securityshortname() const {
  return _impl_.securityshortname_.Get();
}
inline void SecurityDefinition::_internal_set_securityshortname(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.securityshortname_.Set(value, GetArenaForAllocation());
}
inline std::string* SecurityDefinition::_internal_mutable_securityshortname() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.securityshortname_.Mutable(GetArenaForAllocation());
}
inline std::string* SecurityDefinition::release_securityshortname() {
  // @@protoc_insertion_point(field_release:data.SecurityDefinition.securityShortName)
  if (!_internal_has_securityshortname()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.securityshortname_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.securityshortname_.IsDefault()) {
    _impl_.securityshortname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SecurityDefinition::set_allocated_securityshortname(std::string* securityshortname) {
  if (securityshortname != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.securityshortname_.SetAllocated(securityshortname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.securityshortname_.IsDefault()) {
    _impl_.securityshortname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:data.SecurityDefinition.securityShortName)
}

// optional .data.CurrencyType currencyCode = 8;
inline bool SecurityDefinition::_internal_has_currencycode() const {
  bool value = (_impl_._has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline bool SecurityDefinition::has_currencycode() const {
  return _internal_has_currencycode();
}
inline void SecurityDefinition::clear_currencycode() {
  _impl_.currencycode_ = 0;
  _impl_._has_bits_[0] &= ~0x00004000u;
}
inline ::data::CurrencyType SecurityDefinition::_internal_currencycode() const {
  return static_cast< ::data::CurrencyType >(_impl_.currencycode_);
}
inline ::data::CurrencyType SecurityDefinition::currencycode() const {
  // @@protoc_insertion_point(field_get:data.SecurityDefinition.currencyCode)
  return _internal_currencycode();
}
inline void SecurityDefinition::_internal_set_currencycode(::data::CurrencyType value) {
  _impl_._has_bits_[0] |= 0x00004000u;
  _impl_.currencycode_ = value;
}
inline void SecurityDefinition::set_currencycode(::data::CurrencyType value) {
  _internal_set_currencycode(value);
  // @@protoc_insertion_point(field_set:data.SecurityDefinition.currencyCode)
}

// optional string securityNameGCCS = 9;
inline bool SecurityDefinition::_internal_has_securitynamegccs() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool SecurityDefinition::has_securitynamegccs() const {
  return _internal_has_securitynamegccs();
}
inline void SecurityDefinition::clear_securitynamegccs() {
  _impl_.securitynamegccs_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& SecurityDefinition::securitynamegccs() const {
  // @@protoc_insertion_point(field_get:data.SecurityDefinition.securityNameGCCS)
  return _internal_securitynamegccs();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SecurityDefinition::set_securitynamegccs(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.securitynamegccs_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:data.SecurityDefinition.securityNameGCCS)
}
inline std::string* SecurityDefinition::mutable_securitynamegccs() {
  std::string* _s = _internal_mutable_securitynamegccs();
  // @@protoc_insertion_point(field_mutable:data.SecurityDefinition.securityNameGCCS)
  return _s;
}
inline const std::string& SecurityDefinition::_internal_securitynamegccs() const {
  return _impl_.securitynamegccs_.Get();
}
inline void SecurityDefinition::_internal_set_securitynamegccs(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.securitynamegccs_.Set(value, GetArenaForAllocation());
}
inline std::string* SecurityDefinition::_internal_mutable_securitynamegccs() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.securitynamegccs_.Mutable(GetArenaForAllocation());
}
inline std::string* SecurityDefinition::release_securitynamegccs() {
  // @@protoc_insertion_point(field_release:data.SecurityDefinition.securityNameGCCS)
  if (!_internal_has_securitynamegccs()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.securitynamegccs_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.securitynamegccs_.IsDefault()) {
    _impl_.securitynamegccs_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SecurityDefinition::set_allocated_securitynamegccs(std::string* securitynamegccs) {
  if (securitynamegccs != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.securitynamegccs_.SetAllocated(securitynamegccs, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.securitynamegccs_.IsDefault()) {
    _impl_.securitynamegccs_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:data.SecurityDefinition.securityNameGCCS)
}

// optional string securityNameGB = 10;
inline bool SecurityDefinition::_internal_has_securitynamegb() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool SecurityDefinition::has_securitynamegb() const {
  return _internal_has_securitynamegb();
}
inline void SecurityDefinition::clear_securitynamegb() {
  _impl_.securitynamegb_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& SecurityDefinition::securitynamegb() const {
  // @@protoc_insertion_point(field_get:data.SecurityDefinition.securityNameGB)
  return _internal_securitynamegb();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SecurityDefinition::set_securitynamegb(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000008u;
 _impl_.securitynamegb_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:data.SecurityDefinition.securityNameGB)
}
inline std::string* SecurityDefinition::mutable_securitynamegb() {
  std::string* _s = _internal_mutable_securitynamegb();
  // @@protoc_insertion_point(field_mutable:data.SecurityDefinition.securityNameGB)
  return _s;
}
inline const std::string& SecurityDefinition::_internal_securitynamegb() const {
  return _impl_.securitynamegb_.Get();
}
inline void SecurityDefinition::_internal_set_securitynamegb(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.securitynamegb_.Set(value, GetArenaForAllocation());
}
inline std::string* SecurityDefinition::_internal_mutable_securitynamegb() {
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.securitynamegb_.Mutable(GetArenaForAllocation());
}
inline std::string* SecurityDefinition::release_securitynamegb() {
  // @@protoc_insertion_point(field_release:data.SecurityDefinition.securityNameGB)
  if (!_internal_has_securitynamegb()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* p = _impl_.securitynamegb_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.securitynamegb_.IsDefault()) {
    _impl_.securitynamegb_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SecurityDefinition::set_allocated_securitynamegb(std::string* securitynamegb) {
  if (securitynamegb != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.securitynamegb_.SetAllocated(securitynamegb, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.securitynamegb_.IsDefault()) {
    _impl_.securitynamegb_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:data.SecurityDefinition.securityNameGB)
}

// optional int64 lotSize = 11;
inline bool SecurityDefinition::_internal_has_lotsize() const {
  bool value = (_impl_._has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool SecurityDefinition::has_lotsize() const {
  return _internal_has_lotsize();
}
inline void SecurityDefinition::clear_lotsize() {
  _impl_.lotsize_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00002000u;
}
inline int64_t SecurityDefinition::_internal_lotsize() const {
  return _impl_.lotsize_;
}
inline int64_t SecurityDefinition::lotsize() const {
  // @@protoc_insertion_point(field_get:data.SecurityDefinition.lotSize)
  return _internal_lotsize();
}
inline void SecurityDefinition::_internal_set_lotsize(int64_t value) {
  _impl_._has_bits_[0] |= 0x00002000u;
  _impl_.lotsize_ = value;
}
inline void SecurityDefinition::set_lotsize(int64_t value) {
  _internal_set_lotsize(value);
  // @@protoc_insertion_point(field_set:data.SecurityDefinition.lotSize)
}

// optional double previousClosingPrice = 12;
inline bool SecurityDefinition::_internal_has_previousclosingprice() const {
  bool value = (_impl_._has_bits_[0] & 0x00010000u) != 0;
  return value;
}
inline bool SecurityDefinition::has_previousclosingprice() const {
  return _internal_has_previousclosingprice();
}
inline void SecurityDefinition::clear_previousclosingprice() {
  _impl_.previousclosingprice_ = 0;
  _impl_._has_bits_[0] &= ~0x00010000u;
}
inline double SecurityDefinition::_internal_previousclosingprice() const {
  return _impl_.previousclosingprice_;
}
inline double SecurityDefinition::previousclosingprice() const {
  // @@protoc_insertion_point(field_get:data.SecurityDefinition.previousClosingPrice)
  return _internal_previousclosingprice();
}
inline void SecurityDefinition::_internal_set_previousclosingprice(double value) {
  _impl_._has_bits_[0] |= 0x00010000u;
  _impl_.previousclosingprice_ = value;
}
inline void SecurityDefinition::set_previousclosingprice(double value) {
  _internal_set_previousclosingprice(value);
  // @@protoc_insertion_point(field_set:data.SecurityDefinition.previousClosingPrice)
}

// optional string VCMFlag = 13;
inline bool SecurityDefinition::_internal_has_vcmflag() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool SecurityDefinition::has_vcmflag() const {
  return _internal_has_vcmflag();
}
inline void SecurityDefinition::clear_vcmflag() {
  _impl_.vcmflag_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const std::string& SecurityDefinition::vcmflag() const {
  // @@protoc_insertion_point(field_get:data.SecurityDefinition.VCMFlag)
  return _internal_vcmflag();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SecurityDefinition::set_vcmflag(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000010u;
 _impl_.vcmflag_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:data.SecurityDefinition.VCMFlag)
}
inline std::string* SecurityDefinition::mutable_vcmflag() {
  std::string* _s = _internal_mutable_vcmflag();
  // @@protoc_insertion_point(field_mutable:data.SecurityDefinition.VCMFlag)
  return _s;
}
inline const std::string& SecurityDefinition::_internal_vcmflag() const {
  return _impl_.vcmflag_.Get();
}
inline void SecurityDefinition::_internal_set_vcmflag(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.vcmflag_.Set(value, GetArenaForAllocation());
}
inline std::string* SecurityDefinition::_internal_mutable_vcmflag() {
  _impl_._has_bits_[0] |= 0x00000010u;
  return _impl_.vcmflag_.Mutable(GetArenaForAllocation());
}
inline std::string* SecurityDefinition::release_vcmflag() {
  // @@protoc_insertion_point(field_release:data.SecurityDefinition.VCMFlag)
  if (!_internal_has_vcmflag()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000010u;
  auto* p = _impl_.vcmflag_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.vcmflag_.IsDefault()) {
    _impl_.vcmflag_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SecurityDefinition::set_allocated_vcmflag(std::string* vcmflag) {
  if (vcmflag != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.vcmflag_.SetAllocated(vcmflag, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.vcmflag_.IsDefault()) {
    _impl_.vcmflag_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:data.SecurityDefinition.VCMFlag)
}

// optional .data.IndicatesWhether shortSellFlag = 14;
inline bool SecurityDefinition::_internal_has_shortsellflag() const {
  bool value = (_impl_._has_bits_[0] & 0x00008000u) != 0;
  return value;
}
inline bool SecurityDefinition::has_shortsellflag() const {
  return _internal_has_shortsellflag();
}
inline void SecurityDefinition::clear_shortsellflag() {
  _impl_.shortsellflag_ = 0;
  _impl_._has_bits_[0] &= ~0x00008000u;
}
inline ::data::IndicatesWhether SecurityDefinition::_internal_shortsellflag() const {
  return static_cast< ::data::IndicatesWhether >(_impl_.shortsellflag_);
}
inline ::data::IndicatesWhether SecurityDefinition::shortsellflag() const {
  // @@protoc_insertion_point(field_get:data.SecurityDefinition.shortSellFlag)
  return _internal_shortsellflag();
}
inline void SecurityDefinition::_internal_set_shortsellflag(::data::IndicatesWhether value) {
  _impl_._has_bits_[0] |= 0x00008000u;
  _impl_.shortsellflag_ = value;
}
inline void SecurityDefinition::set_shortsellflag(::data::IndicatesWhether value) {
  _internal_set_shortsellflag(value);
  // @@protoc_insertion_point(field_set:data.SecurityDefinition.shortSellFlag)
}

// optional .data.IndicatesWhether casFlag = 15;
inline bool SecurityDefinition::_internal_has_casflag() const {
  bool value = (_impl_._has_bits_[0] & 0x00020000u) != 0;
  return value;
}
inline bool SecurityDefinition::has_casflag() const {
  return _internal_has_casflag();
}
inline void SecurityDefinition::clear_casflag() {
  _impl_.casflag_ = 0;
  _impl_._has_bits_[0] &= ~0x00020000u;
}
inline ::data::IndicatesWhether SecurityDefinition::_internal_casflag() const {
  return static_cast< ::data::IndicatesWhether >(_impl_.casflag_);
}
inline ::data::IndicatesWhether SecurityDefinition::casflag() const {
  // @@protoc_insertion_point(field_get:data.SecurityDefinition.casFlag)
  return _internal_casflag();
}
inline void SecurityDefinition::_internal_set_casflag(::data::IndicatesWhether value) {
  _impl_._has_bits_[0] |= 0x00020000u;
  _impl_.casflag_ = value;
}
inline void SecurityDefinition::set_casflag(::data::IndicatesWhether value) {
  _internal_set_casflag(value);
  // @@protoc_insertion_point(field_set:data.SecurityDefinition.casFlag)
}

// optional .data.IndicatesWhether CCASSFlag = 16;
inline bool SecurityDefinition::_internal_has_ccassflag() const {
  bool value = (_impl_._has_bits_[0] & 0x00040000u) != 0;
  return value;
}
inline bool SecurityDefinition::has_ccassflag() const {
  return _internal_has_ccassflag();
}
inline void SecurityDefinition::clear_ccassflag() {
  _impl_.ccassflag_ = 0;
  _impl_._has_bits_[0] &= ~0x00040000u;
}
inline ::data::IndicatesWhether SecurityDefinition::_internal_ccassflag() const {
  return static_cast< ::data::IndicatesWhether >(_impl_.ccassflag_);
}
inline ::data::IndicatesWhether SecurityDefinition::ccassflag() const {
  // @@protoc_insertion_point(field_get:data.SecurityDefinition.CCASSFlag)
  return _internal_ccassflag();
}
inline void SecurityDefinition::_internal_set_ccassflag(::data::IndicatesWhether value) {
  _impl_._has_bits_[0] |= 0x00040000u;
  _impl_.ccassflag_ = value;
}
inline void SecurityDefinition::set_ccassflag(::data::IndicatesWhether value) {
  _internal_set_ccassflag(value);
  // @@protoc_insertion_point(field_set:data.SecurityDefinition.CCASSFlag)
}

// optional .data.IndicatesWhether dummySecurityFlag = 17;
inline bool SecurityDefinition::_internal_has_dummysecurityflag() const {
  bool value = (_impl_._has_bits_[0] & 0x00080000u) != 0;
  return value;
}
inline bool SecurityDefinition::has_dummysecurityflag() const {
  return _internal_has_dummysecurityflag();
}
inline void SecurityDefinition::clear_dummysecurityflag() {
  _impl_.dummysecurityflag_ = 0;
  _impl_._has_bits_[0] &= ~0x00080000u;
}
inline ::data::IndicatesWhether SecurityDefinition::_internal_dummysecurityflag() const {
  return static_cast< ::data::IndicatesWhether >(_impl_.dummysecurityflag_);
}
inline ::data::IndicatesWhether SecurityDefinition::dummysecurityflag() const {
  // @@protoc_insertion_point(field_get:data.SecurityDefinition.dummySecurityFlag)
  return _internal_dummysecurityflag();
}
inline void SecurityDefinition::_internal_set_dummysecurityflag(::data::IndicatesWhether value) {
  _impl_._has_bits_[0] |= 0x00080000u;
  _impl_.dummysecurityflag_ = value;
}
inline void SecurityDefinition::set_dummysecurityflag(::data::IndicatesWhether value) {
  _internal_set_dummysecurityflag(value);
  // @@protoc_insertion_point(field_set:data.SecurityDefinition.dummySecurityFlag)
}

// optional .data.IndicatesWhether stampDutyFlag = 18;
inline bool SecurityDefinition::_internal_has_stampdutyflag() const {
  bool value = (_impl_._has_bits_[0] & 0x00100000u) != 0;
  return value;
}
inline bool SecurityDefinition::has_stampdutyflag() const {
  return _internal_has_stampdutyflag();
}
inline void SecurityDefinition::clear_stampdutyflag() {
  _impl_.stampdutyflag_ = 0;
  _impl_._has_bits_[0] &= ~0x00100000u;
}
inline ::data::IndicatesWhether SecurityDefinition::_internal_stampdutyflag() const {
  return static_cast< ::data::IndicatesWhether >(_impl_.stampdutyflag_);
}
inline ::data::IndicatesWhether SecurityDefinition::stampdutyflag() const {
  // @@protoc_insertion_point(field_get:data.SecurityDefinition.stampDutyFlag)
  return _internal_stampdutyflag();
}
inline void SecurityDefinition::_internal_set_stampdutyflag(::data::IndicatesWhether value) {
  _impl_._has_bits_[0] |= 0x00100000u;
  _impl_.stampdutyflag_ = value;
}
inline void SecurityDefinition::set_stampdutyflag(::data::IndicatesWhether value) {
  _internal_set_stampdutyflag(value);
  // @@protoc_insertion_point(field_set:data.SecurityDefinition.stampDutyFlag)
}

// optional int64 listingDate = 19;
inline bool SecurityDefinition::_internal_has_listingdate() const {
  bool value = (_impl_._has_bits_[0] & 0x00200000u) != 0;
  return value;
}
inline bool SecurityDefinition::has_listingdate() const {
  return _internal_has_listingdate();
}
inline void SecurityDefinition::clear_listingdate() {
  _impl_.listingdate_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00200000u;
}
inline int64_t SecurityDefinition::_internal_listingdate() const {
  return _impl_.listingdate_;
}
inline int64_t SecurityDefinition::listingdate() const {
  // @@protoc_insertion_point(field_get:data.SecurityDefinition.listingDate)
  return _internal_listingdate();
}
inline void SecurityDefinition::_internal_set_listingdate(int64_t value) {
  _impl_._has_bits_[0] |= 0x00200000u;
  _impl_.listingdate_ = value;
}
inline void SecurityDefinition::set_listingdate(int64_t value) {
  _internal_set_listingdate(value);
  // @@protoc_insertion_point(field_set:data.SecurityDefinition.listingDate)
}

// optional int64 delistingDate = 20;
inline bool SecurityDefinition::_internal_has_delistingdate() const {
  bool value = (_impl_._has_bits_[0] & 0x00400000u) != 0;
  return value;
}
inline bool SecurityDefinition::has_delistingdate() const {
  return _internal_has_delistingdate();
}
inline void SecurityDefinition::clear_delistingdate() {
  _impl_.delistingdate_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00400000u;
}
inline int64_t SecurityDefinition::_internal_delistingdate() const {
  return _impl_.delistingdate_;
}
inline int64_t SecurityDefinition::delistingdate() const {
  // @@protoc_insertion_point(field_get:data.SecurityDefinition.delistingDate)
  return _internal_delistingdate();
}
inline void SecurityDefinition::_internal_set_delistingdate(int64_t value) {
  _impl_._has_bits_[0] |= 0x00400000u;
  _impl_.delistingdate_ = value;
}
inline void SecurityDefinition::set_delistingdate(int64_t value) {
  _internal_set_delistingdate(value);
  // @@protoc_insertion_point(field_set:data.SecurityDefinition.delistingDate)
}

// optional string freeText = 21;
inline bool SecurityDefinition::_internal_has_freetext() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool SecurityDefinition::has_freetext() const {
  return _internal_has_freetext();
}
inline void SecurityDefinition::clear_freetext() {
  _impl_.freetext_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const std::string& SecurityDefinition::freetext() const {
  // @@protoc_insertion_point(field_get:data.SecurityDefinition.freeText)
  return _internal_freetext();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SecurityDefinition::set_freetext(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000020u;
 _impl_.freetext_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:data.SecurityDefinition.freeText)
}
inline std::string* SecurityDefinition::mutable_freetext() {
  std::string* _s = _internal_mutable_freetext();
  // @@protoc_insertion_point(field_mutable:data.SecurityDefinition.freeText)
  return _s;
}
inline const std::string& SecurityDefinition::_internal_freetext() const {
  return _impl_.freetext_.Get();
}
inline void SecurityDefinition::_internal_set_freetext(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.freetext_.Set(value, GetArenaForAllocation());
}
inline std::string* SecurityDefinition::_internal_mutable_freetext() {
  _impl_._has_bits_[0] |= 0x00000020u;
  return _impl_.freetext_.Mutable(GetArenaForAllocation());
}
inline std::string* SecurityDefinition::release_freetext() {
  // @@protoc_insertion_point(field_release:data.SecurityDefinition.freeText)
  if (!_internal_has_freetext()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000020u;
  auto* p = _impl_.freetext_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.freetext_.IsDefault()) {
    _impl_.freetext_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SecurityDefinition::set_allocated_freetext(std::string* freetext) {
  if (freetext != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.freetext_.SetAllocated(freetext, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.freetext_.IsDefault()) {
    _impl_.freetext_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:data.SecurityDefinition.freeText)
}

// optional .data.IndicatesWhether posFlag = 22;
inline bool SecurityDefinition::_internal_has_posflag() const {
  bool value = (_impl_._has_bits_[0] & 0x00800000u) != 0;
  return value;
}
inline bool SecurityDefinition::has_posflag() const {
  return _internal_has_posflag();
}
inline void SecurityDefinition::clear_posflag() {
  _impl_.posflag_ = 0;
  _impl_._has_bits_[0] &= ~0x00800000u;
}
inline ::data::IndicatesWhether SecurityDefinition::_internal_posflag() const {
  return static_cast< ::data::IndicatesWhether >(_impl_.posflag_);
}
inline ::data::IndicatesWhether SecurityDefinition::posflag() const {
  // @@protoc_insertion_point(field_get:data.SecurityDefinition.posFlag)
  return _internal_posflag();
}
inline void SecurityDefinition::_internal_set_posflag(::data::IndicatesWhether value) {
  _impl_._has_bits_[0] |= 0x00800000u;
  _impl_.posflag_ = value;
}
inline void SecurityDefinition::set_posflag(::data::IndicatesWhether value) {
  _internal_set_posflag(value);
  // @@protoc_insertion_point(field_set:data.SecurityDefinition.posFlag)
}

// optional int32 posUpperLimit = 23;
inline bool SecurityDefinition::_internal_has_posupperlimit() const {
  bool value = (_impl_._has_bits_[0] & 0x01000000u) != 0;
  return value;
}
inline bool SecurityDefinition::has_posupperlimit() const {
  return _internal_has_posupperlimit();
}
inline void SecurityDefinition::clear_posupperlimit() {
  _impl_.posupperlimit_ = 0;
  _impl_._has_bits_[0] &= ~0x01000000u;
}
inline int32_t SecurityDefinition::_internal_posupperlimit() const {
  return _impl_.posupperlimit_;
}
inline int32_t SecurityDefinition::posupperlimit() const {
  // @@protoc_insertion_point(field_get:data.SecurityDefinition.posUpperLimit)
  return _internal_posupperlimit();
}
inline void SecurityDefinition::_internal_set_posupperlimit(int32_t value) {
  _impl_._has_bits_[0] |= 0x01000000u;
  _impl_.posupperlimit_ = value;
}
inline void SecurityDefinition::set_posupperlimit(int32_t value) {
  _internal_set_posupperlimit(value);
  // @@protoc_insertion_point(field_set:data.SecurityDefinition.posUpperLimit)
}

// optional int32 posLowerLimit = 24;
inline bool SecurityDefinition::_internal_has_poslowerlimit() const {
  bool value = (_impl_._has_bits_[0] & 0x02000000u) != 0;
  return value;
}
inline bool SecurityDefinition::has_poslowerlimit() const {
  return _internal_has_poslowerlimit();
}
inline void SecurityDefinition::clear_poslowerlimit() {
  _impl_.poslowerlimit_ = 0;
  _impl_._has_bits_[0] &= ~0x02000000u;
}
inline int32_t SecurityDefinition::_internal_poslowerlimit() const {
  return _impl_.poslowerlimit_;
}
inline int32_t SecurityDefinition::poslowerlimit() const {
  // @@protoc_insertion_point(field_get:data.SecurityDefinition.posLowerLimit)
  return _internal_poslowerlimit();
}
inline void SecurityDefinition::_internal_set_poslowerlimit(int32_t value) {
  _impl_._has_bits_[0] |= 0x02000000u;
  _impl_.poslowerlimit_ = value;
}
inline void SecurityDefinition::set_poslowerlimit(int32_t value) {
  _internal_set_poslowerlimit(value);
  // @@protoc_insertion_point(field_set:data.SecurityDefinition.posLowerLimit)
}

// optional .data.IndicatesWhether EFNFlag = 25;
inline bool SecurityDefinition::_internal_has_efnflag() const {
  bool value = (_impl_._has_bits_[0] & 0x04000000u) != 0;
  return value;
}
inline bool SecurityDefinition::has_efnflag() const {
  return _internal_has_efnflag();
}
inline void SecurityDefinition::clear_efnflag() {
  _impl_.efnflag_ = 0;
  _impl_._has_bits_[0] &= ~0x04000000u;
}
inline ::data::IndicatesWhether SecurityDefinition::_internal_efnflag() const {
  return static_cast< ::data::IndicatesWhether >(_impl_.efnflag_);
}
inline ::data::IndicatesWhether SecurityDefinition::efnflag() const {
  // @@protoc_insertion_point(field_get:data.SecurityDefinition.EFNFlag)
  return _internal_efnflag();
}
inline void SecurityDefinition::_internal_set_efnflag(::data::IndicatesWhether value) {
  _impl_._has_bits_[0] |= 0x04000000u;
  _impl_.efnflag_ = value;
}
inline void SecurityDefinition::set_efnflag(::data::IndicatesWhether value) {
  _internal_set_efnflag(value);
  // @@protoc_insertion_point(field_set:data.SecurityDefinition.EFNFlag)
}

// optional double accruedInterest = 26;
inline bool SecurityDefinition::_internal_has_accruedinterest() const {
  bool value = (_impl_._has_bits_[0] & 0x08000000u) != 0;
  return value;
}
inline bool SecurityDefinition::has_accruedinterest() const {
  return _internal_has_accruedinterest();
}
inline void SecurityDefinition::clear_accruedinterest() {
  _impl_.accruedinterest_ = 0;
  _impl_._has_bits_[0] &= ~0x08000000u;
}
inline double SecurityDefinition::_internal_accruedinterest() const {
  return _impl_.accruedinterest_;
}
inline double SecurityDefinition::accruedinterest() const {
  // @@protoc_insertion_point(field_get:data.SecurityDefinition.accruedInterest)
  return _internal_accruedinterest();
}
inline void SecurityDefinition::_internal_set_accruedinterest(double value) {
  _impl_._has_bits_[0] |= 0x08000000u;
  _impl_.accruedinterest_ = value;
}
inline void SecurityDefinition::set_accruedinterest(double value) {
  _internal_set_accruedinterest(value);
  // @@protoc_insertion_point(field_set:data.SecurityDefinition.accruedInterest)
}

// optional double couponRate = 27;
inline bool SecurityDefinition::_internal_has_couponrate() const {
  bool value = (_impl_._has_bits_[0] & 0x10000000u) != 0;
  return value;
}
inline bool SecurityDefinition::has_couponrate() const {
  return _internal_has_couponrate();
}
inline void SecurityDefinition::clear_couponrate() {
  _impl_.couponrate_ = 0;
  _impl_._has_bits_[0] &= ~0x10000000u;
}
inline double SecurityDefinition::_internal_couponrate() const {
  return _impl_.couponrate_;
}
inline double SecurityDefinition::couponrate() const {
  // @@protoc_insertion_point(field_get:data.SecurityDefinition.couponRate)
  return _internal_couponrate();
}
inline void SecurityDefinition::_internal_set_couponrate(double value) {
  _impl_._has_bits_[0] |= 0x10000000u;
  _impl_.couponrate_ = value;
}
inline void SecurityDefinition::set_couponrate(double value) {
  _internal_set_couponrate(value);
  // @@protoc_insertion_point(field_set:data.SecurityDefinition.couponRate)
}

// optional int64 faceValue = 28;
inline bool SecurityDefinition::_internal_has_facevalue() const {
  bool value = (_impl_._has_bits_[0] & 0x20000000u) != 0;
  return value;
}
inline bool SecurityDefinition::has_facevalue() const {
  return _internal_has_facevalue();
}
inline void SecurityDefinition::clear_facevalue() {
  _impl_.facevalue_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x20000000u;
}
inline int64_t SecurityDefinition::_internal_facevalue() const {
  return _impl_.facevalue_;
}
inline int64_t SecurityDefinition::facevalue() const {
  // @@protoc_insertion_point(field_get:data.SecurityDefinition.faceValue)
  return _internal_facevalue();
}
inline void SecurityDefinition::_internal_set_facevalue(int64_t value) {
  _impl_._has_bits_[0] |= 0x20000000u;
  _impl_.facevalue_ = value;
}
inline void SecurityDefinition::set_facevalue(int64_t value) {
  _internal_set_facevalue(value);
  // @@protoc_insertion_point(field_set:data.SecurityDefinition.faceValue)
}

// optional int32 decimalsInFaceValue = 29;
inline bool SecurityDefinition::_internal_has_decimalsinfacevalue() const {
  bool value = (_impl_._has_bits_[0] & 0x40000000u) != 0;
  return value;
}
inline bool SecurityDefinition::has_decimalsinfacevalue() const {
  return _internal_has_decimalsinfacevalue();
}
inline void SecurityDefinition::clear_decimalsinfacevalue() {
  _impl_.decimalsinfacevalue_ = 0;
  _impl_._has_bits_[0] &= ~0x40000000u;
}
inline int32_t SecurityDefinition::_internal_decimalsinfacevalue() const {
  return _impl_.decimalsinfacevalue_;
}
inline int32_t SecurityDefinition::decimalsinfacevalue() const {
  // @@protoc_insertion_point(field_get:data.SecurityDefinition.decimalsInFaceValue)
  return _internal_decimalsinfacevalue();
}
inline void SecurityDefinition::_internal_set_decimalsinfacevalue(int32_t value) {
  _impl_._has_bits_[0] |= 0x40000000u;
  _impl_.decimalsinfacevalue_ = value;
}
inline void SecurityDefinition::set_decimalsinfacevalue(int32_t value) {
  _internal_set_decimalsinfacevalue(value);
  // @@protoc_insertion_point(field_set:data.SecurityDefinition.decimalsInFaceValue)
}

// optional string faceValueCurrency = 30;
inline bool SecurityDefinition::_internal_has_facevaluecurrency() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool SecurityDefinition::has_facevaluecurrency() const {
  return _internal_has_facevaluecurrency();
}
inline void SecurityDefinition::clear_facevaluecurrency() {
  _impl_.facevaluecurrency_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline const std::string& SecurityDefinition::facevaluecurrency() const {
  // @@protoc_insertion_point(field_get:data.SecurityDefinition.faceValueCurrency)
  return _internal_facevaluecurrency();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SecurityDefinition::set_facevaluecurrency(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000040u;
 _impl_.facevaluecurrency_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:data.SecurityDefinition.faceValueCurrency)
}
inline std::string* SecurityDefinition::mutable_facevaluecurrency() {
  std::string* _s = _internal_mutable_facevaluecurrency();
  // @@protoc_insertion_point(field_mutable:data.SecurityDefinition.faceValueCurrency)
  return _s;
}
inline const std::string& SecurityDefinition::_internal_facevaluecurrency() const {
  return _impl_.facevaluecurrency_.Get();
}
inline void SecurityDefinition::_internal_set_facevaluecurrency(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.facevaluecurrency_.Set(value, GetArenaForAllocation());
}
inline std::string* SecurityDefinition::_internal_mutable_facevaluecurrency() {
  _impl_._has_bits_[0] |= 0x00000040u;
  return _impl_.facevaluecurrency_.Mutable(GetArenaForAllocation());
}
inline std::string* SecurityDefinition::release_facevaluecurrency() {
  // @@protoc_insertion_point(field_release:data.SecurityDefinition.faceValueCurrency)
  if (!_internal_has_facevaluecurrency()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000040u;
  auto* p = _impl_.facevaluecurrency_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.facevaluecurrency_.IsDefault()) {
    _impl_.facevaluecurrency_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SecurityDefinition::set_allocated_facevaluecurrency(std::string* facevaluecurrency) {
  if (facevaluecurrency != nullptr) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  _impl_.facevaluecurrency_.SetAllocated(facevaluecurrency, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.facevaluecurrency_.IsDefault()) {
    _impl_.facevaluecurrency_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:data.SecurityDefinition.faceValueCurrency)
}

// optional int64 bondMaturityDate = 31;
inline bool SecurityDefinition::_internal_has_bondmaturitydate() const {
  bool value = (_impl_._has_bits_[1] & 0x00000001u) != 0;
  return value;
}
inline bool SecurityDefinition::has_bondmaturitydate() const {
  return _internal_has_bondmaturitydate();
}
inline void SecurityDefinition::clear_bondmaturitydate() {
  _impl_.bondmaturitydate_ = int64_t{0};
  _impl_._has_bits_[1] &= ~0x00000001u;
}
inline int64_t SecurityDefinition::_internal_bondmaturitydate() const {
  return _impl_.bondmaturitydate_;
}
inline int64_t SecurityDefinition::bondmaturitydate() const {
  // @@protoc_insertion_point(field_get:data.SecurityDefinition.bondMaturityDate)
  return _internal_bondmaturitydate();
}
inline void SecurityDefinition::_internal_set_bondmaturitydate(int64_t value) {
  _impl_._has_bits_[1] |= 0x00000001u;
  _impl_.bondmaturitydate_ = value;
}
inline void SecurityDefinition::set_bondmaturitydate(int64_t value) {
  _internal_set_bondmaturitydate(value);
  // @@protoc_insertion_point(field_set:data.SecurityDefinition.bondMaturityDate)
}

// optional .data.InvestorType investorType = 32;
inline bool SecurityDefinition::_internal_has_investortype() const {
  bool value = (_impl_._has_bits_[0] & 0x80000000u) != 0;
  return value;
}
inline bool SecurityDefinition::has_investortype() const {
  return _internal_has_investortype();
}
inline void SecurityDefinition::clear_investortype() {
  _impl_.investortype_ = 0;
  _impl_._has_bits_[0] &= ~0x80000000u;
}
inline ::data::InvestorType SecurityDefinition::_internal_investortype() const {
  return static_cast< ::data::InvestorType >(_impl_.investortype_);
}
inline ::data::InvestorType SecurityDefinition::investortype() const {
  // @@protoc_insertion_point(field_get:data.SecurityDefinition.investorType)
  return _internal_investortype();
}
inline void SecurityDefinition::_internal_set_investortype(::data::InvestorType value) {
  _impl_._has_bits_[0] |= 0x80000000u;
  _impl_.investortype_ = value;
}
inline void SecurityDefinition::set_investortype(::data::InvestorType value) {
  _internal_set_investortype(value);
  // @@protoc_insertion_point(field_set:data.SecurityDefinition.investorType)
}

// optional double conversionRatio = 33;
inline bool SecurityDefinition::_internal_has_conversionratio() const {
  bool value = (_impl_._has_bits_[1] & 0x00000002u) != 0;
  return value;
}
inline bool SecurityDefinition::has_conversionratio() const {
  return _internal_has_conversionratio();
}
inline void SecurityDefinition::clear_conversionratio() {
  _impl_.conversionratio_ = 0;
  _impl_._has_bits_[1] &= ~0x00000002u;
}
inline double SecurityDefinition::_internal_conversionratio() const {
  return _impl_.conversionratio_;
}
inline double SecurityDefinition::conversionratio() const {
  // @@protoc_insertion_point(field_get:data.SecurityDefinition.conversionRatio)
  return _internal_conversionratio();
}
inline void SecurityDefinition::_internal_set_conversionratio(double value) {
  _impl_._has_bits_[1] |= 0x00000002u;
  _impl_.conversionratio_ = value;
}
inline void SecurityDefinition::set_conversionratio(double value) {
  _internal_set_conversionratio(value);
  // @@protoc_insertion_point(field_set:data.SecurityDefinition.conversionRatio)
}

// optional double strikePrice1 = 34;
inline bool SecurityDefinition::_internal_has_strikeprice1() const {
  bool value = (_impl_._has_bits_[1] & 0x00000004u) != 0;
  return value;
}
inline bool SecurityDefinition::has_strikeprice1() const {
  return _internal_has_strikeprice1();
}
inline void SecurityDefinition::clear_strikeprice1() {
  _impl_.strikeprice1_ = 0;
  _impl_._has_bits_[1] &= ~0x00000004u;
}
inline double SecurityDefinition::_internal_strikeprice1() const {
  return _impl_.strikeprice1_;
}
inline double SecurityDefinition::strikeprice1() const {
  // @@protoc_insertion_point(field_get:data.SecurityDefinition.strikePrice1)
  return _internal_strikeprice1();
}
inline void SecurityDefinition::_internal_set_strikeprice1(double value) {
  _impl_._has_bits_[1] |= 0x00000004u;
  _impl_.strikeprice1_ = value;
}
inline void SecurityDefinition::set_strikeprice1(double value) {
  _internal_set_strikeprice1(value);
  // @@protoc_insertion_point(field_set:data.SecurityDefinition.strikePrice1)
}

// optional double strikePrice2 = 35;
inline bool SecurityDefinition::_internal_has_strikeprice2() const {
  bool value = (_impl_._has_bits_[1] & 0x00000008u) != 0;
  return value;
}
inline bool SecurityDefinition::has_strikeprice2() const {
  return _internal_has_strikeprice2();
}
inline void SecurityDefinition::clear_strikeprice2() {
  _impl_.strikeprice2_ = 0;
  _impl_._has_bits_[1] &= ~0x00000008u;
}
inline double SecurityDefinition::_internal_strikeprice2() const {
  return _impl_.strikeprice2_;
}
inline double SecurityDefinition::strikeprice2() const {
  // @@protoc_insertion_point(field_get:data.SecurityDefinition.strikePrice2)
  return _internal_strikeprice2();
}
inline void SecurityDefinition::_internal_set_strikeprice2(double value) {
  _impl_._has_bits_[1] |= 0x00000008u;
  _impl_.strikeprice2_ = value;
}
inline void SecurityDefinition::set_strikeprice2(double value) {
  _internal_set_strikeprice2(value);
  // @@protoc_insertion_point(field_set:data.SecurityDefinition.strikePrice2)
}

// optional int64 warrantMaturityDate = 36;
inline bool SecurityDefinition::_internal_has_warrantmaturitydate() const {
  bool value = (_impl_._has_bits_[1] & 0x00000010u) != 0;
  return value;
}
inline bool SecurityDefinition::has_warrantmaturitydate() const {
  return _internal_has_warrantmaturitydate();
}
inline void SecurityDefinition::clear_warrantmaturitydate() {
  _impl_.warrantmaturitydate_ = int64_t{0};
  _impl_._has_bits_[1] &= ~0x00000010u;
}
inline int64_t SecurityDefinition::_internal_warrantmaturitydate() const {
  return _impl_.warrantmaturitydate_;
}
inline int64_t SecurityDefinition::warrantmaturitydate() const {
  // @@protoc_insertion_point(field_get:data.SecurityDefinition.warrantMaturityDate)
  return _internal_warrantmaturitydate();
}
inline void SecurityDefinition::_internal_set_warrantmaturitydate(int64_t value) {
  _impl_._has_bits_[1] |= 0x00000010u;
  _impl_.warrantmaturitydate_ = value;
}
inline void SecurityDefinition::set_warrantmaturitydate(int64_t value) {
  _internal_set_warrantmaturitydate(value);
  // @@protoc_insertion_point(field_set:data.SecurityDefinition.warrantMaturityDate)
}

// optional .data.CallPutFlag callPutFlag = 37;
inline bool SecurityDefinition::_internal_has_callputflag() const {
  bool value = (_impl_._has_bits_[1] & 0x00000020u) != 0;
  return value;
}
inline bool SecurityDefinition::has_callputflag() const {
  return _internal_has_callputflag();
}
inline void SecurityDefinition::clear_callputflag() {
  _impl_.callputflag_ = 0;
  _impl_._has_bits_[1] &= ~0x00000020u;
}
inline ::data::CallPutFlag SecurityDefinition::_internal_callputflag() const {
  return static_cast< ::data::CallPutFlag >(_impl_.callputflag_);
}
inline ::data::CallPutFlag SecurityDefinition::callputflag() const {
  // @@protoc_insertion_point(field_get:data.SecurityDefinition.callPutFlag)
  return _internal_callputflag();
}
inline void SecurityDefinition::_internal_set_callputflag(::data::CallPutFlag value) {
  _impl_._has_bits_[1] |= 0x00000020u;
  _impl_.callputflag_ = value;
}
inline void SecurityDefinition::set_callputflag(::data::CallPutFlag value) {
  _internal_set_callputflag(value);
  // @@protoc_insertion_point(field_set:data.SecurityDefinition.callPutFlag)
}

// optional .data.Style style = 38;
inline bool SecurityDefinition::_internal_has_style() const {
  bool value = (_impl_._has_bits_[1] & 0x00000040u) != 0;
  return value;
}
inline bool SecurityDefinition::has_style() const {
  return _internal_has_style();
}
inline void SecurityDefinition::clear_style() {
  _impl_.style_ = 0;
  _impl_._has_bits_[1] &= ~0x00000040u;
}
inline ::data::Style SecurityDefinition::_internal_style() const {
  return static_cast< ::data::Style >(_impl_.style_);
}
inline ::data::Style SecurityDefinition::style() const {
  // @@protoc_insertion_point(field_get:data.SecurityDefinition.style)
  return _internal_style();
}
inline void SecurityDefinition::_internal_set_style(::data::Style value) {
  _impl_._has_bits_[1] |= 0x00000040u;
  _impl_.style_ = value;
}
inline void SecurityDefinition::set_style(::data::Style value) {
  _internal_set_style(value);
  // @@protoc_insertion_point(field_set:data.SecurityDefinition.style)
}

// optional string warrantType = 39;
inline bool SecurityDefinition::_internal_has_warranttype() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool SecurityDefinition::has_warranttype() const {
  return _internal_has_warranttype();
}
inline void SecurityDefinition::clear_warranttype() {
  _impl_.warranttype_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline const std::string& SecurityDefinition::warranttype() const {
  // @@protoc_insertion_point(field_get:data.SecurityDefinition.warrantType)
  return _internal_warranttype();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SecurityDefinition::set_warranttype(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000080u;
 _impl_.warranttype_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:data.SecurityDefinition.warrantType)
}
inline std::string* SecurityDefinition::mutable_warranttype() {
  std::string* _s = _internal_mutable_warranttype();
  // @@protoc_insertion_point(field_mutable:data.SecurityDefinition.warrantType)
  return _s;
}
inline const std::string& SecurityDefinition::_internal_warranttype() const {
  return _impl_.warranttype_.Get();
}
inline void SecurityDefinition::_internal_set_warranttype(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.warranttype_.Set(value, GetArenaForAllocation());
}
inline std::string* SecurityDefinition::_internal_mutable_warranttype() {
  _impl_._has_bits_[0] |= 0x00000080u;
  return _impl_.warranttype_.Mutable(GetArenaForAllocation());
}
inline std::string* SecurityDefinition::release_warranttype() {
  // @@protoc_insertion_point(field_release:data.SecurityDefinition.warrantType)
  if (!_internal_has_warranttype()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000080u;
  auto* p = _impl_.warranttype_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.warranttype_.IsDefault()) {
    _impl_.warranttype_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SecurityDefinition::set_allocated_warranttype(std::string* warranttype) {
  if (warranttype != nullptr) {
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  _impl_.warranttype_.SetAllocated(warranttype, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.warranttype_.IsDefault()) {
    _impl_.warranttype_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:data.SecurityDefinition.warrantType)
}

// optional int32 callPrice = 40;
inline bool SecurityDefinition::_internal_has_callprice() const {
  bool value = (_impl_._has_bits_[1] & 0x00000080u) != 0;
  return value;
}
inline bool SecurityDefinition::has_callprice() const {
  return _internal_has_callprice();
}
inline void SecurityDefinition::clear_callprice() {
  _impl_.callprice_ = 0;
  _impl_._has_bits_[1] &= ~0x00000080u;
}
inline int32_t SecurityDefinition::_internal_callprice() const {
  return _impl_.callprice_;
}
inline int32_t SecurityDefinition::callprice() const {
  // @@protoc_insertion_point(field_get:data.SecurityDefinition.callPrice)
  return _internal_callprice();
}
inline void SecurityDefinition::_internal_set_callprice(int32_t value) {
  _impl_._has_bits_[1] |= 0x00000080u;
  _impl_.callprice_ = value;
}
inline void SecurityDefinition::set_callprice(int32_t value) {
  _internal_set_callprice(value);
  // @@protoc_insertion_point(field_set:data.SecurityDefinition.callPrice)
}

// optional int32 DecimalsInCallPrice = 41;
inline bool SecurityDefinition::_internal_has_decimalsincallprice() const {
  bool value = (_impl_._has_bits_[1] & 0x00000100u) != 0;
  return value;
}
inline bool SecurityDefinition::has_decimalsincallprice() const {
  return _internal_has_decimalsincallprice();
}
inline void SecurityDefinition::clear_decimalsincallprice() {
  _impl_.decimalsincallprice_ = 0;
  _impl_._has_bits_[1] &= ~0x00000100u;
}
inline int32_t SecurityDefinition::_internal_decimalsincallprice() const {
  return _impl_.decimalsincallprice_;
}
inline int32_t SecurityDefinition::decimalsincallprice() const {
  // @@protoc_insertion_point(field_get:data.SecurityDefinition.DecimalsInCallPrice)
  return _internal_decimalsincallprice();
}
inline void SecurityDefinition::_internal_set_decimalsincallprice(int32_t value) {
  _impl_._has_bits_[1] |= 0x00000100u;
  _impl_.decimalsincallprice_ = value;
}
inline void SecurityDefinition::set_decimalsincallprice(int32_t value) {
  _internal_set_decimalsincallprice(value);
  // @@protoc_insertion_point(field_set:data.SecurityDefinition.DecimalsInCallPrice)
}

// optional int32 entitlement = 42;
inline bool SecurityDefinition::_internal_has_entitlement() const {
  bool value = (_impl_._has_bits_[1] & 0x00000200u) != 0;
  return value;
}
inline bool SecurityDefinition::has_entitlement() const {
  return _internal_has_entitlement();
}
inline void SecurityDefinition::clear_entitlement() {
  _impl_.entitlement_ = 0;
  _impl_._has_bits_[1] &= ~0x00000200u;
}
inline int32_t SecurityDefinition::_internal_entitlement() const {
  return _impl_.entitlement_;
}
inline int32_t SecurityDefinition::entitlement() const {
  // @@protoc_insertion_point(field_get:data.SecurityDefinition.entitlement)
  return _internal_entitlement();
}
inline void SecurityDefinition::_internal_set_entitlement(int32_t value) {
  _impl_._has_bits_[1] |= 0x00000200u;
  _impl_.entitlement_ = value;
}
inline void SecurityDefinition::set_entitlement(int32_t value) {
  _internal_set_entitlement(value);
  // @@protoc_insertion_point(field_set:data.SecurityDefinition.entitlement)
}

// optional int32 decimalsInEntitlement = 43;
inline bool SecurityDefinition::_internal_has_decimalsinentitlement() const {
  bool value = (_impl_._has_bits_[1] & 0x00000400u) != 0;
  return value;
}
inline bool SecurityDefinition::has_decimalsinentitlement() const {
  return _internal_has_decimalsinentitlement();
}
inline void SecurityDefinition::clear_decimalsinentitlement() {
  _impl_.decimalsinentitlement_ = 0;
  _impl_._has_bits_[1] &= ~0x00000400u;
}
inline int32_t SecurityDefinition::_internal_decimalsinentitlement() const {
  return _impl_.decimalsinentitlement_;
}
inline int32_t SecurityDefinition::decimalsinentitlement() const {
  // @@protoc_insertion_point(field_get:data.SecurityDefinition.decimalsInEntitlement)
  return _internal_decimalsinentitlement();
}
inline void SecurityDefinition::_internal_set_decimalsinentitlement(int32_t value) {
  _impl_._has_bits_[1] |= 0x00000400u;
  _impl_.decimalsinentitlement_ = value;
}
inline void SecurityDefinition::set_decimalsinentitlement(int32_t value) {
  _internal_set_decimalsinentitlement(value);
  // @@protoc_insertion_point(field_set:data.SecurityDefinition.decimalsInEntitlement)
}

// optional int64 noWarrantsPerEntitlement = 44;
inline bool SecurityDefinition::_internal_has_nowarrantsperentitlement() const {
  bool value = (_impl_._has_bits_[1] & 0x00000800u) != 0;
  return value;
}
inline bool SecurityDefinition::has_nowarrantsperentitlement() const {
  return _internal_has_nowarrantsperentitlement();
}
inline void SecurityDefinition::clear_nowarrantsperentitlement() {
  _impl_.nowarrantsperentitlement_ = int64_t{0};
  _impl_._has_bits_[1] &= ~0x00000800u;
}
inline int64_t SecurityDefinition::_internal_nowarrantsperentitlement() const {
  return _impl_.nowarrantsperentitlement_;
}
inline int64_t SecurityDefinition::nowarrantsperentitlement() const {
  // @@protoc_insertion_point(field_get:data.SecurityDefinition.noWarrantsPerEntitlement)
  return _internal_nowarrantsperentitlement();
}
inline void SecurityDefinition::_internal_set_nowarrantsperentitlement(int64_t value) {
  _impl_._has_bits_[1] |= 0x00000800u;
  _impl_.nowarrantsperentitlement_ = value;
}
inline void SecurityDefinition::set_nowarrantsperentitlement(int64_t value) {
  _internal_set_nowarrantsperentitlement(value);
  // @@protoc_insertion_point(field_set:data.SecurityDefinition.noWarrantsPerEntitlement)
}

// repeated .data.NoUnderlyingSecurity noUnderlyingSecurities = 45;
inline int SecurityDefinition::_internal_nounderlyingsecurities_size() const {
  return _impl_.nounderlyingsecurities_.size();
}
inline int SecurityDefinition::nounderlyingsecurities_size() const {
  return _internal_nounderlyingsecurities_size();
}
inline void SecurityDefinition::clear_nounderlyingsecurities() {
  _impl_.nounderlyingsecurities_.Clear();
}
inline ::data::NoUnderlyingSecurity* SecurityDefinition::mutable_nounderlyingsecurities(int index) {
  // @@protoc_insertion_point(field_mutable:data.SecurityDefinition.noUnderlyingSecurities)
  return _impl_.nounderlyingsecurities_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::data::NoUnderlyingSecurity >*
SecurityDefinition::mutable_nounderlyingsecurities() {
  // @@protoc_insertion_point(field_mutable_list:data.SecurityDefinition.noUnderlyingSecurities)
  return &_impl_.nounderlyingsecurities_;
}
inline const ::data::NoUnderlyingSecurity& SecurityDefinition::_internal_nounderlyingsecurities(int index) const {
  return _impl_.nounderlyingsecurities_.Get(index);
}
inline const ::data::NoUnderlyingSecurity& SecurityDefinition::nounderlyingsecurities(int index) const {
  // @@protoc_insertion_point(field_get:data.SecurityDefinition.noUnderlyingSecurities)
  return _internal_nounderlyingsecurities(index);
}
inline ::data::NoUnderlyingSecurity* SecurityDefinition::_internal_add_nounderlyingsecurities() {
  return _impl_.nounderlyingsecurities_.Add();
}
inline ::data::NoUnderlyingSecurity* SecurityDefinition::add_nounderlyingsecurities() {
  ::data::NoUnderlyingSecurity* _add = _internal_add_nounderlyingsecurities();
  // @@protoc_insertion_point(field_add:data.SecurityDefinition.noUnderlyingSecurities)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::data::NoUnderlyingSecurity >&
SecurityDefinition::nounderlyingsecurities() const {
  // @@protoc_insertion_point(field_list:data.SecurityDefinition.noUnderlyingSecurities)
  return _impl_.nounderlyingsecurities_;
}

// -------------------------------------------------------------------

// SecurityStatus

// optional int64 securityCode = 1;
inline bool SecurityStatus::_internal_has_securitycode() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SecurityStatus::has_securitycode() const {
  return _internal_has_securitycode();
}
inline void SecurityStatus::clear_securitycode() {
  _impl_.securitycode_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int64_t SecurityStatus::_internal_securitycode() const {
  return _impl_.securitycode_;
}
inline int64_t SecurityStatus::securitycode() const {
  // @@protoc_insertion_point(field_get:data.SecurityStatus.securityCode)
  return _internal_securitycode();
}
inline void SecurityStatus::_internal_set_securitycode(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.securitycode_ = value;
}
inline void SecurityStatus::set_securitycode(int64_t value) {
  _internal_set_securitycode(value);
  // @@protoc_insertion_point(field_set:data.SecurityStatus.securityCode)
}

// optional .data.SuspensionIndicator suspensionIndicator = 2;
inline bool SecurityStatus::_internal_has_suspensionindicator() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SecurityStatus::has_suspensionindicator() const {
  return _internal_has_suspensionindicator();
}
inline void SecurityStatus::clear_suspensionindicator() {
  _impl_.suspensionindicator_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::data::SuspensionIndicator SecurityStatus::_internal_suspensionindicator() const {
  return static_cast< ::data::SuspensionIndicator >(_impl_.suspensionindicator_);
}
inline ::data::SuspensionIndicator SecurityStatus::suspensionindicator() const {
  // @@protoc_insertion_point(field_get:data.SecurityStatus.suspensionIndicator)
  return _internal_suspensionindicator();
}
inline void SecurityStatus::_internal_set_suspensionindicator(::data::SuspensionIndicator value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.suspensionindicator_ = value;
}
inline void SecurityStatus::set_suspensionindicator(::data::SuspensionIndicator value) {
  _internal_set_suspensionindicator(value);
  // @@protoc_insertion_point(field_set:data.SecurityStatus.suspensionIndicator)
}

// -------------------------------------------------------------------

// Statistics

// optional int64 securityCode = 1;
inline bool Statistics::_internal_has_securitycode() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Statistics::has_securitycode() const {
  return _internal_has_securitycode();
}
inline void Statistics::clear_securitycode() {
  _impl_.securitycode_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int64_t Statistics::_internal_securitycode() const {
  return _impl_.securitycode_;
}
inline int64_t Statistics::securitycode() const {
  // @@protoc_insertion_point(field_get:data.Statistics.securityCode)
  return _internal_securitycode();
}
inline void Statistics::_internal_set_securitycode(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.securitycode_ = value;
}
inline void Statistics::set_securitycode(int64_t value) {
  _internal_set_securitycode(value);
  // @@protoc_insertion_point(field_set:data.Statistics.securityCode)
}

// optional int64 sharesTraded = 2;
inline bool Statistics::_internal_has_sharestraded() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Statistics::has_sharestraded() const {
  return _internal_has_sharestraded();
}
inline void Statistics::clear_sharestraded() {
  _impl_.sharestraded_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int64_t Statistics::_internal_sharestraded() const {
  return _impl_.sharestraded_;
}
inline int64_t Statistics::sharestraded() const {
  // @@protoc_insertion_point(field_get:data.Statistics.sharesTraded)
  return _internal_sharestraded();
}
inline void Statistics::_internal_set_sharestraded(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.sharestraded_ = value;
}
inline void Statistics::set_sharestraded(int64_t value) {
  _internal_set_sharestraded(value);
  // @@protoc_insertion_point(field_set:data.Statistics.sharesTraded)
}

// optional double vCMReferencePrice = 3;
inline bool Statistics::_internal_has_vcmreferenceprice() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Statistics::has_vcmreferenceprice() const {
  return _internal_has_vcmreferenceprice();
}
inline void Statistics::clear_vcmreferenceprice() {
  _impl_.vcmreferenceprice_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline double Statistics::_internal_vcmreferenceprice() const {
  return _impl_.vcmreferenceprice_;
}
inline double Statistics::vcmreferenceprice() const {
  // @@protoc_insertion_point(field_get:data.Statistics.vCMReferencePrice)
  return _internal_vcmreferenceprice();
}
inline void Statistics::_internal_set_vcmreferenceprice(double value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.vcmreferenceprice_ = value;
}
inline void Statistics::set_vcmreferenceprice(double value) {
  _internal_set_vcmreferenceprice(value);
  // @@protoc_insertion_point(field_set:data.Statistics.vCMReferencePrice)
}

// optional double highPrice = 4;
inline bool Statistics::_internal_has_highprice() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool Statistics::has_highprice() const {
  return _internal_has_highprice();
}
inline void Statistics::clear_highprice() {
  _impl_.highprice_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline double Statistics::_internal_highprice() const {
  return _impl_.highprice_;
}
inline double Statistics::highprice() const {
  // @@protoc_insertion_point(field_get:data.Statistics.highPrice)
  return _internal_highprice();
}
inline void Statistics::_internal_set_highprice(double value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.highprice_ = value;
}
inline void Statistics::set_highprice(double value) {
  _internal_set_highprice(value);
  // @@protoc_insertion_point(field_set:data.Statistics.highPrice)
}

// optional double lowPrice = 5;
inline bool Statistics::_internal_has_lowprice() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool Statistics::has_lowprice() const {
  return _internal_has_lowprice();
}
inline void Statistics::clear_lowprice() {
  _impl_.lowprice_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline double Statistics::_internal_lowprice() const {
  return _impl_.lowprice_;
}
inline double Statistics::lowprice() const {
  // @@protoc_insertion_point(field_get:data.Statistics.lowPrice)
  return _internal_lowprice();
}
inline void Statistics::_internal_set_lowprice(double value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.lowprice_ = value;
}
inline void Statistics::set_lowprice(double value) {
  _internal_set_lowprice(value);
  // @@protoc_insertion_point(field_set:data.Statistics.lowPrice)
}

// optional double lastPrice = 6;
inline bool Statistics::_internal_has_lastprice() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool Statistics::has_lastprice() const {
  return _internal_has_lastprice();
}
inline void Statistics::clear_lastprice() {
  _impl_.lastprice_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline double Statistics::_internal_lastprice() const {
  return _impl_.lastprice_;
}
inline double Statistics::lastprice() const {
  // @@protoc_insertion_point(field_get:data.Statistics.lastPrice)
  return _internal_lastprice();
}
inline void Statistics::_internal_set_lastprice(double value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.lastprice_ = value;
}
inline void Statistics::set_lastprice(double value) {
  _internal_set_lastprice(value);
  // @@protoc_insertion_point(field_set:data.Statistics.lastPrice)
}

// optional double vwap = 7;
inline bool Statistics::_internal_has_vwap() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool Statistics::has_vwap() const {
  return _internal_has_vwap();
}
inline void Statistics::clear_vwap() {
  _impl_.vwap_ = 0;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline double Statistics::_internal_vwap() const {
  return _impl_.vwap_;
}
inline double Statistics::vwap() const {
  // @@protoc_insertion_point(field_get:data.Statistics.vwap)
  return _internal_vwap();
}
inline void Statistics::_internal_set_vwap(double value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.vwap_ = value;
}
inline void Statistics::set_vwap(double value) {
  _internal_set_vwap(value);
  // @@protoc_insertion_point(field_set:data.Statistics.vwap)
}

// optional int64 shortSellSharesTraded = 8;
inline bool Statistics::_internal_has_shortsellsharestraded() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool Statistics::has_shortsellsharestraded() const {
  return _internal_has_shortsellsharestraded();
}
inline void Statistics::clear_shortsellsharestraded() {
  _impl_.shortsellsharestraded_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline int64_t Statistics::_internal_shortsellsharestraded() const {
  return _impl_.shortsellsharestraded_;
}
inline int64_t Statistics::shortsellsharestraded() const {
  // @@protoc_insertion_point(field_get:data.Statistics.shortSellSharesTraded)
  return _internal_shortsellsharestraded();
}
inline void Statistics::_internal_set_shortsellsharestraded(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.shortsellsharestraded_ = value;
}
inline void Statistics::set_shortsellsharestraded(int64_t value) {
  _internal_set_shortsellsharestraded(value);
  // @@protoc_insertion_point(field_set:data.Statistics.shortSellSharesTraded)
}

// optional double shortSellTurnover = 9;
inline bool Statistics::_internal_has_shortsellturnover() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool Statistics::has_shortsellturnover() const {
  return _internal_has_shortsellturnover();
}
inline void Statistics::clear_shortsellturnover() {
  _impl_.shortsellturnover_ = 0;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline double Statistics::_internal_shortsellturnover() const {
  return _impl_.shortsellturnover_;
}
inline double Statistics::shortsellturnover() const {
  // @@protoc_insertion_point(field_get:data.Statistics.shortSellTurnover)
  return _internal_shortsellturnover();
}
inline void Statistics::_internal_set_shortsellturnover(double value) {
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.shortsellturnover_ = value;
}
inline void Statistics::set_shortsellturnover(double value) {
  _internal_set_shortsellturnover(value);
  // @@protoc_insertion_point(field_set:data.Statistics.shortSellTurnover)
}

// -------------------------------------------------------------------

// StockConnectDailyQuotaBalance

// optional string stockConnectMarket = 1;
inline bool StockConnectDailyQuotaBalance::_internal_has_stockconnectmarket() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool StockConnectDailyQuotaBalance::has_stockconnectmarket() const {
  return _internal_has_stockconnectmarket();
}
inline void StockConnectDailyQuotaBalance::clear_stockconnectmarket() {
  _impl_.stockconnectmarket_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& StockConnectDailyQuotaBalance::stockconnectmarket() const {
  // @@protoc_insertion_point(field_get:data.StockConnectDailyQuotaBalance.stockConnectMarket)
  return _internal_stockconnectmarket();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StockConnectDailyQuotaBalance::set_stockconnectmarket(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.stockconnectmarket_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:data.StockConnectDailyQuotaBalance.stockConnectMarket)
}
inline std::string* StockConnectDailyQuotaBalance::mutable_stockconnectmarket() {
  std::string* _s = _internal_mutable_stockconnectmarket();
  // @@protoc_insertion_point(field_mutable:data.StockConnectDailyQuotaBalance.stockConnectMarket)
  return _s;
}
inline const std::string& StockConnectDailyQuotaBalance::_internal_stockconnectmarket() const {
  return _impl_.stockconnectmarket_.Get();
}
inline void StockConnectDailyQuotaBalance::_internal_set_stockconnectmarket(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.stockconnectmarket_.Set(value, GetArenaForAllocation());
}
inline std::string* StockConnectDailyQuotaBalance::_internal_mutable_stockconnectmarket() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.stockconnectmarket_.Mutable(GetArenaForAllocation());
}
inline std::string* StockConnectDailyQuotaBalance::release_stockconnectmarket() {
  // @@protoc_insertion_point(field_release:data.StockConnectDailyQuotaBalance.stockConnectMarket)
  if (!_internal_has_stockconnectmarket()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.stockconnectmarket_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.stockconnectmarket_.IsDefault()) {
    _impl_.stockconnectmarket_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void StockConnectDailyQuotaBalance::set_allocated_stockconnectmarket(std::string* stockconnectmarket) {
  if (stockconnectmarket != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.stockconnectmarket_.SetAllocated(stockconnectmarket, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.stockconnectmarket_.IsDefault()) {
    _impl_.stockconnectmarket_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:data.StockConnectDailyQuotaBalance.stockConnectMarket)
}

// optional string tradingDirection = 2;
inline bool StockConnectDailyQuotaBalance::_internal_has_tradingdirection() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool StockConnectDailyQuotaBalance::has_tradingdirection() const {
  return _internal_has_tradingdirection();
}
inline void StockConnectDailyQuotaBalance::clear_tradingdirection() {
  _impl_.tradingdirection_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& StockConnectDailyQuotaBalance::tradingdirection() const {
  // @@protoc_insertion_point(field_get:data.StockConnectDailyQuotaBalance.tradingDirection)
  return _internal_tradingdirection();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StockConnectDailyQuotaBalance::set_tradingdirection(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.tradingdirection_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:data.StockConnectDailyQuotaBalance.tradingDirection)
}
inline std::string* StockConnectDailyQuotaBalance::mutable_tradingdirection() {
  std::string* _s = _internal_mutable_tradingdirection();
  // @@protoc_insertion_point(field_mutable:data.StockConnectDailyQuotaBalance.tradingDirection)
  return _s;
}
inline const std::string& StockConnectDailyQuotaBalance::_internal_tradingdirection() const {
  return _impl_.tradingdirection_.Get();
}
inline void StockConnectDailyQuotaBalance::_internal_set_tradingdirection(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.tradingdirection_.Set(value, GetArenaForAllocation());
}
inline std::string* StockConnectDailyQuotaBalance::_internal_mutable_tradingdirection() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.tradingdirection_.Mutable(GetArenaForAllocation());
}
inline std::string* StockConnectDailyQuotaBalance::release_tradingdirection() {
  // @@protoc_insertion_point(field_release:data.StockConnectDailyQuotaBalance.tradingDirection)
  if (!_internal_has_tradingdirection()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.tradingdirection_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.tradingdirection_.IsDefault()) {
    _impl_.tradingdirection_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void StockConnectDailyQuotaBalance::set_allocated_tradingdirection(std::string* tradingdirection) {
  if (tradingdirection != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.tradingdirection_.SetAllocated(tradingdirection, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.tradingdirection_.IsDefault()) {
    _impl_.tradingdirection_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:data.StockConnectDailyQuotaBalance.tradingDirection)
}

// optional int64 dailyQuotaBalance = 3;
inline bool StockConnectDailyQuotaBalance::_internal_has_dailyquotabalance() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool StockConnectDailyQuotaBalance::has_dailyquotabalance() const {
  return _internal_has_dailyquotabalance();
}
inline void StockConnectDailyQuotaBalance::clear_dailyquotabalance() {
  _impl_.dailyquotabalance_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int64_t StockConnectDailyQuotaBalance::_internal_dailyquotabalance() const {
  return _impl_.dailyquotabalance_;
}
inline int64_t StockConnectDailyQuotaBalance::dailyquotabalance() const {
  // @@protoc_insertion_point(field_get:data.StockConnectDailyQuotaBalance.dailyQuotaBalance)
  return _internal_dailyquotabalance();
}
inline void StockConnectDailyQuotaBalance::_internal_set_dailyquotabalance(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.dailyquotabalance_ = value;
}
inline void StockConnectDailyQuotaBalance::set_dailyquotabalance(int64_t value) {
  _internal_set_dailyquotabalance(value);
  // @@protoc_insertion_point(field_set:data.StockConnectDailyQuotaBalance.dailyQuotaBalance)
}

// optional int64 dailyQuotaBalanceTime = 4;
inline bool StockConnectDailyQuotaBalance::_internal_has_dailyquotabalancetime() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool StockConnectDailyQuotaBalance::has_dailyquotabalancetime() const {
  return _internal_has_dailyquotabalancetime();
}
inline void StockConnectDailyQuotaBalance::clear_dailyquotabalancetime() {
  _impl_.dailyquotabalancetime_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline int64_t StockConnectDailyQuotaBalance::_internal_dailyquotabalancetime() const {
  return _impl_.dailyquotabalancetime_;
}
inline int64_t StockConnectDailyQuotaBalance::dailyquotabalancetime() const {
  // @@protoc_insertion_point(field_get:data.StockConnectDailyQuotaBalance.dailyQuotaBalanceTime)
  return _internal_dailyquotabalancetime();
}
inline void StockConnectDailyQuotaBalance::_internal_set_dailyquotabalancetime(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.dailyquotabalancetime_ = value;
}
inline void StockConnectDailyQuotaBalance::set_dailyquotabalancetime(int64_t value) {
  _internal_set_dailyquotabalancetime(value);
  // @@protoc_insertion_point(field_set:data.StockConnectDailyQuotaBalance.dailyQuotaBalanceTime)
}

// -------------------------------------------------------------------

// StockConnectMarketTurnover

// optional string stockConnectMarket = 1;
inline bool StockConnectMarketTurnover::_internal_has_stockconnectmarket() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool StockConnectMarketTurnover::has_stockconnectmarket() const {
  return _internal_has_stockconnectmarket();
}
inline void StockConnectMarketTurnover::clear_stockconnectmarket() {
  _impl_.stockconnectmarket_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& StockConnectMarketTurnover::stockconnectmarket() const {
  // @@protoc_insertion_point(field_get:data.StockConnectMarketTurnover.stockConnectMarket)
  return _internal_stockconnectmarket();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StockConnectMarketTurnover::set_stockconnectmarket(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.stockconnectmarket_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:data.StockConnectMarketTurnover.stockConnectMarket)
}
inline std::string* StockConnectMarketTurnover::mutable_stockconnectmarket() {
  std::string* _s = _internal_mutable_stockconnectmarket();
  // @@protoc_insertion_point(field_mutable:data.StockConnectMarketTurnover.stockConnectMarket)
  return _s;
}
inline const std::string& StockConnectMarketTurnover::_internal_stockconnectmarket() const {
  return _impl_.stockconnectmarket_.Get();
}
inline void StockConnectMarketTurnover::_internal_set_stockconnectmarket(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.stockconnectmarket_.Set(value, GetArenaForAllocation());
}
inline std::string* StockConnectMarketTurnover::_internal_mutable_stockconnectmarket() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.stockconnectmarket_.Mutable(GetArenaForAllocation());
}
inline std::string* StockConnectMarketTurnover::release_stockconnectmarket() {
  // @@protoc_insertion_point(field_release:data.StockConnectMarketTurnover.stockConnectMarket)
  if (!_internal_has_stockconnectmarket()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.stockconnectmarket_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.stockconnectmarket_.IsDefault()) {
    _impl_.stockconnectmarket_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void StockConnectMarketTurnover::set_allocated_stockconnectmarket(std::string* stockconnectmarket) {
  if (stockconnectmarket != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.stockconnectmarket_.SetAllocated(stockconnectmarket, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.stockconnectmarket_.IsDefault()) {
    _impl_.stockconnectmarket_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:data.StockConnectMarketTurnover.stockConnectMarket)
}

// optional string tradingDirection = 2;
inline bool StockConnectMarketTurnover::_internal_has_tradingdirection() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool StockConnectMarketTurnover::has_tradingdirection() const {
  return _internal_has_tradingdirection();
}
inline void StockConnectMarketTurnover::clear_tradingdirection() {
  _impl_.tradingdirection_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& StockConnectMarketTurnover::tradingdirection() const {
  // @@protoc_insertion_point(field_get:data.StockConnectMarketTurnover.tradingDirection)
  return _internal_tradingdirection();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StockConnectMarketTurnover::set_tradingdirection(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.tradingdirection_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:data.StockConnectMarketTurnover.tradingDirection)
}
inline std::string* StockConnectMarketTurnover::mutable_tradingdirection() {
  std::string* _s = _internal_mutable_tradingdirection();
  // @@protoc_insertion_point(field_mutable:data.StockConnectMarketTurnover.tradingDirection)
  return _s;
}
inline const std::string& StockConnectMarketTurnover::_internal_tradingdirection() const {
  return _impl_.tradingdirection_.Get();
}
inline void StockConnectMarketTurnover::_internal_set_tradingdirection(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.tradingdirection_.Set(value, GetArenaForAllocation());
}
inline std::string* StockConnectMarketTurnover::_internal_mutable_tradingdirection() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.tradingdirection_.Mutable(GetArenaForAllocation());
}
inline std::string* StockConnectMarketTurnover::release_tradingdirection() {
  // @@protoc_insertion_point(field_release:data.StockConnectMarketTurnover.tradingDirection)
  if (!_internal_has_tradingdirection()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.tradingdirection_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.tradingdirection_.IsDefault()) {
    _impl_.tradingdirection_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void StockConnectMarketTurnover::set_allocated_tradingdirection(std::string* tradingdirection) {
  if (tradingdirection != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.tradingdirection_.SetAllocated(tradingdirection, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.tradingdirection_.IsDefault()) {
    _impl_.tradingdirection_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:data.StockConnectMarketTurnover.tradingDirection)
}

// optional int64 buyTurnover = 3;
inline bool StockConnectMarketTurnover::_internal_has_buyturnover() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool StockConnectMarketTurnover::has_buyturnover() const {
  return _internal_has_buyturnover();
}
inline void StockConnectMarketTurnover::clear_buyturnover() {
  _impl_.buyturnover_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int64_t StockConnectMarketTurnover::_internal_buyturnover() const {
  return _impl_.buyturnover_;
}
inline int64_t StockConnectMarketTurnover::buyturnover() const {
  // @@protoc_insertion_point(field_get:data.StockConnectMarketTurnover.buyTurnover)
  return _internal_buyturnover();
}
inline void StockConnectMarketTurnover::_internal_set_buyturnover(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.buyturnover_ = value;
}
inline void StockConnectMarketTurnover::set_buyturnover(int64_t value) {
  _internal_set_buyturnover(value);
  // @@protoc_insertion_point(field_set:data.StockConnectMarketTurnover.buyTurnover)
}

// optional int64 sellTurnover = 4;
inline bool StockConnectMarketTurnover::_internal_has_sellturnover() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool StockConnectMarketTurnover::has_sellturnover() const {
  return _internal_has_sellturnover();
}
inline void StockConnectMarketTurnover::clear_sellturnover() {
  _impl_.sellturnover_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline int64_t StockConnectMarketTurnover::_internal_sellturnover() const {
  return _impl_.sellturnover_;
}
inline int64_t StockConnectMarketTurnover::sellturnover() const {
  // @@protoc_insertion_point(field_get:data.StockConnectMarketTurnover.sellTurnover)
  return _internal_sellturnover();
}
inline void StockConnectMarketTurnover::_internal_set_sellturnover(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.sellturnover_ = value;
}
inline void StockConnectMarketTurnover::set_sellturnover(int64_t value) {
  _internal_set_sellturnover(value);
  // @@protoc_insertion_point(field_set:data.StockConnectMarketTurnover.sellTurnover)
}

// optional int64 buySellTurnover = 5;
inline bool StockConnectMarketTurnover::_internal_has_buysellturnover() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool StockConnectMarketTurnover::has_buysellturnover() const {
  return _internal_has_buysellturnover();
}
inline void StockConnectMarketTurnover::clear_buysellturnover() {
  _impl_.buysellturnover_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline int64_t StockConnectMarketTurnover::_internal_buysellturnover() const {
  return _impl_.buysellturnover_;
}
inline int64_t StockConnectMarketTurnover::buysellturnover() const {
  // @@protoc_insertion_point(field_get:data.StockConnectMarketTurnover.buySellTurnover)
  return _internal_buysellturnover();
}
inline void StockConnectMarketTurnover::_internal_set_buysellturnover(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.buysellturnover_ = value;
}
inline void StockConnectMarketTurnover::set_buysellturnover(int64_t value) {
  _internal_set_buysellturnover(value);
  // @@protoc_insertion_point(field_set:data.StockConnectMarketTurnover.buySellTurnover)
}

// -------------------------------------------------------------------

// Trade

// optional int64 securityCode = 1;
inline bool Trade::_internal_has_securitycode() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Trade::has_securitycode() const {
  return _internal_has_securitycode();
}
inline void Trade::clear_securitycode() {
  _impl_.securitycode_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int64_t Trade::_internal_securitycode() const {
  return _impl_.securitycode_;
}
inline int64_t Trade::securitycode() const {
  // @@protoc_insertion_point(field_get:data.Trade.securityCode)
  return _internal_securitycode();
}
inline void Trade::_internal_set_securitycode(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.securitycode_ = value;
}
inline void Trade::set_securitycode(int64_t value) {
  _internal_set_securitycode(value);
  // @@protoc_insertion_point(field_set:data.Trade.securityCode)
}

// optional int64 tradeId = 2;
inline bool Trade::_internal_has_tradeid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Trade::has_tradeid() const {
  return _internal_has_tradeid();
}
inline void Trade::clear_tradeid() {
  _impl_.tradeid_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int64_t Trade::_internal_tradeid() const {
  return _impl_.tradeid_;
}
inline int64_t Trade::tradeid() const {
  // @@protoc_insertion_point(field_get:data.Trade.tradeId)
  return _internal_tradeid();
}
inline void Trade::_internal_set_tradeid(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.tradeid_ = value;
}
inline void Trade::set_tradeid(int64_t value) {
  _internal_set_tradeid(value);
  // @@protoc_insertion_point(field_set:data.Trade.tradeId)
}

// optional double price = 3;
inline bool Trade::_internal_has_price() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Trade::has_price() const {
  return _internal_has_price();
}
inline void Trade::clear_price() {
  _impl_.price_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline double Trade::_internal_price() const {
  return _impl_.price_;
}
inline double Trade::price() const {
  // @@protoc_insertion_point(field_get:data.Trade.price)
  return _internal_price();
}
inline void Trade::_internal_set_price(double value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.price_ = value;
}
inline void Trade::set_price(double value) {
  _internal_set_price(value);
  // @@protoc_insertion_point(field_set:data.Trade.price)
}

// optional int64 quantity = 4;
inline bool Trade::_internal_has_quantity() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool Trade::has_quantity() const {
  return _internal_has_quantity();
}
inline void Trade::clear_quantity() {
  _impl_.quantity_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline int64_t Trade::_internal_quantity() const {
  return _impl_.quantity_;
}
inline int64_t Trade::quantity() const {
  // @@protoc_insertion_point(field_get:data.Trade.quantity)
  return _internal_quantity();
}
inline void Trade::_internal_set_quantity(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.quantity_ = value;
}
inline void Trade::set_quantity(int64_t value) {
  _internal_set_quantity(value);
  // @@protoc_insertion_point(field_set:data.Trade.quantity)
}

// optional .data.TrdType trdType = 5;
inline bool Trade::_internal_has_trdtype() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool Trade::has_trdtype() const {
  return _internal_has_trdtype();
}
inline void Trade::clear_trdtype() {
  _impl_.trdtype_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::data::TrdType Trade::_internal_trdtype() const {
  return static_cast< ::data::TrdType >(_impl_.trdtype_);
}
inline ::data::TrdType Trade::trdtype() const {
  // @@protoc_insertion_point(field_get:data.Trade.trdType)
  return _internal_trdtype();
}
inline void Trade::_internal_set_trdtype(::data::TrdType value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.trdtype_ = value;
}
inline void Trade::set_trdtype(::data::TrdType value) {
  _internal_set_trdtype(value);
  // @@protoc_insertion_point(field_set:data.Trade.trdType)
}

// optional int64 TradeTime = 6;
inline bool Trade::_internal_has_tradetime() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool Trade::has_tradetime() const {
  return _internal_has_tradetime();
}
inline void Trade::clear_tradetime() {
  _impl_.tradetime_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline int64_t Trade::_internal_tradetime() const {
  return _impl_.tradetime_;
}
inline int64_t Trade::tradetime() const {
  // @@protoc_insertion_point(field_get:data.Trade.TradeTime)
  return _internal_tradetime();
}
inline void Trade::_internal_set_tradetime(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.tradetime_ = value;
}
inline void Trade::set_tradetime(int64_t value) {
  _internal_set_tradetime(value);
  // @@protoc_insertion_point(field_set:data.Trade.TradeTime)
}

// -------------------------------------------------------------------

// TradeCancel

// optional int64 securityCode = 1;
inline bool TradeCancel::_internal_has_securitycode() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TradeCancel::has_securitycode() const {
  return _internal_has_securitycode();
}
inline void TradeCancel::clear_securitycode() {
  _impl_.securitycode_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int64_t TradeCancel::_internal_securitycode() const {
  return _impl_.securitycode_;
}
inline int64_t TradeCancel::securitycode() const {
  // @@protoc_insertion_point(field_get:data.TradeCancel.securityCode)
  return _internal_securitycode();
}
inline void TradeCancel::_internal_set_securitycode(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.securitycode_ = value;
}
inline void TradeCancel::set_securitycode(int64_t value) {
  _internal_set_securitycode(value);
  // @@protoc_insertion_point(field_set:data.TradeCancel.securityCode)
}

// optional int64 tradeId = 2;
inline bool TradeCancel::_internal_has_tradeid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TradeCancel::has_tradeid() const {
  return _internal_has_tradeid();
}
inline void TradeCancel::clear_tradeid() {
  _impl_.tradeid_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int64_t TradeCancel::_internal_tradeid() const {
  return _impl_.tradeid_;
}
inline int64_t TradeCancel::tradeid() const {
  // @@protoc_insertion_point(field_get:data.TradeCancel.tradeId)
  return _internal_tradeid();
}
inline void TradeCancel::_internal_set_tradeid(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.tradeid_ = value;
}
inline void TradeCancel::set_tradeid(int64_t value) {
  _internal_set_tradeid(value);
  // @@protoc_insertion_point(field_set:data.TradeCancel.tradeId)
}

// -------------------------------------------------------------------

// TradingSessionStatus

// optional .data.MarketCode marketCode = 1;
inline bool TradingSessionStatus::_internal_has_marketcode() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TradingSessionStatus::has_marketcode() const {
  return _internal_has_marketcode();
}
inline void TradingSessionStatus::clear_marketcode() {
  _impl_.marketcode_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::data::MarketCode TradingSessionStatus::_internal_marketcode() const {
  return static_cast< ::data::MarketCode >(_impl_.marketcode_);
}
inline ::data::MarketCode TradingSessionStatus::marketcode() const {
  // @@protoc_insertion_point(field_get:data.TradingSessionStatus.marketCode)
  return _internal_marketcode();
}
inline void TradingSessionStatus::_internal_set_marketcode(::data::MarketCode value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.marketcode_ = value;
}
inline void TradingSessionStatus::set_marketcode(::data::MarketCode value) {
  _internal_set_marketcode(value);
  // @@protoc_insertion_point(field_set:data.TradingSessionStatus.marketCode)
}

// optional .data.TradingSessionSubID tradingSessionSubID = 2;
inline bool TradingSessionStatus::_internal_has_tradingsessionsubid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TradingSessionStatus::has_tradingsessionsubid() const {
  return _internal_has_tradingsessionsubid();
}
inline void TradingSessionStatus::clear_tradingsessionsubid() {
  _impl_.tradingsessionsubid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::data::TradingSessionSubID TradingSessionStatus::_internal_tradingsessionsubid() const {
  return static_cast< ::data::TradingSessionSubID >(_impl_.tradingsessionsubid_);
}
inline ::data::TradingSessionSubID TradingSessionStatus::tradingsessionsubid() const {
  // @@protoc_insertion_point(field_get:data.TradingSessionStatus.tradingSessionSubID)
  return _internal_tradingsessionsubid();
}
inline void TradingSessionStatus::_internal_set_tradingsessionsubid(::data::TradingSessionSubID value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.tradingsessionsubid_ = value;
}
inline void TradingSessionStatus::set_tradingsessionsubid(::data::TradingSessionSubID value) {
  _internal_set_tradingsessionsubid(value);
  // @@protoc_insertion_point(field_set:data.TradingSessionStatus.tradingSessionSubID)
}

// optional .data.TradingSesStatus tradingSesStatus = 3;
inline bool TradingSessionStatus::_internal_has_tradingsesstatus() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool TradingSessionStatus::has_tradingsesstatus() const {
  return _internal_has_tradingsesstatus();
}
inline void TradingSessionStatus::clear_tradingsesstatus() {
  _impl_.tradingsesstatus_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::data::TradingSesStatus TradingSessionStatus::_internal_tradingsesstatus() const {
  return static_cast< ::data::TradingSesStatus >(_impl_.tradingsesstatus_);
}
inline ::data::TradingSesStatus TradingSessionStatus::tradingsesstatus() const {
  // @@protoc_insertion_point(field_get:data.TradingSessionStatus.tradingSesStatus)
  return _internal_tradingsesstatus();
}
inline void TradingSessionStatus::_internal_set_tradingsesstatus(::data::TradingSesStatus value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.tradingsesstatus_ = value;
}
inline void TradingSessionStatus::set_tradingsesstatus(::data::TradingSesStatus value) {
  _internal_set_tradingsesstatus(value);
  // @@protoc_insertion_point(field_set:data.TradingSessionStatus.tradingSesStatus)
}

// optional .data.TradingSesControlType TradingSesControlFlag = 4;
inline bool TradingSessionStatus::_internal_has_tradingsescontrolflag() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool TradingSessionStatus::has_tradingsescontrolflag() const {
  return _internal_has_tradingsescontrolflag();
}
inline void TradingSessionStatus::clear_tradingsescontrolflag() {
  _impl_.tradingsescontrolflag_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::data::TradingSesControlType TradingSessionStatus::_internal_tradingsescontrolflag() const {
  return static_cast< ::data::TradingSesControlType >(_impl_.tradingsescontrolflag_);
}
inline ::data::TradingSesControlType TradingSessionStatus::tradingsescontrolflag() const {
  // @@protoc_insertion_point(field_get:data.TradingSessionStatus.TradingSesControlFlag)
  return _internal_tradingsescontrolflag();
}
inline void TradingSessionStatus::_internal_set_tradingsescontrolflag(::data::TradingSesControlType value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.tradingsescontrolflag_ = value;
}
inline void TradingSessionStatus::set_tradingsescontrolflag(::data::TradingSesControlType value) {
  _internal_set_tradingsescontrolflag(value);
  // @@protoc_insertion_point(field_set:data.TradingSessionStatus.TradingSesControlFlag)
}

// optional int64 startDateTime = 5;
inline bool TradingSessionStatus::_internal_has_startdatetime() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool TradingSessionStatus::has_startdatetime() const {
  return _internal_has_startdatetime();
}
inline void TradingSessionStatus::clear_startdatetime() {
  _impl_.startdatetime_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline int64_t TradingSessionStatus::_internal_startdatetime() const {
  return _impl_.startdatetime_;
}
inline int64_t TradingSessionStatus::startdatetime() const {
  // @@protoc_insertion_point(field_get:data.TradingSessionStatus.startDateTime)
  return _internal_startdatetime();
}
inline void TradingSessionStatus::_internal_set_startdatetime(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.startdatetime_ = value;
}
inline void TradingSessionStatus::set_startdatetime(int64_t value) {
  _internal_set_startdatetime(value);
  // @@protoc_insertion_point(field_set:data.TradingSessionStatus.startDateTime)
}

// optional int64 endDateTime = 6;
inline bool TradingSessionStatus::_internal_has_enddatetime() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool TradingSessionStatus::has_enddatetime() const {
  return _internal_has_enddatetime();
}
inline void TradingSessionStatus::clear_enddatetime() {
  _impl_.enddatetime_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline int64_t TradingSessionStatus::_internal_enddatetime() const {
  return _impl_.enddatetime_;
}
inline int64_t TradingSessionStatus::enddatetime() const {
  // @@protoc_insertion_point(field_get:data.TradingSessionStatus.endDateTime)
  return _internal_enddatetime();
}
inline void TradingSessionStatus::_internal_set_enddatetime(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.enddatetime_ = value;
}
inline void TradingSessionStatus::set_enddatetime(int64_t value) {
  _internal_set_enddatetime(value);
  // @@protoc_insertion_point(field_set:data.TradingSessionStatus.endDateTime)
}

// -------------------------------------------------------------------

// VCMTrigger

// optional int64 securityCode = 1;
inline bool VCMTrigger::_internal_has_securitycode() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool VCMTrigger::has_securitycode() const {
  return _internal_has_securitycode();
}
inline void VCMTrigger::clear_securitycode() {
  _impl_.securitycode_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int64_t VCMTrigger::_internal_securitycode() const {
  return _impl_.securitycode_;
}
inline int64_t VCMTrigger::securitycode() const {
  // @@protoc_insertion_point(field_get:data.VCMTrigger.securityCode)
  return _internal_securitycode();
}
inline void VCMTrigger::_internal_set_securitycode(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.securitycode_ = value;
}
inline void VCMTrigger::set_securitycode(int64_t value) {
  _internal_set_securitycode(value);
  // @@protoc_insertion_point(field_set:data.VCMTrigger.securityCode)
}

// optional int64 coolingOffStartTime = 2;
inline bool VCMTrigger::_internal_has_coolingoffstarttime() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool VCMTrigger::has_coolingoffstarttime() const {
  return _internal_has_coolingoffstarttime();
}
inline void VCMTrigger::clear_coolingoffstarttime() {
  _impl_.coolingoffstarttime_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int64_t VCMTrigger::_internal_coolingoffstarttime() const {
  return _impl_.coolingoffstarttime_;
}
inline int64_t VCMTrigger::coolingoffstarttime() const {
  // @@protoc_insertion_point(field_get:data.VCMTrigger.coolingOffStartTime)
  return _internal_coolingoffstarttime();
}
inline void VCMTrigger::_internal_set_coolingoffstarttime(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.coolingoffstarttime_ = value;
}
inline void VCMTrigger::set_coolingoffstarttime(int64_t value) {
  _internal_set_coolingoffstarttime(value);
  // @@protoc_insertion_point(field_set:data.VCMTrigger.coolingOffStartTime)
}

// optional int64 coolingOffEndTime = 3;
inline bool VCMTrigger::_internal_has_coolingoffendtime() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool VCMTrigger::has_coolingoffendtime() const {
  return _internal_has_coolingoffendtime();
}
inline void VCMTrigger::clear_coolingoffendtime() {
  _impl_.coolingoffendtime_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int64_t VCMTrigger::_internal_coolingoffendtime() const {
  return _impl_.coolingoffendtime_;
}
inline int64_t VCMTrigger::coolingoffendtime() const {
  // @@protoc_insertion_point(field_get:data.VCMTrigger.coolingOffEndTime)
  return _internal_coolingoffendtime();
}
inline void VCMTrigger::_internal_set_coolingoffendtime(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.coolingoffendtime_ = value;
}
inline void VCMTrigger::set_coolingoffendtime(int64_t value) {
  _internal_set_coolingoffendtime(value);
  // @@protoc_insertion_point(field_set:data.VCMTrigger.coolingOffEndTime)
}

// optional double vCMReferencePrice = 4;
inline bool VCMTrigger::_internal_has_vcmreferenceprice() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool VCMTrigger::has_vcmreferenceprice() const {
  return _internal_has_vcmreferenceprice();
}
inline void VCMTrigger::clear_vcmreferenceprice() {
  _impl_.vcmreferenceprice_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline double VCMTrigger::_internal_vcmreferenceprice() const {
  return _impl_.vcmreferenceprice_;
}
inline double VCMTrigger::vcmreferenceprice() const {
  // @@protoc_insertion_point(field_get:data.VCMTrigger.vCMReferencePrice)
  return _internal_vcmreferenceprice();
}
inline void VCMTrigger::_internal_set_vcmreferenceprice(double value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.vcmreferenceprice_ = value;
}
inline void VCMTrigger::set_vcmreferenceprice(double value) {
  _internal_set_vcmreferenceprice(value);
  // @@protoc_insertion_point(field_set:data.VCMTrigger.vCMReferencePrice)
}

// optional double vCMLowerPrice = 5;
inline bool VCMTrigger::_internal_has_vcmlowerprice() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool VCMTrigger::has_vcmlowerprice() const {
  return _internal_has_vcmlowerprice();
}
inline void VCMTrigger::clear_vcmlowerprice() {
  _impl_.vcmlowerprice_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline double VCMTrigger::_internal_vcmlowerprice() const {
  return _impl_.vcmlowerprice_;
}
inline double VCMTrigger::vcmlowerprice() const {
  // @@protoc_insertion_point(field_get:data.VCMTrigger.vCMLowerPrice)
  return _internal_vcmlowerprice();
}
inline void VCMTrigger::_internal_set_vcmlowerprice(double value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.vcmlowerprice_ = value;
}
inline void VCMTrigger::set_vcmlowerprice(double value) {
  _internal_set_vcmlowerprice(value);
  // @@protoc_insertion_point(field_set:data.VCMTrigger.vCMLowerPrice)
}

// optional double vCMUpperPrice = 6;
inline bool VCMTrigger::_internal_has_vcmupperprice() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool VCMTrigger::has_vcmupperprice() const {
  return _internal_has_vcmupperprice();
}
inline void VCMTrigger::clear_vcmupperprice() {
  _impl_.vcmupperprice_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline double VCMTrigger::_internal_vcmupperprice() const {
  return _impl_.vcmupperprice_;
}
inline double VCMTrigger::vcmupperprice() const {
  // @@protoc_insertion_point(field_get:data.VCMTrigger.vCMUpperPrice)
  return _internal_vcmupperprice();
}
inline void VCMTrigger::_internal_set_vcmupperprice(double value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.vcmupperprice_ = value;
}
inline void VCMTrigger::set_vcmupperprice(double value) {
  _internal_set_vcmupperprice(value);
  // @@protoc_insertion_point(field_set:data.VCMTrigger.vCMUpperPrice)
}

// -------------------------------------------------------------------

// Yield

// optional int64 securityCode = 1;
inline bool Yield::_internal_has_securitycode() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Yield::has_securitycode() const {
  return _internal_has_securitycode();
}
inline void Yield::clear_securitycode() {
  _impl_.securitycode_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int64_t Yield::_internal_securitycode() const {
  return _impl_.securitycode_;
}
inline int64_t Yield::securitycode() const {
  // @@protoc_insertion_point(field_get:data.Yield.securityCode)
  return _internal_securitycode();
}
inline void Yield::_internal_set_securitycode(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.securitycode_ = value;
}
inline void Yield::set_securitycode(int64_t value) {
  _internal_set_securitycode(value);
  // @@protoc_insertion_point(field_set:data.Yield.securityCode)
}

// optional int32 yield = 2;
inline bool Yield::_internal_has_yield() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Yield::has_yield() const {
  return _internal_has_yield();
}
inline void Yield::clear_yield() {
  _impl_.yield_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t Yield::_internal_yield() const {
  return _impl_.yield_;
}
inline int32_t Yield::yield() const {
  // @@protoc_insertion_point(field_get:data.Yield.yield)
  return _internal_yield();
}
inline void Yield::_internal_set_yield(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.yield_ = value;
}
inline void Yield::set_yield(int32_t value) {
  _internal_set_yield(value);
  // @@protoc_insertion_point(field_set:data.Yield.yield)
}

// -------------------------------------------------------------------

// CNMarketDefinition

// optional .data.CnMarketCode marketCode = 1;
inline bool CNMarketDefinition::_internal_has_marketcode() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CNMarketDefinition::has_marketcode() const {
  return _internal_has_marketcode();
}
inline void CNMarketDefinition::clear_marketcode() {
  _impl_.marketcode_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::data::CnMarketCode CNMarketDefinition::_internal_marketcode() const {
  return static_cast< ::data::CnMarketCode >(_impl_.marketcode_);
}
inline ::data::CnMarketCode CNMarketDefinition::marketcode() const {
  // @@protoc_insertion_point(field_get:data.CNMarketDefinition.marketCode)
  return _internal_marketcode();
}
inline void CNMarketDefinition::_internal_set_marketcode(::data::CnMarketCode value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.marketcode_ = value;
}
inline void CNMarketDefinition::set_marketcode(::data::CnMarketCode value) {
  _internal_set_marketcode(value);
  // @@protoc_insertion_point(field_set:data.CNMarketDefinition.marketCode)
}

// optional string marketName = 2;
inline bool CNMarketDefinition::_internal_has_marketname() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CNMarketDefinition::has_marketname() const {
  return _internal_has_marketname();
}
inline void CNMarketDefinition::clear_marketname() {
  _impl_.marketname_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CNMarketDefinition::marketname() const {
  // @@protoc_insertion_point(field_get:data.CNMarketDefinition.marketName)
  return _internal_marketname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CNMarketDefinition::set_marketname(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.marketname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:data.CNMarketDefinition.marketName)
}
inline std::string* CNMarketDefinition::mutable_marketname() {
  std::string* _s = _internal_mutable_marketname();
  // @@protoc_insertion_point(field_mutable:data.CNMarketDefinition.marketName)
  return _s;
}
inline const std::string& CNMarketDefinition::_internal_marketname() const {
  return _impl_.marketname_.Get();
}
inline void CNMarketDefinition::_internal_set_marketname(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.marketname_.Set(value, GetArenaForAllocation());
}
inline std::string* CNMarketDefinition::_internal_mutable_marketname() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.marketname_.Mutable(GetArenaForAllocation());
}
inline std::string* CNMarketDefinition::release_marketname() {
  // @@protoc_insertion_point(field_release:data.CNMarketDefinition.marketName)
  if (!_internal_has_marketname()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.marketname_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.marketname_.IsDefault()) {
    _impl_.marketname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CNMarketDefinition::set_allocated_marketname(std::string* marketname) {
  if (marketname != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.marketname_.SetAllocated(marketname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.marketname_.IsDefault()) {
    _impl_.marketname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:data.CNMarketDefinition.marketName)
}

// optional .data.CurrencyType currencyCode = 3;
inline bool CNMarketDefinition::_internal_has_currencycode() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CNMarketDefinition::has_currencycode() const {
  return _internal_has_currencycode();
}
inline void CNMarketDefinition::clear_currencycode() {
  _impl_.currencycode_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::data::CurrencyType CNMarketDefinition::_internal_currencycode() const {
  return static_cast< ::data::CurrencyType >(_impl_.currencycode_);
}
inline ::data::CurrencyType CNMarketDefinition::currencycode() const {
  // @@protoc_insertion_point(field_get:data.CNMarketDefinition.currencyCode)
  return _internal_currencycode();
}
inline void CNMarketDefinition::_internal_set_currencycode(::data::CurrencyType value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.currencycode_ = value;
}
inline void CNMarketDefinition::set_currencycode(::data::CurrencyType value) {
  _internal_set_currencycode(value);
  // @@protoc_insertion_point(field_set:data.CNMarketDefinition.currencyCode)
}

// optional int64 numberOfSecurities = 4;
inline bool CNMarketDefinition::_internal_has_numberofsecurities() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CNMarketDefinition::has_numberofsecurities() const {
  return _internal_has_numberofsecurities();
}
inline void CNMarketDefinition::clear_numberofsecurities() {
  _impl_.numberofsecurities_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline int64_t CNMarketDefinition::_internal_numberofsecurities() const {
  return _impl_.numberofsecurities_;
}
inline int64_t CNMarketDefinition::numberofsecurities() const {
  // @@protoc_insertion_point(field_get:data.CNMarketDefinition.numberOfSecurities)
  return _internal_numberofsecurities();
}
inline void CNMarketDefinition::_internal_set_numberofsecurities(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.numberofsecurities_ = value;
}
inline void CNMarketDefinition::set_numberofsecurities(int64_t value) {
  _internal_set_numberofsecurities(value);
  // @@protoc_insertion_point(field_set:data.CNMarketDefinition.numberOfSecurities)
}

// -------------------------------------------------------------------

// CNSecurityDefinition

// optional int64 securityCode = 1;
inline bool CNSecurityDefinition::_internal_has_securitycode() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CNSecurityDefinition::has_securitycode() const {
  return _internal_has_securitycode();
}
inline void CNSecurityDefinition::clear_securitycode() {
  _impl_.securitycode_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline int64_t CNSecurityDefinition::_internal_securitycode() const {
  return _impl_.securitycode_;
}
inline int64_t CNSecurityDefinition::securitycode() const {
  // @@protoc_insertion_point(field_get:data.CNSecurityDefinition.securityCode)
  return _internal_securitycode();
}
inline void CNSecurityDefinition::_internal_set_securitycode(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.securitycode_ = value;
}
inline void CNSecurityDefinition::set_securitycode(int64_t value) {
  _internal_set_securitycode(value);
  // @@protoc_insertion_point(field_set:data.CNSecurityDefinition.securityCode)
}

// optional .data.CnMarketCode marketCode = 2;
inline bool CNSecurityDefinition::_internal_has_marketcode() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CNSecurityDefinition::has_marketcode() const {
  return _internal_has_marketcode();
}
inline void CNSecurityDefinition::clear_marketcode() {
  _impl_.marketcode_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::data::CnMarketCode CNSecurityDefinition::_internal_marketcode() const {
  return static_cast< ::data::CnMarketCode >(_impl_.marketcode_);
}
inline ::data::CnMarketCode CNSecurityDefinition::marketcode() const {
  // @@protoc_insertion_point(field_get:data.CNSecurityDefinition.marketCode)
  return _internal_marketcode();
}
inline void CNSecurityDefinition::_internal_set_marketcode(::data::CnMarketCode value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.marketcode_ = value;
}
inline void CNSecurityDefinition::set_marketcode(::data::CnMarketCode value) {
  _internal_set_marketcode(value);
  // @@protoc_insertion_point(field_set:data.CNSecurityDefinition.marketCode)
}

// optional string isinCode = 3;
inline bool CNSecurityDefinition::_internal_has_isincode() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CNSecurityDefinition::has_isincode() const {
  return _internal_has_isincode();
}
inline void CNSecurityDefinition::clear_isincode() {
  _impl_.isincode_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CNSecurityDefinition::isincode() const {
  // @@protoc_insertion_point(field_get:data.CNSecurityDefinition.isinCode)
  return _internal_isincode();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CNSecurityDefinition::set_isincode(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.isincode_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:data.CNSecurityDefinition.isinCode)
}
inline std::string* CNSecurityDefinition::mutable_isincode() {
  std::string* _s = _internal_mutable_isincode();
  // @@protoc_insertion_point(field_mutable:data.CNSecurityDefinition.isinCode)
  return _s;
}
inline const std::string& CNSecurityDefinition::_internal_isincode() const {
  return _impl_.isincode_.Get();
}
inline void CNSecurityDefinition::_internal_set_isincode(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.isincode_.Set(value, GetArenaForAllocation());
}
inline std::string* CNSecurityDefinition::_internal_mutable_isincode() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.isincode_.Mutable(GetArenaForAllocation());
}
inline std::string* CNSecurityDefinition::release_isincode() {
  // @@protoc_insertion_point(field_release:data.CNSecurityDefinition.isinCode)
  if (!_internal_has_isincode()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.isincode_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.isincode_.IsDefault()) {
    _impl_.isincode_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CNSecurityDefinition::set_allocated_isincode(std::string* isincode) {
  if (isincode != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.isincode_.SetAllocated(isincode, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.isincode_.IsDefault()) {
    _impl_.isincode_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:data.CNSecurityDefinition.isinCode)
}

// optional .data.InstrumentType instrumentType = 4;
inline bool CNSecurityDefinition::_internal_has_instrumenttype() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool CNSecurityDefinition::has_instrumenttype() const {
  return _internal_has_instrumenttype();
}
inline void CNSecurityDefinition::clear_instrumenttype() {
  _impl_.instrumenttype_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::data::InstrumentType CNSecurityDefinition::_internal_instrumenttype() const {
  return static_cast< ::data::InstrumentType >(_impl_.instrumenttype_);
}
inline ::data::InstrumentType CNSecurityDefinition::instrumenttype() const {
  // @@protoc_insertion_point(field_get:data.CNSecurityDefinition.instrumentType)
  return _internal_instrumenttype();
}
inline void CNSecurityDefinition::_internal_set_instrumenttype(::data::InstrumentType value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.instrumenttype_ = value;
}
inline void CNSecurityDefinition::set_instrumenttype(::data::InstrumentType value) {
  _internal_set_instrumenttype(value);
  // @@protoc_insertion_point(field_set:data.CNSecurityDefinition.instrumentType)
}

// optional string securityShortName = 5;
inline bool CNSecurityDefinition::_internal_has_securityshortname() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CNSecurityDefinition::has_securityshortname() const {
  return _internal_has_securityshortname();
}
inline void CNSecurityDefinition::clear_securityshortname() {
  _impl_.securityshortname_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CNSecurityDefinition::securityshortname() const {
  // @@protoc_insertion_point(field_get:data.CNSecurityDefinition.securityShortName)
  return _internal_securityshortname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CNSecurityDefinition::set_securityshortname(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.securityshortname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:data.CNSecurityDefinition.securityShortName)
}
inline std::string* CNSecurityDefinition::mutable_securityshortname() {
  std::string* _s = _internal_mutable_securityshortname();
  // @@protoc_insertion_point(field_mutable:data.CNSecurityDefinition.securityShortName)
  return _s;
}
inline const std::string& CNSecurityDefinition::_internal_securityshortname() const {
  return _impl_.securityshortname_.Get();
}
inline void CNSecurityDefinition::_internal_set_securityshortname(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.securityshortname_.Set(value, GetArenaForAllocation());
}
inline std::string* CNSecurityDefinition::_internal_mutable_securityshortname() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.securityshortname_.Mutable(GetArenaForAllocation());
}
inline std::string* CNSecurityDefinition::release_securityshortname() {
  // @@protoc_insertion_point(field_release:data.CNSecurityDefinition.securityShortName)
  if (!_internal_has_securityshortname()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.securityshortname_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.securityshortname_.IsDefault()) {
    _impl_.securityshortname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CNSecurityDefinition::set_allocated_securityshortname(std::string* securityshortname) {
  if (securityshortname != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.securityshortname_.SetAllocated(securityshortname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.securityshortname_.IsDefault()) {
    _impl_.securityshortname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:data.CNSecurityDefinition.securityShortName)
}

// optional .data.CurrencyType currencyCode = 6;
inline bool CNSecurityDefinition::_internal_has_currencycode() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool CNSecurityDefinition::has_currencycode() const {
  return _internal_has_currencycode();
}
inline void CNSecurityDefinition::clear_currencycode() {
  _impl_.currencycode_ = 0;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline ::data::CurrencyType CNSecurityDefinition::_internal_currencycode() const {
  return static_cast< ::data::CurrencyType >(_impl_.currencycode_);
}
inline ::data::CurrencyType CNSecurityDefinition::currencycode() const {
  // @@protoc_insertion_point(field_get:data.CNSecurityDefinition.currencyCode)
  return _internal_currencycode();
}
inline void CNSecurityDefinition::_internal_set_currencycode(::data::CurrencyType value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.currencycode_ = value;
}
inline void CNSecurityDefinition::set_currencycode(::data::CurrencyType value) {
  _internal_set_currencycode(value);
  // @@protoc_insertion_point(field_set:data.CNSecurityDefinition.currencyCode)
}

// optional string securityNameGB = 7;
inline bool CNSecurityDefinition::_internal_has_securitynamegb() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CNSecurityDefinition::has_securitynamegb() const {
  return _internal_has_securitynamegb();
}
inline void CNSecurityDefinition::clear_securitynamegb() {
  _impl_.securitynamegb_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& CNSecurityDefinition::securitynamegb() const {
  // @@protoc_insertion_point(field_get:data.CNSecurityDefinition.securityNameGB)
  return _internal_securitynamegb();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CNSecurityDefinition::set_securitynamegb(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.securitynamegb_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:data.CNSecurityDefinition.securityNameGB)
}
inline std::string* CNSecurityDefinition::mutable_securitynamegb() {
  std::string* _s = _internal_mutable_securitynamegb();
  // @@protoc_insertion_point(field_mutable:data.CNSecurityDefinition.securityNameGB)
  return _s;
}
inline const std::string& CNSecurityDefinition::_internal_securitynamegb() const {
  return _impl_.securitynamegb_.Get();
}
inline void CNSecurityDefinition::_internal_set_securitynamegb(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.securitynamegb_.Set(value, GetArenaForAllocation());
}
inline std::string* CNSecurityDefinition::_internal_mutable_securitynamegb() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.securitynamegb_.Mutable(GetArenaForAllocation());
}
inline std::string* CNSecurityDefinition::release_securitynamegb() {
  // @@protoc_insertion_point(field_release:data.CNSecurityDefinition.securityNameGB)
  if (!_internal_has_securitynamegb()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.securitynamegb_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.securitynamegb_.IsDefault()) {
    _impl_.securitynamegb_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CNSecurityDefinition::set_allocated_securitynamegb(std::string* securitynamegb) {
  if (securitynamegb != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.securitynamegb_.SetAllocated(securitynamegb, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.securitynamegb_.IsDefault()) {
    _impl_.securitynamegb_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:data.CNSecurityDefinition.securityNameGB)
}

// optional int64 lotSize = 8;
inline bool CNSecurityDefinition::_internal_has_lotsize() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool CNSecurityDefinition::has_lotsize() const {
  return _internal_has_lotsize();
}
inline void CNSecurityDefinition::clear_lotsize() {
  _impl_.lotsize_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline int64_t CNSecurityDefinition::_internal_lotsize() const {
  return _impl_.lotsize_;
}
inline int64_t CNSecurityDefinition::lotsize() const {
  // @@protoc_insertion_point(field_get:data.CNSecurityDefinition.lotSize)
  return _internal_lotsize();
}
inline void CNSecurityDefinition::_internal_set_lotsize(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.lotsize_ = value;
}
inline void CNSecurityDefinition::set_lotsize(int64_t value) {
  _internal_set_lotsize(value);
  // @@protoc_insertion_point(field_set:data.CNSecurityDefinition.lotSize)
}

// optional double previousClosingPrice = 9;
inline bool CNSecurityDefinition::_internal_has_previousclosingprice() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool CNSecurityDefinition::has_previousclosingprice() const {
  return _internal_has_previousclosingprice();
}
inline void CNSecurityDefinition::clear_previousclosingprice() {
  _impl_.previousclosingprice_ = 0;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline double CNSecurityDefinition::_internal_previousclosingprice() const {
  return _impl_.previousclosingprice_;
}
inline double CNSecurityDefinition::previousclosingprice() const {
  // @@protoc_insertion_point(field_get:data.CNSecurityDefinition.previousClosingPrice)
  return _internal_previousclosingprice();
}
inline void CNSecurityDefinition::_internal_set_previousclosingprice(double value) {
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.previousclosingprice_ = value;
}
inline void CNSecurityDefinition::set_previousclosingprice(double value) {
  _internal_set_previousclosingprice(value);
  // @@protoc_insertion_point(field_set:data.CNSecurityDefinition.previousClosingPrice)
}

// optional .data.IndicatesWhether shortSellFlag = 10;
inline bool CNSecurityDefinition::_internal_has_shortsellflag() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool CNSecurityDefinition::has_shortsellflag() const {
  return _internal_has_shortsellflag();
}
inline void CNSecurityDefinition::clear_shortsellflag() {
  _impl_.shortsellflag_ = 0;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline ::data::IndicatesWhether CNSecurityDefinition::_internal_shortsellflag() const {
  return static_cast< ::data::IndicatesWhether >(_impl_.shortsellflag_);
}
inline ::data::IndicatesWhether CNSecurityDefinition::shortsellflag() const {
  // @@protoc_insertion_point(field_get:data.CNSecurityDefinition.shortSellFlag)
  return _internal_shortsellflag();
}
inline void CNSecurityDefinition::_internal_set_shortsellflag(::data::IndicatesWhether value) {
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.shortsellflag_ = value;
}
inline void CNSecurityDefinition::set_shortsellflag(::data::IndicatesWhether value) {
  _internal_set_shortsellflag(value);
  // @@protoc_insertion_point(field_set:data.CNSecurityDefinition.shortSellFlag)
}

// optional int64 listingDate = 11;
inline bool CNSecurityDefinition::_internal_has_listingdate() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool CNSecurityDefinition::has_listingdate() const {
  return _internal_has_listingdate();
}
inline void CNSecurityDefinition::clear_listingdate() {
  _impl_.listingdate_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline int64_t CNSecurityDefinition::_internal_listingdate() const {
  return _impl_.listingdate_;
}
inline int64_t CNSecurityDefinition::listingdate() const {
  // @@protoc_insertion_point(field_get:data.CNSecurityDefinition.listingDate)
  return _internal_listingdate();
}
inline void CNSecurityDefinition::_internal_set_listingdate(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000400u;
  _impl_.listingdate_ = value;
}
inline void CNSecurityDefinition::set_listingdate(int64_t value) {
  _internal_set_listingdate(value);
  // @@protoc_insertion_point(field_set:data.CNSecurityDefinition.listingDate)
}

// -------------------------------------------------------------------

// CNSecurityStatus

// optional int64 securityCode = 1;
inline bool CNSecurityStatus::_internal_has_securitycode() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CNSecurityStatus::has_securitycode() const {
  return _internal_has_securitycode();
}
inline void CNSecurityStatus::clear_securitycode() {
  _impl_.securitycode_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int64_t CNSecurityStatus::_internal_securitycode() const {
  return _impl_.securitycode_;
}
inline int64_t CNSecurityStatus::securitycode() const {
  // @@protoc_insertion_point(field_get:data.CNSecurityStatus.securityCode)
  return _internal_securitycode();
}
inline void CNSecurityStatus::_internal_set_securitycode(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.securitycode_ = value;
}
inline void CNSecurityStatus::set_securitycode(int64_t value) {
  _internal_set_securitycode(value);
  // @@protoc_insertion_point(field_set:data.CNSecurityStatus.securityCode)
}

// optional .data.SecurityTradingStatus securityTradingStatus = 2;
inline bool CNSecurityStatus::_internal_has_securitytradingstatus() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CNSecurityStatus::has_securitytradingstatus() const {
  return _internal_has_securitytradingstatus();
}
inline void CNSecurityStatus::clear_securitytradingstatus() {
  _impl_.securitytradingstatus_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::data::SecurityTradingStatus CNSecurityStatus::_internal_securitytradingstatus() const {
  return static_cast< ::data::SecurityTradingStatus >(_impl_.securitytradingstatus_);
}
inline ::data::SecurityTradingStatus CNSecurityStatus::securitytradingstatus() const {
  // @@protoc_insertion_point(field_get:data.CNSecurityStatus.securityTradingStatus)
  return _internal_securitytradingstatus();
}
inline void CNSecurityStatus::_internal_set_securitytradingstatus(::data::SecurityTradingStatus value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.securitytradingstatus_ = value;
}
inline void CNSecurityStatus::set_securitytradingstatus(::data::SecurityTradingStatus value) {
  _internal_set_securitytradingstatus(value);
  // @@protoc_insertion_point(field_set:data.CNSecurityStatus.securityTradingStatus)
}

// optional string tradingPhaseCode = 3;
inline bool CNSecurityStatus::_internal_has_tradingphasecode() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CNSecurityStatus::has_tradingphasecode() const {
  return _internal_has_tradingphasecode();
}
inline void CNSecurityStatus::clear_tradingphasecode() {
  _impl_.tradingphasecode_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CNSecurityStatus::tradingphasecode() const {
  // @@protoc_insertion_point(field_get:data.CNSecurityStatus.tradingPhaseCode)
  return _internal_tradingphasecode();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CNSecurityStatus::set_tradingphasecode(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.tradingphasecode_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:data.CNSecurityStatus.tradingPhaseCode)
}
inline std::string* CNSecurityStatus::mutable_tradingphasecode() {
  std::string* _s = _internal_mutable_tradingphasecode();
  // @@protoc_insertion_point(field_mutable:data.CNSecurityStatus.tradingPhaseCode)
  return _s;
}
inline const std::string& CNSecurityStatus::_internal_tradingphasecode() const {
  return _impl_.tradingphasecode_.Get();
}
inline void CNSecurityStatus::_internal_set_tradingphasecode(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.tradingphasecode_.Set(value, GetArenaForAllocation());
}
inline std::string* CNSecurityStatus::_internal_mutable_tradingphasecode() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.tradingphasecode_.Mutable(GetArenaForAllocation());
}
inline std::string* CNSecurityStatus::release_tradingphasecode() {
  // @@protoc_insertion_point(field_release:data.CNSecurityStatus.tradingPhaseCode)
  if (!_internal_has_tradingphasecode()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.tradingphasecode_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.tradingphasecode_.IsDefault()) {
    _impl_.tradingphasecode_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CNSecurityStatus::set_allocated_tradingphasecode(std::string* tradingphasecode) {
  if (tradingphasecode != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.tradingphasecode_.SetAllocated(tradingphasecode, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.tradingphasecode_.IsDefault()) {
    _impl_.tradingphasecode_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:data.CNSecurityStatus.tradingPhaseCode)
}

// -------------------------------------------------------------------

// CNStatistics

// optional int64 securityCode = 1;
inline bool CNStatistics::_internal_has_securitycode() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CNStatistics::has_securitycode() const {
  return _internal_has_securitycode();
}
inline void CNStatistics::clear_securitycode() {
  _impl_.securitycode_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int64_t CNStatistics::_internal_securitycode() const {
  return _impl_.securitycode_;
}
inline int64_t CNStatistics::securitycode() const {
  // @@protoc_insertion_point(field_get:data.CNStatistics.securityCode)
  return _internal_securitycode();
}
inline void CNStatistics::_internal_set_securitycode(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.securitycode_ = value;
}
inline void CNStatistics::set_securitycode(int64_t value) {
  _internal_set_securitycode(value);
  // @@protoc_insertion_point(field_set:data.CNStatistics.securityCode)
}

// optional int64 sharesTraded = 2;
inline bool CNStatistics::_internal_has_sharestraded() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CNStatistics::has_sharestraded() const {
  return _internal_has_sharestraded();
}
inline void CNStatistics::clear_sharestraded() {
  _impl_.sharestraded_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int64_t CNStatistics::_internal_sharestraded() const {
  return _impl_.sharestraded_;
}
inline int64_t CNStatistics::sharestraded() const {
  // @@protoc_insertion_point(field_get:data.CNStatistics.sharesTraded)
  return _internal_sharestraded();
}
inline void CNStatistics::_internal_set_sharestraded(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.sharestraded_ = value;
}
inline void CNStatistics::set_sharestraded(int64_t value) {
  _internal_set_sharestraded(value);
  // @@protoc_insertion_point(field_set:data.CNStatistics.sharesTraded)
}

// optional double turnover = 3;
inline bool CNStatistics::_internal_has_turnover() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CNStatistics::has_turnover() const {
  return _internal_has_turnover();
}
inline void CNStatistics::clear_turnover() {
  _impl_.turnover_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline double CNStatistics::_internal_turnover() const {
  return _impl_.turnover_;
}
inline double CNStatistics::turnover() const {
  // @@protoc_insertion_point(field_get:data.CNStatistics.turnover)
  return _internal_turnover();
}
inline void CNStatistics::_internal_set_turnover(double value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.turnover_ = value;
}
inline void CNStatistics::set_turnover(double value) {
  _internal_set_turnover(value);
  // @@protoc_insertion_point(field_set:data.CNStatistics.turnover)
}

// optional double highPrice = 4;
inline bool CNStatistics::_internal_has_highprice() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CNStatistics::has_highprice() const {
  return _internal_has_highprice();
}
inline void CNStatistics::clear_highprice() {
  _impl_.highprice_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline double CNStatistics::_internal_highprice() const {
  return _impl_.highprice_;
}
inline double CNStatistics::highprice() const {
  // @@protoc_insertion_point(field_get:data.CNStatistics.highPrice)
  return _internal_highprice();
}
inline void CNStatistics::_internal_set_highprice(double value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.highprice_ = value;
}
inline void CNStatistics::set_highprice(double value) {
  _internal_set_highprice(value);
  // @@protoc_insertion_point(field_set:data.CNStatistics.highPrice)
}

// optional double lowPrice = 5;
inline bool CNStatistics::_internal_has_lowprice() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CNStatistics::has_lowprice() const {
  return _internal_has_lowprice();
}
inline void CNStatistics::clear_lowprice() {
  _impl_.lowprice_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline double CNStatistics::_internal_lowprice() const {
  return _impl_.lowprice_;
}
inline double CNStatistics::lowprice() const {
  // @@protoc_insertion_point(field_get:data.CNStatistics.lowPrice)
  return _internal_lowprice();
}
inline void CNStatistics::_internal_set_lowprice(double value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.lowprice_ = value;
}
inline void CNStatistics::set_lowprice(double value) {
  _internal_set_lowprice(value);
  // @@protoc_insertion_point(field_set:data.CNStatistics.lowPrice)
}

// optional double lastPrice = 6;
inline bool CNStatistics::_internal_has_lastprice() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool CNStatistics::has_lastprice() const {
  return _internal_has_lastprice();
}
inline void CNStatistics::clear_lastprice() {
  _impl_.lastprice_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline double CNStatistics::_internal_lastprice() const {
  return _impl_.lastprice_;
}
inline double CNStatistics::lastprice() const {
  // @@protoc_insertion_point(field_get:data.CNStatistics.lastPrice)
  return _internal_lastprice();
}
inline void CNStatistics::_internal_set_lastprice(double value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.lastprice_ = value;
}
inline void CNStatistics::set_lastprice(double value) {
  _internal_set_lastprice(value);
  // @@protoc_insertion_point(field_set:data.CNStatistics.lastPrice)
}

// optional double openingPrice = 7;
inline bool CNStatistics::_internal_has_openingprice() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool CNStatistics::has_openingprice() const {
  return _internal_has_openingprice();
}
inline void CNStatistics::clear_openingprice() {
  _impl_.openingprice_ = 0;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline double CNStatistics::_internal_openingprice() const {
  return _impl_.openingprice_;
}
inline double CNStatistics::openingprice() const {
  // @@protoc_insertion_point(field_get:data.CNStatistics.openingPrice)
  return _internal_openingprice();
}
inline void CNStatistics::_internal_set_openingprice(double value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.openingprice_ = value;
}
inline void CNStatistics::set_openingprice(double value) {
  _internal_set_openingprice(value);
  // @@protoc_insertion_point(field_set:data.CNStatistics.openingPrice)
}

// -------------------------------------------------------------------

// CNTopBook

// optional int64 securityCode = 1;
inline bool CNTopBook::_internal_has_securitycode() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CNTopBook::has_securitycode() const {
  return _internal_has_securitycode();
}
inline void CNTopBook::clear_securitycode() {
  _impl_.securitycode_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int64_t CNTopBook::_internal_securitycode() const {
  return _impl_.securitycode_;
}
inline int64_t CNTopBook::securitycode() const {
  // @@protoc_insertion_point(field_get:data.CNTopBook.securityCode)
  return _internal_securitycode();
}
inline void CNTopBook::_internal_set_securitycode(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.securitycode_ = value;
}
inline void CNTopBook::set_securitycode(int64_t value) {
  _internal_set_securitycode(value);
  // @@protoc_insertion_point(field_set:data.CNTopBook.securityCode)
}

// optional int64 aggregateBidQuantity = 2;
inline bool CNTopBook::_internal_has_aggregatebidquantity() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CNTopBook::has_aggregatebidquantity() const {
  return _internal_has_aggregatebidquantity();
}
inline void CNTopBook::clear_aggregatebidquantity() {
  _impl_.aggregatebidquantity_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int64_t CNTopBook::_internal_aggregatebidquantity() const {
  return _impl_.aggregatebidquantity_;
}
inline int64_t CNTopBook::aggregatebidquantity() const {
  // @@protoc_insertion_point(field_get:data.CNTopBook.aggregateBidQuantity)
  return _internal_aggregatebidquantity();
}
inline void CNTopBook::_internal_set_aggregatebidquantity(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.aggregatebidquantity_ = value;
}
inline void CNTopBook::set_aggregatebidquantity(int64_t value) {
  _internal_set_aggregatebidquantity(value);
  // @@protoc_insertion_point(field_set:data.CNTopBook.aggregateBidQuantity)
}

// optional int64 aggregateAskQuantity = 3;
inline bool CNTopBook::_internal_has_aggregateaskquantity() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CNTopBook::has_aggregateaskquantity() const {
  return _internal_has_aggregateaskquantity();
}
inline void CNTopBook::clear_aggregateaskquantity() {
  _impl_.aggregateaskquantity_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int64_t CNTopBook::_internal_aggregateaskquantity() const {
  return _impl_.aggregateaskquantity_;
}
inline int64_t CNTopBook::aggregateaskquantity() const {
  // @@protoc_insertion_point(field_get:data.CNTopBook.aggregateAskQuantity)
  return _internal_aggregateaskquantity();
}
inline void CNTopBook::_internal_set_aggregateaskquantity(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.aggregateaskquantity_ = value;
}
inline void CNTopBook::set_aggregateaskquantity(int64_t value) {
  _internal_set_aggregateaskquantity(value);
  // @@protoc_insertion_point(field_set:data.CNTopBook.aggregateAskQuantity)
}

// optional double bidPrice = 4;
inline bool CNTopBook::_internal_has_bidprice() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CNTopBook::has_bidprice() const {
  return _internal_has_bidprice();
}
inline void CNTopBook::clear_bidprice() {
  _impl_.bidprice_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline double CNTopBook::_internal_bidprice() const {
  return _impl_.bidprice_;
}
inline double CNTopBook::bidprice() const {
  // @@protoc_insertion_point(field_get:data.CNTopBook.bidPrice)
  return _internal_bidprice();
}
inline void CNTopBook::_internal_set_bidprice(double value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.bidprice_ = value;
}
inline void CNTopBook::set_bidprice(double value) {
  _internal_set_bidprice(value);
  // @@protoc_insertion_point(field_set:data.CNTopBook.bidPrice)
}

// optional double askPrice = 5;
inline bool CNTopBook::_internal_has_askprice() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CNTopBook::has_askprice() const {
  return _internal_has_askprice();
}
inline void CNTopBook::clear_askprice() {
  _impl_.askprice_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline double CNTopBook::_internal_askprice() const {
  return _impl_.askprice_;
}
inline double CNTopBook::askprice() const {
  // @@protoc_insertion_point(field_get:data.CNTopBook.askPrice)
  return _internal_askprice();
}
inline void CNTopBook::_internal_set_askprice(double value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.askprice_ = value;
}
inline void CNTopBook::set_askprice(double value) {
  _internal_set_askprice(value);
  // @@protoc_insertion_point(field_set:data.CNTopBook.askPrice)
}

// -------------------------------------------------------------------

// CertificationMsg

// optional .data.ActionType actionType = 1;
inline bool CertificationMsg::_internal_has_actiontype() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CertificationMsg::has_actiontype() const {
  return _internal_has_actiontype();
}
inline void CertificationMsg::clear_actiontype() {
  _impl_.actiontype_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::data::ActionType CertificationMsg::_internal_actiontype() const {
  return static_cast< ::data::ActionType >(_impl_.actiontype_);
}
inline ::data::ActionType CertificationMsg::actiontype() const {
  // @@protoc_insertion_point(field_get:data.CertificationMsg.actionType)
  return _internal_actiontype();
}
inline void CertificationMsg::_internal_set_actiontype(::data::ActionType value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.actiontype_ = value;
}
inline void CertificationMsg::set_actiontype(::data::ActionType value) {
  _internal_set_actiontype(value);
  // @@protoc_insertion_point(field_set:data.CertificationMsg.actionType)
}

// optional string auth = 2;
inline bool CertificationMsg::_internal_has_auth() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CertificationMsg::has_auth() const {
  return _internal_has_auth();
}
inline void CertificationMsg::clear_auth() {
  _impl_.auth_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CertificationMsg::auth() const {
  // @@protoc_insertion_point(field_get:data.CertificationMsg.auth)
  return _internal_auth();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CertificationMsg::set_auth(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.auth_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:data.CertificationMsg.auth)
}
inline std::string* CertificationMsg::mutable_auth() {
  std::string* _s = _internal_mutable_auth();
  // @@protoc_insertion_point(field_mutable:data.CertificationMsg.auth)
  return _s;
}
inline const std::string& CertificationMsg::_internal_auth() const {
  return _impl_.auth_.Get();
}
inline void CertificationMsg::_internal_set_auth(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.auth_.Set(value, GetArenaForAllocation());
}
inline std::string* CertificationMsg::_internal_mutable_auth() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.auth_.Mutable(GetArenaForAllocation());
}
inline std::string* CertificationMsg::release_auth() {
  // @@protoc_insertion_point(field_release:data.CertificationMsg.auth)
  if (!_internal_has_auth()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.auth_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.auth_.IsDefault()) {
    _impl_.auth_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CertificationMsg::set_allocated_auth(std::string* auth) {
  if (auth != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.auth_.SetAllocated(auth, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.auth_.IsDefault()) {
    _impl_.auth_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:data.CertificationMsg.auth)
}

// optional .data.Resp response = 3;
inline bool CertificationMsg::_internal_has_response() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.response_ != nullptr);
  return value;
}
inline bool CertificationMsg::has_response() const {
  return _internal_has_response();
}
inline void CertificationMsg::clear_response() {
  if (_impl_.response_ != nullptr) _impl_.response_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::data::Resp& CertificationMsg::_internal_response() const {
  const ::data::Resp* p = _impl_.response_;
  return p != nullptr ? *p : reinterpret_cast<const ::data::Resp&>(
      ::data::_Resp_default_instance_);
}
inline const ::data::Resp& CertificationMsg::response() const {
  // @@protoc_insertion_point(field_get:data.CertificationMsg.response)
  return _internal_response();
}
inline void CertificationMsg::unsafe_arena_set_allocated_response(
    ::data::Resp* response) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  _impl_.response_ = response;
  if (response) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:data.CertificationMsg.response)
}
inline ::data::Resp* CertificationMsg::release_response() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::data::Resp* temp = _impl_.response_;
  _impl_.response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::data::Resp* CertificationMsg::unsafe_arena_release_response() {
  // @@protoc_insertion_point(field_release:data.CertificationMsg.response)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::data::Resp* temp = _impl_.response_;
  _impl_.response_ = nullptr;
  return temp;
}
inline ::data::Resp* CertificationMsg::_internal_mutable_response() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.response_ == nullptr) {
    auto* p = CreateMaybeMessage<::data::Resp>(GetArenaForAllocation());
    _impl_.response_ = p;
  }
  return _impl_.response_;
}
inline ::data::Resp* CertificationMsg::mutable_response() {
  ::data::Resp* _msg = _internal_mutable_response();
  // @@protoc_insertion_point(field_mutable:data.CertificationMsg.response)
  return _msg;
}
inline void CertificationMsg::set_allocated_response(::data::Resp* response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.response_;
  }
  if (response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(response);
    if (message_arena != submessage_arena) {
      response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, response, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.response_ = response;
  // @@protoc_insertion_point(field_set_allocated:data.CertificationMsg.response)
}

// -------------------------------------------------------------------

// Resp

// optional .data.ResponseType type = 1;
inline bool Resp::_internal_has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Resp::has_type() const {
  return _internal_has_type();
}
inline void Resp::clear_type() {
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::data::ResponseType Resp::_internal_type() const {
  return static_cast< ::data::ResponseType >(_impl_.type_);
}
inline ::data::ResponseType Resp::type() const {
  // @@protoc_insertion_point(field_get:data.Resp.type)
  return _internal_type();
}
inline void Resp::_internal_set_type(::data::ResponseType value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.type_ = value;
}
inline void Resp::set_type(::data::ResponseType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:data.Resp.type)
}

// optional string errorMsg = 2;
inline bool Resp::_internal_has_errormsg() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Resp::has_errormsg() const {
  return _internal_has_errormsg();
}
inline void Resp::clear_errormsg() {
  _impl_.errormsg_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Resp::errormsg() const {
  // @@protoc_insertion_point(field_get:data.Resp.errorMsg)
  return _internal_errormsg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Resp::set_errormsg(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.errormsg_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:data.Resp.errorMsg)
}
inline std::string* Resp::mutable_errormsg() {
  std::string* _s = _internal_mutable_errormsg();
  // @@protoc_insertion_point(field_mutable:data.Resp.errorMsg)
  return _s;
}
inline const std::string& Resp::_internal_errormsg() const {
  return _impl_.errormsg_.Get();
}
inline void Resp::_internal_set_errormsg(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.errormsg_.Set(value, GetArenaForAllocation());
}
inline std::string* Resp::_internal_mutable_errormsg() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.errormsg_.Mutable(GetArenaForAllocation());
}
inline std::string* Resp::release_errormsg() {
  // @@protoc_insertion_point(field_release:data.Resp.errorMsg)
  if (!_internal_has_errormsg()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.errormsg_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.errormsg_.IsDefault()) {
    _impl_.errormsg_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Resp::set_allocated_errormsg(std::string* errormsg) {
  if (errormsg != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.errormsg_.SetAllocated(errormsg, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.errormsg_.IsDefault()) {
    _impl_.errormsg_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:data.Resp.errorMsg)
}

// -------------------------------------------------------------------

// Message

// optional .data.Message.DataType data_type = 1;
inline bool Message::_internal_has_data_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Message::has_data_type() const {
  return _internal_has_data_type();
}
inline void Message::clear_data_type() {
  _impl_.data_type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::data::Message_DataType Message::_internal_data_type() const {
  return static_cast< ::data::Message_DataType >(_impl_.data_type_);
}
inline ::data::Message_DataType Message::data_type() const {
  // @@protoc_insertion_point(field_get:data.Message.data_type)
  return _internal_data_type();
}
inline void Message::_internal_set_data_type(::data::Message_DataType value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.data_type_ = value;
}
inline void Message::set_data_type(::data::Message_DataType value) {
  _internal_set_data_type(value);
  // @@protoc_insertion_point(field_set:data.Message.data_type)
}

// .data.AddOddLotOrder addOddLotOrder = 2;
inline bool Message::_internal_has_addoddlotorder() const {
  return dataBody_case() == kAddOddLotOrder;
}
inline bool Message::has_addoddlotorder() const {
  return _internal_has_addoddlotorder();
}
inline void Message::set_has_addoddlotorder() {
  _impl_._oneof_case_[0] = kAddOddLotOrder;
}
inline void Message::clear_addoddlotorder() {
  if (_internal_has_addoddlotorder()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.dataBody_.addoddlotorder_;
    }
    clear_has_dataBody();
  }
}
inline ::data::AddOddLotOrder* Message::release_addoddlotorder() {
  // @@protoc_insertion_point(field_release:data.Message.addOddLotOrder)
  if (_internal_has_addoddlotorder()) {
    clear_has_dataBody();
    ::data::AddOddLotOrder* temp = _impl_.dataBody_.addoddlotorder_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.dataBody_.addoddlotorder_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::data::AddOddLotOrder& Message::_internal_addoddlotorder() const {
  return _internal_has_addoddlotorder()
      ? *_impl_.dataBody_.addoddlotorder_
      : reinterpret_cast< ::data::AddOddLotOrder&>(::data::_AddOddLotOrder_default_instance_);
}
inline const ::data::AddOddLotOrder& Message::addoddlotorder() const {
  // @@protoc_insertion_point(field_get:data.Message.addOddLotOrder)
  return _internal_addoddlotorder();
}
inline ::data::AddOddLotOrder* Message::unsafe_arena_release_addoddlotorder() {
  // @@protoc_insertion_point(field_unsafe_arena_release:data.Message.addOddLotOrder)
  if (_internal_has_addoddlotorder()) {
    clear_has_dataBody();
    ::data::AddOddLotOrder* temp = _impl_.dataBody_.addoddlotorder_;
    _impl_.dataBody_.addoddlotorder_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Message::unsafe_arena_set_allocated_addoddlotorder(::data::AddOddLotOrder* addoddlotorder) {
  clear_dataBody();
  if (addoddlotorder) {
    set_has_addoddlotorder();
    _impl_.dataBody_.addoddlotorder_ = addoddlotorder;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:data.Message.addOddLotOrder)
}
inline ::data::AddOddLotOrder* Message::_internal_mutable_addoddlotorder() {
  if (!_internal_has_addoddlotorder()) {
    clear_dataBody();
    set_has_addoddlotorder();
    _impl_.dataBody_.addoddlotorder_ = CreateMaybeMessage< ::data::AddOddLotOrder >(GetArenaForAllocation());
  }
  return _impl_.dataBody_.addoddlotorder_;
}
inline ::data::AddOddLotOrder* Message::mutable_addoddlotorder() {
  ::data::AddOddLotOrder* _msg = _internal_mutable_addoddlotorder();
  // @@protoc_insertion_point(field_mutable:data.Message.addOddLotOrder)
  return _msg;
}

// .data.AggregateOrderBookUpdate aggregateOrderBookUpdate = 3;
inline bool Message::_internal_has_aggregateorderbookupdate() const {
  return dataBody_case() == kAggregateOrderBookUpdate;
}
inline bool Message::has_aggregateorderbookupdate() const {
  return _internal_has_aggregateorderbookupdate();
}
inline void Message::set_has_aggregateorderbookupdate() {
  _impl_._oneof_case_[0] = kAggregateOrderBookUpdate;
}
inline void Message::clear_aggregateorderbookupdate() {
  if (_internal_has_aggregateorderbookupdate()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.dataBody_.aggregateorderbookupdate_;
    }
    clear_has_dataBody();
  }
}
inline ::data::AggregateOrderBookUpdate* Message::release_aggregateorderbookupdate() {
  // @@protoc_insertion_point(field_release:data.Message.aggregateOrderBookUpdate)
  if (_internal_has_aggregateorderbookupdate()) {
    clear_has_dataBody();
    ::data::AggregateOrderBookUpdate* temp = _impl_.dataBody_.aggregateorderbookupdate_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.dataBody_.aggregateorderbookupdate_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::data::AggregateOrderBookUpdate& Message::_internal_aggregateorderbookupdate() const {
  return _internal_has_aggregateorderbookupdate()
      ? *_impl_.dataBody_.aggregateorderbookupdate_
      : reinterpret_cast< ::data::AggregateOrderBookUpdate&>(::data::_AggregateOrderBookUpdate_default_instance_);
}
inline const ::data::AggregateOrderBookUpdate& Message::aggregateorderbookupdate() const {
  // @@protoc_insertion_point(field_get:data.Message.aggregateOrderBookUpdate)
  return _internal_aggregateorderbookupdate();
}
inline ::data::AggregateOrderBookUpdate* Message::unsafe_arena_release_aggregateorderbookupdate() {
  // @@protoc_insertion_point(field_unsafe_arena_release:data.Message.aggregateOrderBookUpdate)
  if (_internal_has_aggregateorderbookupdate()) {
    clear_has_dataBody();
    ::data::AggregateOrderBookUpdate* temp = _impl_.dataBody_.aggregateorderbookupdate_;
    _impl_.dataBody_.aggregateorderbookupdate_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Message::unsafe_arena_set_allocated_aggregateorderbookupdate(::data::AggregateOrderBookUpdate* aggregateorderbookupdate) {
  clear_dataBody();
  if (aggregateorderbookupdate) {
    set_has_aggregateorderbookupdate();
    _impl_.dataBody_.aggregateorderbookupdate_ = aggregateorderbookupdate;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:data.Message.aggregateOrderBookUpdate)
}
inline ::data::AggregateOrderBookUpdate* Message::_internal_mutable_aggregateorderbookupdate() {
  if (!_internal_has_aggregateorderbookupdate()) {
    clear_dataBody();
    set_has_aggregateorderbookupdate();
    _impl_.dataBody_.aggregateorderbookupdate_ = CreateMaybeMessage< ::data::AggregateOrderBookUpdate >(GetArenaForAllocation());
  }
  return _impl_.dataBody_.aggregateorderbookupdate_;
}
inline ::data::AggregateOrderBookUpdate* Message::mutable_aggregateorderbookupdate() {
  ::data::AggregateOrderBookUpdate* _msg = _internal_mutable_aggregateorderbookupdate();
  // @@protoc_insertion_point(field_mutable:data.Message.aggregateOrderBookUpdate)
  return _msg;
}

// .data.BrokerQueue brokerQueue = 4;
inline bool Message::_internal_has_brokerqueue() const {
  return dataBody_case() == kBrokerQueue;
}
inline bool Message::has_brokerqueue() const {
  return _internal_has_brokerqueue();
}
inline void Message::set_has_brokerqueue() {
  _impl_._oneof_case_[0] = kBrokerQueue;
}
inline void Message::clear_brokerqueue() {
  if (_internal_has_brokerqueue()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.dataBody_.brokerqueue_;
    }
    clear_has_dataBody();
  }
}
inline ::data::BrokerQueue* Message::release_brokerqueue() {
  // @@protoc_insertion_point(field_release:data.Message.brokerQueue)
  if (_internal_has_brokerqueue()) {
    clear_has_dataBody();
    ::data::BrokerQueue* temp = _impl_.dataBody_.brokerqueue_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.dataBody_.brokerqueue_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::data::BrokerQueue& Message::_internal_brokerqueue() const {
  return _internal_has_brokerqueue()
      ? *_impl_.dataBody_.brokerqueue_
      : reinterpret_cast< ::data::BrokerQueue&>(::data::_BrokerQueue_default_instance_);
}
inline const ::data::BrokerQueue& Message::brokerqueue() const {
  // @@protoc_insertion_point(field_get:data.Message.brokerQueue)
  return _internal_brokerqueue();
}
inline ::data::BrokerQueue* Message::unsafe_arena_release_brokerqueue() {
  // @@protoc_insertion_point(field_unsafe_arena_release:data.Message.brokerQueue)
  if (_internal_has_brokerqueue()) {
    clear_has_dataBody();
    ::data::BrokerQueue* temp = _impl_.dataBody_.brokerqueue_;
    _impl_.dataBody_.brokerqueue_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Message::unsafe_arena_set_allocated_brokerqueue(::data::BrokerQueue* brokerqueue) {
  clear_dataBody();
  if (brokerqueue) {
    set_has_brokerqueue();
    _impl_.dataBody_.brokerqueue_ = brokerqueue;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:data.Message.brokerQueue)
}
inline ::data::BrokerQueue* Message::_internal_mutable_brokerqueue() {
  if (!_internal_has_brokerqueue()) {
    clear_dataBody();
    set_has_brokerqueue();
    _impl_.dataBody_.brokerqueue_ = CreateMaybeMessage< ::data::BrokerQueue >(GetArenaForAllocation());
  }
  return _impl_.dataBody_.brokerqueue_;
}
inline ::data::BrokerQueue* Message::mutable_brokerqueue() {
  ::data::BrokerQueue* _msg = _internal_mutable_brokerqueue();
  // @@protoc_insertion_point(field_mutable:data.Message.brokerQueue)
  return _msg;
}

// .data.ClosingPrice closingPrice = 5;
inline bool Message::_internal_has_closingprice() const {
  return dataBody_case() == kClosingPrice;
}
inline bool Message::has_closingprice() const {
  return _internal_has_closingprice();
}
inline void Message::set_has_closingprice() {
  _impl_._oneof_case_[0] = kClosingPrice;
}
inline void Message::clear_closingprice() {
  if (_internal_has_closingprice()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.dataBody_.closingprice_;
    }
    clear_has_dataBody();
  }
}
inline ::data::ClosingPrice* Message::release_closingprice() {
  // @@protoc_insertion_point(field_release:data.Message.closingPrice)
  if (_internal_has_closingprice()) {
    clear_has_dataBody();
    ::data::ClosingPrice* temp = _impl_.dataBody_.closingprice_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.dataBody_.closingprice_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::data::ClosingPrice& Message::_internal_closingprice() const {
  return _internal_has_closingprice()
      ? *_impl_.dataBody_.closingprice_
      : reinterpret_cast< ::data::ClosingPrice&>(::data::_ClosingPrice_default_instance_);
}
inline const ::data::ClosingPrice& Message::closingprice() const {
  // @@protoc_insertion_point(field_get:data.Message.closingPrice)
  return _internal_closingprice();
}
inline ::data::ClosingPrice* Message::unsafe_arena_release_closingprice() {
  // @@protoc_insertion_point(field_unsafe_arena_release:data.Message.closingPrice)
  if (_internal_has_closingprice()) {
    clear_has_dataBody();
    ::data::ClosingPrice* temp = _impl_.dataBody_.closingprice_;
    _impl_.dataBody_.closingprice_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Message::unsafe_arena_set_allocated_closingprice(::data::ClosingPrice* closingprice) {
  clear_dataBody();
  if (closingprice) {
    set_has_closingprice();
    _impl_.dataBody_.closingprice_ = closingprice;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:data.Message.closingPrice)
}
inline ::data::ClosingPrice* Message::_internal_mutable_closingprice() {
  if (!_internal_has_closingprice()) {
    clear_dataBody();
    set_has_closingprice();
    _impl_.dataBody_.closingprice_ = CreateMaybeMessage< ::data::ClosingPrice >(GetArenaForAllocation());
  }
  return _impl_.dataBody_.closingprice_;
}
inline ::data::ClosingPrice* Message::mutable_closingprice() {
  ::data::ClosingPrice* _msg = _internal_mutable_closingprice();
  // @@protoc_insertion_point(field_mutable:data.Message.closingPrice)
  return _msg;
}

// .data.CurrencyRate currencyRate = 6;
inline bool Message::_internal_has_currencyrate() const {
  return dataBody_case() == kCurrencyRate;
}
inline bool Message::has_currencyrate() const {
  return _internal_has_currencyrate();
}
inline void Message::set_has_currencyrate() {
  _impl_._oneof_case_[0] = kCurrencyRate;
}
inline void Message::clear_currencyrate() {
  if (_internal_has_currencyrate()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.dataBody_.currencyrate_;
    }
    clear_has_dataBody();
  }
}
inline ::data::CurrencyRate* Message::release_currencyrate() {
  // @@protoc_insertion_point(field_release:data.Message.currencyRate)
  if (_internal_has_currencyrate()) {
    clear_has_dataBody();
    ::data::CurrencyRate* temp = _impl_.dataBody_.currencyrate_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.dataBody_.currencyrate_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::data::CurrencyRate& Message::_internal_currencyrate() const {
  return _internal_has_currencyrate()
      ? *_impl_.dataBody_.currencyrate_
      : reinterpret_cast< ::data::CurrencyRate&>(::data::_CurrencyRate_default_instance_);
}
inline const ::data::CurrencyRate& Message::currencyrate() const {
  // @@protoc_insertion_point(field_get:data.Message.currencyRate)
  return _internal_currencyrate();
}
inline ::data::CurrencyRate* Message::unsafe_arena_release_currencyrate() {
  // @@protoc_insertion_point(field_unsafe_arena_release:data.Message.currencyRate)
  if (_internal_has_currencyrate()) {
    clear_has_dataBody();
    ::data::CurrencyRate* temp = _impl_.dataBody_.currencyrate_;
    _impl_.dataBody_.currencyrate_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Message::unsafe_arena_set_allocated_currencyrate(::data::CurrencyRate* currencyrate) {
  clear_dataBody();
  if (currencyrate) {
    set_has_currencyrate();
    _impl_.dataBody_.currencyrate_ = currencyrate;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:data.Message.currencyRate)
}
inline ::data::CurrencyRate* Message::_internal_mutable_currencyrate() {
  if (!_internal_has_currencyrate()) {
    clear_dataBody();
    set_has_currencyrate();
    _impl_.dataBody_.currencyrate_ = CreateMaybeMessage< ::data::CurrencyRate >(GetArenaForAllocation());
  }
  return _impl_.dataBody_.currencyrate_;
}
inline ::data::CurrencyRate* Message::mutable_currencyrate() {
  ::data::CurrencyRate* _msg = _internal_mutable_currencyrate();
  // @@protoc_insertion_point(field_mutable:data.Message.currencyRate)
  return _msg;
}

// .data.DeleteOddLotOrder deleteOddLotOrder = 7;
inline bool Message::_internal_has_deleteoddlotorder() const {
  return dataBody_case() == kDeleteOddLotOrder;
}
inline bool Message::has_deleteoddlotorder() const {
  return _internal_has_deleteoddlotorder();
}
inline void Message::set_has_deleteoddlotorder() {
  _impl_._oneof_case_[0] = kDeleteOddLotOrder;
}
inline void Message::clear_deleteoddlotorder() {
  if (_internal_has_deleteoddlotorder()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.dataBody_.deleteoddlotorder_;
    }
    clear_has_dataBody();
  }
}
inline ::data::DeleteOddLotOrder* Message::release_deleteoddlotorder() {
  // @@protoc_insertion_point(field_release:data.Message.deleteOddLotOrder)
  if (_internal_has_deleteoddlotorder()) {
    clear_has_dataBody();
    ::data::DeleteOddLotOrder* temp = _impl_.dataBody_.deleteoddlotorder_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.dataBody_.deleteoddlotorder_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::data::DeleteOddLotOrder& Message::_internal_deleteoddlotorder() const {
  return _internal_has_deleteoddlotorder()
      ? *_impl_.dataBody_.deleteoddlotorder_
      : reinterpret_cast< ::data::DeleteOddLotOrder&>(::data::_DeleteOddLotOrder_default_instance_);
}
inline const ::data::DeleteOddLotOrder& Message::deleteoddlotorder() const {
  // @@protoc_insertion_point(field_get:data.Message.deleteOddLotOrder)
  return _internal_deleteoddlotorder();
}
inline ::data::DeleteOddLotOrder* Message::unsafe_arena_release_deleteoddlotorder() {
  // @@protoc_insertion_point(field_unsafe_arena_release:data.Message.deleteOddLotOrder)
  if (_internal_has_deleteoddlotorder()) {
    clear_has_dataBody();
    ::data::DeleteOddLotOrder* temp = _impl_.dataBody_.deleteoddlotorder_;
    _impl_.dataBody_.deleteoddlotorder_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Message::unsafe_arena_set_allocated_deleteoddlotorder(::data::DeleteOddLotOrder* deleteoddlotorder) {
  clear_dataBody();
  if (deleteoddlotorder) {
    set_has_deleteoddlotorder();
    _impl_.dataBody_.deleteoddlotorder_ = deleteoddlotorder;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:data.Message.deleteOddLotOrder)
}
inline ::data::DeleteOddLotOrder* Message::_internal_mutable_deleteoddlotorder() {
  if (!_internal_has_deleteoddlotorder()) {
    clear_dataBody();
    set_has_deleteoddlotorder();
    _impl_.dataBody_.deleteoddlotorder_ = CreateMaybeMessage< ::data::DeleteOddLotOrder >(GetArenaForAllocation());
  }
  return _impl_.dataBody_.deleteoddlotorder_;
}
inline ::data::DeleteOddLotOrder* Message::mutable_deleteoddlotorder() {
  ::data::DeleteOddLotOrder* _msg = _internal_mutable_deleteoddlotorder();
  // @@protoc_insertion_point(field_mutable:data.Message.deleteOddLotOrder)
  return _msg;
}

// .data.IndexData indexData = 8;
inline bool Message::_internal_has_indexdata() const {
  return dataBody_case() == kIndexData;
}
inline bool Message::has_indexdata() const {
  return _internal_has_indexdata();
}
inline void Message::set_has_indexdata() {
  _impl_._oneof_case_[0] = kIndexData;
}
inline void Message::clear_indexdata() {
  if (_internal_has_indexdata()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.dataBody_.indexdata_;
    }
    clear_has_dataBody();
  }
}
inline ::data::IndexData* Message::release_indexdata() {
  // @@protoc_insertion_point(field_release:data.Message.indexData)
  if (_internal_has_indexdata()) {
    clear_has_dataBody();
    ::data::IndexData* temp = _impl_.dataBody_.indexdata_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.dataBody_.indexdata_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::data::IndexData& Message::_internal_indexdata() const {
  return _internal_has_indexdata()
      ? *_impl_.dataBody_.indexdata_
      : reinterpret_cast< ::data::IndexData&>(::data::_IndexData_default_instance_);
}
inline const ::data::IndexData& Message::indexdata() const {
  // @@protoc_insertion_point(field_get:data.Message.indexData)
  return _internal_indexdata();
}
inline ::data::IndexData* Message::unsafe_arena_release_indexdata() {
  // @@protoc_insertion_point(field_unsafe_arena_release:data.Message.indexData)
  if (_internal_has_indexdata()) {
    clear_has_dataBody();
    ::data::IndexData* temp = _impl_.dataBody_.indexdata_;
    _impl_.dataBody_.indexdata_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Message::unsafe_arena_set_allocated_indexdata(::data::IndexData* indexdata) {
  clear_dataBody();
  if (indexdata) {
    set_has_indexdata();
    _impl_.dataBody_.indexdata_ = indexdata;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:data.Message.indexData)
}
inline ::data::IndexData* Message::_internal_mutable_indexdata() {
  if (!_internal_has_indexdata()) {
    clear_dataBody();
    set_has_indexdata();
    _impl_.dataBody_.indexdata_ = CreateMaybeMessage< ::data::IndexData >(GetArenaForAllocation());
  }
  return _impl_.dataBody_.indexdata_;
}
inline ::data::IndexData* Message::mutable_indexdata() {
  ::data::IndexData* _msg = _internal_mutable_indexdata();
  // @@protoc_insertion_point(field_mutable:data.Message.indexData)
  return _msg;
}

// .data.IndexDefinition indexDefinition = 9;
inline bool Message::_internal_has_indexdefinition() const {
  return dataBody_case() == kIndexDefinition;
}
inline bool Message::has_indexdefinition() const {
  return _internal_has_indexdefinition();
}
inline void Message::set_has_indexdefinition() {
  _impl_._oneof_case_[0] = kIndexDefinition;
}
inline void Message::clear_indexdefinition() {
  if (_internal_has_indexdefinition()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.dataBody_.indexdefinition_;
    }
    clear_has_dataBody();
  }
}
inline ::data::IndexDefinition* Message::release_indexdefinition() {
  // @@protoc_insertion_point(field_release:data.Message.indexDefinition)
  if (_internal_has_indexdefinition()) {
    clear_has_dataBody();
    ::data::IndexDefinition* temp = _impl_.dataBody_.indexdefinition_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.dataBody_.indexdefinition_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::data::IndexDefinition& Message::_internal_indexdefinition() const {
  return _internal_has_indexdefinition()
      ? *_impl_.dataBody_.indexdefinition_
      : reinterpret_cast< ::data::IndexDefinition&>(::data::_IndexDefinition_default_instance_);
}
inline const ::data::IndexDefinition& Message::indexdefinition() const {
  // @@protoc_insertion_point(field_get:data.Message.indexDefinition)
  return _internal_indexdefinition();
}
inline ::data::IndexDefinition* Message::unsafe_arena_release_indexdefinition() {
  // @@protoc_insertion_point(field_unsafe_arena_release:data.Message.indexDefinition)
  if (_internal_has_indexdefinition()) {
    clear_has_dataBody();
    ::data::IndexDefinition* temp = _impl_.dataBody_.indexdefinition_;
    _impl_.dataBody_.indexdefinition_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Message::unsafe_arena_set_allocated_indexdefinition(::data::IndexDefinition* indexdefinition) {
  clear_dataBody();
  if (indexdefinition) {
    set_has_indexdefinition();
    _impl_.dataBody_.indexdefinition_ = indexdefinition;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:data.Message.indexDefinition)
}
inline ::data::IndexDefinition* Message::_internal_mutable_indexdefinition() {
  if (!_internal_has_indexdefinition()) {
    clear_dataBody();
    set_has_indexdefinition();
    _impl_.dataBody_.indexdefinition_ = CreateMaybeMessage< ::data::IndexDefinition >(GetArenaForAllocation());
  }
  return _impl_.dataBody_.indexdefinition_;
}
inline ::data::IndexDefinition* Message::mutable_indexdefinition() {
  ::data::IndexDefinition* _msg = _internal_mutable_indexdefinition();
  // @@protoc_insertion_point(field_mutable:data.Message.indexDefinition)
  return _msg;
}

// .data.IndicativeEquilibriumPrice indicativeEquilibriumPrice = 10;
inline bool Message::_internal_has_indicativeequilibriumprice() const {
  return dataBody_case() == kIndicativeEquilibriumPrice;
}
inline bool Message::has_indicativeequilibriumprice() const {
  return _internal_has_indicativeequilibriumprice();
}
inline void Message::set_has_indicativeequilibriumprice() {
  _impl_._oneof_case_[0] = kIndicativeEquilibriumPrice;
}
inline void Message::clear_indicativeequilibriumprice() {
  if (_internal_has_indicativeequilibriumprice()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.dataBody_.indicativeequilibriumprice_;
    }
    clear_has_dataBody();
  }
}
inline ::data::IndicativeEquilibriumPrice* Message::release_indicativeequilibriumprice() {
  // @@protoc_insertion_point(field_release:data.Message.indicativeEquilibriumPrice)
  if (_internal_has_indicativeequilibriumprice()) {
    clear_has_dataBody();
    ::data::IndicativeEquilibriumPrice* temp = _impl_.dataBody_.indicativeequilibriumprice_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.dataBody_.indicativeequilibriumprice_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::data::IndicativeEquilibriumPrice& Message::_internal_indicativeequilibriumprice() const {
  return _internal_has_indicativeequilibriumprice()
      ? *_impl_.dataBody_.indicativeequilibriumprice_
      : reinterpret_cast< ::data::IndicativeEquilibriumPrice&>(::data::_IndicativeEquilibriumPrice_default_instance_);
}
inline const ::data::IndicativeEquilibriumPrice& Message::indicativeequilibriumprice() const {
  // @@protoc_insertion_point(field_get:data.Message.indicativeEquilibriumPrice)
  return _internal_indicativeequilibriumprice();
}
inline ::data::IndicativeEquilibriumPrice* Message::unsafe_arena_release_indicativeequilibriumprice() {
  // @@protoc_insertion_point(field_unsafe_arena_release:data.Message.indicativeEquilibriumPrice)
  if (_internal_has_indicativeequilibriumprice()) {
    clear_has_dataBody();
    ::data::IndicativeEquilibriumPrice* temp = _impl_.dataBody_.indicativeequilibriumprice_;
    _impl_.dataBody_.indicativeequilibriumprice_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Message::unsafe_arena_set_allocated_indicativeequilibriumprice(::data::IndicativeEquilibriumPrice* indicativeequilibriumprice) {
  clear_dataBody();
  if (indicativeequilibriumprice) {
    set_has_indicativeequilibriumprice();
    _impl_.dataBody_.indicativeequilibriumprice_ = indicativeequilibriumprice;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:data.Message.indicativeEquilibriumPrice)
}
inline ::data::IndicativeEquilibriumPrice* Message::_internal_mutable_indicativeequilibriumprice() {
  if (!_internal_has_indicativeequilibriumprice()) {
    clear_dataBody();
    set_has_indicativeequilibriumprice();
    _impl_.dataBody_.indicativeequilibriumprice_ = CreateMaybeMessage< ::data::IndicativeEquilibriumPrice >(GetArenaForAllocation());
  }
  return _impl_.dataBody_.indicativeequilibriumprice_;
}
inline ::data::IndicativeEquilibriumPrice* Message::mutable_indicativeequilibriumprice() {
  ::data::IndicativeEquilibriumPrice* _msg = _internal_mutable_indicativeequilibriumprice();
  // @@protoc_insertion_point(field_mutable:data.Message.indicativeEquilibriumPrice)
  return _msg;
}

// .data.LiquidityProvider liquidityProvider = 11;
inline bool Message::_internal_has_liquidityprovider() const {
  return dataBody_case() == kLiquidityProvider;
}
inline bool Message::has_liquidityprovider() const {
  return _internal_has_liquidityprovider();
}
inline void Message::set_has_liquidityprovider() {
  _impl_._oneof_case_[0] = kLiquidityProvider;
}
inline void Message::clear_liquidityprovider() {
  if (_internal_has_liquidityprovider()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.dataBody_.liquidityprovider_;
    }
    clear_has_dataBody();
  }
}
inline ::data::LiquidityProvider* Message::release_liquidityprovider() {
  // @@protoc_insertion_point(field_release:data.Message.liquidityProvider)
  if (_internal_has_liquidityprovider()) {
    clear_has_dataBody();
    ::data::LiquidityProvider* temp = _impl_.dataBody_.liquidityprovider_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.dataBody_.liquidityprovider_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::data::LiquidityProvider& Message::_internal_liquidityprovider() const {
  return _internal_has_liquidityprovider()
      ? *_impl_.dataBody_.liquidityprovider_
      : reinterpret_cast< ::data::LiquidityProvider&>(::data::_LiquidityProvider_default_instance_);
}
inline const ::data::LiquidityProvider& Message::liquidityprovider() const {
  // @@protoc_insertion_point(field_get:data.Message.liquidityProvider)
  return _internal_liquidityprovider();
}
inline ::data::LiquidityProvider* Message::unsafe_arena_release_liquidityprovider() {
  // @@protoc_insertion_point(field_unsafe_arena_release:data.Message.liquidityProvider)
  if (_internal_has_liquidityprovider()) {
    clear_has_dataBody();
    ::data::LiquidityProvider* temp = _impl_.dataBody_.liquidityprovider_;
    _impl_.dataBody_.liquidityprovider_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Message::unsafe_arena_set_allocated_liquidityprovider(::data::LiquidityProvider* liquidityprovider) {
  clear_dataBody();
  if (liquidityprovider) {
    set_has_liquidityprovider();
    _impl_.dataBody_.liquidityprovider_ = liquidityprovider;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:data.Message.liquidityProvider)
}
inline ::data::LiquidityProvider* Message::_internal_mutable_liquidityprovider() {
  if (!_internal_has_liquidityprovider()) {
    clear_dataBody();
    set_has_liquidityprovider();
    _impl_.dataBody_.liquidityprovider_ = CreateMaybeMessage< ::data::LiquidityProvider >(GetArenaForAllocation());
  }
  return _impl_.dataBody_.liquidityprovider_;
}
inline ::data::LiquidityProvider* Message::mutable_liquidityprovider() {
  ::data::LiquidityProvider* _msg = _internal_mutable_liquidityprovider();
  // @@protoc_insertion_point(field_mutable:data.Message.liquidityProvider)
  return _msg;
}

// .data.MarketDefinition marketDefinition = 12;
inline bool Message::_internal_has_marketdefinition() const {
  return dataBody_case() == kMarketDefinition;
}
inline bool Message::has_marketdefinition() const {
  return _internal_has_marketdefinition();
}
inline void Message::set_has_marketdefinition() {
  _impl_._oneof_case_[0] = kMarketDefinition;
}
inline void Message::clear_marketdefinition() {
  if (_internal_has_marketdefinition()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.dataBody_.marketdefinition_;
    }
    clear_has_dataBody();
  }
}
inline ::data::MarketDefinition* Message::release_marketdefinition() {
  // @@protoc_insertion_point(field_release:data.Message.marketDefinition)
  if (_internal_has_marketdefinition()) {
    clear_has_dataBody();
    ::data::MarketDefinition* temp = _impl_.dataBody_.marketdefinition_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.dataBody_.marketdefinition_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::data::MarketDefinition& Message::_internal_marketdefinition() const {
  return _internal_has_marketdefinition()
      ? *_impl_.dataBody_.marketdefinition_
      : reinterpret_cast< ::data::MarketDefinition&>(::data::_MarketDefinition_default_instance_);
}
inline const ::data::MarketDefinition& Message::marketdefinition() const {
  // @@protoc_insertion_point(field_get:data.Message.marketDefinition)
  return _internal_marketdefinition();
}
inline ::data::MarketDefinition* Message::unsafe_arena_release_marketdefinition() {
  // @@protoc_insertion_point(field_unsafe_arena_release:data.Message.marketDefinition)
  if (_internal_has_marketdefinition()) {
    clear_has_dataBody();
    ::data::MarketDefinition* temp = _impl_.dataBody_.marketdefinition_;
    _impl_.dataBody_.marketdefinition_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Message::unsafe_arena_set_allocated_marketdefinition(::data::MarketDefinition* marketdefinition) {
  clear_dataBody();
  if (marketdefinition) {
    set_has_marketdefinition();
    _impl_.dataBody_.marketdefinition_ = marketdefinition;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:data.Message.marketDefinition)
}
inline ::data::MarketDefinition* Message::_internal_mutable_marketdefinition() {
  if (!_internal_has_marketdefinition()) {
    clear_dataBody();
    set_has_marketdefinition();
    _impl_.dataBody_.marketdefinition_ = CreateMaybeMessage< ::data::MarketDefinition >(GetArenaForAllocation());
  }
  return _impl_.dataBody_.marketdefinition_;
}
inline ::data::MarketDefinition* Message::mutable_marketdefinition() {
  ::data::MarketDefinition* _msg = _internal_mutable_marketdefinition();
  // @@protoc_insertion_point(field_mutable:data.Message.marketDefinition)
  return _msg;
}

// .data.MarketTurnover marketTurnover = 13;
inline bool Message::_internal_has_marketturnover() const {
  return dataBody_case() == kMarketTurnover;
}
inline bool Message::has_marketturnover() const {
  return _internal_has_marketturnover();
}
inline void Message::set_has_marketturnover() {
  _impl_._oneof_case_[0] = kMarketTurnover;
}
inline void Message::clear_marketturnover() {
  if (_internal_has_marketturnover()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.dataBody_.marketturnover_;
    }
    clear_has_dataBody();
  }
}
inline ::data::MarketTurnover* Message::release_marketturnover() {
  // @@protoc_insertion_point(field_release:data.Message.marketTurnover)
  if (_internal_has_marketturnover()) {
    clear_has_dataBody();
    ::data::MarketTurnover* temp = _impl_.dataBody_.marketturnover_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.dataBody_.marketturnover_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::data::MarketTurnover& Message::_internal_marketturnover() const {
  return _internal_has_marketturnover()
      ? *_impl_.dataBody_.marketturnover_
      : reinterpret_cast< ::data::MarketTurnover&>(::data::_MarketTurnover_default_instance_);
}
inline const ::data::MarketTurnover& Message::marketturnover() const {
  // @@protoc_insertion_point(field_get:data.Message.marketTurnover)
  return _internal_marketturnover();
}
inline ::data::MarketTurnover* Message::unsafe_arena_release_marketturnover() {
  // @@protoc_insertion_point(field_unsafe_arena_release:data.Message.marketTurnover)
  if (_internal_has_marketturnover()) {
    clear_has_dataBody();
    ::data::MarketTurnover* temp = _impl_.dataBody_.marketturnover_;
    _impl_.dataBody_.marketturnover_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Message::unsafe_arena_set_allocated_marketturnover(::data::MarketTurnover* marketturnover) {
  clear_dataBody();
  if (marketturnover) {
    set_has_marketturnover();
    _impl_.dataBody_.marketturnover_ = marketturnover;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:data.Message.marketTurnover)
}
inline ::data::MarketTurnover* Message::_internal_mutable_marketturnover() {
  if (!_internal_has_marketturnover()) {
    clear_dataBody();
    set_has_marketturnover();
    _impl_.dataBody_.marketturnover_ = CreateMaybeMessage< ::data::MarketTurnover >(GetArenaForAllocation());
  }
  return _impl_.dataBody_.marketturnover_;
}
inline ::data::MarketTurnover* Message::mutable_marketturnover() {
  ::data::MarketTurnover* _msg = _internal_mutable_marketturnover();
  // @@protoc_insertion_point(field_mutable:data.Message.marketTurnover)
  return _msg;
}

// .data.News news = 14;
inline bool Message::_internal_has_news() const {
  return dataBody_case() == kNews;
}
inline bool Message::has_news() const {
  return _internal_has_news();
}
inline void Message::set_has_news() {
  _impl_._oneof_case_[0] = kNews;
}
inline void Message::clear_news() {
  if (_internal_has_news()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.dataBody_.news_;
    }
    clear_has_dataBody();
  }
}
inline ::data::News* Message::release_news() {
  // @@protoc_insertion_point(field_release:data.Message.news)
  if (_internal_has_news()) {
    clear_has_dataBody();
    ::data::News* temp = _impl_.dataBody_.news_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.dataBody_.news_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::data::News& Message::_internal_news() const {
  return _internal_has_news()
      ? *_impl_.dataBody_.news_
      : reinterpret_cast< ::data::News&>(::data::_News_default_instance_);
}
inline const ::data::News& Message::news() const {
  // @@protoc_insertion_point(field_get:data.Message.news)
  return _internal_news();
}
inline ::data::News* Message::unsafe_arena_release_news() {
  // @@protoc_insertion_point(field_unsafe_arena_release:data.Message.news)
  if (_internal_has_news()) {
    clear_has_dataBody();
    ::data::News* temp = _impl_.dataBody_.news_;
    _impl_.dataBody_.news_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Message::unsafe_arena_set_allocated_news(::data::News* news) {
  clear_dataBody();
  if (news) {
    set_has_news();
    _impl_.dataBody_.news_ = news;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:data.Message.news)
}
inline ::data::News* Message::_internal_mutable_news() {
  if (!_internal_has_news()) {
    clear_dataBody();
    set_has_news();
    _impl_.dataBody_.news_ = CreateMaybeMessage< ::data::News >(GetArenaForAllocation());
  }
  return _impl_.dataBody_.news_;
}
inline ::data::News* Message::mutable_news() {
  ::data::News* _msg = _internal_mutable_news();
  // @@protoc_insertion_point(field_mutable:data.Message.news)
  return _msg;
}

// .data.NominalPrice nominalPrice = 15;
inline bool Message::_internal_has_nominalprice() const {
  return dataBody_case() == kNominalPrice;
}
inline bool Message::has_nominalprice() const {
  return _internal_has_nominalprice();
}
inline void Message::set_has_nominalprice() {
  _impl_._oneof_case_[0] = kNominalPrice;
}
inline void Message::clear_nominalprice() {
  if (_internal_has_nominalprice()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.dataBody_.nominalprice_;
    }
    clear_has_dataBody();
  }
}
inline ::data::NominalPrice* Message::release_nominalprice() {
  // @@protoc_insertion_point(field_release:data.Message.nominalPrice)
  if (_internal_has_nominalprice()) {
    clear_has_dataBody();
    ::data::NominalPrice* temp = _impl_.dataBody_.nominalprice_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.dataBody_.nominalprice_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::data::NominalPrice& Message::_internal_nominalprice() const {
  return _internal_has_nominalprice()
      ? *_impl_.dataBody_.nominalprice_
      : reinterpret_cast< ::data::NominalPrice&>(::data::_NominalPrice_default_instance_);
}
inline const ::data::NominalPrice& Message::nominalprice() const {
  // @@protoc_insertion_point(field_get:data.Message.nominalPrice)
  return _internal_nominalprice();
}
inline ::data::NominalPrice* Message::unsafe_arena_release_nominalprice() {
  // @@protoc_insertion_point(field_unsafe_arena_release:data.Message.nominalPrice)
  if (_internal_has_nominalprice()) {
    clear_has_dataBody();
    ::data::NominalPrice* temp = _impl_.dataBody_.nominalprice_;
    _impl_.dataBody_.nominalprice_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Message::unsafe_arena_set_allocated_nominalprice(::data::NominalPrice* nominalprice) {
  clear_dataBody();
  if (nominalprice) {
    set_has_nominalprice();
    _impl_.dataBody_.nominalprice_ = nominalprice;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:data.Message.nominalPrice)
}
inline ::data::NominalPrice* Message::_internal_mutable_nominalprice() {
  if (!_internal_has_nominalprice()) {
    clear_dataBody();
    set_has_nominalprice();
    _impl_.dataBody_.nominalprice_ = CreateMaybeMessage< ::data::NominalPrice >(GetArenaForAllocation());
  }
  return _impl_.dataBody_.nominalprice_;
}
inline ::data::NominalPrice* Message::mutable_nominalprice() {
  ::data::NominalPrice* _msg = _internal_mutable_nominalprice();
  // @@protoc_insertion_point(field_mutable:data.Message.nominalPrice)
  return _msg;
}

// .data.OrderImbalance orderImbalance = 16;
inline bool Message::_internal_has_orderimbalance() const {
  return dataBody_case() == kOrderImbalance;
}
inline bool Message::has_orderimbalance() const {
  return _internal_has_orderimbalance();
}
inline void Message::set_has_orderimbalance() {
  _impl_._oneof_case_[0] = kOrderImbalance;
}
inline void Message::clear_orderimbalance() {
  if (_internal_has_orderimbalance()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.dataBody_.orderimbalance_;
    }
    clear_has_dataBody();
  }
}
inline ::data::OrderImbalance* Message::release_orderimbalance() {
  // @@protoc_insertion_point(field_release:data.Message.orderImbalance)
  if (_internal_has_orderimbalance()) {
    clear_has_dataBody();
    ::data::OrderImbalance* temp = _impl_.dataBody_.orderimbalance_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.dataBody_.orderimbalance_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::data::OrderImbalance& Message::_internal_orderimbalance() const {
  return _internal_has_orderimbalance()
      ? *_impl_.dataBody_.orderimbalance_
      : reinterpret_cast< ::data::OrderImbalance&>(::data::_OrderImbalance_default_instance_);
}
inline const ::data::OrderImbalance& Message::orderimbalance() const {
  // @@protoc_insertion_point(field_get:data.Message.orderImbalance)
  return _internal_orderimbalance();
}
inline ::data::OrderImbalance* Message::unsafe_arena_release_orderimbalance() {
  // @@protoc_insertion_point(field_unsafe_arena_release:data.Message.orderImbalance)
  if (_internal_has_orderimbalance()) {
    clear_has_dataBody();
    ::data::OrderImbalance* temp = _impl_.dataBody_.orderimbalance_;
    _impl_.dataBody_.orderimbalance_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Message::unsafe_arena_set_allocated_orderimbalance(::data::OrderImbalance* orderimbalance) {
  clear_dataBody();
  if (orderimbalance) {
    set_has_orderimbalance();
    _impl_.dataBody_.orderimbalance_ = orderimbalance;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:data.Message.orderImbalance)
}
inline ::data::OrderImbalance* Message::_internal_mutable_orderimbalance() {
  if (!_internal_has_orderimbalance()) {
    clear_dataBody();
    set_has_orderimbalance();
    _impl_.dataBody_.orderimbalance_ = CreateMaybeMessage< ::data::OrderImbalance >(GetArenaForAllocation());
  }
  return _impl_.dataBody_.orderimbalance_;
}
inline ::data::OrderImbalance* Message::mutable_orderimbalance() {
  ::data::OrderImbalance* _msg = _internal_mutable_orderimbalance();
  // @@protoc_insertion_point(field_mutable:data.Message.orderImbalance)
  return _msg;
}

// .data.ReferencePrice referencePrice = 17;
inline bool Message::_internal_has_referenceprice() const {
  return dataBody_case() == kReferencePrice;
}
inline bool Message::has_referenceprice() const {
  return _internal_has_referenceprice();
}
inline void Message::set_has_referenceprice() {
  _impl_._oneof_case_[0] = kReferencePrice;
}
inline void Message::clear_referenceprice() {
  if (_internal_has_referenceprice()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.dataBody_.referenceprice_;
    }
    clear_has_dataBody();
  }
}
inline ::data::ReferencePrice* Message::release_referenceprice() {
  // @@protoc_insertion_point(field_release:data.Message.referencePrice)
  if (_internal_has_referenceprice()) {
    clear_has_dataBody();
    ::data::ReferencePrice* temp = _impl_.dataBody_.referenceprice_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.dataBody_.referenceprice_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::data::ReferencePrice& Message::_internal_referenceprice() const {
  return _internal_has_referenceprice()
      ? *_impl_.dataBody_.referenceprice_
      : reinterpret_cast< ::data::ReferencePrice&>(::data::_ReferencePrice_default_instance_);
}
inline const ::data::ReferencePrice& Message::referenceprice() const {
  // @@protoc_insertion_point(field_get:data.Message.referencePrice)
  return _internal_referenceprice();
}
inline ::data::ReferencePrice* Message::unsafe_arena_release_referenceprice() {
  // @@protoc_insertion_point(field_unsafe_arena_release:data.Message.referencePrice)
  if (_internal_has_referenceprice()) {
    clear_has_dataBody();
    ::data::ReferencePrice* temp = _impl_.dataBody_.referenceprice_;
    _impl_.dataBody_.referenceprice_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Message::unsafe_arena_set_allocated_referenceprice(::data::ReferencePrice* referenceprice) {
  clear_dataBody();
  if (referenceprice) {
    set_has_referenceprice();
    _impl_.dataBody_.referenceprice_ = referenceprice;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:data.Message.referencePrice)
}
inline ::data::ReferencePrice* Message::_internal_mutable_referenceprice() {
  if (!_internal_has_referenceprice()) {
    clear_dataBody();
    set_has_referenceprice();
    _impl_.dataBody_.referenceprice_ = CreateMaybeMessage< ::data::ReferencePrice >(GetArenaForAllocation());
  }
  return _impl_.dataBody_.referenceprice_;
}
inline ::data::ReferencePrice* Message::mutable_referenceprice() {
  ::data::ReferencePrice* _msg = _internal_mutable_referenceprice();
  // @@protoc_insertion_point(field_mutable:data.Message.referencePrice)
  return _msg;
}

// .data.SecurityDefinition securityDefinition = 18;
inline bool Message::_internal_has_securitydefinition() const {
  return dataBody_case() == kSecurityDefinition;
}
inline bool Message::has_securitydefinition() const {
  return _internal_has_securitydefinition();
}
inline void Message::set_has_securitydefinition() {
  _impl_._oneof_case_[0] = kSecurityDefinition;
}
inline void Message::clear_securitydefinition() {
  if (_internal_has_securitydefinition()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.dataBody_.securitydefinition_;
    }
    clear_has_dataBody();
  }
}
inline ::data::SecurityDefinition* Message::release_securitydefinition() {
  // @@protoc_insertion_point(field_release:data.Message.securityDefinition)
  if (_internal_has_securitydefinition()) {
    clear_has_dataBody();
    ::data::SecurityDefinition* temp = _impl_.dataBody_.securitydefinition_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.dataBody_.securitydefinition_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::data::SecurityDefinition& Message::_internal_securitydefinition() const {
  return _internal_has_securitydefinition()
      ? *_impl_.dataBody_.securitydefinition_
      : reinterpret_cast< ::data::SecurityDefinition&>(::data::_SecurityDefinition_default_instance_);
}
inline const ::data::SecurityDefinition& Message::securitydefinition() const {
  // @@protoc_insertion_point(field_get:data.Message.securityDefinition)
  return _internal_securitydefinition();
}
inline ::data::SecurityDefinition* Message::unsafe_arena_release_securitydefinition() {
  // @@protoc_insertion_point(field_unsafe_arena_release:data.Message.securityDefinition)
  if (_internal_has_securitydefinition()) {
    clear_has_dataBody();
    ::data::SecurityDefinition* temp = _impl_.dataBody_.securitydefinition_;
    _impl_.dataBody_.securitydefinition_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Message::unsafe_arena_set_allocated_securitydefinition(::data::SecurityDefinition* securitydefinition) {
  clear_dataBody();
  if (securitydefinition) {
    set_has_securitydefinition();
    _impl_.dataBody_.securitydefinition_ = securitydefinition;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:data.Message.securityDefinition)
}
inline ::data::SecurityDefinition* Message::_internal_mutable_securitydefinition() {
  if (!_internal_has_securitydefinition()) {
    clear_dataBody();
    set_has_securitydefinition();
    _impl_.dataBody_.securitydefinition_ = CreateMaybeMessage< ::data::SecurityDefinition >(GetArenaForAllocation());
  }
  return _impl_.dataBody_.securitydefinition_;
}
inline ::data::SecurityDefinition* Message::mutable_securitydefinition() {
  ::data::SecurityDefinition* _msg = _internal_mutable_securitydefinition();
  // @@protoc_insertion_point(field_mutable:data.Message.securityDefinition)
  return _msg;
}

// .data.SecurityStatus securityStatus = 19;
inline bool Message::_internal_has_securitystatus() const {
  return dataBody_case() == kSecurityStatus;
}
inline bool Message::has_securitystatus() const {
  return _internal_has_securitystatus();
}
inline void Message::set_has_securitystatus() {
  _impl_._oneof_case_[0] = kSecurityStatus;
}
inline void Message::clear_securitystatus() {
  if (_internal_has_securitystatus()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.dataBody_.securitystatus_;
    }
    clear_has_dataBody();
  }
}
inline ::data::SecurityStatus* Message::release_securitystatus() {
  // @@protoc_insertion_point(field_release:data.Message.securityStatus)
  if (_internal_has_securitystatus()) {
    clear_has_dataBody();
    ::data::SecurityStatus* temp = _impl_.dataBody_.securitystatus_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.dataBody_.securitystatus_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::data::SecurityStatus& Message::_internal_securitystatus() const {
  return _internal_has_securitystatus()
      ? *_impl_.dataBody_.securitystatus_
      : reinterpret_cast< ::data::SecurityStatus&>(::data::_SecurityStatus_default_instance_);
}
inline const ::data::SecurityStatus& Message::securitystatus() const {
  // @@protoc_insertion_point(field_get:data.Message.securityStatus)
  return _internal_securitystatus();
}
inline ::data::SecurityStatus* Message::unsafe_arena_release_securitystatus() {
  // @@protoc_insertion_point(field_unsafe_arena_release:data.Message.securityStatus)
  if (_internal_has_securitystatus()) {
    clear_has_dataBody();
    ::data::SecurityStatus* temp = _impl_.dataBody_.securitystatus_;
    _impl_.dataBody_.securitystatus_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Message::unsafe_arena_set_allocated_securitystatus(::data::SecurityStatus* securitystatus) {
  clear_dataBody();
  if (securitystatus) {
    set_has_securitystatus();
    _impl_.dataBody_.securitystatus_ = securitystatus;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:data.Message.securityStatus)
}
inline ::data::SecurityStatus* Message::_internal_mutable_securitystatus() {
  if (!_internal_has_securitystatus()) {
    clear_dataBody();
    set_has_securitystatus();
    _impl_.dataBody_.securitystatus_ = CreateMaybeMessage< ::data::SecurityStatus >(GetArenaForAllocation());
  }
  return _impl_.dataBody_.securitystatus_;
}
inline ::data::SecurityStatus* Message::mutable_securitystatus() {
  ::data::SecurityStatus* _msg = _internal_mutable_securitystatus();
  // @@protoc_insertion_point(field_mutable:data.Message.securityStatus)
  return _msg;
}

// .data.Statistics statistics = 20;
inline bool Message::_internal_has_statistics() const {
  return dataBody_case() == kStatistics;
}
inline bool Message::has_statistics() const {
  return _internal_has_statistics();
}
inline void Message::set_has_statistics() {
  _impl_._oneof_case_[0] = kStatistics;
}
inline void Message::clear_statistics() {
  if (_internal_has_statistics()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.dataBody_.statistics_;
    }
    clear_has_dataBody();
  }
}
inline ::data::Statistics* Message::release_statistics() {
  // @@protoc_insertion_point(field_release:data.Message.statistics)
  if (_internal_has_statistics()) {
    clear_has_dataBody();
    ::data::Statistics* temp = _impl_.dataBody_.statistics_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.dataBody_.statistics_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::data::Statistics& Message::_internal_statistics() const {
  return _internal_has_statistics()
      ? *_impl_.dataBody_.statistics_
      : reinterpret_cast< ::data::Statistics&>(::data::_Statistics_default_instance_);
}
inline const ::data::Statistics& Message::statistics() const {
  // @@protoc_insertion_point(field_get:data.Message.statistics)
  return _internal_statistics();
}
inline ::data::Statistics* Message::unsafe_arena_release_statistics() {
  // @@protoc_insertion_point(field_unsafe_arena_release:data.Message.statistics)
  if (_internal_has_statistics()) {
    clear_has_dataBody();
    ::data::Statistics* temp = _impl_.dataBody_.statistics_;
    _impl_.dataBody_.statistics_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Message::unsafe_arena_set_allocated_statistics(::data::Statistics* statistics) {
  clear_dataBody();
  if (statistics) {
    set_has_statistics();
    _impl_.dataBody_.statistics_ = statistics;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:data.Message.statistics)
}
inline ::data::Statistics* Message::_internal_mutable_statistics() {
  if (!_internal_has_statistics()) {
    clear_dataBody();
    set_has_statistics();
    _impl_.dataBody_.statistics_ = CreateMaybeMessage< ::data::Statistics >(GetArenaForAllocation());
  }
  return _impl_.dataBody_.statistics_;
}
inline ::data::Statistics* Message::mutable_statistics() {
  ::data::Statistics* _msg = _internal_mutable_statistics();
  // @@protoc_insertion_point(field_mutable:data.Message.statistics)
  return _msg;
}

// .data.StockConnectDailyQuotaBalance stockConnectDailyQuotaBalance = 21;
inline bool Message::_internal_has_stockconnectdailyquotabalance() const {
  return dataBody_case() == kStockConnectDailyQuotaBalance;
}
inline bool Message::has_stockconnectdailyquotabalance() const {
  return _internal_has_stockconnectdailyquotabalance();
}
inline void Message::set_has_stockconnectdailyquotabalance() {
  _impl_._oneof_case_[0] = kStockConnectDailyQuotaBalance;
}
inline void Message::clear_stockconnectdailyquotabalance() {
  if (_internal_has_stockconnectdailyquotabalance()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.dataBody_.stockconnectdailyquotabalance_;
    }
    clear_has_dataBody();
  }
}
inline ::data::StockConnectDailyQuotaBalance* Message::release_stockconnectdailyquotabalance() {
  // @@protoc_insertion_point(field_release:data.Message.stockConnectDailyQuotaBalance)
  if (_internal_has_stockconnectdailyquotabalance()) {
    clear_has_dataBody();
    ::data::StockConnectDailyQuotaBalance* temp = _impl_.dataBody_.stockconnectdailyquotabalance_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.dataBody_.stockconnectdailyquotabalance_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::data::StockConnectDailyQuotaBalance& Message::_internal_stockconnectdailyquotabalance() const {
  return _internal_has_stockconnectdailyquotabalance()
      ? *_impl_.dataBody_.stockconnectdailyquotabalance_
      : reinterpret_cast< ::data::StockConnectDailyQuotaBalance&>(::data::_StockConnectDailyQuotaBalance_default_instance_);
}
inline const ::data::StockConnectDailyQuotaBalance& Message::stockconnectdailyquotabalance() const {
  // @@protoc_insertion_point(field_get:data.Message.stockConnectDailyQuotaBalance)
  return _internal_stockconnectdailyquotabalance();
}
inline ::data::StockConnectDailyQuotaBalance* Message::unsafe_arena_release_stockconnectdailyquotabalance() {
  // @@protoc_insertion_point(field_unsafe_arena_release:data.Message.stockConnectDailyQuotaBalance)
  if (_internal_has_stockconnectdailyquotabalance()) {
    clear_has_dataBody();
    ::data::StockConnectDailyQuotaBalance* temp = _impl_.dataBody_.stockconnectdailyquotabalance_;
    _impl_.dataBody_.stockconnectdailyquotabalance_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Message::unsafe_arena_set_allocated_stockconnectdailyquotabalance(::data::StockConnectDailyQuotaBalance* stockconnectdailyquotabalance) {
  clear_dataBody();
  if (stockconnectdailyquotabalance) {
    set_has_stockconnectdailyquotabalance();
    _impl_.dataBody_.stockconnectdailyquotabalance_ = stockconnectdailyquotabalance;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:data.Message.stockConnectDailyQuotaBalance)
}
inline ::data::StockConnectDailyQuotaBalance* Message::_internal_mutable_stockconnectdailyquotabalance() {
  if (!_internal_has_stockconnectdailyquotabalance()) {
    clear_dataBody();
    set_has_stockconnectdailyquotabalance();
    _impl_.dataBody_.stockconnectdailyquotabalance_ = CreateMaybeMessage< ::data::StockConnectDailyQuotaBalance >(GetArenaForAllocation());
  }
  return _impl_.dataBody_.stockconnectdailyquotabalance_;
}
inline ::data::StockConnectDailyQuotaBalance* Message::mutable_stockconnectdailyquotabalance() {
  ::data::StockConnectDailyQuotaBalance* _msg = _internal_mutable_stockconnectdailyquotabalance();
  // @@protoc_insertion_point(field_mutable:data.Message.stockConnectDailyQuotaBalance)
  return _msg;
}

// .data.StockConnectMarketTurnover stockConnectMarketTurnover = 22;
inline bool Message::_internal_has_stockconnectmarketturnover() const {
  return dataBody_case() == kStockConnectMarketTurnover;
}
inline bool Message::has_stockconnectmarketturnover() const {
  return _internal_has_stockconnectmarketturnover();
}
inline void Message::set_has_stockconnectmarketturnover() {
  _impl_._oneof_case_[0] = kStockConnectMarketTurnover;
}
inline void Message::clear_stockconnectmarketturnover() {
  if (_internal_has_stockconnectmarketturnover()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.dataBody_.stockconnectmarketturnover_;
    }
    clear_has_dataBody();
  }
}
inline ::data::StockConnectMarketTurnover* Message::release_stockconnectmarketturnover() {
  // @@protoc_insertion_point(field_release:data.Message.stockConnectMarketTurnover)
  if (_internal_has_stockconnectmarketturnover()) {
    clear_has_dataBody();
    ::data::StockConnectMarketTurnover* temp = _impl_.dataBody_.stockconnectmarketturnover_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.dataBody_.stockconnectmarketturnover_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::data::StockConnectMarketTurnover& Message::_internal_stockconnectmarketturnover() const {
  return _internal_has_stockconnectmarketturnover()
      ? *_impl_.dataBody_.stockconnectmarketturnover_
      : reinterpret_cast< ::data::StockConnectMarketTurnover&>(::data::_StockConnectMarketTurnover_default_instance_);
}
inline const ::data::StockConnectMarketTurnover& Message::stockconnectmarketturnover() const {
  // @@protoc_insertion_point(field_get:data.Message.stockConnectMarketTurnover)
  return _internal_stockconnectmarketturnover();
}
inline ::data::StockConnectMarketTurnover* Message::unsafe_arena_release_stockconnectmarketturnover() {
  // @@protoc_insertion_point(field_unsafe_arena_release:data.Message.stockConnectMarketTurnover)
  if (_internal_has_stockconnectmarketturnover()) {
    clear_has_dataBody();
    ::data::StockConnectMarketTurnover* temp = _impl_.dataBody_.stockconnectmarketturnover_;
    _impl_.dataBody_.stockconnectmarketturnover_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Message::unsafe_arena_set_allocated_stockconnectmarketturnover(::data::StockConnectMarketTurnover* stockconnectmarketturnover) {
  clear_dataBody();
  if (stockconnectmarketturnover) {
    set_has_stockconnectmarketturnover();
    _impl_.dataBody_.stockconnectmarketturnover_ = stockconnectmarketturnover;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:data.Message.stockConnectMarketTurnover)
}
inline ::data::StockConnectMarketTurnover* Message::_internal_mutable_stockconnectmarketturnover() {
  if (!_internal_has_stockconnectmarketturnover()) {
    clear_dataBody();
    set_has_stockconnectmarketturnover();
    _impl_.dataBody_.stockconnectmarketturnover_ = CreateMaybeMessage< ::data::StockConnectMarketTurnover >(GetArenaForAllocation());
  }
  return _impl_.dataBody_.stockconnectmarketturnover_;
}
inline ::data::StockConnectMarketTurnover* Message::mutable_stockconnectmarketturnover() {
  ::data::StockConnectMarketTurnover* _msg = _internal_mutable_stockconnectmarketturnover();
  // @@protoc_insertion_point(field_mutable:data.Message.stockConnectMarketTurnover)
  return _msg;
}

// .data.Trade trade = 23;
inline bool Message::_internal_has_trade() const {
  return dataBody_case() == kTrade;
}
inline bool Message::has_trade() const {
  return _internal_has_trade();
}
inline void Message::set_has_trade() {
  _impl_._oneof_case_[0] = kTrade;
}
inline void Message::clear_trade() {
  if (_internal_has_trade()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.dataBody_.trade_;
    }
    clear_has_dataBody();
  }
}
inline ::data::Trade* Message::release_trade() {
  // @@protoc_insertion_point(field_release:data.Message.trade)
  if (_internal_has_trade()) {
    clear_has_dataBody();
    ::data::Trade* temp = _impl_.dataBody_.trade_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.dataBody_.trade_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::data::Trade& Message::_internal_trade() const {
  return _internal_has_trade()
      ? *_impl_.dataBody_.trade_
      : reinterpret_cast< ::data::Trade&>(::data::_Trade_default_instance_);
}
inline const ::data::Trade& Message::trade() const {
  // @@protoc_insertion_point(field_get:data.Message.trade)
  return _internal_trade();
}
inline ::data::Trade* Message::unsafe_arena_release_trade() {
  // @@protoc_insertion_point(field_unsafe_arena_release:data.Message.trade)
  if (_internal_has_trade()) {
    clear_has_dataBody();
    ::data::Trade* temp = _impl_.dataBody_.trade_;
    _impl_.dataBody_.trade_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Message::unsafe_arena_set_allocated_trade(::data::Trade* trade) {
  clear_dataBody();
  if (trade) {
    set_has_trade();
    _impl_.dataBody_.trade_ = trade;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:data.Message.trade)
}
inline ::data::Trade* Message::_internal_mutable_trade() {
  if (!_internal_has_trade()) {
    clear_dataBody();
    set_has_trade();
    _impl_.dataBody_.trade_ = CreateMaybeMessage< ::data::Trade >(GetArenaForAllocation());
  }
  return _impl_.dataBody_.trade_;
}
inline ::data::Trade* Message::mutable_trade() {
  ::data::Trade* _msg = _internal_mutable_trade();
  // @@protoc_insertion_point(field_mutable:data.Message.trade)
  return _msg;
}

// .data.TradeCancel tradeCancel = 24;
inline bool Message::_internal_has_tradecancel() const {
  return dataBody_case() == kTradeCancel;
}
inline bool Message::has_tradecancel() const {
  return _internal_has_tradecancel();
}
inline void Message::set_has_tradecancel() {
  _impl_._oneof_case_[0] = kTradeCancel;
}
inline void Message::clear_tradecancel() {
  if (_internal_has_tradecancel()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.dataBody_.tradecancel_;
    }
    clear_has_dataBody();
  }
}
inline ::data::TradeCancel* Message::release_tradecancel() {
  // @@protoc_insertion_point(field_release:data.Message.tradeCancel)
  if (_internal_has_tradecancel()) {
    clear_has_dataBody();
    ::data::TradeCancel* temp = _impl_.dataBody_.tradecancel_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.dataBody_.tradecancel_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::data::TradeCancel& Message::_internal_tradecancel() const {
  return _internal_has_tradecancel()
      ? *_impl_.dataBody_.tradecancel_
      : reinterpret_cast< ::data::TradeCancel&>(::data::_TradeCancel_default_instance_);
}
inline const ::data::TradeCancel& Message::tradecancel() const {
  // @@protoc_insertion_point(field_get:data.Message.tradeCancel)
  return _internal_tradecancel();
}
inline ::data::TradeCancel* Message::unsafe_arena_release_tradecancel() {
  // @@protoc_insertion_point(field_unsafe_arena_release:data.Message.tradeCancel)
  if (_internal_has_tradecancel()) {
    clear_has_dataBody();
    ::data::TradeCancel* temp = _impl_.dataBody_.tradecancel_;
    _impl_.dataBody_.tradecancel_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Message::unsafe_arena_set_allocated_tradecancel(::data::TradeCancel* tradecancel) {
  clear_dataBody();
  if (tradecancel) {
    set_has_tradecancel();
    _impl_.dataBody_.tradecancel_ = tradecancel;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:data.Message.tradeCancel)
}
inline ::data::TradeCancel* Message::_internal_mutable_tradecancel() {
  if (!_internal_has_tradecancel()) {
    clear_dataBody();
    set_has_tradecancel();
    _impl_.dataBody_.tradecancel_ = CreateMaybeMessage< ::data::TradeCancel >(GetArenaForAllocation());
  }
  return _impl_.dataBody_.tradecancel_;
}
inline ::data::TradeCancel* Message::mutable_tradecancel() {
  ::data::TradeCancel* _msg = _internal_mutable_tradecancel();
  // @@protoc_insertion_point(field_mutable:data.Message.tradeCancel)
  return _msg;
}

// .data.TradingSessionStatus tradingSessionStatus = 25;
inline bool Message::_internal_has_tradingsessionstatus() const {
  return dataBody_case() == kTradingSessionStatus;
}
inline bool Message::has_tradingsessionstatus() const {
  return _internal_has_tradingsessionstatus();
}
inline void Message::set_has_tradingsessionstatus() {
  _impl_._oneof_case_[0] = kTradingSessionStatus;
}
inline void Message::clear_tradingsessionstatus() {
  if (_internal_has_tradingsessionstatus()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.dataBody_.tradingsessionstatus_;
    }
    clear_has_dataBody();
  }
}
inline ::data::TradingSessionStatus* Message::release_tradingsessionstatus() {
  // @@protoc_insertion_point(field_release:data.Message.tradingSessionStatus)
  if (_internal_has_tradingsessionstatus()) {
    clear_has_dataBody();
    ::data::TradingSessionStatus* temp = _impl_.dataBody_.tradingsessionstatus_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.dataBody_.tradingsessionstatus_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::data::TradingSessionStatus& Message::_internal_tradingsessionstatus() const {
  return _internal_has_tradingsessionstatus()
      ? *_impl_.dataBody_.tradingsessionstatus_
      : reinterpret_cast< ::data::TradingSessionStatus&>(::data::_TradingSessionStatus_default_instance_);
}
inline const ::data::TradingSessionStatus& Message::tradingsessionstatus() const {
  // @@protoc_insertion_point(field_get:data.Message.tradingSessionStatus)
  return _internal_tradingsessionstatus();
}
inline ::data::TradingSessionStatus* Message::unsafe_arena_release_tradingsessionstatus() {
  // @@protoc_insertion_point(field_unsafe_arena_release:data.Message.tradingSessionStatus)
  if (_internal_has_tradingsessionstatus()) {
    clear_has_dataBody();
    ::data::TradingSessionStatus* temp = _impl_.dataBody_.tradingsessionstatus_;
    _impl_.dataBody_.tradingsessionstatus_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Message::unsafe_arena_set_allocated_tradingsessionstatus(::data::TradingSessionStatus* tradingsessionstatus) {
  clear_dataBody();
  if (tradingsessionstatus) {
    set_has_tradingsessionstatus();
    _impl_.dataBody_.tradingsessionstatus_ = tradingsessionstatus;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:data.Message.tradingSessionStatus)
}
inline ::data::TradingSessionStatus* Message::_internal_mutable_tradingsessionstatus() {
  if (!_internal_has_tradingsessionstatus()) {
    clear_dataBody();
    set_has_tradingsessionstatus();
    _impl_.dataBody_.tradingsessionstatus_ = CreateMaybeMessage< ::data::TradingSessionStatus >(GetArenaForAllocation());
  }
  return _impl_.dataBody_.tradingsessionstatus_;
}
inline ::data::TradingSessionStatus* Message::mutable_tradingsessionstatus() {
  ::data::TradingSessionStatus* _msg = _internal_mutable_tradingsessionstatus();
  // @@protoc_insertion_point(field_mutable:data.Message.tradingSessionStatus)
  return _msg;
}

// .data.VCMTrigger vCMTrigger = 26;
inline bool Message::_internal_has_vcmtrigger() const {
  return dataBody_case() == kVCMTrigger;
}
inline bool Message::has_vcmtrigger() const {
  return _internal_has_vcmtrigger();
}
inline void Message::set_has_vcmtrigger() {
  _impl_._oneof_case_[0] = kVCMTrigger;
}
inline void Message::clear_vcmtrigger() {
  if (_internal_has_vcmtrigger()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.dataBody_.vcmtrigger_;
    }
    clear_has_dataBody();
  }
}
inline ::data::VCMTrigger* Message::release_vcmtrigger() {
  // @@protoc_insertion_point(field_release:data.Message.vCMTrigger)
  if (_internal_has_vcmtrigger()) {
    clear_has_dataBody();
    ::data::VCMTrigger* temp = _impl_.dataBody_.vcmtrigger_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.dataBody_.vcmtrigger_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::data::VCMTrigger& Message::_internal_vcmtrigger() const {
  return _internal_has_vcmtrigger()
      ? *_impl_.dataBody_.vcmtrigger_
      : reinterpret_cast< ::data::VCMTrigger&>(::data::_VCMTrigger_default_instance_);
}
inline const ::data::VCMTrigger& Message::vcmtrigger() const {
  // @@protoc_insertion_point(field_get:data.Message.vCMTrigger)
  return _internal_vcmtrigger();
}
inline ::data::VCMTrigger* Message::unsafe_arena_release_vcmtrigger() {
  // @@protoc_insertion_point(field_unsafe_arena_release:data.Message.vCMTrigger)
  if (_internal_has_vcmtrigger()) {
    clear_has_dataBody();
    ::data::VCMTrigger* temp = _impl_.dataBody_.vcmtrigger_;
    _impl_.dataBody_.vcmtrigger_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Message::unsafe_arena_set_allocated_vcmtrigger(::data::VCMTrigger* vcmtrigger) {
  clear_dataBody();
  if (vcmtrigger) {
    set_has_vcmtrigger();
    _impl_.dataBody_.vcmtrigger_ = vcmtrigger;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:data.Message.vCMTrigger)
}
inline ::data::VCMTrigger* Message::_internal_mutable_vcmtrigger() {
  if (!_internal_has_vcmtrigger()) {
    clear_dataBody();
    set_has_vcmtrigger();
    _impl_.dataBody_.vcmtrigger_ = CreateMaybeMessage< ::data::VCMTrigger >(GetArenaForAllocation());
  }
  return _impl_.dataBody_.vcmtrigger_;
}
inline ::data::VCMTrigger* Message::mutable_vcmtrigger() {
  ::data::VCMTrigger* _msg = _internal_mutable_vcmtrigger();
  // @@protoc_insertion_point(field_mutable:data.Message.vCMTrigger)
  return _msg;
}

// .data.Yield yield = 27;
inline bool Message::_internal_has_yield() const {
  return dataBody_case() == kYield;
}
inline bool Message::has_yield() const {
  return _internal_has_yield();
}
inline void Message::set_has_yield() {
  _impl_._oneof_case_[0] = kYield;
}
inline void Message::clear_yield() {
  if (_internal_has_yield()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.dataBody_.yield_;
    }
    clear_has_dataBody();
  }
}
inline ::data::Yield* Message::release_yield() {
  // @@protoc_insertion_point(field_release:data.Message.yield)
  if (_internal_has_yield()) {
    clear_has_dataBody();
    ::data::Yield* temp = _impl_.dataBody_.yield_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.dataBody_.yield_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::data::Yield& Message::_internal_yield() const {
  return _internal_has_yield()
      ? *_impl_.dataBody_.yield_
      : reinterpret_cast< ::data::Yield&>(::data::_Yield_default_instance_);
}
inline const ::data::Yield& Message::yield() const {
  // @@protoc_insertion_point(field_get:data.Message.yield)
  return _internal_yield();
}
inline ::data::Yield* Message::unsafe_arena_release_yield() {
  // @@protoc_insertion_point(field_unsafe_arena_release:data.Message.yield)
  if (_internal_has_yield()) {
    clear_has_dataBody();
    ::data::Yield* temp = _impl_.dataBody_.yield_;
    _impl_.dataBody_.yield_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Message::unsafe_arena_set_allocated_yield(::data::Yield* yield) {
  clear_dataBody();
  if (yield) {
    set_has_yield();
    _impl_.dataBody_.yield_ = yield;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:data.Message.yield)
}
inline ::data::Yield* Message::_internal_mutable_yield() {
  if (!_internal_has_yield()) {
    clear_dataBody();
    set_has_yield();
    _impl_.dataBody_.yield_ = CreateMaybeMessage< ::data::Yield >(GetArenaForAllocation());
  }
  return _impl_.dataBody_.yield_;
}
inline ::data::Yield* Message::mutable_yield() {
  ::data::Yield* _msg = _internal_mutable_yield();
  // @@protoc_insertion_point(field_mutable:data.Message.yield)
  return _msg;
}

// .data.AdjustedClosingPrice adjustedClosingPrice = 28;
inline bool Message::_internal_has_adjustedclosingprice() const {
  return dataBody_case() == kAdjustedClosingPrice;
}
inline bool Message::has_adjustedclosingprice() const {
  return _internal_has_adjustedclosingprice();
}
inline void Message::set_has_adjustedclosingprice() {
  _impl_._oneof_case_[0] = kAdjustedClosingPrice;
}
inline void Message::clear_adjustedclosingprice() {
  if (_internal_has_adjustedclosingprice()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.dataBody_.adjustedclosingprice_;
    }
    clear_has_dataBody();
  }
}
inline ::data::AdjustedClosingPrice* Message::release_adjustedclosingprice() {
  // @@protoc_insertion_point(field_release:data.Message.adjustedClosingPrice)
  if (_internal_has_adjustedclosingprice()) {
    clear_has_dataBody();
    ::data::AdjustedClosingPrice* temp = _impl_.dataBody_.adjustedclosingprice_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.dataBody_.adjustedclosingprice_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::data::AdjustedClosingPrice& Message::_internal_adjustedclosingprice() const {
  return _internal_has_adjustedclosingprice()
      ? *_impl_.dataBody_.adjustedclosingprice_
      : reinterpret_cast< ::data::AdjustedClosingPrice&>(::data::_AdjustedClosingPrice_default_instance_);
}
inline const ::data::AdjustedClosingPrice& Message::adjustedclosingprice() const {
  // @@protoc_insertion_point(field_get:data.Message.adjustedClosingPrice)
  return _internal_adjustedclosingprice();
}
inline ::data::AdjustedClosingPrice* Message::unsafe_arena_release_adjustedclosingprice() {
  // @@protoc_insertion_point(field_unsafe_arena_release:data.Message.adjustedClosingPrice)
  if (_internal_has_adjustedclosingprice()) {
    clear_has_dataBody();
    ::data::AdjustedClosingPrice* temp = _impl_.dataBody_.adjustedclosingprice_;
    _impl_.dataBody_.adjustedclosingprice_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Message::unsafe_arena_set_allocated_adjustedclosingprice(::data::AdjustedClosingPrice* adjustedclosingprice) {
  clear_dataBody();
  if (adjustedclosingprice) {
    set_has_adjustedclosingprice();
    _impl_.dataBody_.adjustedclosingprice_ = adjustedclosingprice;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:data.Message.adjustedClosingPrice)
}
inline ::data::AdjustedClosingPrice* Message::_internal_mutable_adjustedclosingprice() {
  if (!_internal_has_adjustedclosingprice()) {
    clear_dataBody();
    set_has_adjustedclosingprice();
    _impl_.dataBody_.adjustedclosingprice_ = CreateMaybeMessage< ::data::AdjustedClosingPrice >(GetArenaForAllocation());
  }
  return _impl_.dataBody_.adjustedclosingprice_;
}
inline ::data::AdjustedClosingPrice* Message::mutable_adjustedclosingprice() {
  ::data::AdjustedClosingPrice* _msg = _internal_mutable_adjustedclosingprice();
  // @@protoc_insertion_point(field_mutable:data.Message.adjustedClosingPrice)
  return _msg;
}

// .data.DayTradeSummary dayTradeSummary = 29;
inline bool Message::_internal_has_daytradesummary() const {
  return dataBody_case() == kDayTradeSummary;
}
inline bool Message::has_daytradesummary() const {
  return _internal_has_daytradesummary();
}
inline void Message::set_has_daytradesummary() {
  _impl_._oneof_case_[0] = kDayTradeSummary;
}
inline void Message::clear_daytradesummary() {
  if (_internal_has_daytradesummary()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.dataBody_.daytradesummary_;
    }
    clear_has_dataBody();
  }
}
inline ::data::DayTradeSummary* Message::release_daytradesummary() {
  // @@protoc_insertion_point(field_release:data.Message.dayTradeSummary)
  if (_internal_has_daytradesummary()) {
    clear_has_dataBody();
    ::data::DayTradeSummary* temp = _impl_.dataBody_.daytradesummary_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.dataBody_.daytradesummary_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::data::DayTradeSummary& Message::_internal_daytradesummary() const {
  return _internal_has_daytradesummary()
      ? *_impl_.dataBody_.daytradesummary_
      : reinterpret_cast< ::data::DayTradeSummary&>(::data::_DayTradeSummary_default_instance_);
}
inline const ::data::DayTradeSummary& Message::daytradesummary() const {
  // @@protoc_insertion_point(field_get:data.Message.dayTradeSummary)
  return _internal_daytradesummary();
}
inline ::data::DayTradeSummary* Message::unsafe_arena_release_daytradesummary() {
  // @@protoc_insertion_point(field_unsafe_arena_release:data.Message.dayTradeSummary)
  if (_internal_has_daytradesummary()) {
    clear_has_dataBody();
    ::data::DayTradeSummary* temp = _impl_.dataBody_.daytradesummary_;
    _impl_.dataBody_.daytradesummary_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Message::unsafe_arena_set_allocated_daytradesummary(::data::DayTradeSummary* daytradesummary) {
  clear_dataBody();
  if (daytradesummary) {
    set_has_daytradesummary();
    _impl_.dataBody_.daytradesummary_ = daytradesummary;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:data.Message.dayTradeSummary)
}
inline ::data::DayTradeSummary* Message::_internal_mutable_daytradesummary() {
  if (!_internal_has_daytradesummary()) {
    clear_dataBody();
    set_has_daytradesummary();
    _impl_.dataBody_.daytradesummary_ = CreateMaybeMessage< ::data::DayTradeSummary >(GetArenaForAllocation());
  }
  return _impl_.dataBody_.daytradesummary_;
}
inline ::data::DayTradeSummary* Message::mutable_daytradesummary() {
  ::data::DayTradeSummary* _msg = _internal_mutable_daytradesummary();
  // @@protoc_insertion_point(field_mutable:data.Message.dayTradeSummary)
  return _msg;
}

// .data.DayTradeSummaryNextShares dayTradeSummaryNextShares = 30;
inline bool Message::_internal_has_daytradesummarynextshares() const {
  return dataBody_case() == kDayTradeSummaryNextShares;
}
inline bool Message::has_daytradesummarynextshares() const {
  return _internal_has_daytradesummarynextshares();
}
inline void Message::set_has_daytradesummarynextshares() {
  _impl_._oneof_case_[0] = kDayTradeSummaryNextShares;
}
inline void Message::clear_daytradesummarynextshares() {
  if (_internal_has_daytradesummarynextshares()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.dataBody_.daytradesummarynextshares_;
    }
    clear_has_dataBody();
  }
}
inline ::data::DayTradeSummaryNextShares* Message::release_daytradesummarynextshares() {
  // @@protoc_insertion_point(field_release:data.Message.dayTradeSummaryNextShares)
  if (_internal_has_daytradesummarynextshares()) {
    clear_has_dataBody();
    ::data::DayTradeSummaryNextShares* temp = _impl_.dataBody_.daytradesummarynextshares_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.dataBody_.daytradesummarynextshares_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::data::DayTradeSummaryNextShares& Message::_internal_daytradesummarynextshares() const {
  return _internal_has_daytradesummarynextshares()
      ? *_impl_.dataBody_.daytradesummarynextshares_
      : reinterpret_cast< ::data::DayTradeSummaryNextShares&>(::data::_DayTradeSummaryNextShares_default_instance_);
}
inline const ::data::DayTradeSummaryNextShares& Message::daytradesummarynextshares() const {
  // @@protoc_insertion_point(field_get:data.Message.dayTradeSummaryNextShares)
  return _internal_daytradesummarynextshares();
}
inline ::data::DayTradeSummaryNextShares* Message::unsafe_arena_release_daytradesummarynextshares() {
  // @@protoc_insertion_point(field_unsafe_arena_release:data.Message.dayTradeSummaryNextShares)
  if (_internal_has_daytradesummarynextshares()) {
    clear_has_dataBody();
    ::data::DayTradeSummaryNextShares* temp = _impl_.dataBody_.daytradesummarynextshares_;
    _impl_.dataBody_.daytradesummarynextshares_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Message::unsafe_arena_set_allocated_daytradesummarynextshares(::data::DayTradeSummaryNextShares* daytradesummarynextshares) {
  clear_dataBody();
  if (daytradesummarynextshares) {
    set_has_daytradesummarynextshares();
    _impl_.dataBody_.daytradesummarynextshares_ = daytradesummarynextshares;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:data.Message.dayTradeSummaryNextShares)
}
inline ::data::DayTradeSummaryNextShares* Message::_internal_mutable_daytradesummarynextshares() {
  if (!_internal_has_daytradesummarynextshares()) {
    clear_dataBody();
    set_has_daytradesummarynextshares();
    _impl_.dataBody_.daytradesummarynextshares_ = CreateMaybeMessage< ::data::DayTradeSummaryNextShares >(GetArenaForAllocation());
  }
  return _impl_.dataBody_.daytradesummarynextshares_;
}
inline ::data::DayTradeSummaryNextShares* Message::mutable_daytradesummarynextshares() {
  ::data::DayTradeSummaryNextShares* _msg = _internal_mutable_daytradesummarynextshares();
  // @@protoc_insertion_point(field_mutable:data.Message.dayTradeSummaryNextShares)
  return _msg;
}

// .data.IPOInformation iPOInformation = 31;
inline bool Message::_internal_has_ipoinformation() const {
  return dataBody_case() == kIPOInformation;
}
inline bool Message::has_ipoinformation() const {
  return _internal_has_ipoinformation();
}
inline void Message::set_has_ipoinformation() {
  _impl_._oneof_case_[0] = kIPOInformation;
}
inline void Message::clear_ipoinformation() {
  if (_internal_has_ipoinformation()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.dataBody_.ipoinformation_;
    }
    clear_has_dataBody();
  }
}
inline ::data::IPOInformation* Message::release_ipoinformation() {
  // @@protoc_insertion_point(field_release:data.Message.iPOInformation)
  if (_internal_has_ipoinformation()) {
    clear_has_dataBody();
    ::data::IPOInformation* temp = _impl_.dataBody_.ipoinformation_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.dataBody_.ipoinformation_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::data::IPOInformation& Message::_internal_ipoinformation() const {
  return _internal_has_ipoinformation()
      ? *_impl_.dataBody_.ipoinformation_
      : reinterpret_cast< ::data::IPOInformation&>(::data::_IPOInformation_default_instance_);
}
inline const ::data::IPOInformation& Message::ipoinformation() const {
  // @@protoc_insertion_point(field_get:data.Message.iPOInformation)
  return _internal_ipoinformation();
}
inline ::data::IPOInformation* Message::unsafe_arena_release_ipoinformation() {
  // @@protoc_insertion_point(field_unsafe_arena_release:data.Message.iPOInformation)
  if (_internal_has_ipoinformation()) {
    clear_has_dataBody();
    ::data::IPOInformation* temp = _impl_.dataBody_.ipoinformation_;
    _impl_.dataBody_.ipoinformation_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Message::unsafe_arena_set_allocated_ipoinformation(::data::IPOInformation* ipoinformation) {
  clear_dataBody();
  if (ipoinformation) {
    set_has_ipoinformation();
    _impl_.dataBody_.ipoinformation_ = ipoinformation;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:data.Message.iPOInformation)
}
inline ::data::IPOInformation* Message::_internal_mutable_ipoinformation() {
  if (!_internal_has_ipoinformation()) {
    clear_dataBody();
    set_has_ipoinformation();
    _impl_.dataBody_.ipoinformation_ = CreateMaybeMessage< ::data::IPOInformation >(GetArenaForAllocation());
  }
  return _impl_.dataBody_.ipoinformation_;
}
inline ::data::IPOInformation* Message::mutable_ipoinformation() {
  ::data::IPOInformation* _msg = _internal_mutable_ipoinformation();
  // @@protoc_insertion_point(field_mutable:data.Message.iPOInformation)
  return _msg;
}

// .data.IPOQuotingPeriodUpdate iPOQuotingPeriodUpdate = 32;
inline bool Message::_internal_has_ipoquotingperiodupdate() const {
  return dataBody_case() == kIPOQuotingPeriodUpdate;
}
inline bool Message::has_ipoquotingperiodupdate() const {
  return _internal_has_ipoquotingperiodupdate();
}
inline void Message::set_has_ipoquotingperiodupdate() {
  _impl_._oneof_case_[0] = kIPOQuotingPeriodUpdate;
}
inline void Message::clear_ipoquotingperiodupdate() {
  if (_internal_has_ipoquotingperiodupdate()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.dataBody_.ipoquotingperiodupdate_;
    }
    clear_has_dataBody();
  }
}
inline ::data::IPOQuotingPeriodUpdate* Message::release_ipoquotingperiodupdate() {
  // @@protoc_insertion_point(field_release:data.Message.iPOQuotingPeriodUpdate)
  if (_internal_has_ipoquotingperiodupdate()) {
    clear_has_dataBody();
    ::data::IPOQuotingPeriodUpdate* temp = _impl_.dataBody_.ipoquotingperiodupdate_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.dataBody_.ipoquotingperiodupdate_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::data::IPOQuotingPeriodUpdate& Message::_internal_ipoquotingperiodupdate() const {
  return _internal_has_ipoquotingperiodupdate()
      ? *_impl_.dataBody_.ipoquotingperiodupdate_
      : reinterpret_cast< ::data::IPOQuotingPeriodUpdate&>(::data::_IPOQuotingPeriodUpdate_default_instance_);
}
inline const ::data::IPOQuotingPeriodUpdate& Message::ipoquotingperiodupdate() const {
  // @@protoc_insertion_point(field_get:data.Message.iPOQuotingPeriodUpdate)
  return _internal_ipoquotingperiodupdate();
}
inline ::data::IPOQuotingPeriodUpdate* Message::unsafe_arena_release_ipoquotingperiodupdate() {
  // @@protoc_insertion_point(field_unsafe_arena_release:data.Message.iPOQuotingPeriodUpdate)
  if (_internal_has_ipoquotingperiodupdate()) {
    clear_has_dataBody();
    ::data::IPOQuotingPeriodUpdate* temp = _impl_.dataBody_.ipoquotingperiodupdate_;
    _impl_.dataBody_.ipoquotingperiodupdate_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Message::unsafe_arena_set_allocated_ipoquotingperiodupdate(::data::IPOQuotingPeriodUpdate* ipoquotingperiodupdate) {
  clear_dataBody();
  if (ipoquotingperiodupdate) {
    set_has_ipoquotingperiodupdate();
    _impl_.dataBody_.ipoquotingperiodupdate_ = ipoquotingperiodupdate;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:data.Message.iPOQuotingPeriodUpdate)
}
inline ::data::IPOQuotingPeriodUpdate* Message::_internal_mutable_ipoquotingperiodupdate() {
  if (!_internal_has_ipoquotingperiodupdate()) {
    clear_dataBody();
    set_has_ipoquotingperiodupdate();
    _impl_.dataBody_.ipoquotingperiodupdate_ = CreateMaybeMessage< ::data::IPOQuotingPeriodUpdate >(GetArenaForAllocation());
  }
  return _impl_.dataBody_.ipoquotingperiodupdate_;
}
inline ::data::IPOQuotingPeriodUpdate* Message::mutable_ipoquotingperiodupdate() {
  ::data::IPOQuotingPeriodUpdate* _msg = _internal_mutable_ipoquotingperiodupdate();
  // @@protoc_insertion_point(field_mutable:data.Message.iPOQuotingPeriodUpdate)
  return _msg;
}

// .data.LongAdjustedClosingPrice longAdjustedClosingPrice = 33;
inline bool Message::_internal_has_longadjustedclosingprice() const {
  return dataBody_case() == kLongAdjustedClosingPrice;
}
inline bool Message::has_longadjustedclosingprice() const {
  return _internal_has_longadjustedclosingprice();
}
inline void Message::set_has_longadjustedclosingprice() {
  _impl_._oneof_case_[0] = kLongAdjustedClosingPrice;
}
inline void Message::clear_longadjustedclosingprice() {
  if (_internal_has_longadjustedclosingprice()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.dataBody_.longadjustedclosingprice_;
    }
    clear_has_dataBody();
  }
}
inline ::data::LongAdjustedClosingPrice* Message::release_longadjustedclosingprice() {
  // @@protoc_insertion_point(field_release:data.Message.longAdjustedClosingPrice)
  if (_internal_has_longadjustedclosingprice()) {
    clear_has_dataBody();
    ::data::LongAdjustedClosingPrice* temp = _impl_.dataBody_.longadjustedclosingprice_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.dataBody_.longadjustedclosingprice_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::data::LongAdjustedClosingPrice& Message::_internal_longadjustedclosingprice() const {
  return _internal_has_longadjustedclosingprice()
      ? *_impl_.dataBody_.longadjustedclosingprice_
      : reinterpret_cast< ::data::LongAdjustedClosingPrice&>(::data::_LongAdjustedClosingPrice_default_instance_);
}
inline const ::data::LongAdjustedClosingPrice& Message::longadjustedclosingprice() const {
  // @@protoc_insertion_point(field_get:data.Message.longAdjustedClosingPrice)
  return _internal_longadjustedclosingprice();
}
inline ::data::LongAdjustedClosingPrice* Message::unsafe_arena_release_longadjustedclosingprice() {
  // @@protoc_insertion_point(field_unsafe_arena_release:data.Message.longAdjustedClosingPrice)
  if (_internal_has_longadjustedclosingprice()) {
    clear_has_dataBody();
    ::data::LongAdjustedClosingPrice* temp = _impl_.dataBody_.longadjustedclosingprice_;
    _impl_.dataBody_.longadjustedclosingprice_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Message::unsafe_arena_set_allocated_longadjustedclosingprice(::data::LongAdjustedClosingPrice* longadjustedclosingprice) {
  clear_dataBody();
  if (longadjustedclosingprice) {
    set_has_longadjustedclosingprice();
    _impl_.dataBody_.longadjustedclosingprice_ = longadjustedclosingprice;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:data.Message.longAdjustedClosingPrice)
}
inline ::data::LongAdjustedClosingPrice* Message::_internal_mutable_longadjustedclosingprice() {
  if (!_internal_has_longadjustedclosingprice()) {
    clear_dataBody();
    set_has_longadjustedclosingprice();
    _impl_.dataBody_.longadjustedclosingprice_ = CreateMaybeMessage< ::data::LongAdjustedClosingPrice >(GetArenaForAllocation());
  }
  return _impl_.dataBody_.longadjustedclosingprice_;
}
inline ::data::LongAdjustedClosingPrice* Message::mutable_longadjustedclosingprice() {
  ::data::LongAdjustedClosingPrice* _msg = _internal_mutable_longadjustedclosingprice();
  // @@protoc_insertion_point(field_mutable:data.Message.longAdjustedClosingPrice)
  return _msg;
}

// .data.LongDayTradeSummary longDayTradeSummary = 34;
inline bool Message::_internal_has_longdaytradesummary() const {
  return dataBody_case() == kLongDayTradeSummary;
}
inline bool Message::has_longdaytradesummary() const {
  return _internal_has_longdaytradesummary();
}
inline void Message::set_has_longdaytradesummary() {
  _impl_._oneof_case_[0] = kLongDayTradeSummary;
}
inline void Message::clear_longdaytradesummary() {
  if (_internal_has_longdaytradesummary()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.dataBody_.longdaytradesummary_;
    }
    clear_has_dataBody();
  }
}
inline ::data::LongDayTradeSummary* Message::release_longdaytradesummary() {
  // @@protoc_insertion_point(field_release:data.Message.longDayTradeSummary)
  if (_internal_has_longdaytradesummary()) {
    clear_has_dataBody();
    ::data::LongDayTradeSummary* temp = _impl_.dataBody_.longdaytradesummary_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.dataBody_.longdaytradesummary_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::data::LongDayTradeSummary& Message::_internal_longdaytradesummary() const {
  return _internal_has_longdaytradesummary()
      ? *_impl_.dataBody_.longdaytradesummary_
      : reinterpret_cast< ::data::LongDayTradeSummary&>(::data::_LongDayTradeSummary_default_instance_);
}
inline const ::data::LongDayTradeSummary& Message::longdaytradesummary() const {
  // @@protoc_insertion_point(field_get:data.Message.longDayTradeSummary)
  return _internal_longdaytradesummary();
}
inline ::data::LongDayTradeSummary* Message::unsafe_arena_release_longdaytradesummary() {
  // @@protoc_insertion_point(field_unsafe_arena_release:data.Message.longDayTradeSummary)
  if (_internal_has_longdaytradesummary()) {
    clear_has_dataBody();
    ::data::LongDayTradeSummary* temp = _impl_.dataBody_.longdaytradesummary_;
    _impl_.dataBody_.longdaytradesummary_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Message::unsafe_arena_set_allocated_longdaytradesummary(::data::LongDayTradeSummary* longdaytradesummary) {
  clear_dataBody();
  if (longdaytradesummary) {
    set_has_longdaytradesummary();
    _impl_.dataBody_.longdaytradesummary_ = longdaytradesummary;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:data.Message.longDayTradeSummary)
}
inline ::data::LongDayTradeSummary* Message::_internal_mutable_longdaytradesummary() {
  if (!_internal_has_longdaytradesummary()) {
    clear_dataBody();
    set_has_longdaytradesummary();
    _impl_.dataBody_.longdaytradesummary_ = CreateMaybeMessage< ::data::LongDayTradeSummary >(GetArenaForAllocation());
  }
  return _impl_.dataBody_.longdaytradesummary_;
}
inline ::data::LongDayTradeSummary* Message::mutable_longdaytradesummary() {
  ::data::LongDayTradeSummary* _msg = _internal_mutable_longdaytradesummary();
  // @@protoc_insertion_point(field_mutable:data.Message.longDayTradeSummary)
  return _msg;
}

// .data.LongTradeCancelForNonNextSharesTrades longTradeCancelForNonNextSharesTrades = 35;
inline bool Message::_internal_has_longtradecancelfornonnextsharestrades() const {
  return dataBody_case() == kLongTradeCancelForNonNextSharesTrades;
}
inline bool Message::has_longtradecancelfornonnextsharestrades() const {
  return _internal_has_longtradecancelfornonnextsharestrades();
}
inline void Message::set_has_longtradecancelfornonnextsharestrades() {
  _impl_._oneof_case_[0] = kLongTradeCancelForNonNextSharesTrades;
}
inline void Message::clear_longtradecancelfornonnextsharestrades() {
  if (_internal_has_longtradecancelfornonnextsharestrades()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.dataBody_.longtradecancelfornonnextsharestrades_;
    }
    clear_has_dataBody();
  }
}
inline ::data::LongTradeCancelForNonNextSharesTrades* Message::release_longtradecancelfornonnextsharestrades() {
  // @@protoc_insertion_point(field_release:data.Message.longTradeCancelForNonNextSharesTrades)
  if (_internal_has_longtradecancelfornonnextsharestrades()) {
    clear_has_dataBody();
    ::data::LongTradeCancelForNonNextSharesTrades* temp = _impl_.dataBody_.longtradecancelfornonnextsharestrades_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.dataBody_.longtradecancelfornonnextsharestrades_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::data::LongTradeCancelForNonNextSharesTrades& Message::_internal_longtradecancelfornonnextsharestrades() const {
  return _internal_has_longtradecancelfornonnextsharestrades()
      ? *_impl_.dataBody_.longtradecancelfornonnextsharestrades_
      : reinterpret_cast< ::data::LongTradeCancelForNonNextSharesTrades&>(::data::_LongTradeCancelForNonNextSharesTrades_default_instance_);
}
inline const ::data::LongTradeCancelForNonNextSharesTrades& Message::longtradecancelfornonnextsharestrades() const {
  // @@protoc_insertion_point(field_get:data.Message.longTradeCancelForNonNextSharesTrades)
  return _internal_longtradecancelfornonnextsharestrades();
}
inline ::data::LongTradeCancelForNonNextSharesTrades* Message::unsafe_arena_release_longtradecancelfornonnextsharestrades() {
  // @@protoc_insertion_point(field_unsafe_arena_release:data.Message.longTradeCancelForNonNextSharesTrades)
  if (_internal_has_longtradecancelfornonnextsharestrades()) {
    clear_has_dataBody();
    ::data::LongTradeCancelForNonNextSharesTrades* temp = _impl_.dataBody_.longtradecancelfornonnextsharestrades_;
    _impl_.dataBody_.longtradecancelfornonnextsharestrades_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Message::unsafe_arena_set_allocated_longtradecancelfornonnextsharestrades(::data::LongTradeCancelForNonNextSharesTrades* longtradecancelfornonnextsharestrades) {
  clear_dataBody();
  if (longtradecancelfornonnextsharestrades) {
    set_has_longtradecancelfornonnextsharestrades();
    _impl_.dataBody_.longtradecancelfornonnextsharestrades_ = longtradecancelfornonnextsharestrades;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:data.Message.longTradeCancelForNonNextSharesTrades)
}
inline ::data::LongTradeCancelForNonNextSharesTrades* Message::_internal_mutable_longtradecancelfornonnextsharestrades() {
  if (!_internal_has_longtradecancelfornonnextsharestrades()) {
    clear_dataBody();
    set_has_longtradecancelfornonnextsharestrades();
    _impl_.dataBody_.longtradecancelfornonnextsharestrades_ = CreateMaybeMessage< ::data::LongTradeCancelForNonNextSharesTrades >(GetArenaForAllocation());
  }
  return _impl_.dataBody_.longtradecancelfornonnextsharestrades_;
}
inline ::data::LongTradeCancelForNonNextSharesTrades* Message::mutable_longtradecancelfornonnextsharestrades() {
  ::data::LongTradeCancelForNonNextSharesTrades* _msg = _internal_mutable_longtradecancelfornonnextsharestrades();
  // @@protoc_insertion_point(field_mutable:data.Message.longTradeCancelForNonNextSharesTrades)
  return _msg;
}

// .data.LongTradeCorrectionForNonNextsharesTrades longTradeCorrectionForNonNextsharesTrades = 36;
inline bool Message::_internal_has_longtradecorrectionfornonnextsharestrades() const {
  return dataBody_case() == kLongTradeCorrectionForNonNextsharesTrades;
}
inline bool Message::has_longtradecorrectionfornonnextsharestrades() const {
  return _internal_has_longtradecorrectionfornonnextsharestrades();
}
inline void Message::set_has_longtradecorrectionfornonnextsharestrades() {
  _impl_._oneof_case_[0] = kLongTradeCorrectionForNonNextsharesTrades;
}
inline void Message::clear_longtradecorrectionfornonnextsharestrades() {
  if (_internal_has_longtradecorrectionfornonnextsharestrades()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.dataBody_.longtradecorrectionfornonnextsharestrades_;
    }
    clear_has_dataBody();
  }
}
inline ::data::LongTradeCorrectionForNonNextsharesTrades* Message::release_longtradecorrectionfornonnextsharestrades() {
  // @@protoc_insertion_point(field_release:data.Message.longTradeCorrectionForNonNextsharesTrades)
  if (_internal_has_longtradecorrectionfornonnextsharestrades()) {
    clear_has_dataBody();
    ::data::LongTradeCorrectionForNonNextsharesTrades* temp = _impl_.dataBody_.longtradecorrectionfornonnextsharestrades_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.dataBody_.longtradecorrectionfornonnextsharestrades_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::data::LongTradeCorrectionForNonNextsharesTrades& Message::_internal_longtradecorrectionfornonnextsharestrades() const {
  return _internal_has_longtradecorrectionfornonnextsharestrades()
      ? *_impl_.dataBody_.longtradecorrectionfornonnextsharestrades_
      : reinterpret_cast< ::data::LongTradeCorrectionForNonNextsharesTrades&>(::data::_LongTradeCorrectionForNonNextsharesTrades_default_instance_);
}
inline const ::data::LongTradeCorrectionForNonNextsharesTrades& Message::longtradecorrectionfornonnextsharestrades() const {
  // @@protoc_insertion_point(field_get:data.Message.longTradeCorrectionForNonNextsharesTrades)
  return _internal_longtradecorrectionfornonnextsharestrades();
}
inline ::data::LongTradeCorrectionForNonNextsharesTrades* Message::unsafe_arena_release_longtradecorrectionfornonnextsharestrades() {
  // @@protoc_insertion_point(field_unsafe_arena_release:data.Message.longTradeCorrectionForNonNextsharesTrades)
  if (_internal_has_longtradecorrectionfornonnextsharestrades()) {
    clear_has_dataBody();
    ::data::LongTradeCorrectionForNonNextsharesTrades* temp = _impl_.dataBody_.longtradecorrectionfornonnextsharestrades_;
    _impl_.dataBody_.longtradecorrectionfornonnextsharestrades_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Message::unsafe_arena_set_allocated_longtradecorrectionfornonnextsharestrades(::data::LongTradeCorrectionForNonNextsharesTrades* longtradecorrectionfornonnextsharestrades) {
  clear_dataBody();
  if (longtradecorrectionfornonnextsharestrades) {
    set_has_longtradecorrectionfornonnextsharestrades();
    _impl_.dataBody_.longtradecorrectionfornonnextsharestrades_ = longtradecorrectionfornonnextsharestrades;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:data.Message.longTradeCorrectionForNonNextsharesTrades)
}
inline ::data::LongTradeCorrectionForNonNextsharesTrades* Message::_internal_mutable_longtradecorrectionfornonnextsharestrades() {
  if (!_internal_has_longtradecorrectionfornonnextsharestrades()) {
    clear_dataBody();
    set_has_longtradecorrectionfornonnextsharestrades();
    _impl_.dataBody_.longtradecorrectionfornonnextsharestrades_ = CreateMaybeMessage< ::data::LongTradeCorrectionForNonNextsharesTrades >(GetArenaForAllocation());
  }
  return _impl_.dataBody_.longtradecorrectionfornonnextsharestrades_;
}
inline ::data::LongTradeCorrectionForNonNextsharesTrades* Message::mutable_longtradecorrectionfornonnextsharestrades() {
  ::data::LongTradeCorrectionForNonNextsharesTrades* _msg = _internal_mutable_longtradecorrectionfornonnextsharestrades();
  // @@protoc_insertion_point(field_mutable:data.Message.longTradeCorrectionForNonNextsharesTrades)
  return _msg;
}

// .data.LongTradeReportForNonNextshares longTradeReportForNonNextshares = 37;
inline bool Message::_internal_has_longtradereportfornonnextshares() const {
  return dataBody_case() == kLongTradeReportForNonNextshares;
}
inline bool Message::has_longtradereportfornonnextshares() const {
  return _internal_has_longtradereportfornonnextshares();
}
inline void Message::set_has_longtradereportfornonnextshares() {
  _impl_._oneof_case_[0] = kLongTradeReportForNonNextshares;
}
inline void Message::clear_longtradereportfornonnextshares() {
  if (_internal_has_longtradereportfornonnextshares()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.dataBody_.longtradereportfornonnextshares_;
    }
    clear_has_dataBody();
  }
}
inline ::data::LongTradeReportForNonNextshares* Message::release_longtradereportfornonnextshares() {
  // @@protoc_insertion_point(field_release:data.Message.longTradeReportForNonNextshares)
  if (_internal_has_longtradereportfornonnextshares()) {
    clear_has_dataBody();
    ::data::LongTradeReportForNonNextshares* temp = _impl_.dataBody_.longtradereportfornonnextshares_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.dataBody_.longtradereportfornonnextshares_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::data::LongTradeReportForNonNextshares& Message::_internal_longtradereportfornonnextshares() const {
  return _internal_has_longtradereportfornonnextshares()
      ? *_impl_.dataBody_.longtradereportfornonnextshares_
      : reinterpret_cast< ::data::LongTradeReportForNonNextshares&>(::data::_LongTradeReportForNonNextshares_default_instance_);
}
inline const ::data::LongTradeReportForNonNextshares& Message::longtradereportfornonnextshares() const {
  // @@protoc_insertion_point(field_get:data.Message.longTradeReportForNonNextshares)
  return _internal_longtradereportfornonnextshares();
}
inline ::data::LongTradeReportForNonNextshares* Message::unsafe_arena_release_longtradereportfornonnextshares() {
  // @@protoc_insertion_point(field_unsafe_arena_release:data.Message.longTradeReportForNonNextshares)
  if (_internal_has_longtradereportfornonnextshares()) {
    clear_has_dataBody();
    ::data::LongTradeReportForNonNextshares* temp = _impl_.dataBody_.longtradereportfornonnextshares_;
    _impl_.dataBody_.longtradereportfornonnextshares_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Message::unsafe_arena_set_allocated_longtradereportfornonnextshares(::data::LongTradeReportForNonNextshares* longtradereportfornonnextshares) {
  clear_dataBody();
  if (longtradereportfornonnextshares) {
    set_has_longtradereportfornonnextshares();
    _impl_.dataBody_.longtradereportfornonnextshares_ = longtradereportfornonnextshares;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:data.Message.longTradeReportForNonNextshares)
}
inline ::data::LongTradeReportForNonNextshares* Message::_internal_mutable_longtradereportfornonnextshares() {
  if (!_internal_has_longtradereportfornonnextshares()) {
    clear_dataBody();
    set_has_longtradereportfornonnextshares();
    _impl_.dataBody_.longtradereportfornonnextshares_ = CreateMaybeMessage< ::data::LongTradeReportForNonNextshares >(GetArenaForAllocation());
  }
  return _impl_.dataBody_.longtradereportfornonnextshares_;
}
inline ::data::LongTradeReportForNonNextshares* Message::mutable_longtradereportfornonnextshares() {
  ::data::LongTradeReportForNonNextshares* _msg = _internal_mutable_longtradereportfornonnextshares();
  // @@protoc_insertion_point(field_mutable:data.Message.longTradeReportForNonNextshares)
  return _msg;
}

// .data.MWCBStatusMessage mWCBStatusMessage = 38;
inline bool Message::_internal_has_mwcbstatusmessage() const {
  return dataBody_case() == kMWCBStatusMessage;
}
inline bool Message::has_mwcbstatusmessage() const {
  return _internal_has_mwcbstatusmessage();
}
inline void Message::set_has_mwcbstatusmessage() {
  _impl_._oneof_case_[0] = kMWCBStatusMessage;
}
inline void Message::clear_mwcbstatusmessage() {
  if (_internal_has_mwcbstatusmessage()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.dataBody_.mwcbstatusmessage_;
    }
    clear_has_dataBody();
  }
}
inline ::data::MWCBStatusMessage* Message::release_mwcbstatusmessage() {
  // @@protoc_insertion_point(field_release:data.Message.mWCBStatusMessage)
  if (_internal_has_mwcbstatusmessage()) {
    clear_has_dataBody();
    ::data::MWCBStatusMessage* temp = _impl_.dataBody_.mwcbstatusmessage_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.dataBody_.mwcbstatusmessage_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::data::MWCBStatusMessage& Message::_internal_mwcbstatusmessage() const {
  return _internal_has_mwcbstatusmessage()
      ? *_impl_.dataBody_.mwcbstatusmessage_
      : reinterpret_cast< ::data::MWCBStatusMessage&>(::data::_MWCBStatusMessage_default_instance_);
}
inline const ::data::MWCBStatusMessage& Message::mwcbstatusmessage() const {
  // @@protoc_insertion_point(field_get:data.Message.mWCBStatusMessage)
  return _internal_mwcbstatusmessage();
}
inline ::data::MWCBStatusMessage* Message::unsafe_arena_release_mwcbstatusmessage() {
  // @@protoc_insertion_point(field_unsafe_arena_release:data.Message.mWCBStatusMessage)
  if (_internal_has_mwcbstatusmessage()) {
    clear_has_dataBody();
    ::data::MWCBStatusMessage* temp = _impl_.dataBody_.mwcbstatusmessage_;
    _impl_.dataBody_.mwcbstatusmessage_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Message::unsafe_arena_set_allocated_mwcbstatusmessage(::data::MWCBStatusMessage* mwcbstatusmessage) {
  clear_dataBody();
  if (mwcbstatusmessage) {
    set_has_mwcbstatusmessage();
    _impl_.dataBody_.mwcbstatusmessage_ = mwcbstatusmessage;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:data.Message.mWCBStatusMessage)
}
inline ::data::MWCBStatusMessage* Message::_internal_mutable_mwcbstatusmessage() {
  if (!_internal_has_mwcbstatusmessage()) {
    clear_dataBody();
    set_has_mwcbstatusmessage();
    _impl_.dataBody_.mwcbstatusmessage_ = CreateMaybeMessage< ::data::MWCBStatusMessage >(GetArenaForAllocation());
  }
  return _impl_.dataBody_.mwcbstatusmessage_;
}
inline ::data::MWCBStatusMessage* Message::mutable_mwcbstatusmessage() {
  ::data::MWCBStatusMessage* _msg = _internal_mutable_mwcbstatusmessage();
  // @@protoc_insertion_point(field_mutable:data.Message.mWCBStatusMessage)
  return _msg;
}

// .data.MarketWideCircuitBreaker marketWideCircuitBreaker = 39;
inline bool Message::_internal_has_marketwidecircuitbreaker() const {
  return dataBody_case() == kMarketWideCircuitBreaker;
}
inline bool Message::has_marketwidecircuitbreaker() const {
  return _internal_has_marketwidecircuitbreaker();
}
inline void Message::set_has_marketwidecircuitbreaker() {
  _impl_._oneof_case_[0] = kMarketWideCircuitBreaker;
}
inline void Message::clear_marketwidecircuitbreaker() {
  if (_internal_has_marketwidecircuitbreaker()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.dataBody_.marketwidecircuitbreaker_;
    }
    clear_has_dataBody();
  }
}
inline ::data::MarketWideCircuitBreaker* Message::release_marketwidecircuitbreaker() {
  // @@protoc_insertion_point(field_release:data.Message.marketWideCircuitBreaker)
  if (_internal_has_marketwidecircuitbreaker()) {
    clear_has_dataBody();
    ::data::MarketWideCircuitBreaker* temp = _impl_.dataBody_.marketwidecircuitbreaker_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.dataBody_.marketwidecircuitbreaker_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::data::MarketWideCircuitBreaker& Message::_internal_marketwidecircuitbreaker() const {
  return _internal_has_marketwidecircuitbreaker()
      ? *_impl_.dataBody_.marketwidecircuitbreaker_
      : reinterpret_cast< ::data::MarketWideCircuitBreaker&>(::data::_MarketWideCircuitBreaker_default_instance_);
}
inline const ::data::MarketWideCircuitBreaker& Message::marketwidecircuitbreaker() const {
  // @@protoc_insertion_point(field_get:data.Message.marketWideCircuitBreaker)
  return _internal_marketwidecircuitbreaker();
}
inline ::data::MarketWideCircuitBreaker* Message::unsafe_arena_release_marketwidecircuitbreaker() {
  // @@protoc_insertion_point(field_unsafe_arena_release:data.Message.marketWideCircuitBreaker)
  if (_internal_has_marketwidecircuitbreaker()) {
    clear_has_dataBody();
    ::data::MarketWideCircuitBreaker* temp = _impl_.dataBody_.marketwidecircuitbreaker_;
    _impl_.dataBody_.marketwidecircuitbreaker_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Message::unsafe_arena_set_allocated_marketwidecircuitbreaker(::data::MarketWideCircuitBreaker* marketwidecircuitbreaker) {
  clear_dataBody();
  if (marketwidecircuitbreaker) {
    set_has_marketwidecircuitbreaker();
    _impl_.dataBody_.marketwidecircuitbreaker_ = marketwidecircuitbreaker;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:data.Message.marketWideCircuitBreaker)
}
inline ::data::MarketWideCircuitBreaker* Message::_internal_mutable_marketwidecircuitbreaker() {
  if (!_internal_has_marketwidecircuitbreaker()) {
    clear_dataBody();
    set_has_marketwidecircuitbreaker();
    _impl_.dataBody_.marketwidecircuitbreaker_ = CreateMaybeMessage< ::data::MarketWideCircuitBreaker >(GetArenaForAllocation());
  }
  return _impl_.dataBody_.marketwidecircuitbreaker_;
}
inline ::data::MarketWideCircuitBreaker* Message::mutable_marketwidecircuitbreaker() {
  ::data::MarketWideCircuitBreaker* _msg = _internal_mutable_marketwidecircuitbreaker();
  // @@protoc_insertion_point(field_mutable:data.Message.marketWideCircuitBreaker)
  return _msg;
}

// .data.OperationalHalt operationalHalt = 40;
inline bool Message::_internal_has_operationalhalt() const {
  return dataBody_case() == kOperationalHalt;
}
inline bool Message::has_operationalhalt() const {
  return _internal_has_operationalhalt();
}
inline void Message::set_has_operationalhalt() {
  _impl_._oneof_case_[0] = kOperationalHalt;
}
inline void Message::clear_operationalhalt() {
  if (_internal_has_operationalhalt()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.dataBody_.operationalhalt_;
    }
    clear_has_dataBody();
  }
}
inline ::data::OperationalHalt* Message::release_operationalhalt() {
  // @@protoc_insertion_point(field_release:data.Message.operationalHalt)
  if (_internal_has_operationalhalt()) {
    clear_has_dataBody();
    ::data::OperationalHalt* temp = _impl_.dataBody_.operationalhalt_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.dataBody_.operationalhalt_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::data::OperationalHalt& Message::_internal_operationalhalt() const {
  return _internal_has_operationalhalt()
      ? *_impl_.dataBody_.operationalhalt_
      : reinterpret_cast< ::data::OperationalHalt&>(::data::_OperationalHalt_default_instance_);
}
inline const ::data::OperationalHalt& Message::operationalhalt() const {
  // @@protoc_insertion_point(field_get:data.Message.operationalHalt)
  return _internal_operationalhalt();
}
inline ::data::OperationalHalt* Message::unsafe_arena_release_operationalhalt() {
  // @@protoc_insertion_point(field_unsafe_arena_release:data.Message.operationalHalt)
  if (_internal_has_operationalhalt()) {
    clear_has_dataBody();
    ::data::OperationalHalt* temp = _impl_.dataBody_.operationalhalt_;
    _impl_.dataBody_.operationalhalt_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Message::unsafe_arena_set_allocated_operationalhalt(::data::OperationalHalt* operationalhalt) {
  clear_dataBody();
  if (operationalhalt) {
    set_has_operationalhalt();
    _impl_.dataBody_.operationalhalt_ = operationalhalt;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:data.Message.operationalHalt)
}
inline ::data::OperationalHalt* Message::_internal_mutable_operationalhalt() {
  if (!_internal_has_operationalhalt()) {
    clear_dataBody();
    set_has_operationalhalt();
    _impl_.dataBody_.operationalhalt_ = CreateMaybeMessage< ::data::OperationalHalt >(GetArenaForAllocation());
  }
  return _impl_.dataBody_.operationalhalt_;
}
inline ::data::OperationalHalt* Message::mutable_operationalhalt() {
  ::data::OperationalHalt* _msg = _internal_mutable_operationalhalt();
  // @@protoc_insertion_point(field_mutable:data.Message.operationalHalt)
  return _msg;
}

// .data.SaleConditionModifier saleConditionModifier = 41;
inline bool Message::_internal_has_saleconditionmodifier() const {
  return dataBody_case() == kSaleConditionModifier;
}
inline bool Message::has_saleconditionmodifier() const {
  return _internal_has_saleconditionmodifier();
}
inline void Message::set_has_saleconditionmodifier() {
  _impl_._oneof_case_[0] = kSaleConditionModifier;
}
inline void Message::clear_saleconditionmodifier() {
  if (_internal_has_saleconditionmodifier()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.dataBody_.saleconditionmodifier_;
    }
    clear_has_dataBody();
  }
}
inline ::data::SaleConditionModifier* Message::release_saleconditionmodifier() {
  // @@protoc_insertion_point(field_release:data.Message.saleConditionModifier)
  if (_internal_has_saleconditionmodifier()) {
    clear_has_dataBody();
    ::data::SaleConditionModifier* temp = _impl_.dataBody_.saleconditionmodifier_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.dataBody_.saleconditionmodifier_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::data::SaleConditionModifier& Message::_internal_saleconditionmodifier() const {
  return _internal_has_saleconditionmodifier()
      ? *_impl_.dataBody_.saleconditionmodifier_
      : reinterpret_cast< ::data::SaleConditionModifier&>(::data::_SaleConditionModifier_default_instance_);
}
inline const ::data::SaleConditionModifier& Message::saleconditionmodifier() const {
  // @@protoc_insertion_point(field_get:data.Message.saleConditionModifier)
  return _internal_saleconditionmodifier();
}
inline ::data::SaleConditionModifier* Message::unsafe_arena_release_saleconditionmodifier() {
  // @@protoc_insertion_point(field_unsafe_arena_release:data.Message.saleConditionModifier)
  if (_internal_has_saleconditionmodifier()) {
    clear_has_dataBody();
    ::data::SaleConditionModifier* temp = _impl_.dataBody_.saleconditionmodifier_;
    _impl_.dataBody_.saleconditionmodifier_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Message::unsafe_arena_set_allocated_saleconditionmodifier(::data::SaleConditionModifier* saleconditionmodifier) {
  clear_dataBody();
  if (saleconditionmodifier) {
    set_has_saleconditionmodifier();
    _impl_.dataBody_.saleconditionmodifier_ = saleconditionmodifier;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:data.Message.saleConditionModifier)
}
inline ::data::SaleConditionModifier* Message::_internal_mutable_saleconditionmodifier() {
  if (!_internal_has_saleconditionmodifier()) {
    clear_dataBody();
    set_has_saleconditionmodifier();
    _impl_.dataBody_.saleconditionmodifier_ = CreateMaybeMessage< ::data::SaleConditionModifier >(GetArenaForAllocation());
  }
  return _impl_.dataBody_.saleconditionmodifier_;
}
inline ::data::SaleConditionModifier* Message::mutable_saleconditionmodifier() {
  ::data::SaleConditionModifier* _msg = _internal_mutable_saleconditionmodifier();
  // @@protoc_insertion_point(field_mutable:data.Message.saleConditionModifier)
  return _msg;
}

// .data.ShortSaleRestrictionIndicatorMessage shortSaleRestrictionIndicatorMessage = 42;
inline bool Message::_internal_has_shortsalerestrictionindicatormessage() const {
  return dataBody_case() == kShortSaleRestrictionIndicatorMessage;
}
inline bool Message::has_shortsalerestrictionindicatormessage() const {
  return _internal_has_shortsalerestrictionindicatormessage();
}
inline void Message::set_has_shortsalerestrictionindicatormessage() {
  _impl_._oneof_case_[0] = kShortSaleRestrictionIndicatorMessage;
}
inline void Message::clear_shortsalerestrictionindicatormessage() {
  if (_internal_has_shortsalerestrictionindicatormessage()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.dataBody_.shortsalerestrictionindicatormessage_;
    }
    clear_has_dataBody();
  }
}
inline ::data::ShortSaleRestrictionIndicatorMessage* Message::release_shortsalerestrictionindicatormessage() {
  // @@protoc_insertion_point(field_release:data.Message.shortSaleRestrictionIndicatorMessage)
  if (_internal_has_shortsalerestrictionindicatormessage()) {
    clear_has_dataBody();
    ::data::ShortSaleRestrictionIndicatorMessage* temp = _impl_.dataBody_.shortsalerestrictionindicatormessage_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.dataBody_.shortsalerestrictionindicatormessage_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::data::ShortSaleRestrictionIndicatorMessage& Message::_internal_shortsalerestrictionindicatormessage() const {
  return _internal_has_shortsalerestrictionindicatormessage()
      ? *_impl_.dataBody_.shortsalerestrictionindicatormessage_
      : reinterpret_cast< ::data::ShortSaleRestrictionIndicatorMessage&>(::data::_ShortSaleRestrictionIndicatorMessage_default_instance_);
}
inline const ::data::ShortSaleRestrictionIndicatorMessage& Message::shortsalerestrictionindicatormessage() const {
  // @@protoc_insertion_point(field_get:data.Message.shortSaleRestrictionIndicatorMessage)
  return _internal_shortsalerestrictionindicatormessage();
}
inline ::data::ShortSaleRestrictionIndicatorMessage* Message::unsafe_arena_release_shortsalerestrictionindicatormessage() {
  // @@protoc_insertion_point(field_unsafe_arena_release:data.Message.shortSaleRestrictionIndicatorMessage)
  if (_internal_has_shortsalerestrictionindicatormessage()) {
    clear_has_dataBody();
    ::data::ShortSaleRestrictionIndicatorMessage* temp = _impl_.dataBody_.shortsalerestrictionindicatormessage_;
    _impl_.dataBody_.shortsalerestrictionindicatormessage_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Message::unsafe_arena_set_allocated_shortsalerestrictionindicatormessage(::data::ShortSaleRestrictionIndicatorMessage* shortsalerestrictionindicatormessage) {
  clear_dataBody();
  if (shortsalerestrictionindicatormessage) {
    set_has_shortsalerestrictionindicatormessage();
    _impl_.dataBody_.shortsalerestrictionindicatormessage_ = shortsalerestrictionindicatormessage;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:data.Message.shortSaleRestrictionIndicatorMessage)
}
inline ::data::ShortSaleRestrictionIndicatorMessage* Message::_internal_mutable_shortsalerestrictionindicatormessage() {
  if (!_internal_has_shortsalerestrictionindicatormessage()) {
    clear_dataBody();
    set_has_shortsalerestrictionindicatormessage();
    _impl_.dataBody_.shortsalerestrictionindicatormessage_ = CreateMaybeMessage< ::data::ShortSaleRestrictionIndicatorMessage >(GetArenaForAllocation());
  }
  return _impl_.dataBody_.shortsalerestrictionindicatormessage_;
}
inline ::data::ShortSaleRestrictionIndicatorMessage* Message::mutable_shortsalerestrictionindicatormessage() {
  ::data::ShortSaleRestrictionIndicatorMessage* _msg = _internal_mutable_shortsalerestrictionindicatormessage();
  // @@protoc_insertion_point(field_mutable:data.Message.shortSaleRestrictionIndicatorMessage)
  return _msg;
}

// .data.StockDirectory stockDirectory = 43;
inline bool Message::_internal_has_stockdirectory() const {
  return dataBody_case() == kStockDirectory;
}
inline bool Message::has_stockdirectory() const {
  return _internal_has_stockdirectory();
}
inline void Message::set_has_stockdirectory() {
  _impl_._oneof_case_[0] = kStockDirectory;
}
inline void Message::clear_stockdirectory() {
  if (_internal_has_stockdirectory()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.dataBody_.stockdirectory_;
    }
    clear_has_dataBody();
  }
}
inline ::data::StockDirectory* Message::release_stockdirectory() {
  // @@protoc_insertion_point(field_release:data.Message.stockDirectory)
  if (_internal_has_stockdirectory()) {
    clear_has_dataBody();
    ::data::StockDirectory* temp = _impl_.dataBody_.stockdirectory_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.dataBody_.stockdirectory_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::data::StockDirectory& Message::_internal_stockdirectory() const {
  return _internal_has_stockdirectory()
      ? *_impl_.dataBody_.stockdirectory_
      : reinterpret_cast< ::data::StockDirectory&>(::data::_StockDirectory_default_instance_);
}
inline const ::data::StockDirectory& Message::stockdirectory() const {
  // @@protoc_insertion_point(field_get:data.Message.stockDirectory)
  return _internal_stockdirectory();
}
inline ::data::StockDirectory* Message::unsafe_arena_release_stockdirectory() {
  // @@protoc_insertion_point(field_unsafe_arena_release:data.Message.stockDirectory)
  if (_internal_has_stockdirectory()) {
    clear_has_dataBody();
    ::data::StockDirectory* temp = _impl_.dataBody_.stockdirectory_;
    _impl_.dataBody_.stockdirectory_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Message::unsafe_arena_set_allocated_stockdirectory(::data::StockDirectory* stockdirectory) {
  clear_dataBody();
  if (stockdirectory) {
    set_has_stockdirectory();
    _impl_.dataBody_.stockdirectory_ = stockdirectory;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:data.Message.stockDirectory)
}
inline ::data::StockDirectory* Message::_internal_mutable_stockdirectory() {
  if (!_internal_has_stockdirectory()) {
    clear_dataBody();
    set_has_stockdirectory();
    _impl_.dataBody_.stockdirectory_ = CreateMaybeMessage< ::data::StockDirectory >(GetArenaForAllocation());
  }
  return _impl_.dataBody_.stockdirectory_;
}
inline ::data::StockDirectory* Message::mutable_stockdirectory() {
  ::data::StockDirectory* _msg = _internal_mutable_stockdirectory();
  // @@protoc_insertion_point(field_mutable:data.Message.stockDirectory)
  return _msg;
}

// .data.StockTradingAction stockTradingAction = 44;
inline bool Message::_internal_has_stocktradingaction() const {
  return dataBody_case() == kStockTradingAction;
}
inline bool Message::has_stocktradingaction() const {
  return _internal_has_stocktradingaction();
}
inline void Message::set_has_stocktradingaction() {
  _impl_._oneof_case_[0] = kStockTradingAction;
}
inline void Message::clear_stocktradingaction() {
  if (_internal_has_stocktradingaction()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.dataBody_.stocktradingaction_;
    }
    clear_has_dataBody();
  }
}
inline ::data::StockTradingAction* Message::release_stocktradingaction() {
  // @@protoc_insertion_point(field_release:data.Message.stockTradingAction)
  if (_internal_has_stocktradingaction()) {
    clear_has_dataBody();
    ::data::StockTradingAction* temp = _impl_.dataBody_.stocktradingaction_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.dataBody_.stocktradingaction_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::data::StockTradingAction& Message::_internal_stocktradingaction() const {
  return _internal_has_stocktradingaction()
      ? *_impl_.dataBody_.stocktradingaction_
      : reinterpret_cast< ::data::StockTradingAction&>(::data::_StockTradingAction_default_instance_);
}
inline const ::data::StockTradingAction& Message::stocktradingaction() const {
  // @@protoc_insertion_point(field_get:data.Message.stockTradingAction)
  return _internal_stocktradingaction();
}
inline ::data::StockTradingAction* Message::unsafe_arena_release_stocktradingaction() {
  // @@protoc_insertion_point(field_unsafe_arena_release:data.Message.stockTradingAction)
  if (_internal_has_stocktradingaction()) {
    clear_has_dataBody();
    ::data::StockTradingAction* temp = _impl_.dataBody_.stocktradingaction_;
    _impl_.dataBody_.stocktradingaction_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Message::unsafe_arena_set_allocated_stocktradingaction(::data::StockTradingAction* stocktradingaction) {
  clear_dataBody();
  if (stocktradingaction) {
    set_has_stocktradingaction();
    _impl_.dataBody_.stocktradingaction_ = stocktradingaction;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:data.Message.stockTradingAction)
}
inline ::data::StockTradingAction* Message::_internal_mutable_stocktradingaction() {
  if (!_internal_has_stocktradingaction()) {
    clear_dataBody();
    set_has_stocktradingaction();
    _impl_.dataBody_.stocktradingaction_ = CreateMaybeMessage< ::data::StockTradingAction >(GetArenaForAllocation());
  }
  return _impl_.dataBody_.stocktradingaction_;
}
inline ::data::StockTradingAction* Message::mutable_stocktradingaction() {
  ::data::StockTradingAction* _msg = _internal_mutable_stocktradingaction();
  // @@protoc_insertion_point(field_mutable:data.Message.stockTradingAction)
  return _msg;
}

// .data.SystemEventMessage systemEventMessage = 45;
inline bool Message::_internal_has_systemeventmessage() const {
  return dataBody_case() == kSystemEventMessage;
}
inline bool Message::has_systemeventmessage() const {
  return _internal_has_systemeventmessage();
}
inline void Message::set_has_systemeventmessage() {
  _impl_._oneof_case_[0] = kSystemEventMessage;
}
inline void Message::clear_systemeventmessage() {
  if (_internal_has_systemeventmessage()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.dataBody_.systemeventmessage_;
    }
    clear_has_dataBody();
  }
}
inline ::data::SystemEventMessage* Message::release_systemeventmessage() {
  // @@protoc_insertion_point(field_release:data.Message.systemEventMessage)
  if (_internal_has_systemeventmessage()) {
    clear_has_dataBody();
    ::data::SystemEventMessage* temp = _impl_.dataBody_.systemeventmessage_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.dataBody_.systemeventmessage_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::data::SystemEventMessage& Message::_internal_systemeventmessage() const {
  return _internal_has_systemeventmessage()
      ? *_impl_.dataBody_.systemeventmessage_
      : reinterpret_cast< ::data::SystemEventMessage&>(::data::_SystemEventMessage_default_instance_);
}
inline const ::data::SystemEventMessage& Message::systemeventmessage() const {
  // @@protoc_insertion_point(field_get:data.Message.systemEventMessage)
  return _internal_systemeventmessage();
}
inline ::data::SystemEventMessage* Message::unsafe_arena_release_systemeventmessage() {
  // @@protoc_insertion_point(field_unsafe_arena_release:data.Message.systemEventMessage)
  if (_internal_has_systemeventmessage()) {
    clear_has_dataBody();
    ::data::SystemEventMessage* temp = _impl_.dataBody_.systemeventmessage_;
    _impl_.dataBody_.systemeventmessage_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Message::unsafe_arena_set_allocated_systemeventmessage(::data::SystemEventMessage* systemeventmessage) {
  clear_dataBody();
  if (systemeventmessage) {
    set_has_systemeventmessage();
    _impl_.dataBody_.systemeventmessage_ = systemeventmessage;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:data.Message.systemEventMessage)
}
inline ::data::SystemEventMessage* Message::_internal_mutable_systemeventmessage() {
  if (!_internal_has_systemeventmessage()) {
    clear_dataBody();
    set_has_systemeventmessage();
    _impl_.dataBody_.systemeventmessage_ = CreateMaybeMessage< ::data::SystemEventMessage >(GetArenaForAllocation());
  }
  return _impl_.dataBody_.systemeventmessage_;
}
inline ::data::SystemEventMessage* Message::mutable_systemeventmessage() {
  ::data::SystemEventMessage* _msg = _internal_mutable_systemeventmessage();
  // @@protoc_insertion_point(field_mutable:data.Message.systemEventMessage)
  return _msg;
}

// .data.TradeCancelForNextsharesTrades tradeCancelForNextsharesTrades = 46;
inline bool Message::_internal_has_tradecancelfornextsharestrades() const {
  return dataBody_case() == kTradeCancelForNextsharesTrades;
}
inline bool Message::has_tradecancelfornextsharestrades() const {
  return _internal_has_tradecancelfornextsharestrades();
}
inline void Message::set_has_tradecancelfornextsharestrades() {
  _impl_._oneof_case_[0] = kTradeCancelForNextsharesTrades;
}
inline void Message::clear_tradecancelfornextsharestrades() {
  if (_internal_has_tradecancelfornextsharestrades()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.dataBody_.tradecancelfornextsharestrades_;
    }
    clear_has_dataBody();
  }
}
inline ::data::TradeCancelForNextsharesTrades* Message::release_tradecancelfornextsharestrades() {
  // @@protoc_insertion_point(field_release:data.Message.tradeCancelForNextsharesTrades)
  if (_internal_has_tradecancelfornextsharestrades()) {
    clear_has_dataBody();
    ::data::TradeCancelForNextsharesTrades* temp = _impl_.dataBody_.tradecancelfornextsharestrades_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.dataBody_.tradecancelfornextsharestrades_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::data::TradeCancelForNextsharesTrades& Message::_internal_tradecancelfornextsharestrades() const {
  return _internal_has_tradecancelfornextsharestrades()
      ? *_impl_.dataBody_.tradecancelfornextsharestrades_
      : reinterpret_cast< ::data::TradeCancelForNextsharesTrades&>(::data::_TradeCancelForNextsharesTrades_default_instance_);
}
inline const ::data::TradeCancelForNextsharesTrades& Message::tradecancelfornextsharestrades() const {
  // @@protoc_insertion_point(field_get:data.Message.tradeCancelForNextsharesTrades)
  return _internal_tradecancelfornextsharestrades();
}
inline ::data::TradeCancelForNextsharesTrades* Message::unsafe_arena_release_tradecancelfornextsharestrades() {
  // @@protoc_insertion_point(field_unsafe_arena_release:data.Message.tradeCancelForNextsharesTrades)
  if (_internal_has_tradecancelfornextsharestrades()) {
    clear_has_dataBody();
    ::data::TradeCancelForNextsharesTrades* temp = _impl_.dataBody_.tradecancelfornextsharestrades_;
    _impl_.dataBody_.tradecancelfornextsharestrades_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Message::unsafe_arena_set_allocated_tradecancelfornextsharestrades(::data::TradeCancelForNextsharesTrades* tradecancelfornextsharestrades) {
  clear_dataBody();
  if (tradecancelfornextsharestrades) {
    set_has_tradecancelfornextsharestrades();
    _impl_.dataBody_.tradecancelfornextsharestrades_ = tradecancelfornextsharestrades;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:data.Message.tradeCancelForNextsharesTrades)
}
inline ::data::TradeCancelForNextsharesTrades* Message::_internal_mutable_tradecancelfornextsharestrades() {
  if (!_internal_has_tradecancelfornextsharestrades()) {
    clear_dataBody();
    set_has_tradecancelfornextsharestrades();
    _impl_.dataBody_.tradecancelfornextsharestrades_ = CreateMaybeMessage< ::data::TradeCancelForNextsharesTrades >(GetArenaForAllocation());
  }
  return _impl_.dataBody_.tradecancelfornextsharestrades_;
}
inline ::data::TradeCancelForNextsharesTrades* Message::mutable_tradecancelfornextsharestrades() {
  ::data::TradeCancelForNextsharesTrades* _msg = _internal_mutable_tradecancelfornextsharestrades();
  // @@protoc_insertion_point(field_mutable:data.Message.tradeCancelForNextsharesTrades)
  return _msg;
}

// .data.TradeCancelForNonNextSharesTrades tradeCancelForNonNextSharesTrades = 47;
inline bool Message::_internal_has_tradecancelfornonnextsharestrades() const {
  return dataBody_case() == kTradeCancelForNonNextSharesTrades;
}
inline bool Message::has_tradecancelfornonnextsharestrades() const {
  return _internal_has_tradecancelfornonnextsharestrades();
}
inline void Message::set_has_tradecancelfornonnextsharestrades() {
  _impl_._oneof_case_[0] = kTradeCancelForNonNextSharesTrades;
}
inline void Message::clear_tradecancelfornonnextsharestrades() {
  if (_internal_has_tradecancelfornonnextsharestrades()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.dataBody_.tradecancelfornonnextsharestrades_;
    }
    clear_has_dataBody();
  }
}
inline ::data::TradeCancelForNonNextSharesTrades* Message::release_tradecancelfornonnextsharestrades() {
  // @@protoc_insertion_point(field_release:data.Message.tradeCancelForNonNextSharesTrades)
  if (_internal_has_tradecancelfornonnextsharestrades()) {
    clear_has_dataBody();
    ::data::TradeCancelForNonNextSharesTrades* temp = _impl_.dataBody_.tradecancelfornonnextsharestrades_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.dataBody_.tradecancelfornonnextsharestrades_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::data::TradeCancelForNonNextSharesTrades& Message::_internal_tradecancelfornonnextsharestrades() const {
  return _internal_has_tradecancelfornonnextsharestrades()
      ? *_impl_.dataBody_.tradecancelfornonnextsharestrades_
      : reinterpret_cast< ::data::TradeCancelForNonNextSharesTrades&>(::data::_TradeCancelForNonNextSharesTrades_default_instance_);
}
inline const ::data::TradeCancelForNonNextSharesTrades& Message::tradecancelfornonnextsharestrades() const {
  // @@protoc_insertion_point(field_get:data.Message.tradeCancelForNonNextSharesTrades)
  return _internal_tradecancelfornonnextsharestrades();
}
inline ::data::TradeCancelForNonNextSharesTrades* Message::unsafe_arena_release_tradecancelfornonnextsharestrades() {
  // @@protoc_insertion_point(field_unsafe_arena_release:data.Message.tradeCancelForNonNextSharesTrades)
  if (_internal_has_tradecancelfornonnextsharestrades()) {
    clear_has_dataBody();
    ::data::TradeCancelForNonNextSharesTrades* temp = _impl_.dataBody_.tradecancelfornonnextsharestrades_;
    _impl_.dataBody_.tradecancelfornonnextsharestrades_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Message::unsafe_arena_set_allocated_tradecancelfornonnextsharestrades(::data::TradeCancelForNonNextSharesTrades* tradecancelfornonnextsharestrades) {
  clear_dataBody();
  if (tradecancelfornonnextsharestrades) {
    set_has_tradecancelfornonnextsharestrades();
    _impl_.dataBody_.tradecancelfornonnextsharestrades_ = tradecancelfornonnextsharestrades;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:data.Message.tradeCancelForNonNextSharesTrades)
}
inline ::data::TradeCancelForNonNextSharesTrades* Message::_internal_mutable_tradecancelfornonnextsharestrades() {
  if (!_internal_has_tradecancelfornonnextsharestrades()) {
    clear_dataBody();
    set_has_tradecancelfornonnextsharestrades();
    _impl_.dataBody_.tradecancelfornonnextsharestrades_ = CreateMaybeMessage< ::data::TradeCancelForNonNextSharesTrades >(GetArenaForAllocation());
  }
  return _impl_.dataBody_.tradecancelfornonnextsharestrades_;
}
inline ::data::TradeCancelForNonNextSharesTrades* Message::mutable_tradecancelfornonnextsharestrades() {
  ::data::TradeCancelForNonNextSharesTrades* _msg = _internal_mutable_tradecancelfornonnextsharestrades();
  // @@protoc_insertion_point(field_mutable:data.Message.tradeCancelForNonNextSharesTrades)
  return _msg;
}

// .data.TradeCorrectionForNextsharesTrades tradeCorrectionForNextsharesTrades = 48;
inline bool Message::_internal_has_tradecorrectionfornextsharestrades() const {
  return dataBody_case() == kTradeCorrectionForNextsharesTrades;
}
inline bool Message::has_tradecorrectionfornextsharestrades() const {
  return _internal_has_tradecorrectionfornextsharestrades();
}
inline void Message::set_has_tradecorrectionfornextsharestrades() {
  _impl_._oneof_case_[0] = kTradeCorrectionForNextsharesTrades;
}
inline void Message::clear_tradecorrectionfornextsharestrades() {
  if (_internal_has_tradecorrectionfornextsharestrades()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.dataBody_.tradecorrectionfornextsharestrades_;
    }
    clear_has_dataBody();
  }
}
inline ::data::TradeCorrectionForNextsharesTrades* Message::release_tradecorrectionfornextsharestrades() {
  // @@protoc_insertion_point(field_release:data.Message.tradeCorrectionForNextsharesTrades)
  if (_internal_has_tradecorrectionfornextsharestrades()) {
    clear_has_dataBody();
    ::data::TradeCorrectionForNextsharesTrades* temp = _impl_.dataBody_.tradecorrectionfornextsharestrades_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.dataBody_.tradecorrectionfornextsharestrades_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::data::TradeCorrectionForNextsharesTrades& Message::_internal_tradecorrectionfornextsharestrades() const {
  return _internal_has_tradecorrectionfornextsharestrades()
      ? *_impl_.dataBody_.tradecorrectionfornextsharestrades_
      : reinterpret_cast< ::data::TradeCorrectionForNextsharesTrades&>(::data::_TradeCorrectionForNextsharesTrades_default_instance_);
}
inline const ::data::TradeCorrectionForNextsharesTrades& Message::tradecorrectionfornextsharestrades() const {
  // @@protoc_insertion_point(field_get:data.Message.tradeCorrectionForNextsharesTrades)
  return _internal_tradecorrectionfornextsharestrades();
}
inline ::data::TradeCorrectionForNextsharesTrades* Message::unsafe_arena_release_tradecorrectionfornextsharestrades() {
  // @@protoc_insertion_point(field_unsafe_arena_release:data.Message.tradeCorrectionForNextsharesTrades)
  if (_internal_has_tradecorrectionfornextsharestrades()) {
    clear_has_dataBody();
    ::data::TradeCorrectionForNextsharesTrades* temp = _impl_.dataBody_.tradecorrectionfornextsharestrades_;
    _impl_.dataBody_.tradecorrectionfornextsharestrades_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Message::unsafe_arena_set_allocated_tradecorrectionfornextsharestrades(::data::TradeCorrectionForNextsharesTrades* tradecorrectionfornextsharestrades) {
  clear_dataBody();
  if (tradecorrectionfornextsharestrades) {
    set_has_tradecorrectionfornextsharestrades();
    _impl_.dataBody_.tradecorrectionfornextsharestrades_ = tradecorrectionfornextsharestrades;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:data.Message.tradeCorrectionForNextsharesTrades)
}
inline ::data::TradeCorrectionForNextsharesTrades* Message::_internal_mutable_tradecorrectionfornextsharestrades() {
  if (!_internal_has_tradecorrectionfornextsharestrades()) {
    clear_dataBody();
    set_has_tradecorrectionfornextsharestrades();
    _impl_.dataBody_.tradecorrectionfornextsharestrades_ = CreateMaybeMessage< ::data::TradeCorrectionForNextsharesTrades >(GetArenaForAllocation());
  }
  return _impl_.dataBody_.tradecorrectionfornextsharestrades_;
}
inline ::data::TradeCorrectionForNextsharesTrades* Message::mutable_tradecorrectionfornextsharestrades() {
  ::data::TradeCorrectionForNextsharesTrades* _msg = _internal_mutable_tradecorrectionfornextsharestrades();
  // @@protoc_insertion_point(field_mutable:data.Message.tradeCorrectionForNextsharesTrades)
  return _msg;
}

// .data.TradeCorrectionForNonNextsharesTrades tradeCorrectionForNonNextsharesTrades = 49;
inline bool Message::_internal_has_tradecorrectionfornonnextsharestrades() const {
  return dataBody_case() == kTradeCorrectionForNonNextsharesTrades;
}
inline bool Message::has_tradecorrectionfornonnextsharestrades() const {
  return _internal_has_tradecorrectionfornonnextsharestrades();
}
inline void Message::set_has_tradecorrectionfornonnextsharestrades() {
  _impl_._oneof_case_[0] = kTradeCorrectionForNonNextsharesTrades;
}
inline void Message::clear_tradecorrectionfornonnextsharestrades() {
  if (_internal_has_tradecorrectionfornonnextsharestrades()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.dataBody_.tradecorrectionfornonnextsharestrades_;
    }
    clear_has_dataBody();
  }
}
inline ::data::TradeCorrectionForNonNextsharesTrades* Message::release_tradecorrectionfornonnextsharestrades() {
  // @@protoc_insertion_point(field_release:data.Message.tradeCorrectionForNonNextsharesTrades)
  if (_internal_has_tradecorrectionfornonnextsharestrades()) {
    clear_has_dataBody();
    ::data::TradeCorrectionForNonNextsharesTrades* temp = _impl_.dataBody_.tradecorrectionfornonnextsharestrades_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.dataBody_.tradecorrectionfornonnextsharestrades_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::data::TradeCorrectionForNonNextsharesTrades& Message::_internal_tradecorrectionfornonnextsharestrades() const {
  return _internal_has_tradecorrectionfornonnextsharestrades()
      ? *_impl_.dataBody_.tradecorrectionfornonnextsharestrades_
      : reinterpret_cast< ::data::TradeCorrectionForNonNextsharesTrades&>(::data::_TradeCorrectionForNonNextsharesTrades_default_instance_);
}
inline const ::data::TradeCorrectionForNonNextsharesTrades& Message::tradecorrectionfornonnextsharestrades() const {
  // @@protoc_insertion_point(field_get:data.Message.tradeCorrectionForNonNextsharesTrades)
  return _internal_tradecorrectionfornonnextsharestrades();
}
inline ::data::TradeCorrectionForNonNextsharesTrades* Message::unsafe_arena_release_tradecorrectionfornonnextsharestrades() {
  // @@protoc_insertion_point(field_unsafe_arena_release:data.Message.tradeCorrectionForNonNextsharesTrades)
  if (_internal_has_tradecorrectionfornonnextsharestrades()) {
    clear_has_dataBody();
    ::data::TradeCorrectionForNonNextsharesTrades* temp = _impl_.dataBody_.tradecorrectionfornonnextsharestrades_;
    _impl_.dataBody_.tradecorrectionfornonnextsharestrades_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Message::unsafe_arena_set_allocated_tradecorrectionfornonnextsharestrades(::data::TradeCorrectionForNonNextsharesTrades* tradecorrectionfornonnextsharestrades) {
  clear_dataBody();
  if (tradecorrectionfornonnextsharestrades) {
    set_has_tradecorrectionfornonnextsharestrades();
    _impl_.dataBody_.tradecorrectionfornonnextsharestrades_ = tradecorrectionfornonnextsharestrades;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:data.Message.tradeCorrectionForNonNextsharesTrades)
}
inline ::data::TradeCorrectionForNonNextsharesTrades* Message::_internal_mutable_tradecorrectionfornonnextsharestrades() {
  if (!_internal_has_tradecorrectionfornonnextsharestrades()) {
    clear_dataBody();
    set_has_tradecorrectionfornonnextsharestrades();
    _impl_.dataBody_.tradecorrectionfornonnextsharestrades_ = CreateMaybeMessage< ::data::TradeCorrectionForNonNextsharesTrades >(GetArenaForAllocation());
  }
  return _impl_.dataBody_.tradecorrectionfornonnextsharestrades_;
}
inline ::data::TradeCorrectionForNonNextsharesTrades* Message::mutable_tradecorrectionfornonnextsharestrades() {
  ::data::TradeCorrectionForNonNextsharesTrades* _msg = _internal_mutable_tradecorrectionfornonnextsharestrades();
  // @@protoc_insertion_point(field_mutable:data.Message.tradeCorrectionForNonNextsharesTrades)
  return _msg;
}

// .data.TradeReportForNextshares tradeReportForNextshares = 50;
inline bool Message::_internal_has_tradereportfornextshares() const {
  return dataBody_case() == kTradeReportForNextshares;
}
inline bool Message::has_tradereportfornextshares() const {
  return _internal_has_tradereportfornextshares();
}
inline void Message::set_has_tradereportfornextshares() {
  _impl_._oneof_case_[0] = kTradeReportForNextshares;
}
inline void Message::clear_tradereportfornextshares() {
  if (_internal_has_tradereportfornextshares()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.dataBody_.tradereportfornextshares_;
    }
    clear_has_dataBody();
  }
}
inline ::data::TradeReportForNextshares* Message::release_tradereportfornextshares() {
  // @@protoc_insertion_point(field_release:data.Message.tradeReportForNextshares)
  if (_internal_has_tradereportfornextshares()) {
    clear_has_dataBody();
    ::data::TradeReportForNextshares* temp = _impl_.dataBody_.tradereportfornextshares_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.dataBody_.tradereportfornextshares_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::data::TradeReportForNextshares& Message::_internal_tradereportfornextshares() const {
  return _internal_has_tradereportfornextshares()
      ? *_impl_.dataBody_.tradereportfornextshares_
      : reinterpret_cast< ::data::TradeReportForNextshares&>(::data::_TradeReportForNextshares_default_instance_);
}
inline const ::data::TradeReportForNextshares& Message::tradereportfornextshares() const {
  // @@protoc_insertion_point(field_get:data.Message.tradeReportForNextshares)
  return _internal_tradereportfornextshares();
}
inline ::data::TradeReportForNextshares* Message::unsafe_arena_release_tradereportfornextshares() {
  // @@protoc_insertion_point(field_unsafe_arena_release:data.Message.tradeReportForNextshares)
  if (_internal_has_tradereportfornextshares()) {
    clear_has_dataBody();
    ::data::TradeReportForNextshares* temp = _impl_.dataBody_.tradereportfornextshares_;
    _impl_.dataBody_.tradereportfornextshares_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Message::unsafe_arena_set_allocated_tradereportfornextshares(::data::TradeReportForNextshares* tradereportfornextshares) {
  clear_dataBody();
  if (tradereportfornextshares) {
    set_has_tradereportfornextshares();
    _impl_.dataBody_.tradereportfornextshares_ = tradereportfornextshares;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:data.Message.tradeReportForNextshares)
}
inline ::data::TradeReportForNextshares* Message::_internal_mutable_tradereportfornextshares() {
  if (!_internal_has_tradereportfornextshares()) {
    clear_dataBody();
    set_has_tradereportfornextshares();
    _impl_.dataBody_.tradereportfornextshares_ = CreateMaybeMessage< ::data::TradeReportForNextshares >(GetArenaForAllocation());
  }
  return _impl_.dataBody_.tradereportfornextshares_;
}
inline ::data::TradeReportForNextshares* Message::mutable_tradereportfornextshares() {
  ::data::TradeReportForNextshares* _msg = _internal_mutable_tradereportfornextshares();
  // @@protoc_insertion_point(field_mutable:data.Message.tradeReportForNextshares)
  return _msg;
}

// .data.TradeReportForNonNextshares tradeReportForNonNextshares = 51;
inline bool Message::_internal_has_tradereportfornonnextshares() const {
  return dataBody_case() == kTradeReportForNonNextshares;
}
inline bool Message::has_tradereportfornonnextshares() const {
  return _internal_has_tradereportfornonnextshares();
}
inline void Message::set_has_tradereportfornonnextshares() {
  _impl_._oneof_case_[0] = kTradeReportForNonNextshares;
}
inline void Message::clear_tradereportfornonnextshares() {
  if (_internal_has_tradereportfornonnextshares()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.dataBody_.tradereportfornonnextshares_;
    }
    clear_has_dataBody();
  }
}
inline ::data::TradeReportForNonNextshares* Message::release_tradereportfornonnextshares() {
  // @@protoc_insertion_point(field_release:data.Message.tradeReportForNonNextshares)
  if (_internal_has_tradereportfornonnextshares()) {
    clear_has_dataBody();
    ::data::TradeReportForNonNextshares* temp = _impl_.dataBody_.tradereportfornonnextshares_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.dataBody_.tradereportfornonnextshares_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::data::TradeReportForNonNextshares& Message::_internal_tradereportfornonnextshares() const {
  return _internal_has_tradereportfornonnextshares()
      ? *_impl_.dataBody_.tradereportfornonnextshares_
      : reinterpret_cast< ::data::TradeReportForNonNextshares&>(::data::_TradeReportForNonNextshares_default_instance_);
}
inline const ::data::TradeReportForNonNextshares& Message::tradereportfornonnextshares() const {
  // @@protoc_insertion_point(field_get:data.Message.tradeReportForNonNextshares)
  return _internal_tradereportfornonnextshares();
}
inline ::data::TradeReportForNonNextshares* Message::unsafe_arena_release_tradereportfornonnextshares() {
  // @@protoc_insertion_point(field_unsafe_arena_release:data.Message.tradeReportForNonNextshares)
  if (_internal_has_tradereportfornonnextshares()) {
    clear_has_dataBody();
    ::data::TradeReportForNonNextshares* temp = _impl_.dataBody_.tradereportfornonnextshares_;
    _impl_.dataBody_.tradereportfornonnextshares_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Message::unsafe_arena_set_allocated_tradereportfornonnextshares(::data::TradeReportForNonNextshares* tradereportfornonnextshares) {
  clear_dataBody();
  if (tradereportfornonnextshares) {
    set_has_tradereportfornonnextshares();
    _impl_.dataBody_.tradereportfornonnextshares_ = tradereportfornonnextshares;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:data.Message.tradeReportForNonNextshares)
}
inline ::data::TradeReportForNonNextshares* Message::_internal_mutable_tradereportfornonnextshares() {
  if (!_internal_has_tradereportfornonnextshares()) {
    clear_dataBody();
    set_has_tradereportfornonnextshares();
    _impl_.dataBody_.tradereportfornonnextshares_ = CreateMaybeMessage< ::data::TradeReportForNonNextshares >(GetArenaForAllocation());
  }
  return _impl_.dataBody_.tradereportfornonnextshares_;
}
inline ::data::TradeReportForNonNextshares* Message::mutable_tradereportfornonnextshares() {
  ::data::TradeReportForNonNextshares* _msg = _internal_mutable_tradereportfornonnextshares();
  // @@protoc_insertion_point(field_mutable:data.Message.tradeReportForNonNextshares)
  return _msg;
}

// .data.QBBOMWCBBreachMessage qBBOMWCBBreachMessage = 52;
inline bool Message::_internal_has_qbbomwcbbreachmessage() const {
  return dataBody_case() == kQBBOMWCBBreachMessage;
}
inline bool Message::has_qbbomwcbbreachmessage() const {
  return _internal_has_qbbomwcbbreachmessage();
}
inline void Message::set_has_qbbomwcbbreachmessage() {
  _impl_._oneof_case_[0] = kQBBOMWCBBreachMessage;
}
inline void Message::clear_qbbomwcbbreachmessage() {
  if (_internal_has_qbbomwcbbreachmessage()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.dataBody_.qbbomwcbbreachmessage_;
    }
    clear_has_dataBody();
  }
}
inline ::data::QBBOMWCBBreachMessage* Message::release_qbbomwcbbreachmessage() {
  // @@protoc_insertion_point(field_release:data.Message.qBBOMWCBBreachMessage)
  if (_internal_has_qbbomwcbbreachmessage()) {
    clear_has_dataBody();
    ::data::QBBOMWCBBreachMessage* temp = _impl_.dataBody_.qbbomwcbbreachmessage_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.dataBody_.qbbomwcbbreachmessage_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::data::QBBOMWCBBreachMessage& Message::_internal_qbbomwcbbreachmessage() const {
  return _internal_has_qbbomwcbbreachmessage()
      ? *_impl_.dataBody_.qbbomwcbbreachmessage_
      : reinterpret_cast< ::data::QBBOMWCBBreachMessage&>(::data::_QBBOMWCBBreachMessage_default_instance_);
}
inline const ::data::QBBOMWCBBreachMessage& Message::qbbomwcbbreachmessage() const {
  // @@protoc_insertion_point(field_get:data.Message.qBBOMWCBBreachMessage)
  return _internal_qbbomwcbbreachmessage();
}
inline ::data::QBBOMWCBBreachMessage* Message::unsafe_arena_release_qbbomwcbbreachmessage() {
  // @@protoc_insertion_point(field_unsafe_arena_release:data.Message.qBBOMWCBBreachMessage)
  if (_internal_has_qbbomwcbbreachmessage()) {
    clear_has_dataBody();
    ::data::QBBOMWCBBreachMessage* temp = _impl_.dataBody_.qbbomwcbbreachmessage_;
    _impl_.dataBody_.qbbomwcbbreachmessage_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Message::unsafe_arena_set_allocated_qbbomwcbbreachmessage(::data::QBBOMWCBBreachMessage* qbbomwcbbreachmessage) {
  clear_dataBody();
  if (qbbomwcbbreachmessage) {
    set_has_qbbomwcbbreachmessage();
    _impl_.dataBody_.qbbomwcbbreachmessage_ = qbbomwcbbreachmessage;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:data.Message.qBBOMWCBBreachMessage)
}
inline ::data::QBBOMWCBBreachMessage* Message::_internal_mutable_qbbomwcbbreachmessage() {
  if (!_internal_has_qbbomwcbbreachmessage()) {
    clear_dataBody();
    set_has_qbbomwcbbreachmessage();
    _impl_.dataBody_.qbbomwcbbreachmessage_ = CreateMaybeMessage< ::data::QBBOMWCBBreachMessage >(GetArenaForAllocation());
  }
  return _impl_.dataBody_.qbbomwcbbreachmessage_;
}
inline ::data::QBBOMWCBBreachMessage* Message::mutable_qbbomwcbbreachmessage() {
  ::data::QBBOMWCBBreachMessage* _msg = _internal_mutable_qbbomwcbbreachmessage();
  // @@protoc_insertion_point(field_mutable:data.Message.qBBOMWCBBreachMessage)
  return _msg;
}

// .data.QBBOMWCBDeclineLevelMessage qBBOMWCBDeclineLevelMessage = 53;
inline bool Message::_internal_has_qbbomwcbdeclinelevelmessage() const {
  return dataBody_case() == kQBBOMWCBDeclineLevelMessage;
}
inline bool Message::has_qbbomwcbdeclinelevelmessage() const {
  return _internal_has_qbbomwcbdeclinelevelmessage();
}
inline void Message::set_has_qbbomwcbdeclinelevelmessage() {
  _impl_._oneof_case_[0] = kQBBOMWCBDeclineLevelMessage;
}
inline void Message::clear_qbbomwcbdeclinelevelmessage() {
  if (_internal_has_qbbomwcbdeclinelevelmessage()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.dataBody_.qbbomwcbdeclinelevelmessage_;
    }
    clear_has_dataBody();
  }
}
inline ::data::QBBOMWCBDeclineLevelMessage* Message::release_qbbomwcbdeclinelevelmessage() {
  // @@protoc_insertion_point(field_release:data.Message.qBBOMWCBDeclineLevelMessage)
  if (_internal_has_qbbomwcbdeclinelevelmessage()) {
    clear_has_dataBody();
    ::data::QBBOMWCBDeclineLevelMessage* temp = _impl_.dataBody_.qbbomwcbdeclinelevelmessage_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.dataBody_.qbbomwcbdeclinelevelmessage_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::data::QBBOMWCBDeclineLevelMessage& Message::_internal_qbbomwcbdeclinelevelmessage() const {
  return _internal_has_qbbomwcbdeclinelevelmessage()
      ? *_impl_.dataBody_.qbbomwcbdeclinelevelmessage_
      : reinterpret_cast< ::data::QBBOMWCBDeclineLevelMessage&>(::data::_QBBOMWCBDeclineLevelMessage_default_instance_);
}
inline const ::data::QBBOMWCBDeclineLevelMessage& Message::qbbomwcbdeclinelevelmessage() const {
  // @@protoc_insertion_point(field_get:data.Message.qBBOMWCBDeclineLevelMessage)
  return _internal_qbbomwcbdeclinelevelmessage();
}
inline ::data::QBBOMWCBDeclineLevelMessage* Message::unsafe_arena_release_qbbomwcbdeclinelevelmessage() {
  // @@protoc_insertion_point(field_unsafe_arena_release:data.Message.qBBOMWCBDeclineLevelMessage)
  if (_internal_has_qbbomwcbdeclinelevelmessage()) {
    clear_has_dataBody();
    ::data::QBBOMWCBDeclineLevelMessage* temp = _impl_.dataBody_.qbbomwcbdeclinelevelmessage_;
    _impl_.dataBody_.qbbomwcbdeclinelevelmessage_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Message::unsafe_arena_set_allocated_qbbomwcbdeclinelevelmessage(::data::QBBOMWCBDeclineLevelMessage* qbbomwcbdeclinelevelmessage) {
  clear_dataBody();
  if (qbbomwcbdeclinelevelmessage) {
    set_has_qbbomwcbdeclinelevelmessage();
    _impl_.dataBody_.qbbomwcbdeclinelevelmessage_ = qbbomwcbdeclinelevelmessage;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:data.Message.qBBOMWCBDeclineLevelMessage)
}
inline ::data::QBBOMWCBDeclineLevelMessage* Message::_internal_mutable_qbbomwcbdeclinelevelmessage() {
  if (!_internal_has_qbbomwcbdeclinelevelmessage()) {
    clear_dataBody();
    set_has_qbbomwcbdeclinelevelmessage();
    _impl_.dataBody_.qbbomwcbdeclinelevelmessage_ = CreateMaybeMessage< ::data::QBBOMWCBDeclineLevelMessage >(GetArenaForAllocation());
  }
  return _impl_.dataBody_.qbbomwcbdeclinelevelmessage_;
}
inline ::data::QBBOMWCBDeclineLevelMessage* Message::mutable_qbbomwcbdeclinelevelmessage() {
  ::data::QBBOMWCBDeclineLevelMessage* _msg = _internal_mutable_qbbomwcbdeclinelevelmessage();
  // @@protoc_insertion_point(field_mutable:data.Message.qBBOMWCBDeclineLevelMessage)
  return _msg;
}

// .data.QBBONextSharesQuotationMessage qBBONextSharesQuotationMessage = 54;
inline bool Message::_internal_has_qbbonextsharesquotationmessage() const {
  return dataBody_case() == kQBBONextSharesQuotationMessage;
}
inline bool Message::has_qbbonextsharesquotationmessage() const {
  return _internal_has_qbbonextsharesquotationmessage();
}
inline void Message::set_has_qbbonextsharesquotationmessage() {
  _impl_._oneof_case_[0] = kQBBONextSharesQuotationMessage;
}
inline void Message::clear_qbbonextsharesquotationmessage() {
  if (_internal_has_qbbonextsharesquotationmessage()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.dataBody_.qbbonextsharesquotationmessage_;
    }
    clear_has_dataBody();
  }
}
inline ::data::QBBONextSharesQuotationMessage* Message::release_qbbonextsharesquotationmessage() {
  // @@protoc_insertion_point(field_release:data.Message.qBBONextSharesQuotationMessage)
  if (_internal_has_qbbonextsharesquotationmessage()) {
    clear_has_dataBody();
    ::data::QBBONextSharesQuotationMessage* temp = _impl_.dataBody_.qbbonextsharesquotationmessage_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.dataBody_.qbbonextsharesquotationmessage_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::data::QBBONextSharesQuotationMessage& Message::_internal_qbbonextsharesquotationmessage() const {
  return _internal_has_qbbonextsharesquotationmessage()
      ? *_impl_.dataBody_.qbbonextsharesquotationmessage_
      : reinterpret_cast< ::data::QBBONextSharesQuotationMessage&>(::data::_QBBONextSharesQuotationMessage_default_instance_);
}
inline const ::data::QBBONextSharesQuotationMessage& Message::qbbonextsharesquotationmessage() const {
  // @@protoc_insertion_point(field_get:data.Message.qBBONextSharesQuotationMessage)
  return _internal_qbbonextsharesquotationmessage();
}
inline ::data::QBBONextSharesQuotationMessage* Message::unsafe_arena_release_qbbonextsharesquotationmessage() {
  // @@protoc_insertion_point(field_unsafe_arena_release:data.Message.qBBONextSharesQuotationMessage)
  if (_internal_has_qbbonextsharesquotationmessage()) {
    clear_has_dataBody();
    ::data::QBBONextSharesQuotationMessage* temp = _impl_.dataBody_.qbbonextsharesquotationmessage_;
    _impl_.dataBody_.qbbonextsharesquotationmessage_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Message::unsafe_arena_set_allocated_qbbonextsharesquotationmessage(::data::QBBONextSharesQuotationMessage* qbbonextsharesquotationmessage) {
  clear_dataBody();
  if (qbbonextsharesquotationmessage) {
    set_has_qbbonextsharesquotationmessage();
    _impl_.dataBody_.qbbonextsharesquotationmessage_ = qbbonextsharesquotationmessage;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:data.Message.qBBONextSharesQuotationMessage)
}
inline ::data::QBBONextSharesQuotationMessage* Message::_internal_mutable_qbbonextsharesquotationmessage() {
  if (!_internal_has_qbbonextsharesquotationmessage()) {
    clear_dataBody();
    set_has_qbbonextsharesquotationmessage();
    _impl_.dataBody_.qbbonextsharesquotationmessage_ = CreateMaybeMessage< ::data::QBBONextSharesQuotationMessage >(GetArenaForAllocation());
  }
  return _impl_.dataBody_.qbbonextsharesquotationmessage_;
}
inline ::data::QBBONextSharesQuotationMessage* Message::mutable_qbbonextsharesquotationmessage() {
  ::data::QBBONextSharesQuotationMessage* _msg = _internal_mutable_qbbonextsharesquotationmessage();
  // @@protoc_insertion_point(field_mutable:data.Message.qBBONextSharesQuotationMessage)
  return _msg;
}

// .data.QBBOOperationalHalt qBBOOperationalHalt = 55;
inline bool Message::_internal_has_qbbooperationalhalt() const {
  return dataBody_case() == kQBBOOperationalHalt;
}
inline bool Message::has_qbbooperationalhalt() const {
  return _internal_has_qbbooperationalhalt();
}
inline void Message::set_has_qbbooperationalhalt() {
  _impl_._oneof_case_[0] = kQBBOOperationalHalt;
}
inline void Message::clear_qbbooperationalhalt() {
  if (_internal_has_qbbooperationalhalt()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.dataBody_.qbbooperationalhalt_;
    }
    clear_has_dataBody();
  }
}
inline ::data::QBBOOperationalHalt* Message::release_qbbooperationalhalt() {
  // @@protoc_insertion_point(field_release:data.Message.qBBOOperationalHalt)
  if (_internal_has_qbbooperationalhalt()) {
    clear_has_dataBody();
    ::data::QBBOOperationalHalt* temp = _impl_.dataBody_.qbbooperationalhalt_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.dataBody_.qbbooperationalhalt_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::data::QBBOOperationalHalt& Message::_internal_qbbooperationalhalt() const {
  return _internal_has_qbbooperationalhalt()
      ? *_impl_.dataBody_.qbbooperationalhalt_
      : reinterpret_cast< ::data::QBBOOperationalHalt&>(::data::_QBBOOperationalHalt_default_instance_);
}
inline const ::data::QBBOOperationalHalt& Message::qbbooperationalhalt() const {
  // @@protoc_insertion_point(field_get:data.Message.qBBOOperationalHalt)
  return _internal_qbbooperationalhalt();
}
inline ::data::QBBOOperationalHalt* Message::unsafe_arena_release_qbbooperationalhalt() {
  // @@protoc_insertion_point(field_unsafe_arena_release:data.Message.qBBOOperationalHalt)
  if (_internal_has_qbbooperationalhalt()) {
    clear_has_dataBody();
    ::data::QBBOOperationalHalt* temp = _impl_.dataBody_.qbbooperationalhalt_;
    _impl_.dataBody_.qbbooperationalhalt_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Message::unsafe_arena_set_allocated_qbbooperationalhalt(::data::QBBOOperationalHalt* qbbooperationalhalt) {
  clear_dataBody();
  if (qbbooperationalhalt) {
    set_has_qbbooperationalhalt();
    _impl_.dataBody_.qbbooperationalhalt_ = qbbooperationalhalt;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:data.Message.qBBOOperationalHalt)
}
inline ::data::QBBOOperationalHalt* Message::_internal_mutable_qbbooperationalhalt() {
  if (!_internal_has_qbbooperationalhalt()) {
    clear_dataBody();
    set_has_qbbooperationalhalt();
    _impl_.dataBody_.qbbooperationalhalt_ = CreateMaybeMessage< ::data::QBBOOperationalHalt >(GetArenaForAllocation());
  }
  return _impl_.dataBody_.qbbooperationalhalt_;
}
inline ::data::QBBOOperationalHalt* Message::mutable_qbbooperationalhalt() {
  ::data::QBBOOperationalHalt* _msg = _internal_mutable_qbbooperationalhalt();
  // @@protoc_insertion_point(field_mutable:data.Message.qBBOOperationalHalt)
  return _msg;
}

// .data.QBBOQuotationMessage qBBOQuotationMessage = 56;
inline bool Message::_internal_has_qbboquotationmessage() const {
  return dataBody_case() == kQBBOQuotationMessage;
}
inline bool Message::has_qbboquotationmessage() const {
  return _internal_has_qbboquotationmessage();
}
inline void Message::set_has_qbboquotationmessage() {
  _impl_._oneof_case_[0] = kQBBOQuotationMessage;
}
inline void Message::clear_qbboquotationmessage() {
  if (_internal_has_qbboquotationmessage()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.dataBody_.qbboquotationmessage_;
    }
    clear_has_dataBody();
  }
}
inline ::data::QBBOQuotationMessage* Message::release_qbboquotationmessage() {
  // @@protoc_insertion_point(field_release:data.Message.qBBOQuotationMessage)
  if (_internal_has_qbboquotationmessage()) {
    clear_has_dataBody();
    ::data::QBBOQuotationMessage* temp = _impl_.dataBody_.qbboquotationmessage_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.dataBody_.qbboquotationmessage_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::data::QBBOQuotationMessage& Message::_internal_qbboquotationmessage() const {
  return _internal_has_qbboquotationmessage()
      ? *_impl_.dataBody_.qbboquotationmessage_
      : reinterpret_cast< ::data::QBBOQuotationMessage&>(::data::_QBBOQuotationMessage_default_instance_);
}
inline const ::data::QBBOQuotationMessage& Message::qbboquotationmessage() const {
  // @@protoc_insertion_point(field_get:data.Message.qBBOQuotationMessage)
  return _internal_qbboquotationmessage();
}
inline ::data::QBBOQuotationMessage* Message::unsafe_arena_release_qbboquotationmessage() {
  // @@protoc_insertion_point(field_unsafe_arena_release:data.Message.qBBOQuotationMessage)
  if (_internal_has_qbboquotationmessage()) {
    clear_has_dataBody();
    ::data::QBBOQuotationMessage* temp = _impl_.dataBody_.qbboquotationmessage_;
    _impl_.dataBody_.qbboquotationmessage_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Message::unsafe_arena_set_allocated_qbboquotationmessage(::data::QBBOQuotationMessage* qbboquotationmessage) {
  clear_dataBody();
  if (qbboquotationmessage) {
    set_has_qbboquotationmessage();
    _impl_.dataBody_.qbboquotationmessage_ = qbboquotationmessage;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:data.Message.qBBOQuotationMessage)
}
inline ::data::QBBOQuotationMessage* Message::_internal_mutable_qbboquotationmessage() {
  if (!_internal_has_qbboquotationmessage()) {
    clear_dataBody();
    set_has_qbboquotationmessage();
    _impl_.dataBody_.qbboquotationmessage_ = CreateMaybeMessage< ::data::QBBOQuotationMessage >(GetArenaForAllocation());
  }
  return _impl_.dataBody_.qbboquotationmessage_;
}
inline ::data::QBBOQuotationMessage* Message::mutable_qbboquotationmessage() {
  ::data::QBBOQuotationMessage* _msg = _internal_mutable_qbboquotationmessage();
  // @@protoc_insertion_point(field_mutable:data.Message.qBBOQuotationMessage)
  return _msg;
}

// .data.QBBORegShoRestriction qBBORegShoRestriction = 57;
inline bool Message::_internal_has_qbboregshorestriction() const {
  return dataBody_case() == kQBBORegShoRestriction;
}
inline bool Message::has_qbboregshorestriction() const {
  return _internal_has_qbboregshorestriction();
}
inline void Message::set_has_qbboregshorestriction() {
  _impl_._oneof_case_[0] = kQBBORegShoRestriction;
}
inline void Message::clear_qbboregshorestriction() {
  if (_internal_has_qbboregshorestriction()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.dataBody_.qbboregshorestriction_;
    }
    clear_has_dataBody();
  }
}
inline ::data::QBBORegShoRestriction* Message::release_qbboregshorestriction() {
  // @@protoc_insertion_point(field_release:data.Message.qBBORegShoRestriction)
  if (_internal_has_qbboregshorestriction()) {
    clear_has_dataBody();
    ::data::QBBORegShoRestriction* temp = _impl_.dataBody_.qbboregshorestriction_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.dataBody_.qbboregshorestriction_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::data::QBBORegShoRestriction& Message::_internal_qbboregshorestriction() const {
  return _internal_has_qbboregshorestriction()
      ? *_impl_.dataBody_.qbboregshorestriction_
      : reinterpret_cast< ::data::QBBORegShoRestriction&>(::data::_QBBORegShoRestriction_default_instance_);
}
inline const ::data::QBBORegShoRestriction& Message::qbboregshorestriction() const {
  // @@protoc_insertion_point(field_get:data.Message.qBBORegShoRestriction)
  return _internal_qbboregshorestriction();
}
inline ::data::QBBORegShoRestriction* Message::unsafe_arena_release_qbboregshorestriction() {
  // @@protoc_insertion_point(field_unsafe_arena_release:data.Message.qBBORegShoRestriction)
  if (_internal_has_qbboregshorestriction()) {
    clear_has_dataBody();
    ::data::QBBORegShoRestriction* temp = _impl_.dataBody_.qbboregshorestriction_;
    _impl_.dataBody_.qbboregshorestriction_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Message::unsafe_arena_set_allocated_qbboregshorestriction(::data::QBBORegShoRestriction* qbboregshorestriction) {
  clear_dataBody();
  if (qbboregshorestriction) {
    set_has_qbboregshorestriction();
    _impl_.dataBody_.qbboregshorestriction_ = qbboregshorestriction;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:data.Message.qBBORegShoRestriction)
}
inline ::data::QBBORegShoRestriction* Message::_internal_mutable_qbboregshorestriction() {
  if (!_internal_has_qbboregshorestriction()) {
    clear_dataBody();
    set_has_qbboregshorestriction();
    _impl_.dataBody_.qbboregshorestriction_ = CreateMaybeMessage< ::data::QBBORegShoRestriction >(GetArenaForAllocation());
  }
  return _impl_.dataBody_.qbboregshorestriction_;
}
inline ::data::QBBORegShoRestriction* Message::mutable_qbboregshorestriction() {
  ::data::QBBORegShoRestriction* _msg = _internal_mutable_qbboregshorestriction();
  // @@protoc_insertion_point(field_mutable:data.Message.qBBORegShoRestriction)
  return _msg;
}

// .data.QBBOStockDirectory qBBOStockDirectory = 58;
inline bool Message::_internal_has_qbbostockdirectory() const {
  return dataBody_case() == kQBBOStockDirectory;
}
inline bool Message::has_qbbostockdirectory() const {
  return _internal_has_qbbostockdirectory();
}
inline void Message::set_has_qbbostockdirectory() {
  _impl_._oneof_case_[0] = kQBBOStockDirectory;
}
inline void Message::clear_qbbostockdirectory() {
  if (_internal_has_qbbostockdirectory()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.dataBody_.qbbostockdirectory_;
    }
    clear_has_dataBody();
  }
}
inline ::data::QBBOStockDirectory* Message::release_qbbostockdirectory() {
  // @@protoc_insertion_point(field_release:data.Message.qBBOStockDirectory)
  if (_internal_has_qbbostockdirectory()) {
    clear_has_dataBody();
    ::data::QBBOStockDirectory* temp = _impl_.dataBody_.qbbostockdirectory_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.dataBody_.qbbostockdirectory_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::data::QBBOStockDirectory& Message::_internal_qbbostockdirectory() const {
  return _internal_has_qbbostockdirectory()
      ? *_impl_.dataBody_.qbbostockdirectory_
      : reinterpret_cast< ::data::QBBOStockDirectory&>(::data::_QBBOStockDirectory_default_instance_);
}
inline const ::data::QBBOStockDirectory& Message::qbbostockdirectory() const {
  // @@protoc_insertion_point(field_get:data.Message.qBBOStockDirectory)
  return _internal_qbbostockdirectory();
}
inline ::data::QBBOStockDirectory* Message::unsafe_arena_release_qbbostockdirectory() {
  // @@protoc_insertion_point(field_unsafe_arena_release:data.Message.qBBOStockDirectory)
  if (_internal_has_qbbostockdirectory()) {
    clear_has_dataBody();
    ::data::QBBOStockDirectory* temp = _impl_.dataBody_.qbbostockdirectory_;
    _impl_.dataBody_.qbbostockdirectory_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Message::unsafe_arena_set_allocated_qbbostockdirectory(::data::QBBOStockDirectory* qbbostockdirectory) {
  clear_dataBody();
  if (qbbostockdirectory) {
    set_has_qbbostockdirectory();
    _impl_.dataBody_.qbbostockdirectory_ = qbbostockdirectory;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:data.Message.qBBOStockDirectory)
}
inline ::data::QBBOStockDirectory* Message::_internal_mutable_qbbostockdirectory() {
  if (!_internal_has_qbbostockdirectory()) {
    clear_dataBody();
    set_has_qbbostockdirectory();
    _impl_.dataBody_.qbbostockdirectory_ = CreateMaybeMessage< ::data::QBBOStockDirectory >(GetArenaForAllocation());
  }
  return _impl_.dataBody_.qbbostockdirectory_;
}
inline ::data::QBBOStockDirectory* Message::mutable_qbbostockdirectory() {
  ::data::QBBOStockDirectory* _msg = _internal_mutable_qbbostockdirectory();
  // @@protoc_insertion_point(field_mutable:data.Message.qBBOStockDirectory)
  return _msg;
}

// .data.QBBOStockTradingAction qBBOStockTradingAction = 59;
inline bool Message::_internal_has_qbbostocktradingaction() const {
  return dataBody_case() == kQBBOStockTradingAction;
}
inline bool Message::has_qbbostocktradingaction() const {
  return _internal_has_qbbostocktradingaction();
}
inline void Message::set_has_qbbostocktradingaction() {
  _impl_._oneof_case_[0] = kQBBOStockTradingAction;
}
inline void Message::clear_qbbostocktradingaction() {
  if (_internal_has_qbbostocktradingaction()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.dataBody_.qbbostocktradingaction_;
    }
    clear_has_dataBody();
  }
}
inline ::data::QBBOStockTradingAction* Message::release_qbbostocktradingaction() {
  // @@protoc_insertion_point(field_release:data.Message.qBBOStockTradingAction)
  if (_internal_has_qbbostocktradingaction()) {
    clear_has_dataBody();
    ::data::QBBOStockTradingAction* temp = _impl_.dataBody_.qbbostocktradingaction_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.dataBody_.qbbostocktradingaction_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::data::QBBOStockTradingAction& Message::_internal_qbbostocktradingaction() const {
  return _internal_has_qbbostocktradingaction()
      ? *_impl_.dataBody_.qbbostocktradingaction_
      : reinterpret_cast< ::data::QBBOStockTradingAction&>(::data::_QBBOStockTradingAction_default_instance_);
}
inline const ::data::QBBOStockTradingAction& Message::qbbostocktradingaction() const {
  // @@protoc_insertion_point(field_get:data.Message.qBBOStockTradingAction)
  return _internal_qbbostocktradingaction();
}
inline ::data::QBBOStockTradingAction* Message::unsafe_arena_release_qbbostocktradingaction() {
  // @@protoc_insertion_point(field_unsafe_arena_release:data.Message.qBBOStockTradingAction)
  if (_internal_has_qbbostocktradingaction()) {
    clear_has_dataBody();
    ::data::QBBOStockTradingAction* temp = _impl_.dataBody_.qbbostocktradingaction_;
    _impl_.dataBody_.qbbostocktradingaction_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Message::unsafe_arena_set_allocated_qbbostocktradingaction(::data::QBBOStockTradingAction* qbbostocktradingaction) {
  clear_dataBody();
  if (qbbostocktradingaction) {
    set_has_qbbostocktradingaction();
    _impl_.dataBody_.qbbostocktradingaction_ = qbbostocktradingaction;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:data.Message.qBBOStockTradingAction)
}
inline ::data::QBBOStockTradingAction* Message::_internal_mutable_qbbostocktradingaction() {
  if (!_internal_has_qbbostocktradingaction()) {
    clear_dataBody();
    set_has_qbbostocktradingaction();
    _impl_.dataBody_.qbbostocktradingaction_ = CreateMaybeMessage< ::data::QBBOStockTradingAction >(GetArenaForAllocation());
  }
  return _impl_.dataBody_.qbbostocktradingaction_;
}
inline ::data::QBBOStockTradingAction* Message::mutable_qbbostocktradingaction() {
  ::data::QBBOStockTradingAction* _msg = _internal_mutable_qbbostocktradingaction();
  // @@protoc_insertion_point(field_mutable:data.Message.qBBOStockTradingAction)
  return _msg;
}

// .data.QBBOSystemEventMessage qBBOSystemEventMessage = 60;
inline bool Message::_internal_has_qbbosystemeventmessage() const {
  return dataBody_case() == kQBBOSystemEventMessage;
}
inline bool Message::has_qbbosystemeventmessage() const {
  return _internal_has_qbbosystemeventmessage();
}
inline void Message::set_has_qbbosystemeventmessage() {
  _impl_._oneof_case_[0] = kQBBOSystemEventMessage;
}
inline void Message::clear_qbbosystemeventmessage() {
  if (_internal_has_qbbosystemeventmessage()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.dataBody_.qbbosystemeventmessage_;
    }
    clear_has_dataBody();
  }
}
inline ::data::QBBOSystemEventMessage* Message::release_qbbosystemeventmessage() {
  // @@protoc_insertion_point(field_release:data.Message.qBBOSystemEventMessage)
  if (_internal_has_qbbosystemeventmessage()) {
    clear_has_dataBody();
    ::data::QBBOSystemEventMessage* temp = _impl_.dataBody_.qbbosystemeventmessage_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.dataBody_.qbbosystemeventmessage_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::data::QBBOSystemEventMessage& Message::_internal_qbbosystemeventmessage() const {
  return _internal_has_qbbosystemeventmessage()
      ? *_impl_.dataBody_.qbbosystemeventmessage_
      : reinterpret_cast< ::data::QBBOSystemEventMessage&>(::data::_QBBOSystemEventMessage_default_instance_);
}
inline const ::data::QBBOSystemEventMessage& Message::qbbosystemeventmessage() const {
  // @@protoc_insertion_point(field_get:data.Message.qBBOSystemEventMessage)
  return _internal_qbbosystemeventmessage();
}
inline ::data::QBBOSystemEventMessage* Message::unsafe_arena_release_qbbosystemeventmessage() {
  // @@protoc_insertion_point(field_unsafe_arena_release:data.Message.qBBOSystemEventMessage)
  if (_internal_has_qbbosystemeventmessage()) {
    clear_has_dataBody();
    ::data::QBBOSystemEventMessage* temp = _impl_.dataBody_.qbbosystemeventmessage_;
    _impl_.dataBody_.qbbosystemeventmessage_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Message::unsafe_arena_set_allocated_qbbosystemeventmessage(::data::QBBOSystemEventMessage* qbbosystemeventmessage) {
  clear_dataBody();
  if (qbbosystemeventmessage) {
    set_has_qbbosystemeventmessage();
    _impl_.dataBody_.qbbosystemeventmessage_ = qbbosystemeventmessage;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:data.Message.qBBOSystemEventMessage)
}
inline ::data::QBBOSystemEventMessage* Message::_internal_mutable_qbbosystemeventmessage() {
  if (!_internal_has_qbbosystemeventmessage()) {
    clear_dataBody();
    set_has_qbbosystemeventmessage();
    _impl_.dataBody_.qbbosystemeventmessage_ = CreateMaybeMessage< ::data::QBBOSystemEventMessage >(GetArenaForAllocation());
  }
  return _impl_.dataBody_.qbbosystemeventmessage_;
}
inline ::data::QBBOSystemEventMessage* Message::mutable_qbbosystemeventmessage() {
  ::data::QBBOSystemEventMessage* _msg = _internal_mutable_qbbosystemeventmessage();
  // @@protoc_insertion_point(field_mutable:data.Message.qBBOSystemEventMessage)
  return _msg;
}

// .data.QBBOIPOQuotingPeriodUpdate qBBOIPOQuotingPeriodUpdate = 61;
inline bool Message::_internal_has_qbboipoquotingperiodupdate() const {
  return dataBody_case() == kQBBOIPOQuotingPeriodUpdate;
}
inline bool Message::has_qbboipoquotingperiodupdate() const {
  return _internal_has_qbboipoquotingperiodupdate();
}
inline void Message::set_has_qbboipoquotingperiodupdate() {
  _impl_._oneof_case_[0] = kQBBOIPOQuotingPeriodUpdate;
}
inline void Message::clear_qbboipoquotingperiodupdate() {
  if (_internal_has_qbboipoquotingperiodupdate()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.dataBody_.qbboipoquotingperiodupdate_;
    }
    clear_has_dataBody();
  }
}
inline ::data::QBBOIPOQuotingPeriodUpdate* Message::release_qbboipoquotingperiodupdate() {
  // @@protoc_insertion_point(field_release:data.Message.qBBOIPOQuotingPeriodUpdate)
  if (_internal_has_qbboipoquotingperiodupdate()) {
    clear_has_dataBody();
    ::data::QBBOIPOQuotingPeriodUpdate* temp = _impl_.dataBody_.qbboipoquotingperiodupdate_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.dataBody_.qbboipoquotingperiodupdate_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::data::QBBOIPOQuotingPeriodUpdate& Message::_internal_qbboipoquotingperiodupdate() const {
  return _internal_has_qbboipoquotingperiodupdate()
      ? *_impl_.dataBody_.qbboipoquotingperiodupdate_
      : reinterpret_cast< ::data::QBBOIPOQuotingPeriodUpdate&>(::data::_QBBOIPOQuotingPeriodUpdate_default_instance_);
}
inline const ::data::QBBOIPOQuotingPeriodUpdate& Message::qbboipoquotingperiodupdate() const {
  // @@protoc_insertion_point(field_get:data.Message.qBBOIPOQuotingPeriodUpdate)
  return _internal_qbboipoquotingperiodupdate();
}
inline ::data::QBBOIPOQuotingPeriodUpdate* Message::unsafe_arena_release_qbboipoquotingperiodupdate() {
  // @@protoc_insertion_point(field_unsafe_arena_release:data.Message.qBBOIPOQuotingPeriodUpdate)
  if (_internal_has_qbboipoquotingperiodupdate()) {
    clear_has_dataBody();
    ::data::QBBOIPOQuotingPeriodUpdate* temp = _impl_.dataBody_.qbboipoquotingperiodupdate_;
    _impl_.dataBody_.qbboipoquotingperiodupdate_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Message::unsafe_arena_set_allocated_qbboipoquotingperiodupdate(::data::QBBOIPOQuotingPeriodUpdate* qbboipoquotingperiodupdate) {
  clear_dataBody();
  if (qbboipoquotingperiodupdate) {
    set_has_qbboipoquotingperiodupdate();
    _impl_.dataBody_.qbboipoquotingperiodupdate_ = qbboipoquotingperiodupdate;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:data.Message.qBBOIPOQuotingPeriodUpdate)
}
inline ::data::QBBOIPOQuotingPeriodUpdate* Message::_internal_mutable_qbboipoquotingperiodupdate() {
  if (!_internal_has_qbboipoquotingperiodupdate()) {
    clear_dataBody();
    set_has_qbboipoquotingperiodupdate();
    _impl_.dataBody_.qbboipoquotingperiodupdate_ = CreateMaybeMessage< ::data::QBBOIPOQuotingPeriodUpdate >(GetArenaForAllocation());
  }
  return _impl_.dataBody_.qbboipoquotingperiodupdate_;
}
inline ::data::QBBOIPOQuotingPeriodUpdate* Message::mutable_qbboipoquotingperiodupdate() {
  ::data::QBBOIPOQuotingPeriodUpdate* _msg = _internal_mutable_qbboipoquotingperiodupdate();
  // @@protoc_insertion_point(field_mutable:data.Message.qBBOIPOQuotingPeriodUpdate)
  return _msg;
}

// .data.CertificationMsg certificationMsg = 62;
inline bool Message::_internal_has_certificationmsg() const {
  return dataBody_case() == kCertificationMsg;
}
inline bool Message::has_certificationmsg() const {
  return _internal_has_certificationmsg();
}
inline void Message::set_has_certificationmsg() {
  _impl_._oneof_case_[0] = kCertificationMsg;
}
inline void Message::clear_certificationmsg() {
  if (_internal_has_certificationmsg()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.dataBody_.certificationmsg_;
    }
    clear_has_dataBody();
  }
}
inline ::data::CertificationMsg* Message::release_certificationmsg() {
  // @@protoc_insertion_point(field_release:data.Message.certificationMsg)
  if (_internal_has_certificationmsg()) {
    clear_has_dataBody();
    ::data::CertificationMsg* temp = _impl_.dataBody_.certificationmsg_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.dataBody_.certificationmsg_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::data::CertificationMsg& Message::_internal_certificationmsg() const {
  return _internal_has_certificationmsg()
      ? *_impl_.dataBody_.certificationmsg_
      : reinterpret_cast< ::data::CertificationMsg&>(::data::_CertificationMsg_default_instance_);
}
inline const ::data::CertificationMsg& Message::certificationmsg() const {
  // @@protoc_insertion_point(field_get:data.Message.certificationMsg)
  return _internal_certificationmsg();
}
inline ::data::CertificationMsg* Message::unsafe_arena_release_certificationmsg() {
  // @@protoc_insertion_point(field_unsafe_arena_release:data.Message.certificationMsg)
  if (_internal_has_certificationmsg()) {
    clear_has_dataBody();
    ::data::CertificationMsg* temp = _impl_.dataBody_.certificationmsg_;
    _impl_.dataBody_.certificationmsg_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Message::unsafe_arena_set_allocated_certificationmsg(::data::CertificationMsg* certificationmsg) {
  clear_dataBody();
  if (certificationmsg) {
    set_has_certificationmsg();
    _impl_.dataBody_.certificationmsg_ = certificationmsg;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:data.Message.certificationMsg)
}
inline ::data::CertificationMsg* Message::_internal_mutable_certificationmsg() {
  if (!_internal_has_certificationmsg()) {
    clear_dataBody();
    set_has_certificationmsg();
    _impl_.dataBody_.certificationmsg_ = CreateMaybeMessage< ::data::CertificationMsg >(GetArenaForAllocation());
  }
  return _impl_.dataBody_.certificationmsg_;
}
inline ::data::CertificationMsg* Message::mutable_certificationmsg() {
  ::data::CertificationMsg* _msg = _internal_mutable_certificationmsg();
  // @@protoc_insertion_point(field_mutable:data.Message.certificationMsg)
  return _msg;
}

// .data.CNMarketDefinition cNMarketDefinition = 63;
inline bool Message::_internal_has_cnmarketdefinition() const {
  return dataBody_case() == kCNMarketDefinition;
}
inline bool Message::has_cnmarketdefinition() const {
  return _internal_has_cnmarketdefinition();
}
inline void Message::set_has_cnmarketdefinition() {
  _impl_._oneof_case_[0] = kCNMarketDefinition;
}
inline void Message::clear_cnmarketdefinition() {
  if (_internal_has_cnmarketdefinition()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.dataBody_.cnmarketdefinition_;
    }
    clear_has_dataBody();
  }
}
inline ::data::CNMarketDefinition* Message::release_cnmarketdefinition() {
  // @@protoc_insertion_point(field_release:data.Message.cNMarketDefinition)
  if (_internal_has_cnmarketdefinition()) {
    clear_has_dataBody();
    ::data::CNMarketDefinition* temp = _impl_.dataBody_.cnmarketdefinition_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.dataBody_.cnmarketdefinition_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::data::CNMarketDefinition& Message::_internal_cnmarketdefinition() const {
  return _internal_has_cnmarketdefinition()
      ? *_impl_.dataBody_.cnmarketdefinition_
      : reinterpret_cast< ::data::CNMarketDefinition&>(::data::_CNMarketDefinition_default_instance_);
}
inline const ::data::CNMarketDefinition& Message::cnmarketdefinition() const {
  // @@protoc_insertion_point(field_get:data.Message.cNMarketDefinition)
  return _internal_cnmarketdefinition();
}
inline ::data::CNMarketDefinition* Message::unsafe_arena_release_cnmarketdefinition() {
  // @@protoc_insertion_point(field_unsafe_arena_release:data.Message.cNMarketDefinition)
  if (_internal_has_cnmarketdefinition()) {
    clear_has_dataBody();
    ::data::CNMarketDefinition* temp = _impl_.dataBody_.cnmarketdefinition_;
    _impl_.dataBody_.cnmarketdefinition_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Message::unsafe_arena_set_allocated_cnmarketdefinition(::data::CNMarketDefinition* cnmarketdefinition) {
  clear_dataBody();
  if (cnmarketdefinition) {
    set_has_cnmarketdefinition();
    _impl_.dataBody_.cnmarketdefinition_ = cnmarketdefinition;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:data.Message.cNMarketDefinition)
}
inline ::data::CNMarketDefinition* Message::_internal_mutable_cnmarketdefinition() {
  if (!_internal_has_cnmarketdefinition()) {
    clear_dataBody();
    set_has_cnmarketdefinition();
    _impl_.dataBody_.cnmarketdefinition_ = CreateMaybeMessage< ::data::CNMarketDefinition >(GetArenaForAllocation());
  }
  return _impl_.dataBody_.cnmarketdefinition_;
}
inline ::data::CNMarketDefinition* Message::mutable_cnmarketdefinition() {
  ::data::CNMarketDefinition* _msg = _internal_mutable_cnmarketdefinition();
  // @@protoc_insertion_point(field_mutable:data.Message.cNMarketDefinition)
  return _msg;
}

// .data.CNSecurityDefinition cNSecurityDefinition = 64;
inline bool Message::_internal_has_cnsecuritydefinition() const {
  return dataBody_case() == kCNSecurityDefinition;
}
inline bool Message::has_cnsecuritydefinition() const {
  return _internal_has_cnsecuritydefinition();
}
inline void Message::set_has_cnsecuritydefinition() {
  _impl_._oneof_case_[0] = kCNSecurityDefinition;
}
inline void Message::clear_cnsecuritydefinition() {
  if (_internal_has_cnsecuritydefinition()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.dataBody_.cnsecuritydefinition_;
    }
    clear_has_dataBody();
  }
}
inline ::data::CNSecurityDefinition* Message::release_cnsecuritydefinition() {
  // @@protoc_insertion_point(field_release:data.Message.cNSecurityDefinition)
  if (_internal_has_cnsecuritydefinition()) {
    clear_has_dataBody();
    ::data::CNSecurityDefinition* temp = _impl_.dataBody_.cnsecuritydefinition_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.dataBody_.cnsecuritydefinition_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::data::CNSecurityDefinition& Message::_internal_cnsecuritydefinition() const {
  return _internal_has_cnsecuritydefinition()
      ? *_impl_.dataBody_.cnsecuritydefinition_
      : reinterpret_cast< ::data::CNSecurityDefinition&>(::data::_CNSecurityDefinition_default_instance_);
}
inline const ::data::CNSecurityDefinition& Message::cnsecuritydefinition() const {
  // @@protoc_insertion_point(field_get:data.Message.cNSecurityDefinition)
  return _internal_cnsecuritydefinition();
}
inline ::data::CNSecurityDefinition* Message::unsafe_arena_release_cnsecuritydefinition() {
  // @@protoc_insertion_point(field_unsafe_arena_release:data.Message.cNSecurityDefinition)
  if (_internal_has_cnsecuritydefinition()) {
    clear_has_dataBody();
    ::data::CNSecurityDefinition* temp = _impl_.dataBody_.cnsecuritydefinition_;
    _impl_.dataBody_.cnsecuritydefinition_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Message::unsafe_arena_set_allocated_cnsecuritydefinition(::data::CNSecurityDefinition* cnsecuritydefinition) {
  clear_dataBody();
  if (cnsecuritydefinition) {
    set_has_cnsecuritydefinition();
    _impl_.dataBody_.cnsecuritydefinition_ = cnsecuritydefinition;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:data.Message.cNSecurityDefinition)
}
inline ::data::CNSecurityDefinition* Message::_internal_mutable_cnsecuritydefinition() {
  if (!_internal_has_cnsecuritydefinition()) {
    clear_dataBody();
    set_has_cnsecuritydefinition();
    _impl_.dataBody_.cnsecuritydefinition_ = CreateMaybeMessage< ::data::CNSecurityDefinition >(GetArenaForAllocation());
  }
  return _impl_.dataBody_.cnsecuritydefinition_;
}
inline ::data::CNSecurityDefinition* Message::mutable_cnsecuritydefinition() {
  ::data::CNSecurityDefinition* _msg = _internal_mutable_cnsecuritydefinition();
  // @@protoc_insertion_point(field_mutable:data.Message.cNSecurityDefinition)
  return _msg;
}

// .data.CNSecurityStatus cNSecurityStatus = 65;
inline bool Message::_internal_has_cnsecuritystatus() const {
  return dataBody_case() == kCNSecurityStatus;
}
inline bool Message::has_cnsecuritystatus() const {
  return _internal_has_cnsecuritystatus();
}
inline void Message::set_has_cnsecuritystatus() {
  _impl_._oneof_case_[0] = kCNSecurityStatus;
}
inline void Message::clear_cnsecuritystatus() {
  if (_internal_has_cnsecuritystatus()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.dataBody_.cnsecuritystatus_;
    }
    clear_has_dataBody();
  }
}
inline ::data::CNSecurityStatus* Message::release_cnsecuritystatus() {
  // @@protoc_insertion_point(field_release:data.Message.cNSecurityStatus)
  if (_internal_has_cnsecuritystatus()) {
    clear_has_dataBody();
    ::data::CNSecurityStatus* temp = _impl_.dataBody_.cnsecuritystatus_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.dataBody_.cnsecuritystatus_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::data::CNSecurityStatus& Message::_internal_cnsecuritystatus() const {
  return _internal_has_cnsecuritystatus()
      ? *_impl_.dataBody_.cnsecuritystatus_
      : reinterpret_cast< ::data::CNSecurityStatus&>(::data::_CNSecurityStatus_default_instance_);
}
inline const ::data::CNSecurityStatus& Message::cnsecuritystatus() const {
  // @@protoc_insertion_point(field_get:data.Message.cNSecurityStatus)
  return _internal_cnsecuritystatus();
}
inline ::data::CNSecurityStatus* Message::unsafe_arena_release_cnsecuritystatus() {
  // @@protoc_insertion_point(field_unsafe_arena_release:data.Message.cNSecurityStatus)
  if (_internal_has_cnsecuritystatus()) {
    clear_has_dataBody();
    ::data::CNSecurityStatus* temp = _impl_.dataBody_.cnsecuritystatus_;
    _impl_.dataBody_.cnsecuritystatus_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Message::unsafe_arena_set_allocated_cnsecuritystatus(::data::CNSecurityStatus* cnsecuritystatus) {
  clear_dataBody();
  if (cnsecuritystatus) {
    set_has_cnsecuritystatus();
    _impl_.dataBody_.cnsecuritystatus_ = cnsecuritystatus;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:data.Message.cNSecurityStatus)
}
inline ::data::CNSecurityStatus* Message::_internal_mutable_cnsecuritystatus() {
  if (!_internal_has_cnsecuritystatus()) {
    clear_dataBody();
    set_has_cnsecuritystatus();
    _impl_.dataBody_.cnsecuritystatus_ = CreateMaybeMessage< ::data::CNSecurityStatus >(GetArenaForAllocation());
  }
  return _impl_.dataBody_.cnsecuritystatus_;
}
inline ::data::CNSecurityStatus* Message::mutable_cnsecuritystatus() {
  ::data::CNSecurityStatus* _msg = _internal_mutable_cnsecuritystatus();
  // @@protoc_insertion_point(field_mutable:data.Message.cNSecurityStatus)
  return _msg;
}

// .data.CNStatistics cNStatistics = 66;
inline bool Message::_internal_has_cnstatistics() const {
  return dataBody_case() == kCNStatistics;
}
inline bool Message::has_cnstatistics() const {
  return _internal_has_cnstatistics();
}
inline void Message::set_has_cnstatistics() {
  _impl_._oneof_case_[0] = kCNStatistics;
}
inline void Message::clear_cnstatistics() {
  if (_internal_has_cnstatistics()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.dataBody_.cnstatistics_;
    }
    clear_has_dataBody();
  }
}
inline ::data::CNStatistics* Message::release_cnstatistics() {
  // @@protoc_insertion_point(field_release:data.Message.cNStatistics)
  if (_internal_has_cnstatistics()) {
    clear_has_dataBody();
    ::data::CNStatistics* temp = _impl_.dataBody_.cnstatistics_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.dataBody_.cnstatistics_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::data::CNStatistics& Message::_internal_cnstatistics() const {
  return _internal_has_cnstatistics()
      ? *_impl_.dataBody_.cnstatistics_
      : reinterpret_cast< ::data::CNStatistics&>(::data::_CNStatistics_default_instance_);
}
inline const ::data::CNStatistics& Message::cnstatistics() const {
  // @@protoc_insertion_point(field_get:data.Message.cNStatistics)
  return _internal_cnstatistics();
}
inline ::data::CNStatistics* Message::unsafe_arena_release_cnstatistics() {
  // @@protoc_insertion_point(field_unsafe_arena_release:data.Message.cNStatistics)
  if (_internal_has_cnstatistics()) {
    clear_has_dataBody();
    ::data::CNStatistics* temp = _impl_.dataBody_.cnstatistics_;
    _impl_.dataBody_.cnstatistics_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Message::unsafe_arena_set_allocated_cnstatistics(::data::CNStatistics* cnstatistics) {
  clear_dataBody();
  if (cnstatistics) {
    set_has_cnstatistics();
    _impl_.dataBody_.cnstatistics_ = cnstatistics;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:data.Message.cNStatistics)
}
inline ::data::CNStatistics* Message::_internal_mutable_cnstatistics() {
  if (!_internal_has_cnstatistics()) {
    clear_dataBody();
    set_has_cnstatistics();
    _impl_.dataBody_.cnstatistics_ = CreateMaybeMessage< ::data::CNStatistics >(GetArenaForAllocation());
  }
  return _impl_.dataBody_.cnstatistics_;
}
inline ::data::CNStatistics* Message::mutable_cnstatistics() {
  ::data::CNStatistics* _msg = _internal_mutable_cnstatistics();
  // @@protoc_insertion_point(field_mutable:data.Message.cNStatistics)
  return _msg;
}

// .data.CNTopBook cNTopBook = 67;
inline bool Message::_internal_has_cntopbook() const {
  return dataBody_case() == kCNTopBook;
}
inline bool Message::has_cntopbook() const {
  return _internal_has_cntopbook();
}
inline void Message::set_has_cntopbook() {
  _impl_._oneof_case_[0] = kCNTopBook;
}
inline void Message::clear_cntopbook() {
  if (_internal_has_cntopbook()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.dataBody_.cntopbook_;
    }
    clear_has_dataBody();
  }
}
inline ::data::CNTopBook* Message::release_cntopbook() {
  // @@protoc_insertion_point(field_release:data.Message.cNTopBook)
  if (_internal_has_cntopbook()) {
    clear_has_dataBody();
    ::data::CNTopBook* temp = _impl_.dataBody_.cntopbook_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.dataBody_.cntopbook_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::data::CNTopBook& Message::_internal_cntopbook() const {
  return _internal_has_cntopbook()
      ? *_impl_.dataBody_.cntopbook_
      : reinterpret_cast< ::data::CNTopBook&>(::data::_CNTopBook_default_instance_);
}
inline const ::data::CNTopBook& Message::cntopbook() const {
  // @@protoc_insertion_point(field_get:data.Message.cNTopBook)
  return _internal_cntopbook();
}
inline ::data::CNTopBook* Message::unsafe_arena_release_cntopbook() {
  // @@protoc_insertion_point(field_unsafe_arena_release:data.Message.cNTopBook)
  if (_internal_has_cntopbook()) {
    clear_has_dataBody();
    ::data::CNTopBook* temp = _impl_.dataBody_.cntopbook_;
    _impl_.dataBody_.cntopbook_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Message::unsafe_arena_set_allocated_cntopbook(::data::CNTopBook* cntopbook) {
  clear_dataBody();
  if (cntopbook) {
    set_has_cntopbook();
    _impl_.dataBody_.cntopbook_ = cntopbook;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:data.Message.cNTopBook)
}
inline ::data::CNTopBook* Message::_internal_mutable_cntopbook() {
  if (!_internal_has_cntopbook()) {
    clear_dataBody();
    set_has_cntopbook();
    _impl_.dataBody_.cntopbook_ = CreateMaybeMessage< ::data::CNTopBook >(GetArenaForAllocation());
  }
  return _impl_.dataBody_.cntopbook_;
}
inline ::data::CNTopBook* Message::mutable_cntopbook() {
  ::data::CNTopBook* _msg = _internal_mutable_cntopbook();
  // @@protoc_insertion_point(field_mutable:data.Message.cNTopBook)
  return _msg;
}

// optional int64 timestamp = 68;
inline bool Message::_internal_has_timestamp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Message::has_timestamp() const {
  return _internal_has_timestamp();
}
inline void Message::clear_timestamp() {
  _impl_.timestamp_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int64_t Message::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline int64_t Message::timestamp() const {
  // @@protoc_insertion_point(field_get:data.Message.timestamp)
  return _internal_timestamp();
}
inline void Message::_internal_set_timestamp(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.timestamp_ = value;
}
inline void Message::set_timestamp(int64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:data.Message.timestamp)
}

inline bool Message::has_dataBody() const {
  return dataBody_case() != DATABODY_NOT_SET;
}
inline void Message::clear_has_dataBody() {
  _impl_._oneof_case_[0] = DATABODY_NOT_SET;
}
inline Message::DataBodyCase Message::dataBody_case() const {
  return Message::DataBodyCase(_impl_._oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace data

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::data::Message_DataType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::data::Message_DataType>() {
  return ::data::Message_DataType_descriptor();
}
template <> struct is_proto_enum< ::data::ActionType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::data::ActionType>() {
  return ::data::ActionType_descriptor();
}
template <> struct is_proto_enum< ::data::ResponseType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::data::ResponseType>() {
  return ::data::ResponseType_descriptor();
}
template <> struct is_proto_enum< ::data::SecurityTradingStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::data::SecurityTradingStatus>() {
  return ::data::SecurityTradingStatus_descriptor();
}
template <> struct is_proto_enum< ::data::SuspensionIndicator> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::data::SuspensionIndicator>() {
  return ::data::SuspensionIndicator_descriptor();
}
template <> struct is_proto_enum< ::data::Authenticity> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::data::Authenticity>() {
  return ::data::Authenticity_descriptor();
}
template <> struct is_proto_enum< ::data::BreachedLevel> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::data::BreachedLevel>() {
  return ::data::BreachedLevel_descriptor();
}
template <> struct is_proto_enum< ::data::CurrentTradingState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::data::CurrentTradingState>() {
  return ::data::CurrentTradingState_descriptor();
}
template <> struct is_proto_enum< ::data::EventCode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::data::EventCode>() {
  return ::data::EventCode_descriptor();
}
template <> struct is_proto_enum< ::data::FinancialStatusIndicator> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::data::FinancialStatusIndicator>() {
  return ::data::FinancialStatusIndicator_descriptor();
}
template <> struct is_proto_enum< ::data::HaltAction> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::data::HaltAction>() {
  return ::data::HaltAction_descriptor();
}
template <> struct is_proto_enum< ::data::IPOQuotationReleaseQualifier> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::data::IPOQuotationReleaseQualifier>() {
  return ::data::IPOQuotationReleaseQualifier_descriptor();
}
template <> struct is_proto_enum< ::data::IndicatesIf> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::data::IndicatesIf>() {
  return ::data::IndicatesIf_descriptor();
}
template <> struct is_proto_enum< ::data::LULDRule> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::data::LULDRule>() {
  return ::data::LULDRule_descriptor();
}
template <> struct is_proto_enum< ::data::LevelFour> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::data::LevelFour>() {
  return ::data::LevelFour_descriptor();
}
template <> struct is_proto_enum< ::data::LevelOne> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::data::LevelOne>() {
  return ::data::LevelOne_descriptor();
}
template <> struct is_proto_enum< ::data::LevelThree> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::data::LevelThree>() {
  return ::data::LevelThree_descriptor();
}
template <> struct is_proto_enum< ::data::LevelTwo> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::data::LevelTwo>() {
  return ::data::LevelTwo_descriptor();
}
template <> struct is_proto_enum< ::data::MarketCategory> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::data::MarketCategory>() {
  return ::data::MarketCategory_descriptor();
}
template <> struct is_proto_enum< ::data::MessageType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::data::MessageType>() {
  return ::data::MessageType_descriptor();
}
template <> struct is_proto_enum< ::data::NetChange> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::data::NetChange>() {
  return ::data::NetChange_descriptor();
}
template <> struct is_proto_enum< ::data::OperationalHaltAction> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::data::OperationalHaltAction>() {
  return ::data::OperationalHaltAction_descriptor();
}
template <> struct is_proto_enum< ::data::OriginatingMarketCenterIdentifier> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::data::OriginatingMarketCenterIdentifier>() {
  return ::data::OriginatingMarketCenterIdentifier_descriptor();
}
template <> struct is_proto_enum< ::data::QBBOMessageType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::data::QBBOMessageType>() {
  return ::data::QBBOMessageType_descriptor();
}
template <> struct is_proto_enum< ::data::QuotationReleaseQualifier> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::data::QuotationReleaseQualifier>() {
  return ::data::QuotationReleaseQualifier_descriptor();
}
template <> struct is_proto_enum< ::data::RegSHOAction> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::data::RegSHOAction>() {
  return ::data::RegSHOAction_descriptor();
}
template <> struct is_proto_enum< ::data::SecurityClass> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::data::SecurityClass>() {
  return ::data::SecurityClass_descriptor();
}
template <> struct is_proto_enum< ::data::BQMoreFlag> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::data::BQMoreFlag>() {
  return ::data::BQMoreFlag_descriptor();
}
template <> struct is_proto_enum< ::data::BrokerSide> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::data::BrokerSide>() {
  return ::data::BrokerSide_descriptor();
}
template <> struct is_proto_enum< ::data::CallPutFlag> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::data::CallPutFlag>() {
  return ::data::CallPutFlag_descriptor();
}
template <> struct is_proto_enum< ::data::CancelFlag> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::data::CancelFlag>() {
  return ::data::CancelFlag_descriptor();
}
template <> struct is_proto_enum< ::data::CurrencyType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::data::CurrencyType>() {
  return ::data::CurrencyType_descriptor();
}
template <> struct is_proto_enum< ::data::IndexSource> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::data::IndexSource>() {
  return ::data::IndexSource_descriptor();
}
template <> struct is_proto_enum< ::data::IndexStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::data::IndexStatus>() {
  return ::data::IndexStatus_descriptor();
}
template <> struct is_proto_enum< ::data::IndicatesType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::data::IndicatesType>() {
  return ::data::IndicatesType_descriptor();
}
template <> struct is_proto_enum< ::data::IndicatesWhether> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::data::IndicatesWhether>() {
  return ::data::IndicatesWhether_descriptor();
}
template <> struct is_proto_enum< ::data::InstrumentType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::data::InstrumentType>() {
  return ::data::InstrumentType_descriptor();
}
template <> struct is_proto_enum< ::data::InvestorType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::data::InvestorType>() {
  return ::data::InvestorType_descriptor();
}
template <> struct is_proto_enum< ::data::LastFragment> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::data::LastFragment>() {
  return ::data::LastFragment_descriptor();
}
template <> struct is_proto_enum< ::data::CnMarketCode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::data::CnMarketCode>() {
  return ::data::CnMarketCode_descriptor();
}
template <> struct is_proto_enum< ::data::MarketCode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::data::MarketCode>() {
  return ::data::MarketCode_descriptor();
}
template <> struct is_proto_enum< ::data::MsgType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::data::MsgType>() {
  return ::data::MsgType_descriptor();
}
template <> struct is_proto_enum< ::data::NewsType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::data::NewsType>() {
  return ::data::NewsType_descriptor();
}
template <> struct is_proto_enum< ::data::OrderImbalanceDirection> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::data::OrderImbalanceDirection>() {
  return ::data::OrderImbalanceDirection_descriptor();
}
template <> struct is_proto_enum< ::data::ProductType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::data::ProductType>() {
  return ::data::ProductType_descriptor();
}
template <> struct is_proto_enum< ::data::Side> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::data::Side>() {
  return ::data::Side_descriptor();
}
template <> struct is_proto_enum< ::data::SpreadTableCode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::data::SpreadTableCode>() {
  return ::data::SpreadTableCode_descriptor();
}
template <> struct is_proto_enum< ::data::Style> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::data::Style>() {
  return ::data::Style_descriptor();
}
template <> struct is_proto_enum< ::data::TradingSesControlType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::data::TradingSesControlType>() {
  return ::data::TradingSesControlType_descriptor();
}
template <> struct is_proto_enum< ::data::TradingSesStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::data::TradingSesStatus>() {
  return ::data::TradingSesStatus_descriptor();
}
template <> struct is_proto_enum< ::data::TradingSessionSubID> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::data::TradingSessionSubID>() {
  return ::data::TradingSessionSubID_descriptor();
}
template <> struct is_proto_enum< ::data::TrdType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::data::TrdType>() {
  return ::data::TrdType_descriptor();
}
template <> struct is_proto_enum< ::data::UpdateAction> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::data::UpdateAction>() {
  return ::data::UpdateAction_descriptor();
}
template <> struct is_proto_enum< ::data::WarrantType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::data::WarrantType>() {
  return ::data::WarrantType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_data_2eproto
